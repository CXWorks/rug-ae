{"<datetime::Datetime as std::convert::From<datetime::Date>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::{Datetime, Date};\n\n    #[test]\n    fn from_date_to_datetime() {\n        let date = Date {\n            year: 2023,\n            month: 4,\n            day: 1,\n        };\n\n        let datetime: Datetime = Datetime::from(date);\n\n        assert_eq!(datetime.date, Some(date));\n        assert_eq!(datetime.time, None);\n        assert_eq!(datetime.offset, None);\n    }\n}\n```", "<datetime::Datetime as std::convert::From<datetime::Time>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_from_time() {\n        let time = Time {\n            hour: 12,\n            minute: 34,\n            second: 56,\n            nanosecond: 789,\n        };\n\n        let datetime: Datetime = Datetime::from(time.clone());\n        assert_eq!(datetime.date, None);\n        assert_eq!(datetime.time, Some(time));\n        assert_eq!(datetime.offset, None);\n    }\n}\n```", "<datetime::Datetime as std::str::FromStr>::from_str": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_valid_full_date_time() {\n        let input = \"2023-03-14T11:53:21.123Z\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_ok());\n        let datetime = result.unwrap();\n        assert_eq!(datetime.date.unwrap().year, 2023);\n        assert_eq!(datetime.date.unwrap().month, 3);\n        assert_eq!(datetime.date.unwrap().day, 14);\n        assert_eq!(datetime.time.unwrap().hour, 11);\n        assert_eq!(datetime.time.unwrap().minute, 53);\n        assert_eq!(datetime.time.unwrap().second, 21);\n        assert_eq!(datetime.time.unwrap().nanosecond, 123_000_000);\n        assert_eq!(datetime.offset, Some(Offset::Z));\n    }\n\n    #[test]\n    fn test_valid_date_only() {\n        let input = \"2023-03-14\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_ok());\n        let datetime = result.unwrap();\n        assert_eq!(datetime.date.unwrap().year, 2023);\n        assert_eq!(datetime.date.unwrap().month, 3);\n        assert_eq!(datetime.date.unwrap().day, 14);\n        assert!(datetime.time.is_none());\n        assert!(datetime.offset.is_none());\n    }\n\n    #[test]\n    fn test_valid_time_only() {\n        let input = \"11:53:21.123\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_ok());\n        let datetime = result.unwrap();\n        assert!(datetime.date.is_none());\n        assert_eq!(datetime.time.unwrap().hour, 11);\n        assert_eq!(datetime.time.unwrap().minute, 53);\n        assert_eq!(datetime.time.unwrap().second, 21);\n        assert_eq!(datetime.time.unwrap().nanosecond, 123_000_000);\n        assert!(datetime.offset.is_none());\n    }\n\n    #[test]\n    fn test_valid_date_time_with_offset() {\n        let input = \"2023-03-14T11:53:21.123+01:30\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_ok());\n        let datetime = result.unwrap();\n        if let Some(Offset::Custom { minutes }) = datetime.offset {\n            assert_eq!(minutes, 90);\n        } else {\n            panic!(\"Expected custom offset\");\n        }\n    }\n\n    #[test]\n    fn test_invalid_too_short() {\n        let input = \"23\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_bad_format() {\n        let input = \"2023-AA-14\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_bad_time() {\n        let input = \"2023-03-14T99:99:99\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_bad_offset() {\n        let input = \"2023-03-14T11:53:21.123+25:00\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_trailing_characters() {\n        let input = \"2023-03-14T11:53:21.123Zgarbage\";\n        let result = Datetime::from_str(input);\n        assert!(result.is_err());\n    }\n}\n```", "datetime::digit": "```rust\n#[cfg(test)]\nmod tests_llm_16_4 {\n    use super::*; // Use items from the parent module\n    use std::str::Chars;\n\n    #[test]\n    fn test_digit_success() {\n        let mut chars: Chars = \"1\".chars();\n        assert_eq!(digit(&mut chars), Ok(1));\n    }\n\n    #[test]\n    fn test_digit_non_digit() {\n        let mut chars: Chars = \"a\".chars();\n        assert!(digit(&mut chars).is_err());\n    }\n\n    #[test]\n    fn test_digit_empty() {\n        let mut chars: Chars = \"\".chars();\n        assert!(digit(&mut chars).is_err());\n    }\n\n    #[test]\n    fn test_digit_boundary() {\n        let mut chars: Chars = \"0\".chars();\n        assert_eq!(digit(&mut chars), Ok(0));\n\n        let mut chars: Chars = \"9\".chars();\n        assert_eq!(digit(&mut chars), Ok(9));\n    }\n}\n```"}