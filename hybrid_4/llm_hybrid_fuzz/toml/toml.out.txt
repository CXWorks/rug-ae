-----------------
crates/serde_spanned/src/spanned.rs spanned::is_spanned
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
+spanned::is_spanned(&p0, p1);
+crate::spanned::is_spanned(&p0, p1);
+crate::spanned::is_spanned(&p0, p1);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as std::clone::Clone>::clone
deps:{"<spanned::Spanned<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"spanned::Spanned":{"T":["std::cmp::Ord","std::marker::Sized","std::cmp::Eq","serde::Deserialize","std::clone::Clone","std::hash::Hash","std::cmp::PartialOrd","std::cmp::PartialEq","serde::Serialize","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<spanned::Spanned<T> as std::clone::Clone>::clone":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","spanned::Spanned","std::clone::impls::<impl std::clone::Clone for &T>"]},"spanned::Spanned":{"T":["spanned::Spanned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.clone();
+<spanned::Spanned<T> as std::clone::Clone>::clone(p0);
+crate::<spanned::Spanned<T> as std::clone::Clone>::clone(p0);
+<spanned::Spanned<T>>::clone(p0);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<spanned::Spanned<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"spanned::Spanned":{"T":["std::cmp::PartialEq","std::clone::Clone","serde::Deserialize","std::fmt::Debug","std::cmp::Eq","std::hash::Hash","std::cmp::Ord","std::marker::Sized","serde::Serialize","std::cmp::PartialOrd"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<spanned::Spanned<T> as std::fmt::Debug>::fmt":{"T":["<*mut T as std::fmt::Debug>","spanned::Spanned","<&T as std::fmt::Debug>"]},"spanned::Spanned":{"T":["spanned::Spanned"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<spanned::Spanned<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<spanned::Spanned<T> as std::fmt::Debug>::fmt(p0, p1);
+<spanned::Spanned<T>>::fmt(p0, p1);
-----------------
crates/serde_spanned/src/spanned.rs spanned::Spanned::<T>::span
deps:{"spanned::Spanned::<T>::span":{"T":["std::marker::Sized"]}}
candidates:{"spanned::Spanned::<T>::span":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.span();
+spanned::Spanned::<T>::span(p0);
+crate::spanned::Spanned::<T>::span(p0);
+<spanned::Spanned<T>>::span(p0);
-----------------
crates/serde_spanned/src/spanned.rs spanned::Spanned::<T>::into_inner
deps:{"spanned::Spanned::<T>::into_inner":{"T":["std::marker::Sized"]}}
candidates:{"spanned::Spanned::<T>::into_inner":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.into_inner();
+spanned::Spanned::<T>::into_inner(p0);
+crate::spanned::Spanned::<T>::into_inner(p0);
+<spanned::Spanned<T>>::into_inner(p0);
-----------------
crates/serde_spanned/src/spanned.rs spanned::Spanned::<T>::get_ref
deps:{"spanned::Spanned::<T>::get_ref":{"T":["std::marker::Sized"]}}
candidates:{"spanned::Spanned::<T>::get_ref":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.get_ref();
+spanned::Spanned::<T>::get_ref(p0);
+crate::spanned::Spanned::<T>::get_ref(p0);
+<spanned::Spanned<T>>::get_ref(p0);
-----------------
crates/serde_spanned/src/spanned.rs spanned::Spanned::<T>::get_mut
deps:{"spanned::Spanned::<T>::get_mut":{"T":["std::marker::Sized"]}}
candidates:{"spanned::Spanned::<T>::get_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.get_mut();
+spanned::Spanned::<T>::get_mut(p0);
+crate::spanned::Spanned::<T>::get_mut(p0);
+<spanned::Spanned<T>>::get_mut(p0);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<std::string::String> as std::borrow::Borrow<str>>::borrow
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+spanned::Spanned<std::string::String>
+p0.borrow();
+<spanned::Spanned<std::string::String> as std::borrow::Borrow<str>>::borrow(p0);
+crate::<spanned::Spanned<std::string::String> as std::borrow::Borrow<str>>::borrow(p0);
+<spanned::Spanned<std::string::String>>::borrow(p0);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as std::convert::AsRef<T>>::as_ref
deps:{"<spanned::Spanned<T> as std::convert::AsRef<T>>::as_ref":{"T":["std::marker::Sized"]}}
candidates:{"<spanned::Spanned<T> as std::convert::AsRef<T>>::as_ref":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.as_ref();
+<spanned::Spanned<T> as std::convert::AsRef<T>>::as_ref(p0);
+crate::<spanned::Spanned<T> as std::convert::AsRef<T>>::as_ref(p0);
+<spanned::Spanned<T>>::as_ref(p0);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as std::convert::AsMut<T>>::as_mut
deps:{"<spanned::Spanned<T> as std::convert::AsMut<T>>::as_mut":{"T":["std::marker::Sized"]}}
candidates:{"<spanned::Spanned<T> as std::convert::AsMut<T>>::as_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.as_mut();
+<spanned::Spanned<T> as std::convert::AsMut<T>>::as_mut(p0);
+crate::<spanned::Spanned<T> as std::convert::AsMut<T>>::as_mut(p0);
+<spanned::Spanned<T>>::as_mut(p0);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as std::cmp::PartialEq>::eq
deps:{"<spanned::Spanned<T> as std::cmp::PartialEq>::eq":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"spanned::Spanned":{"T":["std::cmp::PartialOrd","serde::Deserialize","std::cmp::PartialEq","std::cmp::Ord","serde::Serialize","std::fmt::Debug","std::clone::Clone","std::hash::Hash","std::marker::Sized","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<spanned::Spanned<T> as std::cmp::PartialEq>::eq":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","spanned::Spanned"]},"spanned::Spanned":{"T":["spanned::Spanned"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.eq(p1);
+<spanned::Spanned<T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<spanned::Spanned<T> as std::cmp::PartialEq>::eq(p0, p1);
+<spanned::Spanned<T>>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs datetime::digit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::str::Chars<'_>
+datetime::digit(p0);
+crate::datetime::digit(p0);
+crate::datetime::digit(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.eq(p1);
+<datetime::Datetime as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::Datetime as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::Datetime>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.assert_receiver_is_total_eq();
+<datetime::Datetime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::Datetime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::Datetime>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.partial_cmp(p1);
+<datetime::Datetime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<datetime::Datetime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<datetime::Datetime>::partial_cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.cmp(p1);
+<datetime::Datetime as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::Datetime as std::cmp::Ord>::cmp(p0, p1);
+<datetime::Datetime>::cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.clone();
+<datetime::Datetime as std::clone::Clone>::clone(p0);
+crate::<datetime::Datetime as std::clone::Clone>::clone(p0);
+<datetime::Datetime>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::Datetime as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::Datetime as std::fmt::Debug>::fmt(p0, p1);
+<datetime::Datetime>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::DatetimeParseError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DatetimeParseError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::DatetimeParseError as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::DatetimeParseError as std::fmt::Debug>::fmt(p0, p1);
+<datetime::DatetimeParseError>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::DatetimeParseError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DatetimeParseError
+p0.clone();
+<datetime::DatetimeParseError as std::clone::Clone>::clone(p0);
+crate::<datetime::DatetimeParseError as std::clone::Clone>::clone(p0);
+<datetime::DatetimeParseError>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.eq(p1);
+<datetime::Date as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::Date as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::Date>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.assert_receiver_is_total_eq();
+<datetime::Date as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::Date as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::Date>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.partial_cmp(p1);
+<datetime::Date as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<datetime::Date as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<datetime::Date>::partial_cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.cmp(p1);
+<datetime::Date as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::Date as std::cmp::Ord>::cmp(p0, p1);
+<datetime::Date>::cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.clone();
+<datetime::Date as std::clone::Clone>::clone(p0);
+crate::<datetime::Date as std::clone::Clone>::clone(p0);
+<datetime::Date>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::Date as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::Date as std::fmt::Debug>::fmt(p0, p1);
+<datetime::Date>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.eq(p1);
+<datetime::Time as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::Time as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::Time>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.assert_receiver_is_total_eq();
+<datetime::Time as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::Time as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::Time>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.partial_cmp(p1);
+<datetime::Time as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<datetime::Time as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<datetime::Time>::partial_cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.cmp(p1);
+<datetime::Time as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::Time as std::cmp::Ord>::cmp(p0, p1);
+<datetime::Time>::cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.clone();
+<datetime::Time as std::clone::Clone>::clone(p0);
+crate::<datetime::Time as std::clone::Clone>::clone(p0);
+<datetime::Time>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::Time as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::Time as std::fmt::Debug>::fmt(p0, p1);
+<datetime::Time>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.eq(p1);
+<datetime::Offset as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::Offset as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::Offset>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.assert_receiver_is_total_eq();
+<datetime::Offset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::Offset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::Offset>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.partial_cmp(p1);
+<datetime::Offset as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<datetime::Offset as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<datetime::Offset>::partial_cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.cmp(p1);
+<datetime::Offset as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::Offset as std::cmp::Ord>::cmp(p0, p1);
+<datetime::Offset>::cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.clone();
+<datetime::Offset as std::clone::Clone>::clone(p0);
+crate::<datetime::Offset as std::clone::Clone>::clone(p0);
+<datetime::Offset>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::Offset as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::Offset as std::fmt::Debug>::fmt(p0, p1);
+<datetime::Offset>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::convert::From<datetime::Date>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::Date
+<datetime::Datetime as std::convert::From<datetime::Date>>::from(p0);
+crate::<datetime::Datetime as std::convert::From<datetime::Date>>::from(p0);
+<datetime::Datetime>::from(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::convert::From<datetime::Time>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::Time
+<datetime::Datetime as std::convert::From<datetime::Time>>::from(p0);
+crate::<datetime::Datetime as std::convert::From<datetime::Time>>::from(p0);
+<datetime::Datetime>::from(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::Datetime as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::Datetime as std::fmt::Display>::fmt(p0, p1);
+<datetime::Datetime>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::Date as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::Date as std::fmt::Display>::fmt(p0, p1);
+<datetime::Date>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::Time as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::Time as std::fmt::Display>::fmt(p0, p1);
+<datetime::Time>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::Offset as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::Offset as std::fmt::Display>::fmt(p0, p1);
+<datetime::Offset>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<datetime::Datetime as std::str::FromStr>::from_str(&p0);
+crate::<datetime::Datetime as std::str::FromStr>::from_str(&p0);
+<datetime::Datetime>::from_str(&p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as serde::Serialize>::serialize
deps:{"<datetime::Datetime as serde::Serialize>::serialize":{"S":["serde::Serializer","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"<datetime::Datetime as serde::Serialize>::serialize":{"S":["serde::__private::ser::FlatMapSerializer<'a, M>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::__private::ser::TaggedSerializer<S>","serde::__private::ser::content::ContentSerializer<E>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+<datetime::Datetime as serde::Serialize>::serialize(p0, p1);
+crate::<datetime::Datetime as serde::Serialize>::serialize(p0, p1);
+<datetime::Datetime>::serialize(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as serde::Deserialize<'de>>::deserialize
'de
deps:{"<datetime::Datetime as serde::Deserialize<'de>>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<datetime::Datetime as serde::Deserialize<'de>>::deserialize":{"D":["serde::de::value::I32Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::BoolDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::EnumAccessDeserializer<A>","serde::__private::de::content::SeqDeserializer<'de, E>","serde::de::value::I8Deserializer<E>","serde::de::value::BytesDeserializer<'a, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::IsizeDeserializer<E>","serde::__private::de::BorrowedStrDeserializer<'de, E>","serde::__private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::I128Deserializer<E>","serde::de::value::U8Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::U32Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::__private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::F64Deserializer<E>","serde::de::value::U16Deserializer<E>","serde::__private::de::missing_field::MissingFieldDeserializer<E>","serde::__private::de::content::ContentDeserializer<'de, E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::CharDeserializer<E>","serde::__private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::F32Deserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::__private::de::content::MapDeserializer<'de, E>","serde::__private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde::__private::de::StrDeserializer<'a, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::UsizeDeserializer<E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<datetime::Datetime as serde::Deserialize<'de>>::deserialize(p0);
+crate::<datetime::Datetime as serde::Deserialize<'de>>::deserialize(p0);
+<datetime::Datetime>::deserialize(p0);
-----------------
crates/toml_datetime/src/datetime.rs <<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor>::expecting(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor as serde::de::Visitor<'de>>::visit_map":{"V":["serde::de::MapAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor as serde::de::Visitor<'de>>::visit_map":{"V":["serde::__private::de::content::MapRefDeserializer<'a, 'de, E>","serde::__private::de::FlatStructAccess<'a, 'de, E>","serde::__private::de::FlatMapAccess<'a, 'de, E>","<&'a mut A as serde::de::MapAccess<'de>>","serde::de::value::MapDeserializer<'de, I, E>","serde::__private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::__private::de::content::MapDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit_map(p1);
+<<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<<datetime::Datetime as serde::Deserialize<'de>>::deserialize::DatetimeVisitor>::visit_map(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize
'de
deps:{"<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize":{"D":["serde::de::value::EnumAccessDeserializer<A>","serde::__private::de::content::MapDeserializer<'de, E>","serde::de::value::SeqAccessDeserializer<A>","serde::__private::de::StrDeserializer<'a, E>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::F32Deserializer<E>","serde::__private::de::content::SeqDeserializer<'de, E>","serde::de::value::I32Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::__private::de::content::MapRefDeserializer<'a, 'de, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::U128Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::I8Deserializer<E>","serde::__private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U8Deserializer<E>","serde::__private::de::BorrowedStrDeserializer<'de, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::U64Deserializer<E>","serde::__private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I128Deserializer<E>","serde::de::value::U16Deserializer<E>","serde::de::value::IsizeDeserializer<E>","serde::__private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::U32Deserializer<E>","serde::de::value::StringDeserializer<E>","serde::de::value::BytesDeserializer<'a, E>","serde::de::value::CharDeserializer<E>","serde::de::value::F64Deserializer<E>","serde::__private::de::FlatMapDeserializer<'a, 'de, E>","serde::__private::de::content::ContentDeserializer<'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize(p0);
+crate::<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize(p0);
+<datetime::DatetimeKey>::deserialize(p0);
-----------------
crates/toml_datetime/src/datetime.rs <<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor>::expecting(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<<datetime::DatetimeKey as serde::Deserialize<'de>>::deserialize::FieldVisitor>::visit_str(p0, &p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize
'de
deps:{"<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize":{"D":["serde::__private::de::content::MapDeserializer<'de, E>","serde::de::value::IsizeDeserializer<E>","serde::de::value::U32Deserializer<E>","serde::__private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::UsizeDeserializer<E>","serde::__private::de::content::ContentDeserializer<'de, E>","serde::de::value::I32Deserializer<E>","serde::de::value::U128Deserializer<E>","serde::de::value::U16Deserializer<E>","serde::__private::de::content::SeqDeserializer<'de, E>","serde::de::value::I8Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::BytesDeserializer<'a, E>","serde::de::value::U8Deserializer<E>","serde::de::value::BoolDeserializer<E>","serde::de::value::F32Deserializer<E>","serde::de::value::I128Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::F64Deserializer<E>","serde::de::value::EnumAccessDeserializer<A>","serde::__private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::U64Deserializer<E>","serde::__private::de::StrDeserializer<'a, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::StringDeserializer<E>","serde::de::value::MapAccessDeserializer<A>","serde::__private::de::content::MapRefDeserializer<'a, 'de, E>","serde::__private::de::BorrowedStrDeserializer<'de, E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::CharDeserializer<E>","serde::de::value::SeqAccessDeserializer<A>","serde::__private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::__private::de::content::ContentRefDeserializer<'a, 'de, E>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize(p0);
+crate::<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize(p0);
+<datetime::DatetimeFromString>::deserialize(p0);
-----------------
crates/toml_datetime/src/datetime.rs <<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor>::expecting(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_str":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_str":{"E":["serde::de::value::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<<datetime::DatetimeFromString as serde::Deserialize<'de>>::deserialize::Visitor>::visit_str(p0, &p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::DatetimeParseError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DatetimeParseError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::DatetimeParseError as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::DatetimeParseError as std::fmt::Display>::fmt(p0, p1);
+<datetime::DatetimeParseError>::fmt(p0, p1);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<spanned::Spanned<T> as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"],"T":["std::hash::Hash","std::marker::Sized"]},"spanned::Spanned":{"T":["serde::Deserialize","serde::Serialize","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord","std::hash::Hash","std::fmt::Debug","std::cmp::Eq"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<spanned::Spanned<T> as std::hash::Hash>::hash":{"H":["std::hash::SipHasher13","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::collections::hash_map::DefaultHasher"],"T":["std::hash::impls::<impl std::hash::Hash for &mut T>","std::hash::impls::<impl std::hash::Hash for *mut T>","spanned::Spanned"]},"spanned::Spanned":{"T":["spanned::Spanned"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<spanned::Spanned<T> as std::hash::Hash>::hash(p0, p1);
+crate::<spanned::Spanned<T> as std::hash::Hash>::hash(p0, p1);
+<spanned::Spanned<T>>::hash(p0, p1);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as std::cmp::PartialOrd>::partial_cmp
deps:{"<spanned::Spanned<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["std::cmp::PartialOrd","std::marker::Sized"]},"spanned::Spanned":{"T":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::cmp::PartialOrd","std::marker::Sized","serde::Deserialize","std::cmp::Eq","std::cmp::Ord","serde::Serialize"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<spanned::Spanned<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["spanned::Spanned","std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>","std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>"]},"spanned::Spanned":{"T":["spanned::Spanned"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.partial_cmp(p1);
+<spanned::Spanned<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<spanned::Spanned<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<spanned::Spanned<T>>::partial_cmp(p0, p1);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as std::cmp::Ord>::cmp
deps:{"<spanned::Spanned<T> as std::cmp::Ord>::cmp":{"T":["std::marker::Sized","std::cmp::Ord"]},"spanned::Spanned":{"T":["std::fmt::Debug","std::hash::Hash","std::clone::Clone","std::cmp::PartialEq","serde::Deserialize","std::cmp::PartialOrd","serde::Serialize","std::cmp::Ord","std::marker::Sized","std::cmp::Eq"]},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<spanned::Spanned<T> as std::cmp::Ord>::cmp":{"T":["spanned::Spanned","std::cmp::impls::<impl std::cmp::Ord for &A>"]},"spanned::Spanned":{"T":["spanned::Spanned"]},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
+p0.cmp(p1);
+<spanned::Spanned<T> as std::cmp::Ord>::cmp(p0, p1);
+crate::<spanned::Spanned<T> as std::cmp::Ord>::cmp(p0, p1);
+<spanned::Spanned<T>>::cmp(p0, p1);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize
'de
deps:{"<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"],"T":["std::marker::Sized","serde::Deserialize"]},"spanned::Spanned":{"T":["std::cmp::PartialOrd","std::cmp::Ord","std::cmp::Eq","std::hash::Hash","serde::Deserialize","std::marker::Sized","std::cmp::PartialEq","serde::Serialize","std::fmt::Debug","std::clone::Clone"]}}
candidates:{"<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize":{"D":["serde::de::value::F32Deserializer<E>","serde::de::value::MapDeserializer<'de, I, E>","serde::de::value::BoolDeserializer<E>","serde::__private::de::missing_field::MissingFieldDeserializer<E>","serde::de::value::StringDeserializer<E>","serde::__private::de::content::SeqRefDeserializer<'a, 'de, E>","serde::de::value::CharDeserializer<E>","serde::__private::de::content::MapRefDeserializer<'a, 'de, E>","serde::__private::de::FlatMapDeserializer<'a, 'de, E>","serde::de::value::BytesDeserializer<'a, E>","serde::de::value::I32Deserializer<E>","serde::de::value::F64Deserializer<E>","serde::de::value::SeqDeserializer<I, E>","serde::de::value::CowStrDeserializer<'a, E>","serde::de::value::SeqAccessDeserializer<A>","serde::de::value::MapAccessDeserializer<A>","serde::de::value::IsizeDeserializer<E>","serde::de::value::U64Deserializer<E>","serde::de::value::UsizeDeserializer<E>","serde::de::value::I64Deserializer<E>","serde::de::value::I16Deserializer<E>","serde::de::value::I8Deserializer<E>","serde::__private::de::StrDeserializer<'a, E>","serde::__private::de::content::ContentDeserializer<'de, E>","serde::de::value::U32Deserializer<E>","serde::__private::de::content::ContentRefDeserializer<'a, 'de, E>","serde::de::value::PairDeserializer<A, B, E>","serde::de::value::EnumAccessDeserializer<A>","serde::de::value::I128Deserializer<E>","serde::de::value::UnitDeserializer<E>","serde::de::value::U8Deserializer<E>","serde::__private::de::content::SeqDeserializer<'de, E>","serde::__private::de::content::MapDeserializer<'de, E>","serde::de::value::U16Deserializer<E>","serde::__private::de::BorrowedStrDeserializer<'de, E>","serde::de::value::BorrowedBytesDeserializer<'de, E>","serde::de::value::StrDeserializer<'a, E>","serde::de::value::BorrowedStrDeserializer<'de, E>","serde::de::value::U128Deserializer<E>"],"T":["spanned::Spanned"]},"spanned::Spanned":{"T":["spanned::Spanned"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize(p0);
+crate::<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize(p0);
+<spanned::Spanned<T>>::deserialize(p0);
-----------------
crates/serde_spanned/src/spanned.rs <<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::expecting
'de
deps:{"<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::expecting":{"T":["std::marker::Sized","serde::Deserialize"]},"spanned::Spanned":{"T":["serde::Serialize","std::hash::Hash","std::cmp::Ord","std::cmp::Eq","std::marker::Sized","serde::Deserialize","std::cmp::PartialEq","std::clone::Clone","std::cmp::PartialOrd","std::fmt::Debug"]}}
candidates:{"<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::expecting":{"T":["spanned::Spanned"]},"spanned::Spanned":{"T":["spanned::Spanned"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T>>::expecting(p0, p1);
-----------------
crates/serde_spanned/src/spanned.rs <<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::visit_map":{"T":["serde::Deserialize","std::marker::Sized"],"V":["std::marker::Sized","serde::de::MapAccess"]},"spanned::Spanned":{"T":["std::clone::Clone","std::marker::Sized","std::hash::Hash","std::cmp::PartialOrd","std::cmp::Ord","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","serde::Deserialize","serde::Serialize"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::visit_map":{"T":["spanned::Spanned"],"V":["<&'a mut A as serde::de::MapAccess<'de>>","serde::__private::de::content::MapDeserializer<'de, E>","serde::__private::de::content::MapRefDeserializer<'a, 'de, E>","serde::__private::de::FlatMapAccess<'a, 'de, E>","serde::__private::de::FlatInternallyTaggedAccess<'a, 'de, E>","serde::de::value::MapDeserializer<'de, I, E>","serde::__private::de::FlatStructAccess<'a, 'de, E>"]},"spanned::Spanned":{"T":["spanned::Spanned"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit_map(p1);
+<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T> as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<<spanned::Spanned<T> as serde::Deserialize<'de>>::deserialize::SpannedVisitor<T>>::visit_map(p0, p1);
-----------------
crates/serde_spanned/src/spanned.rs <spanned::Spanned<T> as serde::Serialize>::serialize
deps:{"<spanned::Spanned<T> as serde::Serialize>::serialize":{"S":["serde::Serializer","std::marker::Sized"],"T":["serde::Serialize","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"spanned::Spanned":{"T":["std::cmp::PartialEq","serde::Deserialize","std::cmp::PartialOrd","std::cmp::Ord","serde::Serialize","std::marker::Sized","std::fmt::Debug","std::hash::Hash","std::clone::Clone","std::cmp::Eq"]}}
candidates:{"<spanned::Spanned<T> as serde::Serialize>::serialize":{"S":["serde::__private::ser::FlatMapSerializer<'a, M>","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","serde::__private::ser::TaggedSerializer<S>","serde::__private::ser::content::ContentSerializer<E>"],"T":["spanned::Spanned","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"spanned::Spanned":{"T":["spanned::Spanned"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // spanned::Spanned<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+<spanned::Spanned<T> as serde::Serialize>::serialize(p0, p1);
+crate::<spanned::Spanned<T> as serde::Serialize>::serialize(p0, p1);
+<spanned::Spanned<T>>::serialize(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::decorate_array
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+array::decorate_array(p0);
+crate::array::decorate_array(p0);
+crate::array::decorate_array(p0);
-----------------
crates/toml_edit/src/encode.rs encode::visit_nested_tables
't
deps:{"encode::visit_nested_tables":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"encode::visit_nested_tables":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = true; // None+bool
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // F
+encode::visit_nested_tables(p0, p1, p2, p3);
+crate::encode::visit_nested_tables(p0, p1, p2, p3);
+crate::encode::visit_nested_tables(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs encode::visit_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p2 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p3 = & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p4 = true; // None+bool
let mut p5 = &mut true; // None+bool
+encode::visit_table(p0, p1, p2, p3, p4, p5);
+crate::encode::visit_table(p0, p1, p2, p3, p4, p5);
+crate::encode::visit_table(p0, p1, p2, p3, p4, p5);
-----------------
crates/toml_edit/src/encode.rs encode::to_string_repr
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<encode::StringStyle>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<bool>
+encode::to_string_repr(&p0, p1, p2);
+crate::encode::to_string_repr(&p0, p1, p2);
+crate::encode::to_string_repr(&p0, p1, p2);
-----------------
crates/toml_edit/src/encode.rs encode::infer_style
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+encode::infer_style(&p0);
+crate::encode::infer_style(&p0);
+crate::encode::infer_style(&p0);
-----------------
crates/toml_edit/src/encode.rs encode::to_f64_repr
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+encode::to_f64_repr(p0);
+crate::encode::to_f64_repr(p0);
+crate::encode::to_f64_repr(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::decorate_inline_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+inline_table::decorate_inline_table(p0);
+crate::inline_table::decorate_inline_table(p0);
+crate::inline_table::decorate_inline_table(p0);
-----------------
crates/toml_edit/src/item.rs item::value
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"item::value":{"V":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"item::value":{"V":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // V
+item::value(p0);
+crate::item::value(p0);
+crate::item::value(p0);
-----------------
crates/toml_edit/src/item.rs item::table
deps:{}
candidates:{}
+item::table();
+crate::item::table();
+crate::item::table();
-----------------
crates/toml_edit/src/item.rs item::array
deps:{}
candidates:{}
+item::array();
+crate::item::array();
+crate::item::array();
-----------------
crates/toml_edit/src/key.rs key::to_key_repr
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+key::to_key_repr(&p0);
+crate::key::to_key_repr(&p0);
+crate::key::to_key_repr(&p0);
-----------------
crates/toml_edit/src/parser/array.rs parser::array::array
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::array::array(p0);
+crate::parser::array::array(p0);
+crate::parser::array::array(p0);
-----------------
crates/toml_edit/src/parser/array.rs parser::array::array_values
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::array::array_values(p0);
+crate::parser::array::array_values(p0);
+crate::parser::array::array_values(p0);
-----------------
crates/toml_edit/src/parser/array.rs parser::array::array_value
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::array::array_value(p0);
+crate::parser::array::array_value(p0);
+crate::parser::array::array_value(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::date_time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::date_time(p0);
+crate::parser::datetime::date_time(p0);
+crate::parser::datetime::date_time(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::full_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::full_date(p0);
+crate::parser::datetime::full_date(p0);
+crate::parser::datetime::full_date(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::partial_time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::partial_time(p0);
+crate::parser::datetime::partial_time(p0);
+crate::parser::datetime::partial_time(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_offset
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_offset(p0);
+crate::parser::datetime::time_offset(p0);
+crate::parser::datetime::time_offset(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::date_fullyear
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::date_fullyear(p0);
+crate::parser::datetime::date_fullyear(p0);
+crate::parser::datetime::date_fullyear(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::date_month
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::date_month(p0);
+crate::parser::datetime::date_month(p0);
+crate::parser::datetime::date_month(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::date_mday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::date_mday(p0);
+crate::parser::datetime::date_mday(p0);
+crate::parser::datetime::date_mday(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_delim
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_delim(p0);
+crate::parser::datetime::time_delim(p0);
+crate::parser::datetime::time_delim(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_hour
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_hour(p0);
+crate::parser::datetime::time_hour(p0);
+crate::parser::datetime::time_hour(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_minute
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_minute(p0);
+crate::parser::datetime::time_minute(p0);
+crate::parser::datetime::time_minute(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_second
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_second(p0);
+crate::parser::datetime::time_second(p0);
+crate::parser::datetime::time_second(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_secfrac
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_secfrac(p0);
+crate::parser::datetime::time_secfrac(p0);
+crate::parser::datetime::time_secfrac(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::unsigned_digits
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::unsigned_digits(p0);
+crate::parser::datetime::unsigned_digits(p0);
+crate::parser::datetime::unsigned_digits(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::document
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::document::document(p0);
+crate::parser::document::document(p0);
+crate::parser::document::document(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::parse_comment
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::document::parse_comment(p0);
+crate::parser::document::parse_comment(p0);
+crate::parser::document::parse_comment(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::parse_ws
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::document::parse_ws(p0);
+crate::parser::document::parse_ws(p0);
+crate::parser::document::parse_ws(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::parse_newline
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::document::parse_newline(p0);
+crate::parser::document::parse_newline(p0);
+crate::parser::document::parse_newline(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::keyval
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::document::keyval(p0);
+crate::parser::document::keyval(p0);
+crate::parser::document::keyval(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::parse_keyval
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::document::parse_keyval(p0);
+crate::parser::document::parse_keyval(p0);
+crate::parser::document::parse_keyval(p0);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::translate_position
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
+parser::errors::translate_position(p0, p1);
+crate::parser::errors::translate_position(p0, p1);
+crate::parser::errors::translate_position(p0, p1);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::inline_table
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::inline_table::inline_table(p0);
+crate::parser::inline_table::inline_table(p0);
+crate::parser::inline_table::inline_table(p0);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::table_from_pairs
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<(std::vec::Vec<key::Key>, table::TableKeyValue)>
let mut p1 = MaybeUninit::uninit().assume_init(); // raw_string::RawString
+parser::inline_table::table_from_pairs(p0, p1);
+crate::parser::inline_table::table_from_pairs(p0, p1);
+crate::parser::inline_table::table_from_pairs(p0, p1);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::descend_path
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // [key::Key]
+parser::inline_table::descend_path(p0, p1);
+crate::parser::inline_table::descend_path(p0, p1);
+crate::parser::inline_table::descend_path(p0, p1);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::inline_table_keyvals
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::inline_table::inline_table_keyvals(p0);
+crate::parser::inline_table::inline_table_keyvals(p0);
+crate::parser::inline_table::inline_table_keyvals(p0);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::keyval
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::inline_table::keyval(p0);
+crate::parser::inline_table::keyval(p0);
+crate::parser::inline_table::keyval(p0);
-----------------
crates/toml_edit/src/parser/key.rs parser::key::key
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::key::key(p0);
+crate::parser::key::key(p0);
+crate::parser::key::key(p0);
-----------------
crates/toml_edit/src/parser/key.rs parser::key::simple_key
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::key::simple_key(p0);
+crate::parser::key::simple_key(p0);
+crate::parser::key::simple_key(p0);
-----------------
crates/toml_edit/src/parser/key.rs parser::key::unquoted_key
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::key::unquoted_key(p0);
+crate::parser::key::unquoted_key(p0);
+crate::parser::key::unquoted_key(p0);
-----------------
crates/toml_edit/src/parser/key.rs parser::key::is_unquoted_char
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+parser::key::is_unquoted_char(p0);
+crate::parser::key::is_unquoted_char(p0);
+crate::parser::key::is_unquoted_char(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::boolean
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::boolean(p0);
+crate::parser::numbers::boolean(p0);
+crate::parser::numbers::boolean(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::true_
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::true_(p0);
+crate::parser::numbers::true_(p0);
+crate::parser::numbers::true_(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::false_
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::false_(p0);
+crate::parser::numbers::false_(p0);
+crate::parser::numbers::false_(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::integer
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::integer(p0);
+crate::parser::numbers::integer(p0);
+crate::parser::numbers::integer(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::dec_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::dec_int(p0);
+crate::parser::numbers::dec_int(p0);
+crate::parser::numbers::dec_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::hex_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::hex_int(p0);
+crate::parser::numbers::hex_int(p0);
+crate::parser::numbers::hex_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::oct_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::oct_int(p0);
+crate::parser::numbers::oct_int(p0);
+crate::parser::numbers::oct_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::bin_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::bin_int(p0);
+crate::parser::numbers::bin_int(p0);
+crate::parser::numbers::bin_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::float
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::float(p0);
+crate::parser::numbers::float(p0);
+crate::parser::numbers::float(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::float_
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::float_(p0);
+crate::parser::numbers::float_(p0);
+crate::parser::numbers::float_(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::frac
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::frac(p0);
+crate::parser::numbers::frac(p0);
+crate::parser::numbers::frac(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::zero_prefixable_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::zero_prefixable_int(p0);
+crate::parser::numbers::zero_prefixable_int(p0);
+crate::parser::numbers::zero_prefixable_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::exp
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::exp(p0);
+crate::parser::numbers::exp(p0);
+crate::parser::numbers::exp(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::special_float
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::special_float(p0);
+crate::parser::numbers::special_float(p0);
+crate::parser::numbers::special_float(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::inf
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::inf(p0);
+crate::parser::numbers::inf(p0);
+crate::parser::numbers::inf(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::nan
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::nan(p0);
+crate::parser::numbers::nan(p0);
+crate::parser::numbers::nan(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::digit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::digit(p0);
+crate::parser::numbers::digit(p0);
+crate::parser::numbers::digit(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::hexdig
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::hexdig(p0);
+crate::parser::numbers::hexdig(p0);
+crate::parser::numbers::hexdig(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::string(p0);
+crate::parser::strings::string(p0);
+crate::parser::strings::string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::basic_string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::basic_string(p0);
+crate::parser::strings::basic_string(p0);
+crate::parser::strings::basic_string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::basic_chars
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::basic_chars(p0);
+crate::parser::strings::basic_chars(p0);
+crate::parser::strings::basic_chars(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::escaped
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::escaped(p0);
+crate::parser::strings::escaped(p0);
+crate::parser::strings::escaped(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::escape_seq_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::escape_seq_char(p0);
+crate::parser::strings::escape_seq_char(p0);
+crate::parser::strings::escape_seq_char(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::hexescape
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::hexescape(p0);
+crate::parser::strings::hexescape(p0);
+crate::parser::strings::hexescape(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::ml_basic_string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::ml_basic_string(p0);
+crate::parser::strings::ml_basic_string(p0);
+crate::parser::strings::ml_basic_string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::ml_basic_body
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::ml_basic_body(p0);
+crate::parser::strings::ml_basic_body(p0);
+crate::parser::strings::ml_basic_body(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mlb_content
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::mlb_content(p0);
+crate::parser::strings::mlb_content(p0);
+crate::parser::strings::mlb_content(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mlb_quotes
'i
deps:{"<F as winnow::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"parser::strings::mlb_quotes":{"impl winnow::Parser<Input<'i>, (), ParserError<'i>>":["winnow::Parser","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as winnow::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"]},"parser::strings::mlb_quotes":{"impl winnow::Parser<Input<'i>, (), ParserError<'i>>":["<F as winnow::Parser<I, O, E>>","u8","char"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl winnow::Parser<Input<'i>, (), ParserError<'i>>
+parser::strings::mlb_quotes(p0);
+crate::parser::strings::mlb_quotes(p0);
+crate::parser::strings::mlb_quotes(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mlb_escaped_nl
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::mlb_escaped_nl(p0);
+crate::parser::strings::mlb_escaped_nl(p0);
+crate::parser::strings::mlb_escaped_nl(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::literal_string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::literal_string(p0);
+crate::parser::strings::literal_string(p0);
+crate::parser::strings::literal_string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::ml_literal_string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::ml_literal_string(p0);
+crate::parser::strings::ml_literal_string(p0);
+crate::parser::strings::ml_literal_string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::ml_literal_body
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::ml_literal_body(p0);
+crate::parser::strings::ml_literal_body(p0);
+crate::parser::strings::ml_literal_body(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mll_content
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::mll_content(p0);
+crate::parser::strings::mll_content(p0);
+crate::parser::strings::mll_content(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mll_quotes
'i
deps:{"<F as winnow::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"parser::strings::mll_quotes":{"impl winnow::Parser<Input<'i>, (), ParserError<'i>>":["std::marker::Sized","winnow::Parser"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as winnow::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty"]},"parser::strings::mll_quotes":{"impl winnow::Parser<Input<'i>, (), ParserError<'i>>":["<F as winnow::Parser<I, O, E>>","u8","char"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl winnow::Parser<Input<'i>, (), ParserError<'i>>
+parser::strings::mll_quotes(p0);
+crate::parser::strings::mll_quotes(p0);
+crate::parser::strings::mll_quotes(p0);
-----------------
crates/toml_edit/src/parser/table.rs parser::table::std_table
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::table::std_table(p0);
+crate::parser::table::std_table(p0);
+crate::parser::table::std_table(p0);
-----------------
crates/toml_edit/src/parser/table.rs parser::table::array_table
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::table::array_table(p0);
+crate::parser::table::array_table(p0);
+crate::parser::table::array_table(p0);
-----------------
crates/toml_edit/src/parser/table.rs parser::table::table
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::table::table(p0);
+crate::parser::table::table(p0);
+crate::parser::table::table(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::from_utf8_unchecked
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = "sample"; // None+&str
+parser::trivia::from_utf8_unchecked(p0, &p1);
+crate::parser::trivia::from_utf8_unchecked(p0, &p1);
+crate::parser::trivia::from_utf8_unchecked(p0, &p1);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::ws
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::ws(p0);
+crate::parser::trivia::ws(p0);
+crate::parser::trivia::ws(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::comment
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::comment(p0);
+crate::parser::trivia::comment(p0);
+crate::parser::trivia::comment(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::newline
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::newline(p0);
+crate::parser::trivia::newline(p0);
+crate::parser::trivia::newline(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::ws_newline
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::ws_newline(p0);
+crate::parser::trivia::ws_newline(p0);
+crate::parser::trivia::ws_newline(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::ws_newlines
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::ws_newlines(p0);
+crate::parser::trivia::ws_newlines(p0);
+crate::parser::trivia::ws_newlines(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::ws_comment_newline
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::ws_comment_newline(p0);
+crate::parser::trivia::ws_comment_newline(p0);
+crate::parser::trivia::ws_comment_newline(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::line_ending
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::line_ending(p0);
+crate::parser::trivia::line_ending(p0);
+crate::parser::trivia::line_ending(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::line_trailing
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::line_trailing(p0);
+crate::parser::trivia::line_trailing(p0);
+crate::parser::trivia::line_trailing(p0);
-----------------
crates/toml_edit/src/parser/value.rs parser::value::value
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::value::value(p0);
+crate::parser::value::value(p0);
+crate::parser::value::value(p0);
-----------------
crates/toml_edit/src/parser/value.rs parser::value::apply_raw
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+parser::value::apply_raw(p0, p1);
+crate::parser::value::apply_raw(p0, p1);
+crate::parser::value::apply_raw(p0, p1);
-----------------
crates/toml_edit/src/parser/mod.rs parser::parse_document
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse_document(&p0);
+crate::parser::parse_document(&p0);
+crate::parser::parse_document(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::parse_key
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse_key(&p0);
+crate::parser::parse_key(&p0);
+crate::parser::parse_key(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::parse_key_path
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse_key_path(&p0);
+crate::parser::parse_key_path(&p0);
+crate::parser::parse_key_path(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::parse_value
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse_value(&p0);
+crate::parser::parse_value(&p0);
+crate::parser::parse_value(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::new_input
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::prelude::new_input(&p0);
+crate::parser::prelude::new_input(&p0);
+crate::parser::prelude::new_input(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::ok_error
deps:{"parser::prelude::ok_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]}}
candidates:{"parser::prelude::ok_error":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<(I, O), winnow::error::ErrMode<E>>
+parser::prelude::ok_error(p0);
+crate::parser::prelude::ok_error(p0);
+crate::parser::prelude::ok_error(p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::trace
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as winnow::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"parser::prelude::trace":{"E":["std::fmt::Debug","std::marker::Sized"],"I":["std::fmt::Debug","std::marker::Sized"],"O":["std::fmt::Debug","std::marker::Sized"],"impl std::fmt::Display":["std::marker::Sized","std::fmt::Display"],"impl winnow::Parser<I, O, E>":["std::marker::Sized","winnow::Parser"]},"repr::Formatted":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::hash::Hash","repr::ValueRepr"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as winnow::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"parser::prelude::trace":{"E":["value::Value","repr::Decor","encode::StringStyle","parser::errors::Context","parser::errors::ParserValue","<&mut T as std::fmt::Debug>","inline_table::InlineTable","repr::Formatted","ser::Error","item::Item","table::TableKeyValue","array_of_tables::ArrayOfTables","internal_string::InternalString","raw_string::RawString","parser::prelude::RecursionCheck","<*const T as std::fmt::Debug>","repr::Repr","parser::errors::ParserError","table::Table","array::Array","key::Key","document::Document","de::Error","key::KeyMut","parser::errors::TomlError","parser::errors::CustomError"],"I":["<*const T as std::fmt::Debug>","array_of_tables::ArrayOfTables","key::KeyMut","document::Document","value::Value","parser::errors::ParserValue","<*mut T as std::fmt::Debug>","ser::Error","de::Error","parser::errors::CustomError","parser::prelude::RecursionCheck","array::Array","parser::errors::ParserError","encode::StringStyle","raw_string::RawString","parser::errors::TomlError","internal_string::InternalString","key::Key","repr::Decor","inline_table::InlineTable","parser::errors::Context","table::Table","repr::Repr","table::TableKeyValue","item::Item","repr::Formatted"],"O":["parser::prelude::RecursionCheck","array::Array","repr::Decor","parser::errors::CustomError","table::TableKeyValue","array_of_tables::ArrayOfTables","parser::errors::TomlError","<&mut T as std::fmt::Debug>","repr::Repr","<*mut T as std::fmt::Debug>","raw_string::RawString","de::Error","encode::StringStyle","item::Item","parser::errors::ParserValue","internal_string::InternalString","ser::Error","inline_table::InlineTable","key::KeyMut","table::Table","repr::Formatted","value::Value","key::Key","parser::errors::ParserError","parser::errors::Context","document::Document"],"impl std::fmt::Display":["ser::Error","parser::errors::TomlError","key::KeyMut","de::Error","<&T as std::fmt::Display>","item::Item","parser::errors::CustomError","internal_string::InternalString","document::Document","table::Table","array_of_tables::ArrayOfTables","value::Value","array::Array","parser::errors::ParserError","inline_table::InlineTable","repr::Formatted","key::Key","parser::errors::ParserValue"],"impl winnow::Parser<I, O, E>":["char","u8","<F as winnow::Parser<I, O, E>>"]},"repr::Formatted":{"T":["i64","bool"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl std::fmt::Display
let mut p1 = MaybeUninit::uninit().assume_init(); // impl winnow::Parser<I, O, E>
+parser::prelude::trace(p0, p1);
+crate::parser::prelude::trace(p0, p1);
+crate::parser::prelude::trace(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::decorate_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+table::decorate_table(p0);
+crate::table::decorate_table(p0);
+crate::table::decorate_table(p0);
-----------------
crates/toml_edit/src/de/key.rs de::key::unit_only
deps:{"de::key::unit_only":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"de::key::unit_only":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+de::key::unit_only(p0);
+crate::de::key::unit_only(p0);
+crate::de::key::unit_only(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::from_str
deps:{"<T as serde::de::DeserializeOwned>":{"T":["serde::Deserialize","std::marker::Sized"]},"de::from_str":{"T":["std::marker::Sized","serde::de::DeserializeOwned"]}}
candidates:{"<T as serde::de::DeserializeOwned>":{"T":["internal_string::InternalString"]},"de::from_str":{"T":["<T as serde::de::DeserializeOwned>"]}}
let mut p0 = "sample"; // None+&str
+de::from_str(&p0);
+crate::de::from_str(&p0);
+crate::de::from_str(&p0);
-----------------
crates/toml_edit/src/de/mod.rs de::from_slice
deps:{"<T as serde::de::DeserializeOwned>":{"T":["std::marker::Sized","serde::Deserialize"]},"de::from_slice":{"T":["serde::de::DeserializeOwned","std::marker::Sized"]}}
candidates:{"<T as serde::de::DeserializeOwned>":{"T":["internal_string::InternalString"]},"de::from_slice":{"T":["<T as serde::de::DeserializeOwned>"]}}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+de::from_slice(p0);
+crate::de::from_slice(p0);
+crate::de::from_slice(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::from_document
deps:{"<T as serde::de::DeserializeOwned>":{"T":["serde::Deserialize","std::marker::Sized"]},"de::from_document":{"T":["serde::de::DeserializeOwned","std::marker::Sized"]}}
candidates:{"<T as serde::de::DeserializeOwned>":{"T":["internal_string::InternalString"]},"de::from_document":{"T":["<T as serde::de::DeserializeOwned>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // document::Document
+de::from_document(p0);
+crate::de::from_document(p0);
+crate::de::from_document(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::validate_struct_keys
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // indexmap::IndexMap<internal_string::InternalString, table::TableKeyValue>
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
+de::validate_struct_keys(p0, p1);
+crate::de::validate_struct_keys(p0, p1);
+crate::de::validate_struct_keys(p0, p1);
-----------------
crates/toml_edit/src/ser/mod.rs ser::to_vec
deps:{"ser::to_vec":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"ser::to_vec":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_vec(p0);
+crate::ser::to_vec(p0);
+crate::ser::to_vec(p0);
-----------------
crates/toml_edit/src/ser/mod.rs ser::to_string
deps:{"ser::to_string":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"ser::to_string":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_string(p0);
+crate::ser::to_string(p0);
+crate::ser::to_string(p0);
-----------------
crates/toml_edit/src/ser/mod.rs ser::to_string_pretty
deps:{"ser::to_string_pretty":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"ser::to_string_pretty":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_string_pretty(p0);
+crate::ser::to_string_pretty(p0);
+crate::ser::to_string_pretty(p0);
-----------------
crates/toml_edit/src/ser/mod.rs ser::to_document
deps:{"ser::to_document":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"ser::to_document":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_document(p0);
+crate::ser::to_document(p0);
+crate::ser::to_document(p0);
-----------------
crates/toml_edit/src/visit.rs visit::visit_document
'doc
deps:{"visit::visit_document":{"V":["visit::Visit"]}}
candidates:{"visit::visit_document":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // document::Document
+visit::visit_document(p0, p1);
+crate::visit::visit_document(p0, p1);
+crate::visit::visit_document(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_item
'doc
deps:{"visit::visit_item":{"V":["visit::Visit"]}}
candidates:{"visit::visit_item":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+visit::visit_item(p0, p1);
+crate::visit::visit_item(p0, p1);
+crate::visit::visit_item(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_table
'doc
deps:{"visit::visit_table":{"V":["visit::Visit"]}}
candidates:{"visit::visit_table":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // table::Table
+visit::visit_table(p0, p1);
+crate::visit::visit_table(p0, p1);
+crate::visit::visit_table(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_inline_table
'doc
deps:{"visit::visit_inline_table":{"V":["visit::Visit"]}}
candidates:{"visit::visit_inline_table":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+visit::visit_inline_table(p0, p1);
+crate::visit::visit_inline_table(p0, p1);
+crate::visit::visit_inline_table(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_table_like
'doc
deps:{"visit::visit_table_like":{"V":["visit::Visit"]}}
candidates:{"visit::visit_table_like":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // (dyn table::TableLike + 'doc)
+visit::visit_table_like(p0, p1);
+crate::visit::visit_table_like(p0, p1);
+crate::visit::visit_table_like(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_table_like_kv
'doc
deps:{"visit::visit_table_like_kv":{"V":["visit::Visit"]}}
candidates:{"visit::visit_table_like_kv":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // item::Item
+visit::visit_table_like_kv(p0, &p1, p2);
+crate::visit::visit_table_like_kv(p0, &p1, p2);
+crate::visit::visit_table_like_kv(p0, &p1, p2);
-----------------
crates/toml_edit/src/visit.rs visit::visit_array
'doc
deps:{"visit::visit_array":{"V":["visit::Visit"]}}
candidates:{"visit::visit_array":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // array::Array
+visit::visit_array(p0, p1);
+crate::visit::visit_array(p0, p1);
+crate::visit::visit_array(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_array_of_tables
'doc
deps:{"visit::visit_array_of_tables":{"V":["visit::Visit"]}}
candidates:{"visit::visit_array_of_tables":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+visit::visit_array_of_tables(p0, p1);
+crate::visit::visit_array_of_tables(p0, p1);
+crate::visit::visit_array_of_tables(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_value
'doc
deps:{"visit::visit_value":{"V":["visit::Visit"]}}
candidates:{"visit::visit_value":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+visit::visit_value(p0, p1);
+crate::visit::visit_value(p0, p1);
+crate::visit::visit_value(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_boolean
'doc
deps:{"visit::visit_boolean":{"V":["visit::Visit"]}}
candidates:{"visit::visit_boolean":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<bool>
+visit::visit_boolean(p0, p1);
+crate::visit::visit_boolean(p0, p1);
+crate::visit::visit_boolean(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_datetime
'doc
deps:{"visit::visit_datetime":{"V":["visit::Visit"]}}
candidates:{"visit::visit_datetime":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<toml_datetime::Datetime>
+visit::visit_datetime(p0, p1);
+crate::visit::visit_datetime(p0, p1);
+crate::visit::visit_datetime(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_float
'doc
deps:{"visit::visit_float":{"V":["visit::Visit"]}}
candidates:{"visit::visit_float":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<f64>
+visit::visit_float(p0, p1);
+crate::visit::visit_float(p0, p1);
+crate::visit::visit_float(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_integer
'doc
deps:{"visit::visit_integer":{"V":["visit::Visit"]}}
candidates:{"visit::visit_integer":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<i64>
+visit::visit_integer(p0, p1);
+crate::visit::visit_integer(p0, p1);
+crate::visit::visit_integer(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_string
'doc
deps:{"visit::visit_string":{"V":["visit::Visit"]}}
candidates:{"visit::visit_string":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & std::string::String::new(); // None+repr::Formatted<std::string::String>
+visit::visit_string(p0, p1);
+crate::visit::visit_string(p0, p1);
+crate::visit::visit_string(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_document_mut
deps:{"visit_mut::visit_document_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_document_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+visit_mut::visit_document_mut(p0, p1);
+crate::visit_mut::visit_document_mut(p0, p1);
+crate::visit_mut::visit_document_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_item_mut
deps:{"visit_mut::visit_item_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_item_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+visit_mut::visit_item_mut(p0, p1);
+crate::visit_mut::visit_item_mut(p0, p1);
+crate::visit_mut::visit_item_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_table_mut
deps:{"visit_mut::visit_table_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_table_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+visit_mut::visit_table_mut(p0, p1);
+crate::visit_mut::visit_table_mut(p0, p1);
+crate::visit_mut::visit_table_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_inline_table_mut
deps:{"visit_mut::visit_inline_table_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_inline_table_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+visit_mut::visit_inline_table_mut(p0, p1);
+crate::visit_mut::visit_inline_table_mut(p0, p1);
+crate::visit_mut::visit_inline_table_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_table_like_mut
deps:{"visit_mut::visit_table_like_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_table_like_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn table::TableLike
+visit_mut::visit_table_like_mut(p0, p1);
+crate::visit_mut::visit_table_like_mut(p0, p1);
+crate::visit_mut::visit_table_like_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_table_like_kv_mut
deps:{"visit_mut::visit_table_like_kv_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_table_like_kv_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = MaybeUninit::uninit().assume_init(); // key::KeyMut<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+visit_mut::visit_table_like_kv_mut(p0, p1, p2);
+crate::visit_mut::visit_table_like_kv_mut(p0, p1, p2);
+crate::visit_mut::visit_table_like_kv_mut(p0, p1, p2);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_array_mut
deps:{"visit_mut::visit_array_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_array_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+visit_mut::visit_array_mut(p0, p1);
+crate::visit_mut::visit_array_mut(p0, p1);
+crate::visit_mut::visit_array_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_array_of_tables_mut
deps:{"visit_mut::visit_array_of_tables_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_array_of_tables_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+visit_mut::visit_array_of_tables_mut(p0, p1);
+crate::visit_mut::visit_array_of_tables_mut(p0, p1);
+crate::visit_mut::visit_array_of_tables_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_value_mut
deps:{"visit_mut::visit_value_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_value_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+visit_mut::visit_value_mut(p0, p1);
+crate::visit_mut::visit_value_mut(p0, p1);
+crate::visit_mut::visit_value_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_boolean_mut
deps:{"visit_mut::visit_boolean_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_boolean_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<bool>
+visit_mut::visit_boolean_mut(p0, p1);
+crate::visit_mut::visit_boolean_mut(p0, p1);
+crate::visit_mut::visit_boolean_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_datetime_mut
deps:{"visit_mut::visit_datetime_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_datetime_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<toml_datetime::Datetime>
+visit_mut::visit_datetime_mut(p0, p1);
+crate::visit_mut::visit_datetime_mut(p0, p1);
+crate::visit_mut::visit_datetime_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_float_mut
deps:{"visit_mut::visit_float_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_float_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<f64>
+visit_mut::visit_float_mut(p0, p1);
+crate::visit_mut::visit_float_mut(p0, p1);
+crate::visit_mut::visit_float_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_integer_mut
deps:{"visit_mut::visit_integer_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_integer_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<i64>
+visit_mut::visit_integer_mut(p0, p1);
+crate::visit_mut::visit_integer_mut(p0, p1);
+crate::visit_mut::visit_integer_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_string_mut
deps:{"visit_mut::visit_string_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_string_mut":{"V":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut std::string::String::new(); // None+repr::Formatted<std::string::String>
+visit_mut::visit_string_mut(p0, p1);
+crate::visit_mut::visit_string_mut(p0, p1);
+crate::visit_mut::visit_string_mut(p0, p1);
-----------------
crates/toml_edit/src/encode.rs encode::Encode::encode
deps:{"encode::Encode::encode":{"Self":["encode::Encode"]},"repr::Formatted":{"T":["std::marker::Sized","std::hash::Hash","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","repr::ValueRepr","std::clone::Clone"]}}
candidates:{"encode::Encode::encode":{"Self":["inline_table::InlineTable","key::Key","repr::Formatted","value::Value","array::Array"]},"repr::Formatted":{"T":["bool","i64"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+encode::Encode::encode(p0, p1, p2, p3);
+crate::encode::Encode::encode(p0, p1, p2, p3);
+crate::encode::Encode::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/index.rs index::Index::index
deps:{"<&'a T as index::Index>":{},"index::Index::index":{"Self":["index::Index","private::Sealed"]}}
candidates:{"<&'a T as index::Index>":{},"index::Index::index":{"Self":["std::string::String","<&'a T as index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+index::Index::index(p0, p1);
+crate::index::Index::index(p0, p1);
+crate::index::Index::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs index::Index::index_mut
deps:{"<&'a T as index::Index>":{},"<&'a T as private::Sealed>":{},"index::Index::index_mut":{"Self":["private::Sealed","index::Index"]}}
candidates:{"<&'a T as index::Index>":{},"<&'a T as private::Sealed>":{},"index::Index::index_mut":{"Self":["std::string::String","<&'a T as index::Index>","<&'a T as private::Sealed>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+index::Index::index_mut(p0, p1);
+crate::index::Index::index_mut(p0, p1);
+crate::index::Index::index_mut(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::ValueRepr::to_repr
deps:{"repr::ValueRepr::to_repr":{"Self":["private::Sealed","repr::ValueRepr"]}}
candidates:{"repr::ValueRepr::to_repr":{"Self":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_repr();
+repr::ValueRepr::to_repr(p0);
+crate::repr::ValueRepr::to_repr(p0);
+crate::repr::ValueRepr::to_repr(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::iter
deps:{"table::TableLike::iter":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::iter":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.iter();
+table::TableLike::iter(p0);
+crate::table::TableLike::iter(p0);
+crate::table::TableLike::iter(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::iter_mut
deps:{"table::TableLike::iter_mut":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::iter_mut":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.iter_mut();
+table::TableLike::iter_mut(p0);
+crate::table::TableLike::iter_mut(p0);
+crate::table::TableLike::iter_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::len
deps:{"table::TableLike::len":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::len":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.len();
+table::TableLike::len(p0);
+crate::table::TableLike::len(p0);
+crate::table::TableLike::len(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::is_empty
deps:{"table::TableLike::is_empty":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::is_empty":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_empty();
+table::TableLike::is_empty(p0);
+crate::table::TableLike::is_empty(p0);
+crate::table::TableLike::is_empty(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::clear
deps:{"table::TableLike::clear":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::clear":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.clear();
+table::TableLike::clear(p0);
+crate::table::TableLike::clear(p0);
+crate::table::TableLike::clear(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::entry
deps:{"table::TableLike::entry":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::entry":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.entry(&p1);
+table::TableLike::entry(p0, &p1);
+crate::table::TableLike::entry(p0, &p1);
+crate::table::TableLike::entry(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::entry_format
deps:{"table::TableLike::entry_format":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::entry_format":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+table::TableLike::entry_format(p0, p1);
+crate::table::TableLike::entry_format(p0, p1);
+crate::table::TableLike::entry_format(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get
deps:{"table::TableLike::get":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::get":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+table::TableLike::get(p0, &p1);
+crate::table::TableLike::get(p0, &p1);
+crate::table::TableLike::get(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get_mut
deps:{"table::TableLike::get_mut":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::get_mut":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+table::TableLike::get_mut(p0, &p1);
+crate::table::TableLike::get_mut(p0, &p1);
+crate::table::TableLike::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get_key_value
deps:{"table::TableLike::get_key_value":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::get_key_value":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+table::TableLike::get_key_value(p0, &p1);
+crate::table::TableLike::get_key_value(p0, &p1);
+crate::table::TableLike::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get_key_value_mut
deps:{"table::TableLike::get_key_value_mut":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::get_key_value_mut":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+table::TableLike::get_key_value_mut(p0, &p1);
+crate::table::TableLike::get_key_value_mut(p0, &p1);
+crate::table::TableLike::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::contains_key
deps:{"table::TableLike::contains_key":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::contains_key":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+table::TableLike::contains_key(p0, &p1);
+crate::table::TableLike::contains_key(p0, &p1);
+crate::table::TableLike::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::insert
deps:{"table::TableLike::insert":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::insert":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(&p1, p2);
+table::TableLike::insert(p0, &p1, p2);
+crate::table::TableLike::insert(p0, &p1, p2);
+crate::table::TableLike::insert(p0, &p1, p2);
-----------------
crates/toml_edit/src/table.rs table::TableLike::remove
deps:{"table::TableLike::remove":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::remove":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+table::TableLike::remove(p0, &p1);
+crate::table::TableLike::remove(p0, &p1);
+crate::table::TableLike::remove(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get_values
deps:{"table::TableLike::get_values":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::get_values":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.get_values();
+table::TableLike::get_values(p0);
+crate::table::TableLike::get_values(p0);
+crate::table::TableLike::get_values(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::fmt
deps:{"table::TableLike::fmt":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::fmt":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.fmt();
+table::TableLike::fmt(p0);
+crate::table::TableLike::fmt(p0);
+crate::table::TableLike::fmt(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::sort_values
deps:{"table::TableLike::sort_values":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::sort_values":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.sort_values();
+table::TableLike::sort_values(p0);
+crate::table::TableLike::sort_values(p0);
+crate::table::TableLike::sort_values(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::set_dotted
deps:{"table::TableLike::set_dotted":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::set_dotted":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+table::TableLike::set_dotted(p0, p1);
+crate::table::TableLike::set_dotted(p0, p1);
+crate::table::TableLike::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::is_dotted
deps:{"table::TableLike::is_dotted":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::is_dotted":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_dotted();
+table::TableLike::is_dotted(p0);
+crate::table::TableLike::is_dotted(p0);
+crate::table::TableLike::is_dotted(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::key_decor_mut
deps:{"table::TableLike::key_decor_mut":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::key_decor_mut":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+table::TableLike::key_decor_mut(p0, &p1);
+crate::table::TableLike::key_decor_mut(p0, &p1);
+crate::table::TableLike::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::key_decor
deps:{"table::TableLike::key_decor":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::key_decor":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+table::TableLike::key_decor(p0, &p1);
+crate::table::TableLike::key_decor(p0, &p1);
+crate::table::TableLike::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_document
'doc
deps:{"visit::Visit::visit_document":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_document":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.visit_document(p1);
+visit::Visit::visit_document(p0, p1);
+crate::visit::Visit::visit_document(p0, p1);
+crate::visit::Visit::visit_document(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_item
'doc
deps:{"visit::Visit::visit_item":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_item":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_item(p1);
+visit::Visit::visit_item(p0, p1);
+crate::visit::Visit::visit_item(p0, p1);
+crate::visit::Visit::visit_item(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_table
'doc
deps:{"visit::Visit::visit_table":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_table":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.visit_table(p1);
+visit::Visit::visit_table(p0, p1);
+crate::visit::Visit::visit_table(p0, p1);
+crate::visit::Visit::visit_table(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_inline_table
'doc
deps:{"visit::Visit::visit_inline_table":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_inline_table":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.visit_inline_table(p1);
+visit::Visit::visit_inline_table(p0, p1);
+crate::visit::Visit::visit_inline_table(p0, p1);
+crate::visit::Visit::visit_inline_table(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_table_like
'doc
deps:{"visit::Visit::visit_table_like":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_table_like":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // (dyn table::TableLike + 'doc)
+p0.visit_table_like(p1);
+visit::Visit::visit_table_like(p0, p1);
+crate::visit::Visit::visit_table_like(p0, p1);
+crate::visit::Visit::visit_table_like(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_table_like_kv
'doc
deps:{"visit::Visit::visit_table_like_kv":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_table_like_kv":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_table_like_kv(&p1, p2);
+visit::Visit::visit_table_like_kv(p0, &p1, p2);
+crate::visit::Visit::visit_table_like_kv(p0, &p1, p2);
+crate::visit::Visit::visit_table_like_kv(p0, &p1, p2);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_array
'doc
deps:{"visit::Visit::visit_array":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_array":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.visit_array(p1);
+visit::Visit::visit_array(p0, p1);
+crate::visit::Visit::visit_array(p0, p1);
+crate::visit::Visit::visit_array(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_array_of_tables
'doc
deps:{"visit::Visit::visit_array_of_tables":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_array_of_tables":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.visit_array_of_tables(p1);
+visit::Visit::visit_array_of_tables(p0, p1);
+crate::visit::Visit::visit_array_of_tables(p0, p1);
+crate::visit::Visit::visit_array_of_tables(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_value
'doc
deps:{"visit::Visit::visit_value":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_value":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.visit_value(p1);
+visit::Visit::visit_value(p0, p1);
+crate::visit::Visit::visit_value(p0, p1);
+crate::visit::Visit::visit_value(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_boolean
'doc
deps:{"visit::Visit::visit_boolean":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_boolean":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<bool>
+p0.visit_boolean(p1);
+visit::Visit::visit_boolean(p0, p1);
+crate::visit::Visit::visit_boolean(p0, p1);
+crate::visit::Visit::visit_boolean(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_datetime
'doc
deps:{"visit::Visit::visit_datetime":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_datetime":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<toml_datetime::Datetime>
+p0.visit_datetime(p1);
+visit::Visit::visit_datetime(p0, p1);
+crate::visit::Visit::visit_datetime(p0, p1);
+crate::visit::Visit::visit_datetime(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_float
'doc
deps:{"visit::Visit::visit_float":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_float":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<f64>
+p0.visit_float(p1);
+visit::Visit::visit_float(p0, p1);
+crate::visit::Visit::visit_float(p0, p1);
+crate::visit::Visit::visit_float(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_integer
'doc
deps:{"visit::Visit::visit_integer":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_integer":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<i64>
+p0.visit_integer(p1);
+visit::Visit::visit_integer(p0, p1);
+crate::visit::Visit::visit_integer(p0, p1);
+crate::visit::Visit::visit_integer(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_string
'doc
deps:{"visit::Visit::visit_string":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_string":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & std::string::String::new(); // None+repr::Formatted<std::string::String>
+p0.visit_string(p1);
+visit::Visit::visit_string(p0, p1);
+crate::visit::Visit::visit_string(p0, p1);
+crate::visit::Visit::visit_string(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_document_mut
deps:{"visit_mut::VisitMut::visit_document_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_document_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.visit_document_mut(p1);
+visit_mut::VisitMut::visit_document_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_document_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_document_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_item_mut
deps:{"visit_mut::VisitMut::visit_item_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_item_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_item_mut(p1);
+visit_mut::VisitMut::visit_item_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_item_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_item_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_table_mut
deps:{"visit_mut::VisitMut::visit_table_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_table_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.visit_table_mut(p1);
+visit_mut::VisitMut::visit_table_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_table_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_table_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_inline_table_mut
deps:{"visit_mut::VisitMut::visit_inline_table_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_inline_table_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.visit_inline_table_mut(p1);
+visit_mut::VisitMut::visit_inline_table_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_inline_table_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_inline_table_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_table_like_mut
deps:{"visit_mut::VisitMut::visit_table_like_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_table_like_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn table::TableLike
+p0.visit_table_like_mut(p1);
+visit_mut::VisitMut::visit_table_like_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_table_like_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_table_like_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_table_like_kv_mut
deps:{"visit_mut::VisitMut::visit_table_like_kv_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_table_like_kv_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // key::KeyMut<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_table_like_kv_mut(p1, p2);
+visit_mut::VisitMut::visit_table_like_kv_mut(p0, p1, p2);
+crate::visit_mut::VisitMut::visit_table_like_kv_mut(p0, p1, p2);
+crate::visit_mut::VisitMut::visit_table_like_kv_mut(p0, p1, p2);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_array_mut
deps:{"visit_mut::VisitMut::visit_array_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_array_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.visit_array_mut(p1);
+visit_mut::VisitMut::visit_array_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_array_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_array_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_array_of_tables_mut
deps:{"visit_mut::VisitMut::visit_array_of_tables_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_array_of_tables_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.visit_array_of_tables_mut(p1);
+visit_mut::VisitMut::visit_array_of_tables_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_array_of_tables_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_array_of_tables_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_value_mut
deps:{"visit_mut::VisitMut::visit_value_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_value_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.visit_value_mut(p1);
+visit_mut::VisitMut::visit_value_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_value_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_value_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_boolean_mut
deps:{"visit_mut::VisitMut::visit_boolean_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_boolean_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<bool>
+p0.visit_boolean_mut(p1);
+visit_mut::VisitMut::visit_boolean_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_boolean_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_boolean_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_datetime_mut
deps:{"visit_mut::VisitMut::visit_datetime_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_datetime_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<toml_datetime::Datetime>
+p0.visit_datetime_mut(p1);
+visit_mut::VisitMut::visit_datetime_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_datetime_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_datetime_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_float_mut
deps:{"visit_mut::VisitMut::visit_float_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_float_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<f64>
+p0.visit_float_mut(p1);
+visit_mut::VisitMut::visit_float_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_float_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_float_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_integer_mut
deps:{"visit_mut::VisitMut::visit_integer_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_integer_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<i64>
+p0.visit_integer_mut(p1);
+visit_mut::VisitMut::visit_integer_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_integer_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_integer_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_string_mut
deps:{"visit_mut::VisitMut::visit_string_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_string_mut":{"Self":["ser::pretty::Pretty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut std::string::String::new(); // None+repr::Formatted<std::string::String>
+p0.visit_string_mut(p1);
+visit_mut::VisitMut::visit_string_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_string_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_string_mut(p0, p1);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<array::Array as std::fmt::Debug>::fmt(p0, p1);
+crate::<array::Array as std::fmt::Debug>::fmt(p0, p1);
+<array::Array>::fmt(p0, p1);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::default::Default>::default
deps:{}
candidates:{}
+<array::Array as std::default::Default>::default();
+crate::<array::Array as std::default::Default>::default();
+<array::Array>::default();
-----------------
crates/toml_edit/src/array.rs <array::Array as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.clone();
+<array::Array as std::clone::Clone>::clone(p0);
+crate::<array::Array as std::clone::Clone>::clone(p0);
+<array::Array>::clone(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::new
deps:{}
candidates:{}
+array::Array::new();
+crate::array::Array::new();
+<array::Array>::new();
-----------------
crates/toml_edit/src/array.rs array::Array::with_vec
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<item::Item>
+array::Array::with_vec(p0);
+crate::array::Array::with_vec(p0);
+<array::Array>::with_vec(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.fmt();
+array::Array::fmt(p0);
+crate::array::Array::fmt(p0);
+<array::Array>::fmt(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::set_trailing_comma
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = true; // None+bool
+p0.set_trailing_comma(p1);
+array::Array::set_trailing_comma(p0, p1);
+crate::array::Array::set_trailing_comma(p0, p1);
+<array::Array>::set_trailing_comma(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::trailing_comma
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.trailing_comma();
+array::Array::trailing_comma(p0);
+crate::array::Array::trailing_comma(p0);
+<array::Array>::trailing_comma(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::set_trailing
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"array::Array::set_trailing":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"array::Array::set_trailing":{"impl Into<RawString>":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_trailing(p1);
+array::Array::set_trailing(p0, p1);
+crate::array::Array::set_trailing(p0, p1);
+<array::Array>::set_trailing(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::trailing
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.trailing();
+array::Array::trailing(p0);
+crate::array::Array::trailing(p0);
+<array::Array>::trailing(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.decor_mut();
+array::Array::decor_mut(p0);
+crate::array::Array::decor_mut(p0);
+<array::Array>::decor_mut(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.decor();
+array::Array::decor(p0);
+crate::array::Array::decor(p0);
+<array::Array>::decor(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.span();
+array::Array::span(p0);
+crate::array::Array::span(p0);
+<array::Array>::span(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+array::Array::despan(p0, &p1);
+crate::array::Array::despan(p0, &p1);
+<array::Array>::despan(p0, &p1);
-----------------
crates/toml_edit/src/array.rs array::Array::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.iter();
+array::Array::iter(p0);
+crate::array::Array::iter(p0);
+<array::Array>::iter(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.iter_mut();
+array::Array::iter_mut(p0);
+crate::array::Array::iter_mut(p0);
+<array::Array>::iter_mut(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.len();
+array::Array::len(p0);
+crate::array::Array::len(p0);
+<array::Array>::len(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.is_empty();
+array::Array::is_empty(p0);
+crate::array::Array::is_empty(p0);
+<array::Array>::is_empty(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.clear();
+array::Array::clear(p0);
+crate::array::Array::clear(p0);
+<array::Array>::clear(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+array::Array::get(p0, p1);
+crate::array::Array::get(p0, p1);
+<array::Array>::get(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
+p0.get_mut(p1);
+array::Array::get_mut(p0, p1);
+crate::array::Array::get_mut(p0, p1);
+<array::Array>::get_mut(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::push
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"array::Array::push":{"V":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"array::Array::push":{"V":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.push(p1);
+array::Array::push(p0, p1);
+crate::array::Array::push(p0, p1);
+<array::Array>::push(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::push_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.push_formatted(p1);
+array::Array::push_formatted(p0, p1);
+crate::array::Array::push_formatted(p0, p1);
+<array::Array>::push_formatted(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::insert
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"array::Array::insert":{"V":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"array::Array::insert":{"V":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.insert(p1, p2);
+array::Array::insert(p0, p1, p2);
+crate::array::Array::insert(p0, p1, p2);
+<array::Array>::insert(p0, p1, p2);
-----------------
crates/toml_edit/src/array.rs array::Array::insert_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert_formatted(p1, p2);
+array::Array::insert_formatted(p0, p1, p2);
+crate::array::Array::insert_formatted(p0, p1, p2);
+<array::Array>::insert_formatted(p0, p1, p2);
-----------------
crates/toml_edit/src/array.rs array::Array::replace
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"array::Array::replace":{"V":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"array::Array::replace":{"V":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.replace(p1, p2);
+array::Array::replace(p0, p1, p2);
+crate::array::Array::replace(p0, p1, p2);
+<array::Array>::replace(p0, p1, p2);
-----------------
crates/toml_edit/src/array.rs array::Array::replace_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.replace_formatted(p1, p2);
+array::Array::replace_formatted(p0, p1, p2);
+crate::array::Array::replace_formatted(p0, p1, p2);
+<array::Array>::replace_formatted(p0, p1, p2);
-----------------
crates/toml_edit/src/array.rs array::Array::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
+p0.remove(p1);
+array::Array::remove(p0, p1);
+crate::array::Array::remove(p0, p1);
+<array::Array>::remove(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::value_op
deps:{"array::Array::value_op":{"T":["std::marker::Sized"],"impl FnOnce(&mut Vec<Item>, Value) -> T":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"array::Array::value_op":{"T":["RUG_ANY"],"impl FnOnce(&mut Vec<Item>, Value) -> T":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","std::panic::AssertUnwindSafe<F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p2 = true; // None+bool
let mut p3 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut Vec<Item>, Value) -> T
+p0.value_op(p1, p2, p3);
+array::Array::value_op(p0, p1, p2, p3);
+crate::array::Array::value_op(p0, p1, p2, p3);
+<array::Array>::value_op(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<array::Array as std::fmt::Display>::fmt(p0, p1);
+crate::<array::Array as std::fmt::Display>::fmt(p0, p1);
+<array::Array>::fmt(p0, p1);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::iter::Extend<V>>::extend
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<array::Array as std::iter::Extend<V>>::extend":{"T":["std::marker::Sized","std::iter::IntoIterator"],"V":["std::convert::Into","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::str::LinesAny<'a>","std::slice::SplitMut<'a, T, P>","std::env::ArgsOs","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::iter::Intersperse<I>","std::collections::hash_map::IntoKeys<K, V>","std::str::MatchIndices<'a, P>","std::slice::Iter<'a, T>","std::iter::adapters::GenericShunt<'_, I, R>","std::collections::hash_map::Keys<'a, K, V>","std::iter::FilterMap<I, F>","std::str::Bytes<'_>","std::iter::Peekable<I>","std::str::SplitTerminator<'a, P>","std::collections::linked_list::Iter<'a, T>","std::slice::GroupByMut<'a, T, P>","std::char::EscapeUnicode","std::collections::btree_map::ValuesMut<'a, K, V>","std::str::Matches<'a, P>","std::iter::SkipWhile<I, P>","std::collections::linked_list::IterMut<'a, T>","std::collections::btree_map::Range<'a, K, V>","std::iter::TakeWhile<I, P>","std::iter::Flatten<I>","std::slice::RChunksExactMut<'a, T>","std::str::SplitInclusive<'a, P>","std::collections::hash_set::Drain<'a, K>","std::os::unix::net::Messages<'a>","std::iter::Copied<I>","std::collections::btree_set::IntoIter<T, A>","std::collections::hash_map::IterMut<'a, K, V>","std::env::Args","std::vec::IntoIter<T, A>","std::collections::btree_map::RangeMut<'a, K, V>","std::io::Bytes<R>","std::collections::vec_deque::IntoIter<T, A>","std::fs::ReadDir","std::str::Utf8Chunks<'a>","std::vec::Drain<'_, T, A>","std::iter::RepeatWith<F>","std::iter::Scan<I, St, F>","std::char::ToLowercase","std::slice::Windows<'a, T>","std::slice::SplitNMut<'a, T, P>","std::str::EscapeDefault<'a>","std::slice::RChunksExact<'a, T>","std::str::RSplitTerminator<'a, P>","std::slice::ChunksMut<'a, T>","std::char::CaseMappingIter","std::collections::btree_set::Range<'a, T>","std::slice::RSplitMut<'a, T, P>","std::str::RSplitN<'a, P>","std::process::CommandEnvs<'a>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::collections::btree_map::Values<'a, K, V>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::slice::ArrayWindows<'a, T, N>","std::sys::unix::fs::ReadDir","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::btree_set::SymmetricDifference<'a, T>","core::error::Source<'a>","std::slice::SplitInclusiveMut<'a, T, P>","std::str::RMatches<'a, P>","std::iter::Fuse<I>","std::collections::hash_set::IntoIter<K>","std::collections::hash_set::DrainFilter<'_, K, F>","std::str::SplitN<'a, P>","std::collections::btree_set::Intersection<'a, T, A>","std::iter::Zip<A, B>","std::sys::unix::os::Env","std::ops::RangeFrom<A>","std::sys_common::net::LookupHost","std::iter::Map<I, F>","std::iter::Take<I>","std::collections::btree_map::Keys<'a, K, V>","std::iter::Enumerate<I>","std::collections::hash_set::Iter<'a, K>","std::collections::btree_map::IntoKeys<K, V, A>","std::iter::Cloned<I>","std::sys_common::wstr::WStrUnits<'_>","std::env::Vars","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::slice::RChunks<'a, T>","std::iter::ByRefSized<'_, I>","std::char::EscapeDebug","std::array::IntoIter<T, N>","std::env::VarsOs","std::io::Split<B>","std::iter::Chain<A, B>","std::result::IntoIter<T>","std::str::EscapeDebug<'a>","std::iter::Empty<T>","std::result::Iter<'a, T>","std::iter::Filter<I, P>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::ops::index_range::IndexRange","std::collections::hash_set::Difference<'a, T, S>","std::iter::IntersperseWith<I, G>","std::str::Split<'a, P>","std::slice::RChunksMut<'a, T>","std::slice::SplitN<'a, T, P>","std::path::Iter<'a>","std::collections::binary_heap::IntoIter<T>","std::sys_common::wtf8::EncodeWide<'a>","std::slice::ChunksExact<'a, T>","std::iter::Repeat<A>","std::sys::unix::os::SplitPaths<'a>","std::os::unix::net::ScmCredentials<'a>","std::sync::mpsc::Iter<'a, T>","std::iter::ArrayChunks<I, N>","std::collections::hash_set::Union<'a, T, S>","std::collections::linked_list::DrainFilter<'_, T, F>","std::str::RMatchIndices<'a, P>","std::option::IterMut<'a, A>","std::collections::vec_deque::Drain<'_, T, A>","std::iter::StepBy<I>","std::net::IntoIncoming","std::collections::hash_map::Iter<'a, K, V>","std::str::EscapeUnicode<'a>","std::collections::binary_heap::IntoIterSorted<T>","std::str::SplitAsciiWhitespace<'a>","std::str::SplitWhitespace<'a>","std::collections::btree_set::Iter<'a, T>","std::iter::FlatMap<I, U, F>","std::iter::Successors<T, F>","std::option::IntoIter<A>","std::str::Chars<'a>","std::slice::ArrayChunksMut<'a, T, N>","std::io::Lines<B>","std::env::SplitPaths<'a>","std::vec::DrainFilter<'_, T, F, A>","std::path::Ancestors<'a>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::hash_map::Drain<'a, K, V>","std::option::Iter<'a, A>","std::iter::Once<T>","std::collections::hash_map::Values<'a, K, V>","std::slice::GroupBy<'a, T, P>","std::str::Lines<'a>","std::iter::FromFn<F>","std::slice::SplitInclusive<'a, T, P>","std::iter::Cycle<I>","std::collections::linked_list::IntoIter<T>","std::iter::OnceWith<F>","std::collections::binary_heap::Iter<'a, T>","std::slice::ArrayChunks<'a, T, N>","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::path::Components<'a>","std::slice::Split<'a, T, P>","std::string::Drain<'_>","core::slice::iter::GenericSplitN<I>","std::collections::binary_heap::Drain<'_, T>","std::process::CommandArgs<'a>","std::slice::RSplit<'a, T, P>","std::slice::RSplitN<'a, T, P>","std::iter::Inspect<I, F>","std::iter::RepeatN<A>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::result::IterMut<'a, T>","std::collections::btree_map::IntoValues<K, V, A>","std::collections::btree_map::IterMut<'a, K, V>","std::option::Item<A>","std::char::DecodeUtf16<I>","std::slice::EscapeAscii<'a>","std::slice::Chunks<'a, T>","std::ascii::EscapeDefault","std::str::CharIndices<'a>","std::iter::MapWhile<I, P>","std::iter::sources::from_generator::FromGenerator<G>","std::collections::vec_deque::Iter<'a, T>","std::char::ToUppercase","std::str::RSplit<'a, P>","std::collections::btree_set::Difference<'a, T, A>","std::vec::Splice<'_, I, A>","std::collections::btree_map::Iter<'a, K, V>","std::collections::vec_deque::IterMut<'a, T>","std::collections::hash_map::IntoIter<K, V>","std::os::unix::net::Incoming<'a>","std::slice::IterMut<'a, T>","std::sync::mpsc::IntoIter<T>","std::slice::ChunksExactMut<'a, T>","std::iter::Skip<I>","std::slice::RSplitNMut<'a, T, P>","std::collections::hash_set::Intersection<'a, T, S>","std::sync::mpsc::TryIter<'a, T>","std::collections::hash_map::IntoValues<K, V>","std::iter::Rev<I>","std::sys::unix::process::process_common::CommandArgs<'a>","std::char::EscapeDefault","std::ops::Range<A>","std::ops::RangeInclusive<A>","std::collections::btree_map::IntoIter<K, V, A>","std::net::Incoming<'a>","std::collections::btree_set::Union<'a, T>","std::os::unix::net::ScmRights<'a>","std::sys::unix::args::Args","std::str::EncodeUtf16<'a>","std::boxed::Box<I, A>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<array::Array as std::iter::Extend<V>>::extend":{"T":["table::Table","array_of_tables::ArrayOfTables","<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>","<&'a std::option::Option<T> as std::iter::IntoIterator>","array::Array","inline_table::InlineTable"],"V":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<array::Array as std::iter::Extend<V>>::extend(p0, p1);
+crate::<array::Array as std::iter::Extend<V>>::extend(p0, p1);
+<array::Array>::extend(p0, p1);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::iter::FromIterator<V>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<array::Array as std::iter::FromIterator<V>>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"],"V":["std::convert::Into","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::collections::hash_set::DrainFilter<'_, K, F>","std::str::Lines<'a>","std::slice::SplitInclusiveMut<'a, T, P>","std::net::IntoIncoming","std::iter::Cloned<I>","std::collections::linked_list::DrainFilter<'_, T, F>","std::collections::hash_map::IterMut<'a, K, V>","std::iter::Map<I, F>","std::slice::SplitMut<'a, T, P>","core::error::Source<'a>","std::char::EscapeDebug","std::collections::binary_heap::IntoIter<T>","std::str::Bytes<'_>","std::collections::btree_set::SymmetricDifference<'a, T>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::collections::btree_set::Iter<'a, T>","std::io::Lines<B>","std::iter::SkipWhile<I, P>","std::iter::IntersperseWith<I, G>","std::slice::RSplitMut<'a, T, P>","std::collections::vec_deque::IterMut<'a, T>","std::slice::RChunks<'a, T>","std::iter::sources::from_generator::FromGenerator<G>","std::env::Args","std::str::EscapeUnicode<'a>","std::slice::GroupByMut<'a, T, P>","std::iter::Intersperse<I>","std::str::SplitWhitespace<'a>","std::slice::ArrayChunksMut<'a, T, N>","std::slice::ChunksExact<'a, T>","std::option::Item<A>","std::ascii::EscapeDefault","std::collections::btree_set::Range<'a, T>","std::sys_common::net::LookupHost","std::iter::Rev<I>","std::str::RSplitN<'a, P>","std::str::SplitInclusive<'a, P>","std::slice::ArrayChunks<'a, T, N>","std::collections::btree_map::IterMut<'a, K, V>","std::collections::binary_heap::Iter<'a, T>","std::collections::hash_set::Difference<'a, T, S>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::str::SplitTerminator<'a, P>","std::vec::Splice<'_, I, A>","std::fs::ReadDir","std::collections::hash_map::IntoValues<K, V>","std::sys::unix::args::Args","std::str::RSplit<'a, P>","std::iter::TakeWhile<I, P>","std::collections::hash_set::Intersection<'a, T, S>","std::io::Split<B>","std::iter::StepBy<I>","std::str::EscapeDebug<'a>","std::iter::FilterMap<I, F>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::collections::linked_list::IterMut<'a, T>","std::slice::RChunksExactMut<'a, T>","std::collections::hash_map::IntoIter<K, V>","std::sync::mpsc::IntoIter<T>","std::sync::mpsc::Iter<'a, T>","std::char::CaseMappingIter","std::path::Iter<'a>","std::iter::Filter<I, P>","std::char::DecodeUtf16<I>","std::option::IntoIter<A>","std::slice::Windows<'a, T>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::slice::RSplitN<'a, T, P>","std::iter::ArrayChunks<I, N>","std::slice::SplitN<'a, T, P>","std::collections::btree_map::Values<'a, K, V>","std::collections::vec_deque::Iter<'a, T>","std::slice::IterMut<'a, T>","std::env::ArgsOs","std::iter::OnceWith<F>","std::iter::Successors<T, F>","std::slice::ArrayWindows<'a, T, N>","std::ops::RangeInclusive<A>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::collections::hash_map::Iter<'a, K, V>","std::str::Split<'a, P>","std::slice::RChunksMut<'a, T>","std::ops::Range<A>","std::iter::Take<I>","std::sys::unix::process::process_common::CommandArgs<'a>","std::collections::hash_set::Iter<'a, K>","std::char::EscapeDefault","std::iter::Flatten<I>","std::str::EscapeDefault<'a>","std::collections::binary_heap::DrainSorted<'_, T>","std::sys_common::wtf8::EncodeWide<'a>","std::process::CommandArgs<'a>","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::btree_map::IntoIter<K, V, A>","std::iter::FlatMap<I, U, F>","std::slice::Iter<'a, T>","std::collections::linked_list::IntoIter<T>","std::iter::Cycle<I>","std::vec::DrainFilter<'_, T, F, A>","std::net::Incoming<'a>","std::collections::btree_map::Keys<'a, K, V>","std::sys::unix::os::SplitPaths<'a>","std::slice::ChunksExactMut<'a, T>","std::os::unix::net::Incoming<'a>","std::ops::RangeFrom<A>","std::path::Ancestors<'a>","std::iter::RepeatN<A>","std::slice::RChunksExact<'a, T>","std::collections::binary_heap::Drain<'_, T>","std::slice::ChunksMut<'a, T>","std::os::unix::net::ScmRights<'a>","std::str::Matches<'a, P>","std::collections::hash_map::Drain<'a, K, V>","std::collections::btree_map::IntoValues<K, V, A>","std::str::EncodeUtf16<'a>","std::iter::Empty<T>","std::iter::Copied<I>","std::vec::Drain<'_, T, A>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::str::SplitAsciiWhitespace<'a>","std::iter::FromFn<F>","std::iter::MapWhile<I, P>","std::str::CharIndices<'a>","std::env::VarsOs","std::slice::RSplit<'a, T, P>","std::slice::GroupBy<'a, T, P>","std::str::Utf8Chunks<'a>","std::collections::hash_map::Values<'a, K, V>","std::slice::SplitInclusive<'a, T, P>","std::sys_common::wstr::WStrUnits<'_>","std::iter::Skip<I>","std::str::RSplitTerminator<'a, P>","std::env::SplitPaths<'a>","std::char::ToLowercase","std::iter::Scan<I, St, F>","std::collections::btree_map::ValuesMut<'a, K, V>","std::slice::Split<'a, T, P>","std::collections::hash_set::Drain<'a, K>","std::str::RMatchIndices<'a, P>","std::os::unix::net::Messages<'a>","std::iter::Fuse<I>","std::iter::Enumerate<I>","std::result::Iter<'a, T>","std::array::IntoIter<T, N>","std::collections::btree_set::Intersection<'a, T, A>","std::sync::mpsc::TryIter<'a, T>","std::iter::Peekable<I>","std::os::unix::net::ScmCredentials<'a>","std::path::Components<'a>","std::collections::btree_set::Difference<'a, T, A>","std::str::Chars<'a>","std::iter::Repeat<A>","std::slice::EscapeAscii<'a>","std::collections::hash_map::Keys<'a, K, V>","std::char::ToUppercase","std::slice::RSplitNMut<'a, T, P>","core::slice::iter::GenericSplitN<I>","std::collections::btree_set::IntoIter<T, A>","std::collections::btree_map::Iter<'a, K, V>","std::slice::SplitNMut<'a, T, P>","std::iter::Once<T>","std::collections::btree_map::RangeMut<'a, K, V>","std::result::IterMut<'a, T>","std::slice::Chunks<'a, T>","std::env::Vars","std::string::Drain<'_>","std::collections::hash_set::Union<'a, T, S>","std::sys::unix::os::Env","std::collections::binary_heap::IntoIterSorted<T>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::char::EscapeUnicode","std::iter::adapters::GenericShunt<'_, I, R>","std::collections::vec_deque::Drain<'_, T, A>","std::iter::Inspect<I, F>","std::option::Iter<'a, A>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::vec::IntoIter<T, A>","std::iter::Zip<A, B>","std::collections::linked_list::Iter<'a, T>","std::collections::vec_deque::IntoIter<T, A>","std::collections::btree_set::Union<'a, T>","std::str::MatchIndices<'a, P>","std::ops::index_range::IndexRange","std::collections::btree_map::Range<'a, K, V>","std::sys::unix::fs::ReadDir","std::str::LinesAny<'a>","std::result::IntoIter<T>","std::str::SplitN<'a, P>","std::collections::hash_map::IntoKeys<K, V>","std::iter::RepeatWith<F>","std::boxed::Box<I, A>","std::io::Bytes<R>","std::process::CommandEnvs<'a>","std::option::IterMut<'a, A>","std::collections::hash_set::IntoIter<K>","std::collections::btree_map::IntoKeys<K, V, A>","std::iter::ByRefSized<'_, I>","std::iter::Chain<A, B>","std::str::RMatches<'a, P>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<array::Array as std::iter::FromIterator<V>>::from_iter":{"I":["inline_table::InlineTable","array::Array","table::Table","<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","array_of_tables::ArrayOfTables","<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>"],"V":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<array::Array as std::iter::FromIterator<V>>::from_iter(p0);
+crate::<array::Array as std::iter::FromIterator<V>>::from_iter(p0);
+<array::Array>::from_iter(p0);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array::Array
+p0.into_iter();
+<array::Array as std::iter::IntoIterator>::into_iter(p0);
+crate::<array::Array as std::iter::IntoIterator>::into_iter(p0);
+<array::Array>::into_iter(p0);
-----------------
crates/toml_edit/src/array.rs <&'s array::Array as std::iter::IntoIterator>::into_iter
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.into_iter();
+<&'s array::Array as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'s array::Array as std::iter::IntoIterator>::into_iter(p0);
+<&'s array::Array>::into_iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.clone();
+<array_of_tables::ArrayOfTables as std::clone::Clone>::clone(p0);
+crate::<array_of_tables::ArrayOfTables as std::clone::Clone>::clone(p0);
+<array_of_tables::ArrayOfTables>::clone(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<array_of_tables::ArrayOfTables as std::fmt::Debug>::fmt(p0, p1);
+crate::<array_of_tables::ArrayOfTables as std::fmt::Debug>::fmt(p0, p1);
+<array_of_tables::ArrayOfTables>::fmt(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::default::Default>::default
deps:{}
candidates:{}
+<array_of_tables::ArrayOfTables as std::default::Default>::default();
+crate::<array_of_tables::ArrayOfTables as std::default::Default>::default();
+<array_of_tables::ArrayOfTables>::default();
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::new
deps:{}
candidates:{}
+array_of_tables::ArrayOfTables::new();
+crate::array_of_tables::ArrayOfTables::new();
+<array_of_tables::ArrayOfTables>::new();
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::into_array
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.into_array();
+array_of_tables::ArrayOfTables::into_array(p0);
+crate::array_of_tables::ArrayOfTables::into_array(p0);
+<array_of_tables::ArrayOfTables>::into_array(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.span();
+array_of_tables::ArrayOfTables::span(p0);
+crate::array_of_tables::ArrayOfTables::span(p0);
+<array_of_tables::ArrayOfTables>::span(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+array_of_tables::ArrayOfTables::despan(p0, &p1);
+crate::array_of_tables::ArrayOfTables::despan(p0, &p1);
+<array_of_tables::ArrayOfTables>::despan(p0, &p1);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.iter();
+array_of_tables::ArrayOfTables::iter(p0);
+crate::array_of_tables::ArrayOfTables::iter(p0);
+<array_of_tables::ArrayOfTables>::iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.iter_mut();
+array_of_tables::ArrayOfTables::iter_mut(p0);
+crate::array_of_tables::ArrayOfTables::iter_mut(p0);
+<array_of_tables::ArrayOfTables>::iter_mut(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.len();
+array_of_tables::ArrayOfTables::len(p0);
+crate::array_of_tables::ArrayOfTables::len(p0);
+<array_of_tables::ArrayOfTables>::len(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.is_empty();
+array_of_tables::ArrayOfTables::is_empty(p0);
+crate::array_of_tables::ArrayOfTables::is_empty(p0);
+<array_of_tables::ArrayOfTables>::is_empty(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.clear();
+array_of_tables::ArrayOfTables::clear(p0);
+crate::array_of_tables::ArrayOfTables::clear(p0);
+<array_of_tables::ArrayOfTables>::clear(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+array_of_tables::ArrayOfTables::get(p0, p1);
+crate::array_of_tables::ArrayOfTables::get(p0, p1);
+<array_of_tables::ArrayOfTables>::get(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = 0usize; // None+usize
+p0.get_mut(p1);
+array_of_tables::ArrayOfTables::get_mut(p0, p1);
+crate::array_of_tables::ArrayOfTables::get_mut(p0, p1);
+<array_of_tables::ArrayOfTables>::get_mut(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = MaybeUninit::uninit().assume_init(); // table::Table
+p0.push(p1);
+array_of_tables::ArrayOfTables::push(p0, p1);
+crate::array_of_tables::ArrayOfTables::push(p0, p1);
+<array_of_tables::ArrayOfTables>::push(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = 0usize; // None+usize
+p0.remove(p1);
+array_of_tables::ArrayOfTables::remove(p0, p1);
+crate::array_of_tables::ArrayOfTables::remove(p0, p1);
+<array_of_tables::ArrayOfTables>::remove(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend":{"T":["std::iter::IntoIterator","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::collections::hash_map::IterMut<'a, K, V>","std::slice::Split<'a, T, P>","std::ops::RangeFrom<A>","std::os::unix::net::Messages<'a>","std::option::IterMut<'a, A>","std::iter::Skip<I>","std::path::Components<'a>","std::collections::btree_set::Range<'a, T>","std::sys::unix::os::SplitPaths<'a>","std::string::Drain<'_>","std::slice::IterMut<'a, T>","std::iter::sources::from_generator::FromGenerator<G>","std::collections::linked_list::IntoIter<T>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::iter::Scan<I, St, F>","std::slice::SplitN<'a, T, P>","std::collections::btree_set::SymmetricDifference<'a, T>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::str::Chars<'a>","std::collections::hash_map::Drain<'a, K, V>","std::collections::vec_deque::IterMut<'a, T>","std::slice::RChunksExact<'a, T>","std::iter::Chain<A, B>","std::str::EncodeUtf16<'a>","std::slice::SplitMut<'a, T, P>","std::slice::ChunksExactMut<'a, T>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::iter::Copied<I>","std::io::Lines<B>","std::collections::btree_set::Intersection<'a, T, A>","std::collections::btree_set::IntoIter<T, A>","std::char::EscapeDebug","std::slice::EscapeAscii<'a>","std::slice::RChunksMut<'a, T>","std::str::Bytes<'_>","std::str::Utf8Chunks<'a>","std::process::CommandArgs<'a>","std::char::CaseMappingIter","std::str::RSplit<'a, P>","std::collections::binary_heap::IntoIter<T>","std::iter::Once<T>","std::str::EscapeDebug<'a>","std::str::RSplitTerminator<'a, P>","std::str::CharIndices<'a>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::collections::btree_map::IntoIter<K, V, A>","std::iter::MapWhile<I, P>","std::slice::GroupByMut<'a, T, P>","std::collections::btree_map::RangeMut<'a, K, V>","std::iter::FromFn<F>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::collections::binary_heap::Iter<'a, T>","std::env::SplitPaths<'a>","std::char::EscapeDefault","std::str::Split<'a, P>","std::collections::binary_heap::Drain<'_, T>","std::iter::SkipWhile<I, P>","std::collections::hash_map::IntoKeys<K, V>","std::vec::Splice<'_, I, A>","std::str::EscapeDefault<'a>","std::net::Incoming<'a>","std::slice::Windows<'a, T>","std::iter::FlatMap<I, U, F>","std::str::MatchIndices<'a, P>","std::collections::hash_set::DrainFilter<'_, K, F>","std::sys_common::wstr::WStrUnits<'_>","core::error::Source<'a>","std::slice::GroupBy<'a, T, P>","std::iter::Take<I>","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::binary_heap::IntoIterSorted<T>","std::sys_common::net::LookupHost","std::result::IterMut<'a, T>","std::iter::Peekable<I>","std::iter::RepeatWith<F>","std::sys::unix::process::process_common::CommandArgs<'a>","std::slice::RSplitNMut<'a, T, P>","std::path::Iter<'a>","std::iter::Inspect<I, F>","std::os::unix::net::Incoming<'a>","std::vec::IntoIter<T, A>","std::char::EscapeUnicode","std::collections::vec_deque::Drain<'_, T, A>","std::iter::adapters::GenericShunt<'_, I, R>","std::str::Lines<'a>","std::fs::ReadDir","std::collections::hash_set::Iter<'a, K>","std::str::RSplitN<'a, P>","std::iter::Enumerate<I>","std::collections::hash_map::Iter<'a, K, V>","std::result::Iter<'a, T>","std::env::ArgsOs","std::collections::hash_set::Drain<'a, K>","std::os::unix::net::ScmCredentials<'a>","std::collections::hash_map::IntoValues<K, V>","std::collections::hash_map::IntoIter<K, V>","std::env::Args","std::collections::hash_set::Difference<'a, T, S>","std::sys::unix::os::Env","std::slice::RChunksExactMut<'a, T>","std::collections::vec_deque::IntoIter<T, A>","std::slice::ChunksExact<'a, T>","std::collections::hash_map::ValuesMut<'a, K, V>","std::iter::Filter<I, P>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::slice::RChunks<'a, T>","std::iter::StepBy<I>","std::iter::Empty<T>","std::env::Vars","std::iter::Cycle<I>","std::str::SplitWhitespace<'a>","std::ops::index_range::IndexRange","std::str::Matches<'a, P>","std::collections::hash_set::Intersection<'a, T, S>","std::collections::linked_list::DrainFilter<'_, T, F>","std::iter::Map<I, F>","std::collections::btree_map::IntoKeys<K, V, A>","std::collections::btree_set::Iter<'a, T>","std::iter::FilterMap<I, F>","std::sync::mpsc::Iter<'a, T>","std::sync::mpsc::IntoIter<T>","std::char::ToLowercase","std::env::VarsOs","std::net::IntoIncoming","std::collections::linked_list::Iter<'a, T>","std::str::SplitTerminator<'a, P>","std::slice::Chunks<'a, T>","std::sync::mpsc::TryIter<'a, T>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::ops::Range<A>","std::iter::OnceWith<F>","std::char::DecodeUtf16<I>","std::collections::btree_map::Range<'a, K, V>","std::collections::vec_deque::Iter<'a, T>","std::ops::RangeInclusive<A>","std::sys_common::wtf8::EncodeWide<'a>","std::str::SplitInclusive<'a, P>","std::option::Item<A>","std::collections::hash_map::Keys<'a, K, V>","std::option::Iter<'a, A>","std::iter::Intersperse<I>","std::iter::TakeWhile<I, P>","std::iter::Zip<A, B>","std::collections::btree_map::IntoValues<K, V, A>","std::collections::btree_map::Iter<'a, K, V>","std::slice::SplitInclusiveMut<'a, T, P>","std::path::Ancestors<'a>","std::str::RMatchIndices<'a, P>","std::slice::ArrayWindows<'a, T, N>","std::iter::Repeat<A>","std::iter::Cloned<I>","core::slice::iter::GenericSplitN<I>","std::iter::RepeatN<A>","std::slice::Iter<'a, T>","std::str::SplitN<'a, P>","std::slice::RSplitN<'a, T, P>","std::slice::RSplitMut<'a, T, P>","std::collections::btree_set::Union<'a, T>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::btree_map::Keys<'a, K, V>","std::option::IntoIter<A>","std::slice::ArrayChunksMut<'a, T, N>","std::array::IntoIter<T, N>","std::collections::btree_set::Difference<'a, T, A>","std::os::unix::net::ScmRights<'a>","std::iter::Successors<T, F>","std::collections::hash_set::Union<'a, T, S>","std::slice::SplitNMut<'a, T, P>","std::slice::ChunksMut<'a, T>","std::str::RMatches<'a, P>","std::slice::RSplit<'a, T, P>","std::io::Split<B>","std::collections::hash_map::Values<'a, K, V>","std::iter::IntersperseWith<I, G>","std::iter::Fuse<I>","std::collections::linked_list::IterMut<'a, T>","std::slice::ArrayChunks<'a, T, N>","std::str::SplitAsciiWhitespace<'a>","std::iter::ArrayChunks<I, N>","<&mut I as std::iter::Iterator>","std::iter::Rev<I>","std::ascii::EscapeDefault","std::collections::btree_map::Values<'a, K, V>","std::sys::unix::fs::ReadDir","std::boxed::Box<I, A>","std::char::ToUppercase","std::vec::Drain<'_, T, A>","std::collections::btree_map::IterMut<'a, K, V>","std::collections::hash_set::IntoIter<K>","std::result::IntoIter<T>","std::io::Bytes<R>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::process::CommandEnvs<'a>","std::slice::SplitInclusive<'a, T, P>","std::vec::DrainFilter<'_, T, F, A>","std::str::LinesAny<'a>","std::str::EscapeUnicode<'a>","std::iter::ByRefSized<'_, I>","std::iter::Flatten<I>","std::sys::unix::args::Args"]},"<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend":{"T":["<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>","array::Array","table::Table","array_of_tables::ArrayOfTables","inline_table::InlineTable","<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend(p0, p1);
+crate::<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend(p0, p1);
+<array_of_tables::ArrayOfTables>::extend(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter":{"I":["std::marker::Sized","std::iter::IntoIterator"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::slice::ArrayWindows<'a, T, N>","std::slice::GroupBy<'a, T, P>","std::collections::btree_set::IntoIter<T, A>","std::option::IntoIter<A>","std::slice::RSplitMut<'a, T, P>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::collections::btree_map::Values<'a, K, V>","std::env::VarsOs","std::sys_common::net::LookupHost","std::boxed::Box<I, A>","std::iter::sources::from_generator::FromGenerator<G>","std::iter::RepeatWith<F>","std::collections::hash_map::Keys<'a, K, V>","std::char::EscapeDefault","std::iter::Repeat<A>","std::collections::btree_map::Keys<'a, K, V>","std::slice::RSplitN<'a, T, P>","std::net::Incoming<'a>","core::error::Source<'a>","std::str::RMatchIndices<'a, P>","std::net::IntoIncoming","std::iter::adapters::GenericShunt<'_, I, R>","std::slice::RChunksExact<'a, T>","std::collections::hash_map::IntoIter<K, V>","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::btree_map::IntoValues<K, V, A>","std::iter::FilterMap<I, F>","std::collections::vec_deque::Iter<'a, T>","std::slice::ArrayChunks<'a, T, N>","std::iter::OnceWith<F>","std::str::SplitInclusive<'a, P>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::collections::btree_map::Range<'a, K, V>","std::str::EscapeUnicode<'a>","std::array::IntoIter<T, N>","std::str::Matches<'a, P>","std::iter::ByRefSized<'_, I>","std::iter::FlatMap<I, U, F>","std::collections::linked_list::DrainFilter<'_, T, F>","std::ops::RangeFrom<A>","std::collections::btree_set::Iter<'a, T>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::iter::Cloned<I>","std::option::Iter<'a, A>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::os::unix::net::Messages<'a>","std::io::Bytes<R>","std::slice::RChunksExactMut<'a, T>","std::slice::EscapeAscii<'a>","std::collections::hash_set::Drain<'a, K>","std::slice::RSplitNMut<'a, T, P>","std::iter::Copied<I>","std::collections::btree_map::RangeMut<'a, K, V>","std::sys::unix::os::SplitPaths<'a>","std::str::SplitTerminator<'a, P>","std::option::Item<A>","std::os::unix::net::ScmRights<'a>","std::str::RSplitN<'a, P>","std::iter::Cycle<I>","std::iter::Successors<T, F>","std::iter::Once<T>","std::str::Utf8Chunks<'a>","std::str::LinesAny<'a>","std::str::SplitWhitespace<'a>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::collections::btree_map::IntoKeys<K, V, A>","std::collections::hash_map::Drain<'a, K, V>","std::sync::mpsc::TryIter<'a, T>","std::sync::mpsc::IntoIter<T>","std::collections::btree_set::Range<'a, T>","std::slice::IterMut<'a, T>","std::iter::Flatten<I>","std::collections::btree_set::SymmetricDifference<'a, T>","std::str::RSplitTerminator<'a, P>","std::iter::Enumerate<I>","std::sys_common::wstr::WStrUnits<'_>","std::env::ArgsOs","std::str::EscapeDebug<'a>","std::collections::hash_map::IterMut<'a, K, V>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::slice::ChunksMut<'a, T>","std::iter::IntersperseWith<I, G>","std::sync::mpsc::Iter<'a, T>","std::iter::SkipWhile<I, P>","std::iter::Intersperse<I>","std::vec::IntoIter<T, A>","std::str::SplitAsciiWhitespace<'a>","std::iter::Fuse<I>","std::slice::RChunksMut<'a, T>","std::collections::hash_map::ValuesMut<'a, K, V>","std::iter::Rev<I>","std::str::Chars<'a>","std::slice::SplitInclusiveMut<'a, T, P>","std::str::MatchIndices<'a, P>","std::iter::MapWhile<I, P>","std::vec::Drain<'_, T, A>","std::collections::linked_list::IterMut<'a, T>","std::char::EscapeDebug","std::process::CommandArgs<'a>","std::iter::Scan<I, St, F>","std::collections::hash_map::Iter<'a, K, V>","std::collections::binary_heap::IntoIterSorted<T>","std::iter::ArrayChunks<I, N>","std::collections::linked_list::Iter<'a, T>","std::slice::SplitNMut<'a, T, P>","std::collections::hash_set::DrainFilter<'_, K, F>","std::slice::SplitInclusive<'a, T, P>","std::collections::hash_set::Intersection<'a, T, S>","std::collections::hash_map::IntoKeys<K, V>","std::ops::index_range::IndexRange","std::ascii::EscapeDefault","std::io::Lines<B>","std::string::Drain<'_>","std::collections::binary_heap::Iter<'a, T>","std::slice::ChunksExact<'a, T>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::collections::binary_heap::IntoIter<T>","std::iter::Take<I>","std::slice::Split<'a, T, P>","std::iter::Peekable<I>","std::env::Args","std::collections::btree_set::Difference<'a, T, A>","std::vec::Splice<'_, I, A>","std::sys::unix::process::process_common::CommandArgs<'a>","std::iter::Skip<I>","std::slice::ChunksExactMut<'a, T>","std::sys_common::wtf8::EncodeWide<'a>","std::path::Ancestors<'a>","std::iter::FromFn<F>","std::char::ToUppercase","std::iter::Zip<A, B>","std::result::IterMut<'a, T>","std::collections::btree_map::IntoIter<K, V, A>","std::env::Vars","std::str::RSplit<'a, P>","std::slice::RSplit<'a, T, P>","std::iter::Map<I, F>","std::str::Lines<'a>","std::slice::ArrayChunksMut<'a, T, N>","std::char::CaseMappingIter","std::sys::unix::os::Env","std::iter::Inspect<I, F>","std::collections::hash_set::Union<'a, T, S>","std::result::IntoIter<T>","std::char::EscapeUnicode","<&mut I as std::iter::Iterator>","std::env::SplitPaths<'a>","std::ops::RangeInclusive<A>","std::iter::Chain<A, B>","std::io::Split<B>","std::collections::hash_set::Difference<'a, T, S>","std::collections::vec_deque::IntoIter<T, A>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::collections::btree_map::Iter<'a, K, V>","std::char::ToLowercase","std::path::Iter<'a>","std::fs::ReadDir","std::str::EscapeDefault<'a>","std::collections::hash_set::IntoIter<K>","std::iter::StepBy<I>","std::collections::vec_deque::Drain<'_, T, A>","std::collections::hash_set::Iter<'a, K>","std::ops::Range<A>","std::slice::RChunks<'a, T>","std::collections::hash_map::IntoValues<K, V>","std::iter::RepeatN<A>","std::str::Bytes<'_>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::linked_list::IntoIter<T>","std::str::SplitN<'a, P>","std::collections::hash_map::Values<'a, K, V>","std::slice::Chunks<'a, T>","std::str::EncodeUtf16<'a>","std::option::IterMut<'a, A>","std::slice::Iter<'a, T>","std::iter::Filter<I, P>","std::slice::SplitN<'a, T, P>","std::vec::DrainFilter<'_, T, F, A>","std::os::unix::net::ScmCredentials<'a>","std::slice::SplitMut<'a, T, P>","std::str::RMatches<'a, P>","std::path::Components<'a>","std::str::Split<'a, P>","std::collections::vec_deque::IterMut<'a, T>","std::slice::Windows<'a, T>","std::sys::unix::args::Args","std::iter::TakeWhile<I, P>","std::os::unix::net::Incoming<'a>","std::process::CommandEnvs<'a>","std::collections::btree_set::Union<'a, T>","std::str::CharIndices<'a>","std::char::DecodeUtf16<I>","std::iter::Empty<T>","std::slice::GroupByMut<'a, T, P>","std::collections::binary_heap::Drain<'_, T>","std::collections::btree_map::IterMut<'a, K, V>","std::sys::unix::fs::ReadDir","std::result::Iter<'a, T>","core::slice::iter::GenericSplitN<I>","std::collections::btree_set::Intersection<'a, T, A>"]},"<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter":{"I":["array_of_tables::ArrayOfTables","table::Table","<I as std::iter::IntoIterator>","array::Array","inline_table::InlineTable","<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter(p0);
+crate::<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter(p0);
+<array_of_tables::ArrayOfTables>::from_iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.into_iter();
+<array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter(p0);
+crate::<array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter(p0);
+<array_of_tables::ArrayOfTables>::into_iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.into_iter();
+<&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter(p0);
+<&'s array_of_tables::ArrayOfTables>::into_iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<array_of_tables::ArrayOfTables as std::fmt::Display>::fmt(p0, p1);
+crate::<array_of_tables::ArrayOfTables as std::fmt::Display>::fmt(p0, p1);
+<array_of_tables::ArrayOfTables>::fmt(p0, p1);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<document::Document as std::fmt::Debug>::fmt(p0, p1);
+crate::<document::Document as std::fmt::Debug>::fmt(p0, p1);
+<document::Document>::fmt(p0, p1);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.clone();
+<document::Document as std::clone::Clone>::clone(p0);
+crate::<document::Document as std::clone::Clone>::clone(p0);
+<document::Document>::clone(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::new
deps:{}
candidates:{}
+document::Document::new();
+crate::document::Document::new();
+<document::Document>::new();
-----------------
crates/toml_edit/src/document.rs document::Document::as_item
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.as_item();
+document::Document::as_item(p0);
+crate::document::Document::as_item(p0);
+<document::Document>::as_item(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::as_item_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.as_item_mut();
+document::Document::as_item_mut(p0);
+crate::document::Document::as_item_mut(p0);
+<document::Document>::as_item_mut(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::as_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.as_table();
+document::Document::as_table(p0);
+crate::document::Document::as_table(p0);
+<document::Document>::as_table(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::as_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.as_table_mut();
+document::Document::as_table_mut(p0);
+crate::document::Document::as_table_mut(p0);
+<document::Document>::as_table_mut(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.iter();
+document::Document::iter(p0);
+crate::document::Document::iter(p0);
+<document::Document>::iter(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::set_trailing
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"document::Document::set_trailing":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"document::Document::set_trailing":{"impl Into<RawString>":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_trailing(p1);
+document::Document::set_trailing(p0, p1);
+crate::document::Document::set_trailing(p0, p1);
+<document::Document>::set_trailing(p0, p1);
-----------------
crates/toml_edit/src/document.rs document::Document::trailing
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.trailing();
+document::Document::trailing(p0);
+crate::document::Document::trailing(p0);
+<document::Document>::trailing(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.despan();
+document::Document::despan(p0);
+crate::document::Document::despan(p0);
+<document::Document>::despan(p0);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::default::Default>::default
deps:{}
candidates:{}
+<document::Document as std::default::Default>::default();
+crate::<document::Document as std::default::Default>::default();
+<document::Document>::default();
-----------------
crates/toml_edit/src/document.rs <document::Document as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<document::Document as std::str::FromStr>::from_str(&p0);
+crate::<document::Document as std::str::FromStr>::from_str(&p0);
+<document::Document>::from_str(&p0);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.deref();
+<document::Document as std::ops::Deref>::deref(p0);
+crate::<document::Document as std::ops::Deref>::deref(p0);
+<document::Document>::deref(p0);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::ops::DerefMut>::deref_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.deref_mut();
+<document::Document as std::ops::DerefMut>::deref_mut(p0);
+crate::<document::Document as std::ops::DerefMut>::deref_mut(p0);
+<document::Document>::deref_mut(p0);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::convert::From<table::Table>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Table
+<document::Document as std::convert::From<table::Table>>::from(p0);
+crate::<document::Document as std::convert::From<table::Table>>::from(p0);
+<document::Document>::from(p0);
-----------------
crates/toml_edit/src/encode.rs <key::Key as encode::Encode>::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<key::Key as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<key::Key as encode::Encode>::encode(p0, p1, p2, p3);
+<key::Key>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <&'k [key::Key] as encode::Encode>::encode
'k
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<&'k [key::Key] as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<&'k [key::Key] as encode::Encode>::encode(p0, p1, p2, p3);
+<&'k [key::Key]>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <&'k [&'k key::Key] as encode::Encode>::encode
'k
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [&'k key::Key]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<&'k [&'k key::Key] as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<&'k [&'k key::Key] as encode::Encode>::encode(p0, p1, p2, p3);
+<&'k [&'k key::Key]>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <repr::Formatted<T> as encode::Encode>::encode
deps:{"<repr::Formatted<T> as encode::Encode>::encode":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"<repr::Formatted<T> as encode::Encode>::encode":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<repr::Formatted<T> as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<repr::Formatted<T> as encode::Encode>::encode(p0, p1, p2, p3);
+<repr::Formatted<T>>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <array::Array as encode::Encode>::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<array::Array as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<array::Array as encode::Encode>::encode(p0, p1, p2, p3);
+<array::Array>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <inline_table::InlineTable as encode::Encode>::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<inline_table::InlineTable as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<inline_table::InlineTable as encode::Encode>::encode(p0, p1, p2, p3);
+<inline_table::InlineTable>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <value::Value as encode::Encode>::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<value::Value as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<value::Value as encode::Encode>::encode(p0, p1, p2, p3);
+<value::Value>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs encode::<impl std::fmt::Display for document::Document>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+encode::<impl std::fmt::Display for document::Document>::fmt(p0, p1);
+crate::encode::<impl std::fmt::Display for document::Document>::fmt(p0, p1);
+<document::Document>::fmt(p0, p1);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for std::string::String>::to_repr
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+p0.to_repr();
+encode::<impl repr::ValueRepr for std::string::String>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for std::string::String>::to_repr(p0);
+<std::string::String>::to_repr(p0);
-----------------
crates/toml_edit/src/encode.rs <encode::StringStyle as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.clone();
+<encode::StringStyle as std::clone::Clone>::clone(p0);
+crate::<encode::StringStyle as std::clone::Clone>::clone(p0);
+<encode::StringStyle>::clone(p0);
-----------------
crates/toml_edit/src/encode.rs <encode::StringStyle as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<encode::StringStyle as std::fmt::Debug>::fmt(p0, p1);
+crate::<encode::StringStyle as std::fmt::Debug>::fmt(p0, p1);
+<encode::StringStyle>::fmt(p0, p1);
-----------------
crates/toml_edit/src/encode.rs <encode::StringStyle as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
let mut p1 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.eq(p1);
+<encode::StringStyle as std::cmp::PartialEq>::eq(p0, p1);
+crate::<encode::StringStyle as std::cmp::PartialEq>::eq(p0, p1);
+<encode::StringStyle>::eq(p0, p1);
-----------------
crates/toml_edit/src/encode.rs <encode::StringStyle as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.assert_receiver_is_total_eq();
+<encode::StringStyle as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<encode::StringStyle as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<encode::StringStyle>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/encode.rs encode::StringStyle::literal_start
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.literal_start();
+encode::StringStyle::literal_start(p0);
+crate::encode::StringStyle::literal_start(p0);
+<encode::StringStyle>::literal_start(p0);
-----------------
crates/toml_edit/src/encode.rs encode::StringStyle::literal_end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.literal_end();
+encode::StringStyle::literal_end(p0);
+crate::encode::StringStyle::literal_end(p0);
+<encode::StringStyle>::literal_end(p0);
-----------------
crates/toml_edit/src/encode.rs encode::StringStyle::standard_start
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.standard_start();
+encode::StringStyle::standard_start(p0);
+crate::encode::StringStyle::standard_start(p0);
+<encode::StringStyle>::standard_start(p0);
-----------------
crates/toml_edit/src/encode.rs encode::StringStyle::standard_end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.standard_end();
+encode::StringStyle::standard_end(p0);
+crate::encode::StringStyle::standard_end(p0);
+<encode::StringStyle>::standard_end(p0);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for i64>::to_repr
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_repr();
+encode::<impl repr::ValueRepr for i64>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for i64>::to_repr(p0);
+<i64>::to_repr(p0);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for f64>::to_repr
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_repr();
+encode::<impl repr::ValueRepr for f64>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for f64>::to_repr(p0);
+<f64>::to_repr(p0);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for bool>::to_repr
deps:{}
candidates:{}
let mut p0 = & true; // None+bool
+p0.to_repr();
+encode::<impl repr::ValueRepr for bool>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for bool>::to_repr(p0);
+<bool>::to_repr(p0);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // toml_datetime::Datetime
+p0.to_repr();
+encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr(p0);
+<toml_datetime::Datetime>::to_repr(p0);
-----------------
crates/toml_edit/src/index.rs <usize as index::Index>::index
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+<usize as index::Index>::index(p0, p1);
+crate::<usize as index::Index>::index(p0, p1);
+<usize>::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs <usize as index::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+<usize as index::Index>::index_mut(p0, p1);
+crate::<usize as index::Index>::index_mut(p0, p1);
+<usize>::index_mut(p0, p1);
-----------------
crates/toml_edit/src/index.rs <str as index::Index>::index
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+<str as index::Index>::index(&p0, p1);
+crate::<str as index::Index>::index(&p0, p1);
+<str>::index(&p0, p1);
-----------------
crates/toml_edit/src/index.rs <str as index::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+<str as index::Index>::index_mut(&p0, p1);
+crate::<str as index::Index>::index_mut(&p0, p1);
+<str>::index_mut(&p0, p1);
-----------------
crates/toml_edit/src/index.rs <std::string::String as index::Index>::index
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+<std::string::String as index::Index>::index(p0, p1);
+crate::<std::string::String as index::Index>::index(p0, p1);
+<std::string::String>::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs <std::string::String as index::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+<std::string::String as index::Index>::index_mut(p0, p1);
+crate::<std::string::String as index::Index>::index_mut(p0, p1);
+<std::string::String>::index_mut(p0, p1);
-----------------
crates/toml_edit/src/index.rs <&'a T as index::Index>::index
'a
deps:{"<&'a T as index::Index>":{},"<&'a T as index::Index>::index":{"T":["index::Index"]}}
candidates:{"<&'a T as index::Index>":{},"<&'a T as index::Index>::index":{"T":["<&'a T as index::Index>","std::string::String"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+<&'a T as index::Index>::index(p0, p1);
+crate::<&'a T as index::Index>::index(p0, p1);
+<&'a T>::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs <&'a T as index::Index>::index_mut
'a
deps:{"<&'a T as index::Index>":{},"<&'a T as index::Index>::index_mut":{"T":["index::Index"]}}
candidates:{"<&'a T as index::Index>":{},"<&'a T as index::Index>::index_mut":{"T":["std::string::String","<&'a T as index::Index>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+<&'a T as index::Index>::index_mut(p0, p1);
+crate::<&'a T as index::Index>::index_mut(p0, p1);
+<&'a T>::index_mut(p0, p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::Index<I> for item::Item>::index
deps:{"<&'a T as index::Index>":{},"index::<impl std::ops::Index<I> for item::Item>::index":{"I":["std::marker::Sized","index::Index"]}}
candidates:{"<&'a T as index::Index>":{},"index::<impl std::ops::Index<I> for item::Item>::index":{"I":["std::string::String","<&'a T as index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.index(p1);
+index::<impl std::ops::Index<I> for item::Item>::index(p0, p1);
+crate::index::<impl std::ops::Index<I> for item::Item>::index(p0, p1);
+<item::Item>::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::IndexMut<I> for item::Item>::index_mut
deps:{"<&'a T as index::Index>":{},"index::<impl std::ops::IndexMut<I> for item::Item>::index_mut":{"I":["index::Index","std::marker::Sized"]}}
candidates:{"<&'a T as index::Index>":{},"index::<impl std::ops::IndexMut<I> for item::Item>::index_mut":{"I":["<&'a T as index::Index>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.index_mut(p1);
+index::<impl std::ops::IndexMut<I> for item::Item>::index_mut(p0, p1);
+crate::index::<impl std::ops::IndexMut<I> for item::Item>::index_mut(p0, p1);
+<item::Item>::index_mut(p0, p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::Index<&'s str> for table::Table>::index
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+index::<impl std::ops::Index<&'s str> for table::Table>::index(p0, &p1);
+crate::index::<impl std::ops::Index<&'s str> for table::Table>::index(p0, &p1);
+<table::Table>::index(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut
's
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.index_mut(&p1);
+index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut(p0, &p1);
+crate::index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut(p0, &p1);
+<table::Table>::index_mut(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index(p0, &p1);
+crate::index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index(p0, &p1);
+<inline_table::InlineTable>::index(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut
's
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.index_mut(&p1);
+index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut(p0, &p1);
+crate::index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut(p0, &p1);
+<inline_table::InlineTable>::index_mut(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::Index<&'s str> for document::Document>::index
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+index::<impl std::ops::Index<&'s str> for document::Document>::index(p0, &p1);
+crate::index::<impl std::ops::Index<&'s str> for document::Document>::index(p0, &p1);
+<document::Document>::index(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut
's
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = "sample"; // None+&str
+p0.index_mut(&p1);
+index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut(p0, &p1);
+crate::index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut(p0, &p1);
+<document::Document>::index_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<inline_table::InlineTable as std::fmt::Debug>::fmt(p0, p1);
+crate::<inline_table::InlineTable as std::fmt::Debug>::fmt(p0, p1);
+<inline_table::InlineTable>::fmt(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::default::Default>::default
deps:{}
candidates:{}
+<inline_table::InlineTable as std::default::Default>::default();
+crate::<inline_table::InlineTable as std::default::Default>::default();
+<inline_table::InlineTable>::default();
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.clone();
+<inline_table::InlineTable as std::clone::Clone>::clone(p0);
+crate::<inline_table::InlineTable as std::clone::Clone>::clone(p0);
+<inline_table::InlineTable>::clone(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::new
deps:{}
candidates:{}
+inline_table::InlineTable::new();
+crate::inline_table::InlineTable::new();
+<inline_table::InlineTable>::new();
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::with_pairs
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // indexmap::IndexMap<internal_string::InternalString, table::TableKeyValue>
+inline_table::InlineTable::with_pairs(p0);
+crate::inline_table::InlineTable::with_pairs(p0);
+<inline_table::InlineTable>::with_pairs(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::into_table
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.into_table();
+inline_table::InlineTable::into_table(p0);
+crate::inline_table::InlineTable::into_table(p0);
+<inline_table::InlineTable>::into_table(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.get_values();
+inline_table::InlineTable::get_values(p0);
+crate::inline_table::InlineTable::get_values(p0);
+<inline_table::InlineTable>::get_values(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::append_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // [&'s key::Key]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<(std::vec::Vec<&'s key::Key>, &'s value::Value)>
+p0.append_values(p1, p2);
+inline_table::InlineTable::append_values(p0, p1, p2);
+crate::inline_table::InlineTable::append_values(p0, p1, p2);
+<inline_table::InlineTable>::append_values(p0, p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.fmt();
+inline_table::InlineTable::fmt(p0);
+crate::inline_table::InlineTable::fmt(p0);
+<inline_table::InlineTable>::fmt(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::sort_values
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.sort_values();
+inline_table::InlineTable::sort_values(p0);
+crate::inline_table::InlineTable::sort_values(p0);
+<inline_table::InlineTable>::sort_values(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::sort_values_by
deps:{"inline_table::InlineTable::sort_values_by":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"inline_table::InlineTable::sort_values_by":{"F":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.sort_values_by(p1);
+inline_table::InlineTable::sort_values_by(p0, p1);
+crate::inline_table::InlineTable::sort_values_by(p0, p1);
+<inline_table::InlineTable>::sort_values_by(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::sort_values_by_internal
deps:{"inline_table::InlineTable::sort_values_by_internal":{"F":["std::ops::FnMut","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"inline_table::InlineTable::sort_values_by_internal":{"F":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // F
+p0.sort_values_by_internal(p1);
+inline_table::InlineTable::sort_values_by_internal(p0, p1);
+crate::inline_table::InlineTable::sort_values_by_internal(p0, p1);
+<inline_table::InlineTable>::sort_values_by_internal(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::set_dotted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+inline_table::InlineTable::set_dotted(p0, p1);
+crate::inline_table::InlineTable::set_dotted(p0, p1);
+<inline_table::InlineTable>::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::is_dotted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.is_dotted();
+inline_table::InlineTable::is_dotted(p0);
+crate::inline_table::InlineTable::is_dotted(p0);
+<inline_table::InlineTable>::is_dotted(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.decor_mut();
+inline_table::InlineTable::decor_mut(p0);
+crate::inline_table::InlineTable::decor_mut(p0);
+<inline_table::InlineTable>::decor_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.decor();
+inline_table::InlineTable::decor(p0);
+crate::inline_table::InlineTable::decor(p0);
+<inline_table::InlineTable>::decor(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::key_decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+inline_table::InlineTable::key_decor_mut(p0, &p1);
+crate::inline_table::InlineTable::key_decor_mut(p0, &p1);
+<inline_table::InlineTable>::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::key_decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+inline_table::InlineTable::key_decor(p0, &p1);
+crate::inline_table::InlineTable::key_decor(p0, &p1);
+<inline_table::InlineTable>::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::set_preamble
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"inline_table::InlineTable::set_preamble":{"impl Into<RawString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"inline_table::InlineTable::set_preamble":{"impl Into<RawString>":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_preamble(p1);
+inline_table::InlineTable::set_preamble(p0, p1);
+crate::inline_table::InlineTable::set_preamble(p0, p1);
+<inline_table::InlineTable>::set_preamble(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::preamble
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.preamble();
+inline_table::InlineTable::preamble(p0);
+crate::inline_table::InlineTable::preamble(p0);
+<inline_table::InlineTable>::preamble(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.span();
+inline_table::InlineTable::span(p0);
+crate::inline_table::InlineTable::span(p0);
+<inline_table::InlineTable>::span(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+inline_table::InlineTable::despan(p0, &p1);
+crate::inline_table::InlineTable::despan(p0, &p1);
+<inline_table::InlineTable>::despan(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.iter();
+inline_table::InlineTable::iter(p0);
+crate::inline_table::InlineTable::iter(p0);
+<inline_table::InlineTable>::iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.iter_mut();
+inline_table::InlineTable::iter_mut(p0);
+crate::inline_table::InlineTable::iter_mut(p0);
+<inline_table::InlineTable>::iter_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.len();
+inline_table::InlineTable::len(p0);
+crate::inline_table::InlineTable::len(p0);
+<inline_table::InlineTable>::len(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.is_empty();
+inline_table::InlineTable::is_empty(p0);
+crate::inline_table::InlineTable::is_empty(p0);
+<inline_table::InlineTable>::is_empty(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.clear();
+inline_table::InlineTable::clear(p0);
+crate::inline_table::InlineTable::clear(p0);
+<inline_table::InlineTable>::clear(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::entry
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"inline_table::InlineTable::entry":{"impl Into<InternalString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"inline_table::InlineTable::entry":{"impl Into<InternalString>":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<InternalString>
+p0.entry(p1);
+inline_table::InlineTable::entry(p0, p1);
+crate::inline_table::InlineTable::entry(p0, p1);
+<inline_table::InlineTable>::entry(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::entry_format
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+inline_table::InlineTable::entry_format(p0, p1);
+crate::inline_table::InlineTable::entry_format(p0, p1);
+<inline_table::InlineTable>::entry_format(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+inline_table::InlineTable::get(p0, &p1);
+crate::inline_table::InlineTable::get(p0, &p1);
+<inline_table::InlineTable>::get(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+inline_table::InlineTable::get_mut(p0, &p1);
+crate::inline_table::InlineTable::get_mut(p0, &p1);
+<inline_table::InlineTable>::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_key_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+inline_table::InlineTable::get_key_value(p0, &p1);
+crate::inline_table::InlineTable::get_key_value(p0, &p1);
+<inline_table::InlineTable>::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_key_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+inline_table::InlineTable::get_key_value_mut(p0, &p1);
+crate::inline_table::InlineTable::get_key_value_mut(p0, &p1);
+<inline_table::InlineTable>::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::contains_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+inline_table::InlineTable::contains_key(p0, &p1);
+crate::inline_table::InlineTable::contains_key(p0, &p1);
+<inline_table::InlineTable>::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_or_insert
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"inline_table::InlineTable::get_or_insert":{"V":["std::marker::Sized","std::convert::Into"],"impl Into<InternalString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"inline_table::InlineTable::get_or_insert":{"V":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"],"impl Into<InternalString>":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<InternalString>
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.get_or_insert(p1, p2);
+inline_table::InlineTable::get_or_insert(p0, p1, p2);
+crate::inline_table::InlineTable::get_or_insert(p0, p1, p2);
+<inline_table::InlineTable>::get_or_insert(p0, p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::insert
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"inline_table::InlineTable::insert":{"impl Into<InternalString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"inline_table::InlineTable::insert":{"impl Into<InternalString>":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<InternalString>
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1, p2);
+inline_table::InlineTable::insert(p0, p1, p2);
+crate::inline_table::InlineTable::insert(p0, p1, p2);
+<inline_table::InlineTable>::insert(p0, p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::insert_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert_formatted(p1, p2);
+inline_table::InlineTable::insert_formatted(p0, p1, p2);
+crate::inline_table::InlineTable::insert_formatted(p0, p1, p2);
+<inline_table::InlineTable>::insert_formatted(p0, p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+inline_table::InlineTable::remove(p0, &p1);
+crate::inline_table::InlineTable::remove(p0, &p1);
+<inline_table::InlineTable>::remove(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::remove_entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.remove_entry(&p1);
+inline_table::InlineTable::remove_entry(p0, &p1);
+crate::inline_table::InlineTable::remove_entry(p0, &p1);
+<inline_table::InlineTable>::remove_entry(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<inline_table::InlineTable as std::fmt::Display>::fmt(p0, p1);
+crate::<inline_table::InlineTable as std::fmt::Display>::fmt(p0, p1);
+<inline_table::InlineTable>::fmt(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend":{"K":["std::marker::Sized","std::convert::Into"],"T":["std::iter::IntoIterator","std::marker::Sized"],"V":["std::convert::Into","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Peekable<I>","std::iter::Copied<I>","std::process::CommandEnvs<'a>","std::iter::Cycle<I>","std::net::IntoIncoming","std::collections::hash_map::IntoIter<K, V>","std::iter::Map<I, F>","std::str::LinesAny<'a>","std::collections::binary_heap::Iter<'a, T>","std::collections::btree_map::RangeMut<'a, K, V>","std::io::Lines<B>","std::char::ToLowercase","std::str::RMatches<'a, P>","std::path::Iter<'a>","std::sys::unix::args::Args","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::slice::GroupBy<'a, T, P>","std::str::Matches<'a, P>","std::collections::btree_map::Keys<'a, K, V>","std::iter::SkipWhile<I, P>","std::collections::hash_map::Keys<'a, K, V>","std::iter::Flatten<I>","std::sys::unix::process::process_common::CommandArgs<'a>","std::iter::Intersperse<I>","std::result::IterMut<'a, T>","std::collections::btree_set::IntoIter<T, A>","std::iter::Successors<T, F>","std::option::IntoIter<A>","std::ops::Range<A>","std::sys::unix::os::Env","std::sync::mpsc::IntoIter<T>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::array::IntoIter<T, N>","std::iter::Repeat<A>","std::collections::btree_set::Union<'a, T>","std::collections::hash_map::Iter<'a, K, V>","std::result::IntoIter<T>","std::collections::btree_map::IntoKeys<K, V, A>","std::iter::ByRefSized<'_, I>","std::collections::btree_map::IterMut<'a, K, V>","std::iter::OnceWith<F>","std::os::unix::net::ScmCredentials<'a>","std::slice::SplitInclusive<'a, T, P>","std::slice::Windows<'a, T>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::linked_list::DrainFilter<'_, T, F>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::iter::Skip<I>","std::collections::binary_heap::IntoIterSorted<T>","std::option::IterMut<'a, A>","std::sys_common::wtf8::EncodeWide<'a>","std::boxed::Box<I, A>","std::iter::IntersperseWith<I, G>","std::ops::RangeFrom<A>","std::collections::binary_heap::IntoIter<T>","std::collections::btree_map::Iter<'a, K, V>","std::char::EscapeDebug","std::str::SplitN<'a, P>","std::env::SplitPaths<'a>","std::slice::RChunksExactMut<'a, T>","std::net::Incoming<'a>","std::collections::hash_map::ValuesMut<'a, K, V>","std::str::Bytes<'_>","std::collections::hash_map::IntoKeys<K, V>","std::env::ArgsOs","std::slice::EscapeAscii<'a>","std::collections::hash_set::Difference<'a, T, S>","std::string::Drain<'_>","std::iter::Rev<I>","std::iter::Empty<T>","std::sys_common::wstr::WStrUnits<'_>","std::collections::hash_map::Drain<'a, K, V>","std::collections::btree_map::IntoValues<K, V, A>","std::iter::StepBy<I>","std::char::ToUppercase","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::hash_set::Iter<'a, K>","std::collections::btree_map::IntoIter<K, V, A>","std::io::Split<B>","std::env::Args","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::binary_heap::Drain<'_, T>","std::iter::Take<I>","std::slice::RSplitNMut<'a, T, P>","std::env::VarsOs","std::slice::ChunksMut<'a, T>","std::iter::ArrayChunks<I, N>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::iter::Enumerate<I>","std::char::EscapeDefault","std::slice::RSplit<'a, T, P>","std::io::Bytes<R>","std::sys::unix::fs::ReadDir","std::str::SplitTerminator<'a, P>","std::slice::SplitNMut<'a, T, P>","std::iter::Inspect<I, F>","std::str::CharIndices<'a>","std::str::RSplit<'a, P>","std::str::RMatchIndices<'a, P>","std::ops::index_range::IndexRange","std::collections::hash_set::DrainFilter<'_, K, F>","std::str::EscapeDebug<'a>","std::sync::mpsc::TryIter<'a, T>","std::slice::ArrayChunksMut<'a, T, N>","std::slice::IterMut<'a, T>","core::error::Source<'a>","std::slice::RSplitN<'a, T, P>","std::str::SplitWhitespace<'a>","std::collections::hash_set::Drain<'a, K>","std::env::Vars","std::str::RSplitTerminator<'a, P>","std::slice::ArrayChunks<'a, T, N>","std::collections::vec_deque::IntoIter<T, A>","std::collections::vec_deque::Iter<'a, T>","std::iter::Fuse<I>","std::iter::FilterMap<I, F>","std::iter::RepeatWith<F>","std::option::Iter<'a, A>","std::os::unix::net::Messages<'a>","std::vec::Drain<'_, T, A>","std::str::SplitInclusive<'a, P>","std::slice::SplitInclusiveMut<'a, T, P>","std::collections::btree_set::Intersection<'a, T, A>","std::slice::RSplitMut<'a, T, P>","std::slice::Iter<'a, T>","std::char::EscapeUnicode","std::iter::Scan<I, St, F>","std::collections::hash_set::Intersection<'a, T, S>","std::sync::mpsc::Iter<'a, T>","std::collections::linked_list::IterMut<'a, T>","std::iter::Chain<A, B>","std::iter::Zip<A, B>","std::collections::hash_set::Union<'a, T, S>","std::ops::RangeInclusive<A>","std::char::CaseMappingIter","std::collections::hash_map::Values<'a, K, V>","std::sys_common::net::LookupHost","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::vec::Splice<'_, I, A>","std::collections::btree_map::Range<'a, K, V>","std::fs::ReadDir","std::str::EncodeUtf16<'a>","std::iter::FlatMap<I, U, F>","std::collections::hash_map::IterMut<'a, K, V>","std::iter::Cloned<I>","std::str::EscapeUnicode<'a>","std::collections::linked_list::IntoIter<T>","std::slice::RChunksMut<'a, T>","std::collections::btree_set::Range<'a, T>","std::iter::sources::from_generator::FromGenerator<G>","std::iter::RepeatN<A>","std::str::MatchIndices<'a, P>","std::ascii::EscapeDefault","std::slice::ChunksExactMut<'a, T>","std::path::Components<'a>","std::os::unix::net::Incoming<'a>","std::iter::Filter<I, P>","std::str::Split<'a, P>","std::collections::btree_set::SymmetricDifference<'a, T>","std::vec::IntoIter<T, A>","std::collections::btree_set::Iter<'a, T>","std::collections::linked_list::Iter<'a, T>","std::slice::RChunksExact<'a, T>","std::iter::FromFn<F>","std::sys::unix::os::SplitPaths<'a>","std::str::SplitAsciiWhitespace<'a>","core::slice::iter::GenericSplitN<I>","std::collections::hash_map::IntoValues<K, V>","std::path::Ancestors<'a>","std::iter::Once<T>","std::collections::hash_set::IntoIter<K>","std::option::Item<A>","std::collections::vec_deque::Drain<'_, T, A>","std::result::Iter<'a, T>","std::iter::adapters::GenericShunt<'_, I, R>","std::vec::DrainFilter<'_, T, F, A>","std::iter::MapWhile<I, P>","std::process::CommandArgs<'a>","std::collections::btree_set::Difference<'a, T, A>","std::slice::SplitN<'a, T, P>","std::slice::Split<'a, T, P>","std::char::DecodeUtf16<I>","std::slice::ChunksExact<'a, T>","std::os::unix::net::ScmRights<'a>","std::str::Lines<'a>","std::collections::vec_deque::IterMut<'a, T>","std::str::EscapeDefault<'a>","std::str::Chars<'a>","std::slice::GroupByMut<'a, T, P>","std::slice::ArrayWindows<'a, T, N>","std::str::RSplitN<'a, P>","std::slice::Chunks<'a, T>","std::collections::btree_map::Values<'a, K, V>","std::slice::RChunks<'a, T>","<&mut I as std::iter::Iterator>","std::slice::SplitMut<'a, T, P>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::str::Utf8Chunks<'a>","std::iter::TakeWhile<I, P>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend":{"K":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"],"T":["array_of_tables::ArrayOfTables","array::Array","<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>","<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>","table::Table","inline_table::InlineTable"],"V":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend(p0, p1);
+crate::<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend(p0, p1);
+<inline_table::InlineTable>::extend(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"],"K":["std::convert::Into","std::marker::Sized"],"V":["std::marker::Sized","std::convert::Into"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::env::Args","std::char::DecodeUtf16<I>","std::iter::Skip<I>","std::collections::vec_deque::IntoIter<T, A>","std::path::Iter<'a>","std::collections::btree_map::IntoValues<K, V, A>","std::slice::ChunksExactMut<'a, T>","std::collections::btree_map::IntoKeys<K, V, A>","std::result::Iter<'a, T>","std::string::Drain<'_>","std::collections::linked_list::IntoIter<T>","std::process::CommandArgs<'a>","std::path::Ancestors<'a>","std::collections::binary_heap::Drain<'_, T>","std::sys::unix::process::process_common::CommandArgs<'a>","std::iter::Inspect<I, F>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::iter::Intersperse<I>","std::iter::IntersperseWith<I, G>","std::str::Chars<'a>","std::str::SplitAsciiWhitespace<'a>","std::str::CharIndices<'a>","std::collections::btree_set::Union<'a, T>","std::iter::RepeatWith<F>","std::str::EscapeUnicode<'a>","std::slice::SplitMut<'a, T, P>","std::slice::SplitN<'a, T, P>","std::iter::Filter<I, P>","std::net::Incoming<'a>","std::char::ToUppercase","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::slice::SplitInclusiveMut<'a, T, P>","core::slice::iter::GenericSplitN<I>","std::iter::Empty<T>","std::slice::ArrayChunksMut<'a, T, N>","std::str::Lines<'a>","std::collections::linked_list::IterMut<'a, T>","std::iter::Fuse<I>","std::iter::Flatten<I>","std::str::Split<'a, P>","std::env::SplitPaths<'a>","std::collections::hash_set::Intersection<'a, T, S>","std::str::SplitN<'a, P>","std::os::unix::net::ScmCredentials<'a>","std::slice::RChunksMut<'a, T>","std::slice::RSplitMut<'a, T, P>","std::iter::sources::from_generator::FromGenerator<G>","std::iter::FilterMap<I, F>","std::str::RMatchIndices<'a, P>","std::iter::Take<I>","std::iter::MapWhile<I, P>","std::collections::hash_map::IntoIter<K, V>","std::collections::btree_set::Range<'a, T>","std::collections::hash_set::Drain<'a, K>","std::option::IterMut<'a, A>","std::collections::btree_map::ValuesMut<'a, K, V>","std::process::CommandEnvs<'a>","std::result::IntoIter<T>","std::str::EscapeDefault<'a>","std::collections::binary_heap::Iter<'a, T>","std::str::RSplitTerminator<'a, P>","std::ops::index_range::IndexRange","std::os::unix::net::Incoming<'a>","std::collections::btree_map::IntoIter<K, V, A>","std::option::Iter<'a, A>","std::slice::ChunksMut<'a, T>","std::io::Lines<B>","std::slice::GroupByMut<'a, T, P>","std::net::IntoIncoming","std::collections::btree_map::Keys<'a, K, V>","std::iter::Cycle<I>","std::collections::hash_set::IntoIter<K>","std::iter::Copied<I>","std::iter::ByRefSized<'_, I>","std::vec::Drain<'_, T, A>","std::path::Components<'a>","std::ops::Range<A>","std::iter::Enumerate<I>","std::iter::FlatMap<I, U, F>","std::env::Vars","std::str::SplitTerminator<'a, P>","std::slice::IterMut<'a, T>","std::collections::vec_deque::Iter<'a, T>","std::boxed::Box<I, A>","std::collections::hash_map::Keys<'a, K, V>","std::collections::hash_map::IterMut<'a, K, V>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::slice::ArrayWindows<'a, T, N>","std::slice::RChunksExact<'a, T>","std::collections::hash_set::Difference<'a, T, S>","std::char::EscapeDebug","std::iter::adapters::GenericShunt<'_, I, R>","std::result::IterMut<'a, T>","std::env::VarsOs","std::collections::hash_set::Union<'a, T, S>","std::str::SplitInclusive<'a, P>","std::slice::Windows<'a, T>","std::collections::linked_list::DrainFilter<'_, T, F>","std::collections::btree_map::Range<'a, K, V>","std::slice::SplitInclusive<'a, T, P>","std::char::CaseMappingIter","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::str::EncodeUtf16<'a>","std::collections::hash_set::DrainFilter<'_, K, F>","std::slice::ChunksExact<'a, T>","std::iter::Once<T>","std::sync::mpsc::TryIter<'a, T>","std::collections::hash_map::IntoKeys<K, V>","std::slice::SplitNMut<'a, T, P>","std::slice::EscapeAscii<'a>","std::iter::Peekable<I>","std::collections::hash_map::IntoValues<K, V>","std::str::Utf8Chunks<'a>","std::collections::hash_map::Drain<'a, K, V>","std::char::ToLowercase","std::collections::hash_map::ValuesMut<'a, K, V>","std::iter::FromFn<F>","std::iter::Map<I, F>","std::sys_common::net::LookupHost","std::collections::btree_set::Intersection<'a, T, A>","std::collections::hash_map::Values<'a, K, V>","std::iter::Rev<I>","std::collections::hash_set::Iter<'a, K>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::slice::Split<'a, T, P>","std::iter::TakeWhile<I, P>","std::slice::Iter<'a, T>","std::str::SplitWhitespace<'a>","std::option::Item<A>","std::collections::linked_list::Iter<'a, T>","std::str::RSplit<'a, P>","std::vec::IntoIter<T, A>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::collections::btree_set::SymmetricDifference<'a, T>","core::error::Source<'a>","std::os::unix::net::ScmRights<'a>","std::option::IntoIter<A>","std::iter::Repeat<A>","std::iter::RepeatN<A>","std::collections::hash_map::Iter<'a, K, V>","std::char::EscapeUnicode","std::fs::ReadDir","std::sys::unix::os::Env","std::collections::btree_set::Difference<'a, T, A>","std::os::unix::net::Messages<'a>","std::iter::Successors<T, F>","std::ops::RangeInclusive<A>","std::vec::Splice<'_, I, A>","std::sys::unix::os::SplitPaths<'a>","std::collections::btree_map::RangeMut<'a, K, V>","std::iter::OnceWith<F>","std::slice::ArrayChunks<'a, T, N>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::sync::mpsc::Iter<'a, T>","std::str::Bytes<'_>","std::slice::Chunks<'a, T>","std::slice::RSplit<'a, T, P>","std::collections::binary_heap::DrainSorted<'_, T>","std::sys_common::wtf8::EncodeWide<'a>","std::collections::btree_map::IterMut<'a, K, V>","std::io::Split<B>","std::collections::vec_deque::Drain<'_, T, A>","std::vec::DrainFilter<'_, T, F, A>","std::slice::GroupBy<'a, T, P>","std::array::IntoIter<T, N>","std::collections::binary_heap::IntoIter<T>","std::ascii::EscapeDefault","std::iter::Chain<A, B>","std::iter::SkipWhile<I, P>","std::sys_common::wstr::WStrUnits<'_>","std::char::EscapeDefault","std::iter::Scan<I, St, F>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::slice::RChunksExactMut<'a, T>","std::collections::binary_heap::IntoIterSorted<T>","std::iter::ArrayChunks<I, N>","std::sys::unix::args::Args","std::collections::btree_set::IntoIter<T, A>","std::slice::RSplitN<'a, T, P>","std::env::ArgsOs","std::collections::btree_map::Iter<'a, K, V>","std::str::Matches<'a, P>","std::io::Bytes<R>","std::slice::RChunks<'a, T>","std::sys::unix::fs::ReadDir","std::ops::RangeFrom<A>","std::str::RSplitN<'a, P>","std::iter::StepBy<I>","std::iter::Zip<A, B>","std::collections::btree_set::Iter<'a, T>","std::collections::vec_deque::IterMut<'a, T>","std::collections::btree_map::Values<'a, K, V>","std::iter::Cloned<I>","std::str::RMatches<'a, P>","std::slice::RSplitNMut<'a, T, P>","std::str::MatchIndices<'a, P>","std::str::EscapeDebug<'a>","std::str::LinesAny<'a>","std::sync::mpsc::IntoIter<T>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["array::Array","table::Table","<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>","array_of_tables::ArrayOfTables","inline_table::InlineTable","<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>"],"K":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError"],"V":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+crate::<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+<inline_table::InlineTable>::from_iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.into_iter();
+<inline_table::InlineTable as std::iter::IntoIterator>::into_iter(p0);
+crate::<inline_table::InlineTable as std::iter::IntoIterator>::into_iter(p0);
+<inline_table::InlineTable>::into_iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs <&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.into_iter();
+<&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter(p0);
+<&'s inline_table::InlineTable>::into_iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.iter();
+<inline_table::InlineTable as table::TableLike>::iter(p0);
+crate::<inline_table::InlineTable as table::TableLike>::iter(p0);
+<inline_table::InlineTable>::iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.iter_mut();
+<inline_table::InlineTable as table::TableLike>::iter_mut(p0);
+crate::<inline_table::InlineTable as table::TableLike>::iter_mut(p0);
+<inline_table::InlineTable>::iter_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.clear();
+<inline_table::InlineTable as table::TableLike>::clear(p0);
+crate::<inline_table::InlineTable as table::TableLike>::clear(p0);
+<inline_table::InlineTable>::clear(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.entry(&p1);
+<inline_table::InlineTable as table::TableLike>::entry(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::entry(p0, &p1);
+<inline_table::InlineTable>::entry(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::entry_format
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+<inline_table::InlineTable as table::TableLike>::entry_format(p0, p1);
+crate::<inline_table::InlineTable as table::TableLike>::entry_format(p0, p1);
+<inline_table::InlineTable>::entry_format(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+<inline_table::InlineTable as table::TableLike>::get(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::get(p0, &p1);
+<inline_table::InlineTable>::get(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+<inline_table::InlineTable as table::TableLike>::get_mut(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::get_mut(p0, &p1);
+<inline_table::InlineTable>::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get_key_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+<inline_table::InlineTable as table::TableLike>::get_key_value(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::get_key_value(p0, &p1);
+<inline_table::InlineTable>::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get_key_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+<inline_table::InlineTable as table::TableLike>::get_key_value_mut(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::get_key_value_mut(p0, &p1);
+<inline_table::InlineTable>::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::contains_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+<inline_table::InlineTable as table::TableLike>::contains_key(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::contains_key(p0, &p1);
+<inline_table::InlineTable>::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(&p1, p2);
+<inline_table::InlineTable as table::TableLike>::insert(p0, &p1, p2);
+crate::<inline_table::InlineTable as table::TableLike>::insert(p0, &p1, p2);
+<inline_table::InlineTable>::insert(p0, &p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+<inline_table::InlineTable as table::TableLike>::remove(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::remove(p0, &p1);
+<inline_table::InlineTable>::remove(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.get_values();
+<inline_table::InlineTable as table::TableLike>::get_values(p0);
+crate::<inline_table::InlineTable as table::TableLike>::get_values(p0);
+<inline_table::InlineTable>::get_values(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.fmt();
+<inline_table::InlineTable as table::TableLike>::fmt(p0);
+crate::<inline_table::InlineTable as table::TableLike>::fmt(p0);
+<inline_table::InlineTable>::fmt(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::sort_values
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.sort_values();
+<inline_table::InlineTable as table::TableLike>::sort_values(p0);
+crate::<inline_table::InlineTable as table::TableLike>::sort_values(p0);
+<inline_table::InlineTable>::sort_values(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::set_dotted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+<inline_table::InlineTable as table::TableLike>::set_dotted(p0, p1);
+crate::<inline_table::InlineTable as table::TableLike>::set_dotted(p0, p1);
+<inline_table::InlineTable>::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::is_dotted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.is_dotted();
+<inline_table::InlineTable as table::TableLike>::is_dotted(p0);
+crate::<inline_table::InlineTable as table::TableLike>::is_dotted(p0);
+<inline_table::InlineTable>::is_dotted(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::key_decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+<inline_table::InlineTable as table::TableLike>::key_decor_mut(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::key_decor_mut(p0, &p1);
+<inline_table::InlineTable>::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::key_decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+<inline_table::InlineTable as table::TableLike>::key_decor(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::key_decor(p0, &p1);
+<inline_table::InlineTable>::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineEntry<'a>
+p0.key();
+inline_table::InlineEntry::<'a>::key(p0);
+crate::inline_table::InlineEntry::<'a>::key(p0);
+<inline_table::InlineEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineEntry::<'a>::or_insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.or_insert(p1);
+inline_table::InlineEntry::<'a>::or_insert(p0, p1);
+crate::inline_table::InlineEntry::<'a>::or_insert(p0, p1);
+<inline_table::InlineEntry<'a>>::or_insert(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineEntry::<'a>::or_insert_with
'a
deps:{"inline_table::InlineEntry::<'a>::or_insert_with":{"F":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"inline_table::InlineEntry::<'a>::or_insert_with":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.or_insert_with(p1);
+inline_table::InlineEntry::<'a>::or_insert_with(p0, p1);
+crate::inline_table::InlineEntry::<'a>::or_insert_with(p0, p1);
+<inline_table::InlineEntry<'a>>::or_insert_with(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.key();
+inline_table::InlineOccupiedEntry::<'a>::key(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::key(p0);
+<inline_table::InlineOccupiedEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::key_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.key_mut();
+inline_table::InlineOccupiedEntry::<'a>::key_mut(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::key_mut(p0);
+<inline_table::InlineOccupiedEntry<'a>>::key_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::get
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.get();
+inline_table::InlineOccupiedEntry::<'a>::get(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::get(p0);
+<inline_table::InlineOccupiedEntry<'a>>::get(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::get_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.get_mut();
+inline_table::InlineOccupiedEntry::<'a>::get_mut(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::get_mut(p0);
+<inline_table::InlineOccupiedEntry<'a>>::get_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::into_mut
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.into_mut();
+inline_table::InlineOccupiedEntry::<'a>::into_mut(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::into_mut(p0);
+<inline_table::InlineOccupiedEntry<'a>>::into_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1);
+inline_table::InlineOccupiedEntry::<'a>::insert(p0, p1);
+crate::inline_table::InlineOccupiedEntry::<'a>::insert(p0, p1);
+<inline_table::InlineOccupiedEntry<'a>>::insert(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::remove
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.remove();
+inline_table::InlineOccupiedEntry::<'a>::remove(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::remove(p0);
+<inline_table::InlineOccupiedEntry<'a>>::remove(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineVacantEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineVacantEntry<'a>
+p0.key();
+inline_table::InlineVacantEntry::<'a>::key(p0);
+crate::inline_table::InlineVacantEntry::<'a>::key(p0);
+<inline_table::InlineVacantEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineVacantEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineVacantEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1);
+inline_table::InlineVacantEntry::<'a>::insert(p0, p1);
+crate::inline_table::InlineVacantEntry::<'a>::insert(p0, p1);
+<inline_table::InlineVacantEntry<'a>>::insert(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::default::Default>::default
deps:{}
candidates:{}
+<internal_string::InternalString as std::default::Default>::default();
+crate::<internal_string::InternalString as std::default::Default>::default();
+<internal_string::InternalString>::default();
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.clone();
+<internal_string::InternalString as std::clone::Clone>::clone(p0);
+crate::<internal_string::InternalString as std::clone::Clone>::clone(p0);
+<internal_string::InternalString>::clone(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.eq(p1);
+<internal_string::InternalString as std::cmp::PartialEq>::eq(p0, p1);
+crate::<internal_string::InternalString as std::cmp::PartialEq>::eq(p0, p1);
+<internal_string::InternalString>::eq(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.assert_receiver_is_total_eq();
+<internal_string::InternalString as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<internal_string::InternalString as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<internal_string::InternalString>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.partial_cmp(p1);
+<internal_string::InternalString as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<internal_string::InternalString as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<internal_string::InternalString>::partial_cmp(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.cmp(p1);
+<internal_string::InternalString as std::cmp::Ord>::cmp(p0, p1);
+crate::<internal_string::InternalString as std::cmp::Ord>::cmp(p0, p1);
+<internal_string::InternalString>::cmp(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<internal_string::InternalString as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<internal_string::InternalString as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<internal_string::InternalString as std::hash::Hash>::hash(p0, p1);
+crate::<internal_string::InternalString as std::hash::Hash>::hash(p0, p1);
+<internal_string::InternalString>::hash(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs internal_string::InternalString::new
deps:{}
candidates:{}
+internal_string::InternalString::new();
+crate::internal_string::InternalString::new();
+<internal_string::InternalString>::new();
-----------------
crates/toml_edit/src/internal_string.rs internal_string::InternalString::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.as_str();
+internal_string::InternalString::as_str(p0);
+crate::internal_string::InternalString::as_str(p0);
+<internal_string::InternalString>::as_str(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<internal_string::InternalString as std::fmt::Debug>::fmt(p0, p1);
+crate::<internal_string::InternalString as std::fmt::Debug>::fmt(p0, p1);
+<internal_string::InternalString>::fmt(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.deref();
+<internal_string::InternalString as std::ops::Deref>::deref(p0);
+crate::<internal_string::InternalString as std::ops::Deref>::deref(p0);
+<internal_string::InternalString>::deref(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::borrow::Borrow<str>>::borrow
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.borrow();
+<internal_string::InternalString as std::borrow::Borrow<str>>::borrow(p0);
+crate::<internal_string::InternalString as std::borrow::Borrow<str>>::borrow(p0);
+<internal_string::InternalString>::borrow(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::AsRef<str>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.as_ref();
+<internal_string::InternalString as std::convert::AsRef<str>>::as_ref(p0);
+crate::<internal_string::InternalString as std::convert::AsRef<str>>::as_ref(p0);
+<internal_string::InternalString>::as_ref(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<&str>>::from
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<internal_string::InternalString as std::convert::From<&str>>::from(&p0);
+crate::<internal_string::InternalString as std::convert::From<&str>>::from(&p0);
+<internal_string::InternalString>::from(&p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<internal_string::InternalString as std::convert::From<std::string::String>>::from(p0);
+crate::<internal_string::InternalString as std::convert::From<std::string::String>>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<&std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<internal_string::InternalString as std::convert::From<&std::string::String>>::from(p0);
+crate::<internal_string::InternalString as std::convert::From<&std::string::String>>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from(p0);
+crate::<internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::boxed::Box<str>
+<internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from(p0);
+crate::<internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<internal_string::InternalString as std::str::FromStr>::from_str(&p0);
+crate::<internal_string::InternalString as std::str::FromStr>::from_str(&p0);
+<internal_string::InternalString>::from_str(&p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<internal_string::InternalString as std::fmt::Display>::fmt(p0, p1);
+crate::<internal_string::InternalString as std::fmt::Display>::fmt(p0, p1);
+<internal_string::InternalString>::fmt(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as serde::Serialize>::serialize
deps:{"<internal_string::InternalString as serde::Serialize>::serialize":{"S":["serde::Serializer","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"<internal_string::InternalString as serde::Serialize>::serialize":{"S":["ser::map::DatetimeFieldSerializer","ser::value::ValueSerializer","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","ser::key::KeySerializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+<internal_string::InternalString as serde::Serialize>::serialize(p0, p1);
+crate::<internal_string::InternalString as serde::Serialize>::serialize(p0, p1);
+<internal_string::InternalString>::serialize(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as serde::Deserialize<'de>>::deserialize
'de
deps:{"<internal_string::InternalString as serde::Deserialize<'de>>::deserialize":{"D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<internal_string::InternalString as serde::Deserialize<'de>>::deserialize":{"D":["de::key::KeyDeserializer","de::value::ValueDeserializer","de::table::TableDeserializer","de::array::ArrayDeserializer","de::Deserializer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<internal_string::InternalString as serde::Deserialize<'de>>::deserialize(p0);
+crate::<internal_string::InternalString as serde::Deserialize<'de>>::deserialize(p0);
+<internal_string::InternalString>::deserialize(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::StringVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::StringVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<internal_string::StringVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<internal_string::StringVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<internal_string::StringVisitor>::expecting(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::StringVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<internal_string::StringVisitor>::visit_str(p0, &p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_string
'de
deps:{"<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_string":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_string":{"E":["de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::StringVisitor
let mut p1 = std::string::String::new(); // None+std::string::String
+p0.visit_string(p1);
+<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_string(p0, p1);
+crate::<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_string(p0, p1);
+<internal_string::StringVisitor>::visit_string(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_bytes
'de
deps:{"<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_bytes":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_bytes":{"E":["de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::StringVisitor
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.visit_bytes(p1);
+<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+crate::<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_bytes(p0, p1);
+<internal_string::StringVisitor>::visit_bytes(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_byte_buf
'de
deps:{"<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_byte_buf":{"E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_byte_buf":{"E":["de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::StringVisitor
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.visit_byte_buf(p1);
+<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_byte_buf(p0, p1);
+crate::<internal_string::StringVisitor as serde::de::Visitor<'de>>::visit_byte_buf(p0, p1);
+<internal_string::StringVisitor>::visit_byte_buf(p0, p1);
-----------------
crates/toml_edit/src/item.rs <item::Item as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<item::Item as std::fmt::Debug>::fmt(p0, p1);
+crate::<item::Item as std::fmt::Debug>::fmt(p0, p1);
+<item::Item>::fmt(p0, p1);
-----------------
crates/toml_edit/src/item.rs <item::Item as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.clone();
+<item::Item as std::clone::Clone>::clone(p0);
+crate::<item::Item as std::clone::Clone>::clone(p0);
+<item::Item>::clone(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::or_insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.or_insert(p1);
+item::Item::or_insert(p0, p1);
+crate::item::Item::or_insert(p0, p1);
+<item::Item>::or_insert(p0, p1);
-----------------
crates/toml_edit/src/item.rs item::Item::type_name
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.type_name();
+item::Item::type_name(p0);
+crate::item::Item::type_name(p0);
+<item::Item>::type_name(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::get
deps:{"<&'a T as index::Index>":{},"item::Item::get":{"I":["index::Index","std::marker::Sized"]}}
candidates:{"<&'a T as index::Index>":{},"item::Item::get":{"I":["std::string::String","<&'a T as index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.get(p1);
+item::Item::get(p0, p1);
+crate::item::Item::get(p0, p1);
+<item::Item>::get(p0, p1);
-----------------
crates/toml_edit/src/item.rs item::Item::get_mut
deps:{"<&'a T as index::Index>":{},"item::Item::get_mut":{"I":["index::Index","std::marker::Sized"]}}
candidates:{"<&'a T as index::Index>":{},"item::Item::get_mut":{"I":["<&'a T as index::Index>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.get_mut(p1);
+item::Item::get_mut(p0, p1);
+crate::item::Item::get_mut(p0, p1);
+<item::Item>::get_mut(p0, p1);
-----------------
crates/toml_edit/src/item.rs item::Item::as_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_value();
+item::Item::as_value(p0);
+crate::item::Item::as_value(p0);
+<item::Item>::as_value(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_table();
+item::Item::as_table(p0);
+crate::item::Item::as_table(p0);
+<item::Item>::as_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_array_of_tables
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_array_of_tables();
+item::Item::as_array_of_tables(p0);
+crate::item::Item::as_array_of_tables(p0);
+<item::Item>::as_array_of_tables(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_value_mut();
+item::Item::as_value_mut(p0);
+crate::item::Item::as_value_mut(p0);
+<item::Item>::as_value_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_table_mut();
+item::Item::as_table_mut(p0);
+crate::item::Item::as_table_mut(p0);
+<item::Item>::as_table_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_array_of_tables_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_array_of_tables_mut();
+item::Item::as_array_of_tables_mut(p0);
+crate::item::Item::as_array_of_tables_mut(p0);
+<item::Item>::as_array_of_tables_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::into_value
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.into_value();
+item::Item::into_value(p0);
+crate::item::Item::into_value(p0);
+<item::Item>::into_value(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::make_value
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.make_value();
+item::Item::make_value(p0);
+crate::item::Item::make_value(p0);
+<item::Item>::make_value(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::into_table
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.into_table();
+item::Item::into_table(p0);
+crate::item::Item::into_table(p0);
+<item::Item>::into_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::into_array_of_tables
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.into_array_of_tables();
+item::Item::into_array_of_tables(p0);
+crate::item::Item::into_array_of_tables(p0);
+<item::Item>::into_array_of_tables(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::make_item
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.make_item();
+item::Item::make_item(p0);
+crate::item::Item::make_item(p0);
+<item::Item>::make_item(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_value();
+item::Item::is_value(p0);
+crate::item::Item::is_value(p0);
+<item::Item>::is_value(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_table();
+item::Item::is_table(p0);
+crate::item::Item::is_table(p0);
+<item::Item>::is_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_array_of_tables
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_array_of_tables();
+item::Item::is_array_of_tables(p0);
+crate::item::Item::is_array_of_tables(p0);
+<item::Item>::is_array_of_tables(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_none
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_none();
+item::Item::is_none(p0);
+crate::item::Item::is_none(p0);
+<item::Item>::is_none(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_integer();
+item::Item::as_integer(p0);
+crate::item::Item::as_integer(p0);
+<item::Item>::as_integer(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_integer();
+item::Item::is_integer(p0);
+crate::item::Item::is_integer(p0);
+<item::Item>::is_integer(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_float();
+item::Item::as_float(p0);
+crate::item::Item::as_float(p0);
+<item::Item>::as_float(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_float();
+item::Item::is_float(p0);
+crate::item::Item::is_float(p0);
+<item::Item>::is_float(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_bool();
+item::Item::as_bool(p0);
+crate::item::Item::as_bool(p0);
+<item::Item>::as_bool(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_bool();
+item::Item::is_bool(p0);
+crate::item::Item::is_bool(p0);
+<item::Item>::is_bool(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_str();
+item::Item::as_str(p0);
+crate::item::Item::as_str(p0);
+<item::Item>::as_str(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_str();
+item::Item::is_str(p0);
+crate::item::Item::is_str(p0);
+<item::Item>::is_str(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_datetime();
+item::Item::as_datetime(p0);
+crate::item::Item::as_datetime(p0);
+<item::Item>::as_datetime(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_datetime();
+item::Item::is_datetime(p0);
+crate::item::Item::is_datetime(p0);
+<item::Item>::is_datetime(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_array();
+item::Item::as_array(p0);
+crate::item::Item::as_array(p0);
+<item::Item>::as_array(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_array_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_array_mut();
+item::Item::as_array_mut(p0);
+crate::item::Item::as_array_mut(p0);
+<item::Item>::as_array_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_array();
+item::Item::is_array(p0);
+crate::item::Item::is_array(p0);
+<item::Item>::is_array(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_inline_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_inline_table();
+item::Item::as_inline_table(p0);
+crate::item::Item::as_inline_table(p0);
+<item::Item>::as_inline_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_inline_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_inline_table_mut();
+item::Item::as_inline_table_mut(p0);
+crate::item::Item::as_inline_table_mut(p0);
+<item::Item>::as_inline_table_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_inline_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_inline_table();
+item::Item::is_inline_table(p0);
+crate::item::Item::is_inline_table(p0);
+<item::Item>::is_inline_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_table_like
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_table_like();
+item::Item::as_table_like(p0);
+crate::item::Item::as_table_like(p0);
+<item::Item>::as_table_like(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_table_like_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_table_like_mut();
+item::Item::as_table_like_mut(p0);
+crate::item::Item::as_table_like_mut(p0);
+<item::Item>::as_table_like_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_table_like
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_table_like();
+item::Item::is_table_like(p0);
+crate::item::Item::is_table_like(p0);
+<item::Item>::is_table_like(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.span();
+item::Item::span(p0);
+crate::item::Item::span(p0);
+<item::Item>::span(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+item::Item::despan(p0, &p1);
+crate::item::Item::despan(p0, &p1);
+<item::Item>::despan(p0, &p1);
-----------------
crates/toml_edit/src/item.rs <item::Item as std::default::Default>::default
deps:{}
candidates:{}
+<item::Item as std::default::Default>::default();
+crate::<item::Item as std::default::Default>::default();
+<item::Item>::default();
-----------------
crates/toml_edit/src/item.rs <item::Item as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<item::Item as std::str::FromStr>::from_str(&p0);
+crate::<item::Item as std::str::FromStr>::from_str(&p0);
+<item::Item>::from_str(&p0);
-----------------
crates/toml_edit/src/item.rs <item::Item as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<item::Item as std::fmt::Display>::fmt(p0, p1);
+crate::<item::Item as std::fmt::Display>::fmt(p0, p1);
+<item::Item>::fmt(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<key::Key as std::fmt::Debug>::fmt(p0, p1);
+crate::<key::Key as std::fmt::Debug>::fmt(p0, p1);
+<key::Key>::fmt(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.clone();
+<key::Key as std::clone::Clone>::clone(p0);
+crate::<key::Key as std::clone::Clone>::clone(p0);
+<key::Key>::clone(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::new
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"key::Key::new":{"impl Into<InternalString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"key::Key::new":{"impl Into<InternalString>":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl Into<InternalString>
+key::Key::new(p0);
+crate::key::Key::new(p0);
+<key::Key>::new(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::parse
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+key::Key::parse(&p0);
+crate::key::Key::parse(&p0);
+<key::Key>::parse(&p0);
-----------------
crates/toml_edit/src/key.rs key::Key::with_repr_unchecked
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.with_repr_unchecked(p1);
+key::Key::with_repr_unchecked(p0, p1);
+crate::key::Key::with_repr_unchecked(p0, p1);
+<key::Key>::with_repr_unchecked(p0, p1);
-----------------
crates/toml_edit/src/key.rs key::Key::with_decor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.with_decor(p1);
+key::Key::with_decor(p0, p1);
+crate::key::Key::with_decor(p0, p1);
+<key::Key>::with_decor(p0, p1);
-----------------
crates/toml_edit/src/key.rs key::Key::as_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::Key
+p0.as_mut();
+key::Key::as_mut(p0);
+crate::key::Key::as_mut(p0);
+<key::Key>::as_mut(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.get();
+key::Key::get(p0);
+crate::key::Key::get(p0);
+<key::Key>::get(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::get_internal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.get_internal();
+key::Key::get_internal(p0);
+crate::key::Key::get_internal(p0);
+<key::Key>::get_internal(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::as_repr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.as_repr();
+key::Key::as_repr(p0);
+crate::key::Key::as_repr(p0);
+<key::Key>::as_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::default_repr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.default_repr();
+key::Key::default_repr(p0);
+crate::key::Key::default_repr(p0);
+<key::Key>::default_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::display_repr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.display_repr();
+key::Key::display_repr(p0);
+crate::key::Key::display_repr(p0);
+<key::Key>::display_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::Key
+p0.decor_mut();
+key::Key::decor_mut(p0);
+crate::key::Key::decor_mut(p0);
+<key::Key>::decor_mut(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.decor();
+key::Key::decor(p0);
+crate::key::Key::decor(p0);
+<key::Key>::decor(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.span();
+key::Key::span(p0);
+crate::key::Key::span(p0);
+<key::Key>::span(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+key::Key::despan(p0, &p1);
+crate::key::Key::despan(p0, &p1);
+<key::Key>::despan(p0, &p1);
-----------------
crates/toml_edit/src/key.rs key::Key::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::Key
+p0.fmt();
+key::Key::fmt(p0);
+crate::key::Key::fmt(p0);
+<key::Key>::fmt(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::try_parse_simple
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+key::Key::try_parse_simple(&p0);
+crate::key::Key::try_parse_simple(&p0);
+<key::Key>::try_parse_simple(&p0);
-----------------
crates/toml_edit/src/key.rs key::Key::try_parse_path
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+key::Key::try_parse_path(&p0);
+crate::key::Key::try_parse_path(&p0);
+<key::Key>::try_parse_path(&p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.deref();
+<key::Key as std::ops::Deref>::deref(p0);
+crate::<key::Key as std::ops::Deref>::deref(p0);
+<key::Key>::deref(p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<key::Key as std::hash::Hash>::hash":{"H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<key::Key as std::hash::Hash>::hash":{"H":["std::hash::sip::Hasher<S>","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<key::Key as std::hash::Hash>::hash(p0, p1);
+crate::<key::Key as std::hash::Hash>::hash(p0, p1);
+<key::Key>::hash(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.cmp(p1);
+<key::Key as std::cmp::Ord>::cmp(p0, p1);
+crate::<key::Key as std::cmp::Ord>::cmp(p0, p1);
+<key::Key>::cmp(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.partial_cmp(p1);
+<key::Key as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<key::Key as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<key::Key>::partial_cmp(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.eq(p1);
+<key::Key as std::cmp::PartialEq>::eq(p0, p1);
+crate::<key::Key as std::cmp::PartialEq>::eq(p0, p1);
+<key::Key>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<key::Key as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<key::Key as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<key::Key>::eq(p0, &p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialEq<&'s str>>::eq
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & "a"; // None+&str
+p0.eq(p1);
+<key::Key as std::cmp::PartialEq<&'s str>>::eq(p0, p1);
+crate::<key::Key as std::cmp::PartialEq<&'s str>>::eq(p0, p1);
+<key::Key>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialEq<std::string::String>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.eq(p1);
+<key::Key as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+crate::<key::Key as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+<key::Key>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<key::Key as std::fmt::Display>::fmt(p0, p1);
+crate::<key::Key as std::fmt::Display>::fmt(p0, p1);
+<key::Key>::fmt(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<key::Key as std::str::FromStr>::from_str(&p0);
+crate::<key::Key as std::str::FromStr>::from_str(&p0);
+<key::Key>::from_str(&p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::convert::From<&'b str>>::from
'b
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<key::Key as std::convert::From<&'b str>>::from(&p0);
+crate::<key::Key as std::convert::From<&'b str>>::from(&p0);
+<key::Key>::from(&p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::convert::From<&'b std::string::String>>::from
'b
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<key::Key as std::convert::From<&'b std::string::String>>::from(p0);
+crate::<key::Key as std::convert::From<&'b std::string::String>>::from(p0);
+<key::Key>::from(p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<key::Key as std::convert::From<std::string::String>>::from(p0);
+crate::<key::Key as std::convert::From<std::string::String>>::from(p0);
+<key::Key>::from(p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::convert::From<internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<key::Key as std::convert::From<internal_string::InternalString>>::from(p0);
+crate::<key::Key as std::convert::From<internal_string::InternalString>>::from(p0);
+<key::Key>::from(p0);
-----------------
crates/toml_edit/src/key.rs key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // key::Key
+key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from(p0);
+crate::key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::fmt::Debug>::fmt
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<key::KeyMut<'k> as std::fmt::Debug>::fmt(p0, p1);
+crate::<key::KeyMut<'k> as std::fmt::Debug>::fmt(p0, p1);
+<key::KeyMut<'k>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::cmp::Eq>::assert_receiver_is_total_eq
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.assert_receiver_is_total_eq();
+<key::KeyMut<'k> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<key::KeyMut<'k> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<key::KeyMut<'k>>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::cmp::PartialEq>::eq
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.eq(p1);
+<key::KeyMut<'k> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<key::KeyMut<'k> as std::cmp::PartialEq>::eq(p0, p1);
+<key::KeyMut<'k>>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::cmp::PartialOrd>::partial_cmp
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.partial_cmp(p1);
+<key::KeyMut<'k> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<key::KeyMut<'k> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<key::KeyMut<'k>>::partial_cmp(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::cmp::Ord>::cmp
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.cmp(p1);
+<key::KeyMut<'k> as std::cmp::Ord>::cmp(p0, p1);
+crate::<key::KeyMut<'k> as std::cmp::Ord>::cmp(p0, p1);
+<key::KeyMut<'k>>::cmp(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::hash::Hash>::hash
'k
deps:{"<&mut H as std::hash::Hasher>":{},"<key::KeyMut<'k> as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<key::KeyMut<'k> as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<key::KeyMut<'k> as std::hash::Hash>::hash(p0, p1);
+crate::<key::KeyMut<'k> as std::hash::Hash>::hash(p0, p1);
+<key::KeyMut<'k>>::hash(p0, p1);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::get
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.get();
+key::KeyMut::<'k>::get(p0);
+crate::key::KeyMut::<'k>::get(p0);
+<key::KeyMut<'k>>::get(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::as_repr
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.as_repr();
+key::KeyMut::<'k>::as_repr(p0);
+crate::key::KeyMut::<'k>::as_repr(p0);
+<key::KeyMut<'k>>::as_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::default_repr
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.default_repr();
+key::KeyMut::<'k>::default_repr(p0);
+crate::key::KeyMut::<'k>::default_repr(p0);
+<key::KeyMut<'k>>::default_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::display_repr
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.display_repr();
+key::KeyMut::<'k>::display_repr(p0);
+crate::key::KeyMut::<'k>::display_repr(p0);
+<key::KeyMut<'k>>::display_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::decor_mut
'k
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.decor_mut();
+key::KeyMut::<'k>::decor_mut(p0);
+crate::key::KeyMut::<'k>::decor_mut(p0);
+<key::KeyMut<'k>>::decor_mut(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::decor
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.decor();
+key::KeyMut::<'k>::decor(p0);
+crate::key::KeyMut::<'k>::decor(p0);
+<key::KeyMut<'k>>::decor(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::fmt
'k
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.fmt();
+key::KeyMut::<'k>::fmt(p0);
+crate::key::KeyMut::<'k>::fmt(p0);
+<key::KeyMut<'k>>::fmt(p0);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::ops::Deref>::deref
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.deref();
+<key::KeyMut<'k> as std::ops::Deref>::deref(p0);
+crate::<key::KeyMut<'k> as std::ops::Deref>::deref(p0);
+<key::KeyMut<'k>>::deref(p0);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'s>
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<key::KeyMut<'s>>::eq(p0, &p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'s>
let mut p1 = & "a"; // None+&str
+p0.eq(p1);
+<key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq(p0, p1);
+crate::<key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq(p0, p1);
+<key::KeyMut<'s>>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'s>
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.eq(p1);
+<key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+crate::<key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+<key::KeyMut<'s>>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::fmt::Display>::fmt
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<key::KeyMut<'k> as std::fmt::Display>::fmt(p0, p1);
+crate::<key::KeyMut<'k> as std::fmt::Display>::fmt(p0, p1);
+<key::KeyMut<'k>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::TomlError as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::TomlError as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::TomlError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.clone();
+<parser::errors::TomlError as std::clone::Clone>::clone(p0);
+crate::<parser::errors::TomlError as std::clone::Clone>::clone(p0);
+<parser::errors::TomlError>::clone(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.assert_receiver_is_total_eq();
+<parser::errors::TomlError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<parser::errors::TomlError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<parser::errors::TomlError>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.eq(p1);
+<parser::errors::TomlError as std::cmp::PartialEq>::eq(p0, p1);
+crate::<parser::errors::TomlError as std::cmp::PartialEq>::eq(p0, p1);
+<parser::errors::TomlError>::eq(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<parser::errors::TomlError as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<parser::errors::TomlError as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<parser::errors::TomlError as std::hash::Hash>::hash(p0, p1);
+crate::<parser::errors::TomlError as std::hash::Hash>::hash(p0, p1);
+<parser::errors::TomlError>::hash(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'_>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::errors::TomlError::new(p0, p1);
+crate::parser::errors::TomlError::new(p0, p1);
+<parser::errors::TomlError>::new(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::custom
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::ops::Range<usize>>
+parser::errors::TomlError::custom(p0, p1);
+crate::parser::errors::TomlError::custom(p0, p1);
+<parser::errors::TomlError>::custom(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::add_key
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = std::string::String::new(); // None+std::string::String
+p0.add_key(p1);
+parser::errors::TomlError::add_key(p0, p1);
+crate::parser::errors::TomlError::add_key(p0, p1);
+<parser::errors::TomlError>::add_key(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::message
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.message();
+parser::errors::TomlError::message(p0);
+crate::parser::errors::TomlError::message(p0);
+<parser::errors::TomlError>::message(p0);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.span();
+parser::errors::TomlError::span(p0);
+crate::parser::errors::TomlError::span(p0);
+<parser::errors::TomlError>::span(p0);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::set_span
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::ops::Range<usize>>
+p0.set_span(p1);
+parser::errors::TomlError::set_span(p0, p1);
+crate::parser::errors::TomlError::set_span(p0, p1);
+<parser::errors::TomlError>::set_span(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::set_original
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = std::string::String::new(); // None+std::option::Option<std::string::String>
+p0.set_original(p1);
+parser::errors::TomlError::set_original(p0, p1);
+crate::parser::errors::TomlError::set_original(p0, p1);
+<parser::errors::TomlError>::set_original(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<parser::errors::TomlError as std::fmt::Display>::fmt(p0, p1);
+crate::<parser::errors::TomlError as std::fmt::Display>::fmt(p0, p1);
+<parser::errors::TomlError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.description();
+<parser::errors::TomlError as std::error::Error>::description(p0);
+crate::<parser::errors::TomlError as std::error::Error>::description(p0);
+<parser::errors::TomlError>::description(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as std::fmt::Debug>::fmt
'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::ParserError<'b> as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::ParserError<'b> as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::ParserError<'b>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&'b winnow::BStr>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
+<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind(p0, p1);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind(p0, p1);
+<parser::errors::ParserError<'b>>::from_error_kind(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::Located<&'b winnow::BStr>
let mut p2 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
+p0.append(p1, p2);
+<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append(p0, p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append(p0, p1, p2);
+<parser::errors::ParserError<'b>>::append(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
+p0.or(p1);
+<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or(p0, p1);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or(p0, p1);
+<parser::errors::ParserError<'b>>::or(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind
'b
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
+<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind(&p0, p1);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind(&p0, p1);
+<parser::errors::ParserError<'b>>::from_error_kind(&p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
+p0.append(&p1, p2);
+<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append(p0, &p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append(p0, &p1, p2);
+<parser::errors::ParserError<'b>>::append(p0, &p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
+p0.or(p1);
+<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or(p0, p1);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or(p0, p1);
+<parser::errors::ParserError<'b>>::or(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::Located<&'b winnow::BStr>
let mut p2 = MaybeUninit::uninit().assume_init(); // parser::errors::Context
+p0.add_context(p1, p2);
+<parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context(p0, p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context(p0, p1, p2);
+<parser::errors::ParserError<'b>>::add_context(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error
'b
deps:{"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error":{"E":["std::error::Error","std::marker::Sync","std::marker::Sized","std::marker::Send"]}}
candidates:{"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error":{"E":["std::sync::Arc<T>","std::boxed::ThinBox<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&'b winnow::BStr>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error(p0, p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error(p0, p1, p2);
+<parser::errors::ParserError<'b>>::from_external_error(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error
'b
deps:{"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error":{"E":["std::marker::Sync","std::error::Error","std::marker::Send","std::marker::Sized"]}}
candidates:{"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error":{"E":["std::sync::Arc<T>","std::boxed::ThinBox<T>"]}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error(&p0, p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error(&p0, p1, p2);
+<parser::errors::ParserError<'b>>::from_external_error(&p0, p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq
'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
+p0.eq(p1);
+<parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq(p0, p1);
+<parser::errors::ParserError<'b>>::eq(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'a> as std::fmt::Display>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<parser::errors::ParserError<'a> as std::fmt::Display>::fmt(p0, p1);
+crate::<parser::errors::ParserError<'a> as std::fmt::Display>::fmt(p0, p1);
+<parser::errors::ParserError<'a>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::Context as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::Context
+p0.clone();
+<parser::errors::Context as std::clone::Clone>::clone(p0);
+crate::<parser::errors::Context as std::clone::Clone>::clone(p0);
+<parser::errors::Context>::clone(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::Context as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::Context
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::Context as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::Context as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::Context>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::Context as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::Context
let mut p1 = & MaybeUninit::uninit().assume_init(); // parser::errors::Context
+p0.eq(p1);
+<parser::errors::Context as std::cmp::PartialEq>::eq(p0, p1);
+crate::<parser::errors::Context as std::cmp::PartialEq>::eq(p0, p1);
+<parser::errors::Context>::eq(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserValue as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
+p0.clone();
+<parser::errors::ParserValue as std::clone::Clone>::clone(p0);
+crate::<parser::errors::ParserValue as std::clone::Clone>::clone(p0);
+<parser::errors::ParserValue>::clone(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserValue as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::ParserValue as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::ParserValue as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::ParserValue>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserValue as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
let mut p1 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
+p0.eq(p1);
+<parser::errors::ParserValue as std::cmp::PartialEq>::eq(p0, p1);
+crate::<parser::errors::ParserValue as std::cmp::PartialEq>::eq(p0, p1);
+<parser::errors::ParserValue>::eq(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserValue as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<parser::errors::ParserValue as std::fmt::Display>::fmt(p0, p1);
+crate::<parser::errors::ParserValue as std::fmt::Display>::fmt(p0, p1);
+<parser::errors::ParserValue>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::CustomError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::CustomError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::CustomError as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::CustomError as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::CustomError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::CustomError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::CustomError
+p0.clone();
+<parser::errors::CustomError as std::clone::Clone>::clone(p0);
+crate::<parser::errors::CustomError as std::clone::Clone>::clone(p0);
+<parser::errors::CustomError>::clone(p0);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::CustomError::duplicate_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p1 = 0usize; // None+usize
+parser::errors::CustomError::duplicate_key(p0, p1);
+crate::parser::errors::CustomError::duplicate_key(p0, p1);
+<parser::errors::CustomError>::duplicate_key(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::CustomError::extend_wrong_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p1 = 0usize; // None+usize
let mut p2 = "sample"; // None+&str
+parser::errors::CustomError::extend_wrong_type(p0, p1, &p2);
+crate::parser::errors::CustomError::extend_wrong_type(p0, p1, &p2);
+<parser::errors::CustomError>::extend_wrong_type(p0, p1, &p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::CustomError as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::CustomError
+p0.description();
+<parser::errors::CustomError as std::error::Error>::description(p0);
+crate::<parser::errors::CustomError as std::error::Error>::description(p0);
+<parser::errors::CustomError>::description(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::CustomError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::CustomError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<parser::errors::CustomError as std::fmt::Display>::fmt(p0, p1);
+crate::<parser::errors::CustomError as std::fmt::Display>::fmt(p0, p1);
+<parser::errors::CustomError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::into_document
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::state::ParseState
+p0.into_document();
+parser::state::ParseState::into_document(p0);
+crate::parser::state::ParseState::into_document(p0);
+<parser::state::ParseState>::into_document(p0);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_ws
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.on_ws(p1);
+parser::state::ParseState::on_ws(p0, p1);
+crate::parser::state::ParseState::on_ws(p0, p1);
+<parser::state::ParseState>::on_ws(p0, p1);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_comment
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.on_comment(p1);
+parser::state::ParseState::on_comment(p0, p1);
+crate::parser::state::ParseState::on_comment(p0, p1);
+<parser::state::ParseState>::on_comment(p0, p1);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_keyval
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // table::TableKeyValue
+p0.on_keyval(p1, p2);
+parser::state::ParseState::on_keyval(p0, p1, p2);
+crate::parser::state::ParseState::on_keyval(p0, p1, p2);
+<parser::state::ParseState>::on_keyval(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::start_aray_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p3 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.start_aray_table(p1, p2, p3);
+parser::state::ParseState::start_aray_table(p0, p1, p2, p3);
+crate::parser::state::ParseState::start_aray_table(p0, p1, p2, p3);
+<parser::state::ParseState>::start_aray_table(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::start_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p3 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.start_table(p1, p2, p3);
+parser::state::ParseState::start_table(p0, p1, p2, p3);
+crate::parser::state::ParseState::start_table(p0, p1, p2, p3);
+<parser::state::ParseState>::start_table(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::finalize_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
+p0.finalize_table();
+parser::state::ParseState::finalize_table(p0);
+crate::parser::state::ParseState::finalize_table(p0);
+<parser::state::ParseState>::finalize_table(p0);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::descend_path
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p2 = true; // None+bool
+parser::state::ParseState::descend_path(p0, p1, p2);
+crate::parser::state::ParseState::descend_path(p0, p1, p2);
+<parser::state::ParseState>::descend_path(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_std_header
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
let mut p3 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.on_std_header(p1, p2, p3);
+parser::state::ParseState::on_std_header(p0, p1, p2, p3);
+crate::parser::state::ParseState::on_std_header(p0, p1, p2, p3);
+<parser::state::ParseState>::on_std_header(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_array_header
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
let mut p3 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.on_array_header(p1, p2, p3);
+parser::state::ParseState::on_array_header(p0, p1, p2, p3);
+crate::parser::state::ParseState::on_array_header(p0, p1, p2, p3);
+<parser::state::ParseState>::on_array_header(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/parser/state.rs <parser::state::ParseState as std::default::Default>::default
deps:{}
candidates:{}
+<parser::state::ParseState as std::default::Default>::default();
+crate::<parser::state::ParseState as std::default::Default>::default();
+<parser::state::ParseState>::default();
-----------------
crates/toml_edit/src/parser/mod.rs <parser::prelude::RecursionCheck as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+p0.clone();
+<parser::prelude::RecursionCheck as std::clone::Clone>::clone(p0);
+crate::<parser::prelude::RecursionCheck as std::clone::Clone>::clone(p0);
+<parser::prelude::RecursionCheck>::clone(p0);
-----------------
crates/toml_edit/src/parser/mod.rs <parser::prelude::RecursionCheck as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::prelude::RecursionCheck as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::prelude::RecursionCheck as std::fmt::Debug>::fmt(p0, p1);
+<parser::prelude::RecursionCheck>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/mod.rs <parser::prelude::RecursionCheck as std::default::Default>::default
deps:{}
candidates:{}
+<parser::prelude::RecursionCheck as std::default::Default>::default();
+crate::<parser::prelude::RecursionCheck as std::default::Default>::default();
+<parser::prelude::RecursionCheck>::default();
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::RecursionCheck::check_depth
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+parser::prelude::RecursionCheck::check_depth(p0);
+crate::parser::prelude::RecursionCheck::check_depth(p0);
+<parser::prelude::RecursionCheck>::check_depth(p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::RecursionCheck::recursing
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+p0.recursing(p1);
+parser::prelude::RecursionCheck::recursing(p0, p1);
+crate::parser::prelude::RecursionCheck::recursing(p0, p1);
+<parser::prelude::RecursionCheck>::recursing(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.eq(p1);
+<raw_string::RawString as std::cmp::PartialEq>::eq(p0, p1);
+crate::<raw_string::RawString as std::cmp::PartialEq>::eq(p0, p1);
+<raw_string::RawString>::eq(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.assert_receiver_is_total_eq();
+<raw_string::RawString as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<raw_string::RawString as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<raw_string::RawString>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.clone();
+<raw_string::RawString as std::clone::Clone>::clone(p0);
+crate::<raw_string::RawString as std::clone::Clone>::clone(p0);
+<raw_string::RawString>::clone(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<raw_string::RawString as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<raw_string::RawString as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::hash::SipHasher13","std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<raw_string::RawString as std::hash::Hash>::hash(p0, p1);
+crate::<raw_string::RawString as std::hash::Hash>::hash(p0, p1);
+<raw_string::RawString>::hash(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawStringInner as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
let mut p1 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
+p0.eq(p1);
+<raw_string::RawStringInner as std::cmp::PartialEq>::eq(p0, p1);
+crate::<raw_string::RawStringInner as std::cmp::PartialEq>::eq(p0, p1);
+<raw_string::RawStringInner>::eq(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawStringInner as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
+p0.assert_receiver_is_total_eq();
+<raw_string::RawStringInner as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<raw_string::RawStringInner as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<raw_string::RawStringInner>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawStringInner as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
+p0.clone();
+<raw_string::RawStringInner as std::clone::Clone>::clone(p0);
+crate::<raw_string::RawStringInner as std::clone::Clone>::clone(p0);
+<raw_string::RawStringInner>::clone(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawStringInner as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<raw_string::RawStringInner as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<raw_string::RawStringInner as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::hash::SipHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<raw_string::RawStringInner as std::hash::Hash>::hash(p0, p1);
+crate::<raw_string::RawStringInner as std::hash::Hash>::hash(p0, p1);
+<raw_string::RawStringInner>::hash(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::with_span
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+raw_string::RawString::with_span(p0);
+crate::raw_string::RawString::with_span(p0);
+<raw_string::RawString>::with_span(p0);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.as_str();
+raw_string::RawString::as_str(p0);
+crate::raw_string::RawString::as_str(p0);
+<raw_string::RawString>::as_str(p0);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::to_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = "sample"; // None+&str
+p0.to_str(&p1);
+raw_string::RawString::to_str(p0, &p1);
+crate::raw_string::RawString::to_str(p0, &p1);
+<raw_string::RawString>::to_str(p0, &p1);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::to_str_with_default
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&'s str>
let mut p2 = "sample"; // None+&str
+p0.to_str_with_default(p1, &p2);
+raw_string::RawString::to_str_with_default(p0, p1, &p2);
+crate::raw_string::RawString::to_str_with_default(p0, p1, &p2);
+<raw_string::RawString>::to_str_with_default(p0, p1, &p2);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.span();
+raw_string::RawString::span(p0);
+crate::raw_string::RawString::span(p0);
+<raw_string::RawString>::span(p0);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+raw_string::RawString::despan(p0, &p1);
+crate::raw_string::RawString::despan(p0, &p1);
+<raw_string::RawString>::despan(p0, &p1);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = "sample"; // None+&str
+p0.encode(p1, &p2);
+raw_string::RawString::encode(p0, p1, &p2);
+crate::raw_string::RawString::encode(p0, p1, &p2);
+<raw_string::RawString>::encode(p0, p1, &p2);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::encode_with_default
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = "sample"; // None+&str
+p0.encode_with_default(p1, p2, &p3);
+raw_string::RawString::encode_with_default(p0, p1, p2, &p3);
+crate::raw_string::RawString::encode_with_default(p0, p1, p2, &p3);
+<raw_string::RawString>::encode_with_default(p0, p1, p2, &p3);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::default::Default>::default
deps:{}
candidates:{}
+<raw_string::RawString as std::default::Default>::default();
+crate::<raw_string::RawString as std::default::Default>::default();
+<raw_string::RawString>::default();
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<raw_string::RawString as std::fmt::Debug>::fmt(p0, p1);
+crate::<raw_string::RawString as std::fmt::Debug>::fmt(p0, p1);
+<raw_string::RawString>::fmt(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<&str>>::from
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<raw_string::RawString as std::convert::From<&str>>::from(&p0);
+crate::<raw_string::RawString as std::convert::From<&str>>::from(&p0);
+<raw_string::RawString>::from(&p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<raw_string::RawString as std::convert::From<std::string::String>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<std::string::String>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<&std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<raw_string::RawString as std::convert::From<&std::string::String>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<&std::string::String>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<raw_string::RawString as std::convert::From<internal_string::InternalString>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<internal_string::InternalString>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::boxed::Box<str>
+<raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["std::cmp::Eq","std::marker::Sized"]},"repr::Formatted":{"T":["std::clone::Clone","std::marker::Sized","std::hash::Hash","std::cmp::PartialEq","std::fmt::Debug","repr::ValueRepr","std::cmp::Eq"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["parser::errors::TomlError","repr::Decor","de::Error","key::Key","ser::Error","repr::Repr","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","raw_string::RawString","repr::Formatted","raw_string::RawStringInner","key::KeyMut","internal_string::InternalString","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","encode::StringStyle"]},"repr::Formatted":{"T":["bool","i64"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.assert_receiver_is_total_eq();
+<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<repr::Formatted<T>>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::cmp::PartialEq>::eq
deps:{"<repr::Formatted<T> as std::cmp::PartialEq>::eq":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"repr::Formatted":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","repr::ValueRepr","std::clone::Clone","std::cmp::PartialEq","std::hash::Hash"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<repr::Formatted<T> as std::cmp::PartialEq>::eq":{"T":["repr::Formatted","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","parser::errors::ParserError","key::KeyMut","internal_string::InternalString","repr::Repr","de::Error","ser::Error","repr::Decor","parser::errors::ParserValue","raw_string::RawString","parser::errors::TomlError","parser::errors::Context","encode::StringStyle","raw_string::RawStringInner"]},"repr::Formatted":{"T":["i64","bool"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.eq(p1);
+<repr::Formatted<T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<repr::Formatted<T> as std::cmp::PartialEq>::eq(p0, p1);
+<repr::Formatted<T>>::eq(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::clone::Clone>::clone
deps:{"<repr::Formatted<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"repr::Formatted":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","repr::ValueRepr","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<repr::Formatted<T> as std::clone::Clone>::clone":{"T":["repr::Decor","document::Document","table::Table","repr::Formatted","raw_string::RawStringInner","value::Value","array_of_tables::ArrayOfTables","std::clone::impls::<impl std::clone::Clone for *mut T>","repr::Repr","parser::errors::Context","array::Array","parser::errors::ParserValue","parser::errors::TomlError","ser::Error","internal_string::InternalString","raw_string::RawString","item::Item","parser::errors::CustomError","key::Key","de::Error","parser::prelude::RecursionCheck","encode::StringStyle","std::clone::impls::<impl std::clone::Clone for &T>","table::TableKeyValue","inline_table::InlineTable"]},"repr::Formatted":{"T":["i64","bool"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.clone();
+<repr::Formatted<T> as std::clone::Clone>::clone(p0);
+crate::<repr::Formatted<T> as std::clone::Clone>::clone(p0);
+<repr::Formatted<T>>::clone(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<repr::Formatted<T> as std::hash::Hash>::hash":{"T":["std::marker::Sized","std::hash::Hash"],"__H":["std::marker::Sized","std::hash::Hasher"]},"repr::Formatted":{"T":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","repr::ValueRepr","std::hash::Hash","std::cmp::Eq"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<repr::Formatted<T> as std::hash::Hash>::hash":{"T":["raw_string::RawStringInner","raw_string::RawString","key::Key","std::hash::impls::<impl std::hash::Hash for *mut T>","key::KeyMut","repr::Decor","parser::errors::TomlError","repr::Repr","repr::Formatted","internal_string::InternalString","std::hash::impls::<impl std::hash::Hash for *const T>"],"__H":["std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher"]},"repr::Formatted":{"T":["i64","bool"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<repr::Formatted<T> as std::hash::Hash>::hash(p0, p1);
+crate::<repr::Formatted<T> as std::hash::Hash>::hash(p0, p1);
+<repr::Formatted<T>>::hash(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::new
deps:{"repr::Formatted::<T>::new":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::new":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+repr::Formatted::<T>::new(p0);
+crate::repr::Formatted::<T>::new(p0);
+<repr::Formatted<T>>::new(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::set_repr_unchecked
deps:{"repr::Formatted::<T>::set_repr_unchecked":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::set_repr_unchecked":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.set_repr_unchecked(p1);
+repr::Formatted::<T>::set_repr_unchecked(p0, p1);
+crate::repr::Formatted::<T>::set_repr_unchecked(p0, p1);
+<repr::Formatted<T>>::set_repr_unchecked(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::value
deps:{"repr::Formatted::<T>::value":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::value":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.value();
+repr::Formatted::<T>::value(p0);
+crate::repr::Formatted::<T>::value(p0);
+<repr::Formatted<T>>::value(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::into_value
deps:{"repr::Formatted::<T>::into_value":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::into_value":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.into_value();
+repr::Formatted::<T>::into_value(p0);
+crate::repr::Formatted::<T>::into_value(p0);
+<repr::Formatted<T>>::into_value(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::as_repr
deps:{"repr::Formatted::<T>::as_repr":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::as_repr":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.as_repr();
+repr::Formatted::<T>::as_repr(p0);
+crate::repr::Formatted::<T>::as_repr(p0);
+<repr::Formatted<T>>::as_repr(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::default_repr
deps:{"repr::Formatted::<T>::default_repr":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::default_repr":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.default_repr();
+repr::Formatted::<T>::default_repr(p0);
+crate::repr::Formatted::<T>::default_repr(p0);
+<repr::Formatted<T>>::default_repr(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::display_repr
deps:{"repr::Formatted::<T>::display_repr":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::display_repr":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.display_repr();
+repr::Formatted::<T>::display_repr(p0);
+crate::repr::Formatted::<T>::display_repr(p0);
+<repr::Formatted<T>>::display_repr(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::span
deps:{"repr::Formatted::<T>::span":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::span":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.span();
+repr::Formatted::<T>::span(p0);
+crate::repr::Formatted::<T>::span(p0);
+<repr::Formatted<T>>::span(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::despan
deps:{"repr::Formatted::<T>::despan":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::despan":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+repr::Formatted::<T>::despan(p0, &p1);
+crate::repr::Formatted::<T>::despan(p0, &p1);
+<repr::Formatted<T>>::despan(p0, &p1);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::decor_mut
deps:{"repr::Formatted::<T>::decor_mut":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::decor_mut":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.decor_mut();
+repr::Formatted::<T>::decor_mut(p0);
+crate::repr::Formatted::<T>::decor_mut(p0);
+<repr::Formatted<T>>::decor_mut(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::decor
deps:{"repr::Formatted::<T>::decor":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::decor":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.decor();
+repr::Formatted::<T>::decor(p0);
+crate::repr::Formatted::<T>::decor(p0);
+<repr::Formatted<T>>::decor(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::fmt
deps:{"repr::Formatted::<T>::fmt":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::fmt":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.fmt();
+repr::Formatted::<T>::fmt(p0);
+crate::repr::Formatted::<T>::fmt(p0);
+<repr::Formatted<T>>::fmt(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<repr::Formatted<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"repr::Formatted":{"T":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","repr::ValueRepr","std::hash::Hash"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<repr::Formatted<T> as std::fmt::Debug>::fmt":{"T":["table::Table","item::Item","key::KeyMut","encode::StringStyle","raw_string::RawString","inline_table::InlineTable","value::Value","<*const T as std::fmt::Debug>","internal_string::InternalString","key::Key","repr::Repr","de::Error","document::Document","array_of_tables::ArrayOfTables","repr::Formatted","array::Array","parser::errors::ParserError","parser::prelude::RecursionCheck","parser::errors::Context","table::TableKeyValue","<*mut T as std::fmt::Debug>","ser::Error","parser::errors::CustomError","parser::errors::ParserValue","repr::Decor","parser::errors::TomlError"]},"repr::Formatted":{"T":["bool","i64"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<repr::Formatted<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<repr::Formatted<T> as std::fmt::Debug>::fmt(p0, p1);
+<repr::Formatted<T>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::fmt::Display>::fmt
deps:{"<repr::Formatted<T> as std::fmt::Display>::fmt":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"<repr::Formatted<T> as std::fmt::Display>::fmt":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<repr::Formatted<T> as std::fmt::Display>::fmt(p0, p1);
+crate::<repr::Formatted<T> as std::fmt::Display>::fmt(p0, p1);
+<repr::Formatted<T>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.assert_receiver_is_total_eq();
+<repr::Repr as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<repr::Repr as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<repr::Repr>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.eq(p1);
+<repr::Repr as std::cmp::PartialEq>::eq(p0, p1);
+crate::<repr::Repr as std::cmp::PartialEq>::eq(p0, p1);
+<repr::Repr>::eq(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.clone();
+<repr::Repr as std::clone::Clone>::clone(p0);
+crate::<repr::Repr as std::clone::Clone>::clone(p0);
+<repr::Repr>::clone(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<repr::Repr as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<repr::Repr as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<repr::Repr as std::hash::Hash>::hash(p0, p1);
+crate::<repr::Repr as std::hash::Hash>::hash(p0, p1);
+<repr::Repr>::hash(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::new_unchecked
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"repr::Repr::new_unchecked":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"repr::Repr::new_unchecked":{"impl Into<RawString>":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+repr::Repr::new_unchecked(p0);
+crate::repr::Repr::new_unchecked(p0);
+<repr::Repr>::new_unchecked(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::as_raw
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.as_raw();
+repr::Repr::as_raw(p0);
+crate::repr::Repr::as_raw(p0);
+<repr::Repr>::as_raw(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.span();
+repr::Repr::span(p0);
+crate::repr::Repr::span(p0);
+<repr::Repr>::span(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+repr::Repr::despan(p0, &p1);
+crate::repr::Repr::despan(p0, &p1);
+<repr::Repr>::despan(p0, &p1);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = "sample"; // None+&str
+p0.encode(p1, &p2);
+repr::Repr::encode(p0, p1, &p2);
+crate::repr::Repr::encode(p0, p1, &p2);
+<repr::Repr>::encode(p0, p1, &p2);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<repr::Repr as std::fmt::Debug>::fmt(p0, p1);
+crate::<repr::Repr as std::fmt::Debug>::fmt(p0, p1);
+<repr::Repr>::fmt(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.assert_receiver_is_total_eq();
+<repr::Decor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<repr::Decor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<repr::Decor>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.eq(p1);
+<repr::Decor as std::cmp::PartialEq>::eq(p0, p1);
+crate::<repr::Decor as std::cmp::PartialEq>::eq(p0, p1);
+<repr::Decor>::eq(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.clone();
+<repr::Decor as std::clone::Clone>::clone(p0);
+crate::<repr::Decor as std::clone::Clone>::clone(p0);
+<repr::Decor>::clone(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::default::Default>::default
deps:{}
candidates:{}
+<repr::Decor as std::default::Default>::default();
+crate::<repr::Decor as std::default::Default>::default();
+<repr::Decor>::default();
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<repr::Decor as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<repr::Decor as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<repr::Decor as std::hash::Hash>::hash(p0, p1);
+crate::<repr::Decor as std::hash::Hash>::hash(p0, p1);
+<repr::Decor>::hash(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::new
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"repr::Decor::new":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"repr::Decor::new":{"impl Into<RawString>":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+repr::Decor::new(p0, p1);
+crate::repr::Decor::new(p0, p1);
+<repr::Decor>::new(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.clear();
+repr::Decor::clear(p0);
+crate::repr::Decor::clear(p0);
+<repr::Decor>::clear(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.prefix();
+repr::Decor::prefix(p0);
+crate::repr::Decor::prefix(p0);
+<repr::Decor>::prefix(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::prefix_encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = "sample"; // None+&str
+p0.prefix_encode(p1, p2, &p3);
+repr::Decor::prefix_encode(p0, p1, p2, &p3);
+crate::repr::Decor::prefix_encode(p0, p1, p2, &p3);
+<repr::Decor>::prefix_encode(p0, p1, p2, &p3);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::set_prefix
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"repr::Decor::set_prefix":{"impl Into<RawString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"repr::Decor::set_prefix":{"impl Into<RawString>":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_prefix(p1);
+repr::Decor::set_prefix(p0, p1);
+crate::repr::Decor::set_prefix(p0, p1);
+<repr::Decor>::set_prefix(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.suffix();
+repr::Decor::suffix(p0);
+crate::repr::Decor::suffix(p0);
+<repr::Decor>::suffix(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::suffix_encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = "sample"; // None+&str
+p0.suffix_encode(p1, p2, &p3);
+repr::Decor::suffix_encode(p0, p1, p2, &p3);
+crate::repr::Decor::suffix_encode(p0, p1, p2, &p3);
+<repr::Decor>::suffix_encode(p0, p1, p2, &p3);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::set_suffix
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"repr::Decor::set_suffix":{"impl Into<RawString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"repr::Decor::set_suffix":{"impl Into<RawString>":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_suffix(p1);
+repr::Decor::set_suffix(p0, p1);
+crate::repr::Decor::set_suffix(p0, p1);
+<repr::Decor>::set_suffix(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+repr::Decor::despan(p0, &p1);
+crate::repr::Decor::despan(p0, &p1);
+<repr::Decor>::despan(p0, &p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<repr::Decor as std::fmt::Debug>::fmt(p0, p1);
+crate::<repr::Decor as std::fmt::Debug>::fmt(p0, p1);
+<repr::Decor>::fmt(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.clone();
+<table::Table as std::clone::Clone>::clone(p0);
+crate::<table::Table as std::clone::Clone>::clone(p0);
+<table::Table>::clone(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<table::Table as std::fmt::Debug>::fmt(p0, p1);
+crate::<table::Table as std::fmt::Debug>::fmt(p0, p1);
+<table::Table>::fmt(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::default::Default>::default
deps:{}
candidates:{}
+<table::Table as std::default::Default>::default();
+crate::<table::Table as std::default::Default>::default();
+<table::Table>::default();
-----------------
crates/toml_edit/src/table.rs table::Table::new
deps:{}
candidates:{}
+table::Table::new();
+crate::table::Table::new();
+<table::Table>::new();
-----------------
crates/toml_edit/src/table.rs table::Table::with_pos
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+table::Table::with_pos(p0);
+crate::table::Table::with_pos(p0);
+<table::Table>::with_pos(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::with_pairs
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // indexmap::IndexMap<internal_string::InternalString, table::TableKeyValue>
+table::Table::with_pairs(p0);
+crate::table::Table::with_pairs(p0);
+<table::Table>::with_pairs(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::into_inline_table
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Table
+p0.into_inline_table();
+table::Table::into_inline_table(p0);
+crate::table::Table::into_inline_table(p0);
+<table::Table>::into_inline_table(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::get_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.get_values();
+table::Table::get_values(p0);
+crate::table::Table::get_values(p0);
+<table::Table>::get_values(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::append_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // [&'s key::Key]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<(std::vec::Vec<&'s key::Key>, &'s value::Value)>
+p0.append_values(p1, p2);
+table::Table::append_values(p0, p1, p2);
+crate::table::Table::append_values(p0, p1, p2);
+<table::Table>::append_values(p0, p1, p2);
-----------------
crates/toml_edit/src/table.rs table::Table::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.fmt();
+table::Table::fmt(p0);
+crate::table::Table::fmt(p0);
+<table::Table>::fmt(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::sort_values
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.sort_values();
+table::Table::sort_values(p0);
+crate::table::Table::sort_values(p0);
+<table::Table>::sort_values(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::sort_values_by
deps:{"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"table::Table::sort_values_by":{"F":["std::marker::Sized","std::ops::FnMut"]}}
candidates:{"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"table::Table::sort_values_by":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.sort_values_by(p1);
+table::Table::sort_values_by(p0, p1);
+crate::table::Table::sort_values_by(p0, p1);
+<table::Table>::sort_values_by(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::sort_values_by_internal
deps:{"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"table::Table::sort_values_by_internal":{"F":["std::ops::FnMut","std::marker::Sized"]}}
candidates:{"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"table::Table::sort_values_by_internal":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // F
+p0.sort_values_by_internal(p1);
+table::Table::sort_values_by_internal(p0, p1);
+crate::table::Table::sort_values_by_internal(p0, p1);
+<table::Table>::sort_values_by_internal(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::set_implicit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = true; // None+bool
+p0.set_implicit(p1);
+table::Table::set_implicit(p0, p1);
+crate::table::Table::set_implicit(p0, p1);
+<table::Table>::set_implicit(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::is_implicit
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.is_implicit();
+table::Table::is_implicit(p0);
+crate::table::Table::is_implicit(p0);
+<table::Table>::is_implicit(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::set_dotted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+table::Table::set_dotted(p0, p1);
+crate::table::Table::set_dotted(p0, p1);
+<table::Table>::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::is_dotted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.is_dotted();
+table::Table::is_dotted(p0);
+crate::table::Table::is_dotted(p0);
+<table::Table>::is_dotted(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::set_position
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = 0usize; // None+usize
+p0.set_position(p1);
+table::Table::set_position(p0, p1);
+crate::table::Table::set_position(p0, p1);
+<table::Table>::set_position(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::position
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.position();
+table::Table::position(p0);
+crate::table::Table::position(p0);
+<table::Table>::position(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.decor_mut();
+table::Table::decor_mut(p0);
+crate::table::Table::decor_mut(p0);
+<table::Table>::decor_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.decor();
+table::Table::decor(p0);
+crate::table::Table::decor(p0);
+<table::Table>::decor(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::key_decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+table::Table::key_decor_mut(p0, &p1);
+crate::table::Table::key_decor_mut(p0, &p1);
+<table::Table>::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::key_decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+table::Table::key_decor(p0, &p1);
+crate::table::Table::key_decor(p0, &p1);
+<table::Table>::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.span();
+table::Table::span(p0);
+crate::table::Table::span(p0);
+<table::Table>::span(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+table::Table::despan(p0, &p1);
+crate::table::Table::despan(p0, &p1);
+<table::Table>::despan(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.iter();
+table::Table::iter(p0);
+crate::table::Table::iter(p0);
+<table::Table>::iter(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.iter_mut();
+table::Table::iter_mut(p0);
+crate::table::Table::iter_mut(p0);
+<table::Table>::iter_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.len();
+table::Table::len(p0);
+crate::table::Table::len(p0);
+<table::Table>::len(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.is_empty();
+table::Table::is_empty(p0);
+crate::table::Table::is_empty(p0);
+<table::Table>::is_empty(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.clear();
+table::Table::clear(p0);
+crate::table::Table::clear(p0);
+<table::Table>::clear(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.entry(&p1);
+table::Table::entry(p0, &p1);
+crate::table::Table::entry(p0, &p1);
+<table::Table>::entry(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::entry_format
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+table::Table::entry_format(p0, p1);
+crate::table::Table::entry_format(p0, p1);
+<table::Table>::entry_format(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+table::Table::get(p0, &p1);
+crate::table::Table::get(p0, &p1);
+<table::Table>::get(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+table::Table::get_mut(p0, &p1);
+crate::table::Table::get_mut(p0, &p1);
+<table::Table>::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::get_key_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+table::Table::get_key_value(p0, &p1);
+crate::table::Table::get_key_value(p0, &p1);
+<table::Table>::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::get_key_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+table::Table::get_key_value_mut(p0, &p1);
+crate::table::Table::get_key_value_mut(p0, &p1);
+<table::Table>::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::contains_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+table::Table::contains_key(p0, &p1);
+crate::table::Table::contains_key(p0, &p1);
+<table::Table>::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::contains_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_table(&p1);
+table::Table::contains_table(p0, &p1);
+crate::table::Table::contains_table(p0, &p1);
+<table::Table>::contains_table(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::contains_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_value(&p1);
+table::Table::contains_value(p0, &p1);
+crate::table::Table::contains_value(p0, &p1);
+<table::Table>::contains_value(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::contains_array_of_tables
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_array_of_tables(&p1);
+table::Table::contains_array_of_tables(p0, &p1);
+crate::table::Table::contains_array_of_tables(p0, &p1);
+<table::Table>::contains_array_of_tables(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(&p1, p2);
+table::Table::insert(p0, &p1, p2);
+crate::table::Table::insert(p0, &p1, p2);
+<table::Table>::insert(p0, &p1, p2);
-----------------
crates/toml_edit/src/table.rs table::Table::insert_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert_formatted(p1, p2);
+table::Table::insert_formatted(p0, p1, p2);
+crate::table::Table::insert_formatted(p0, p1, p2);
+<table::Table>::insert_formatted(p0, p1, p2);
-----------------
crates/toml_edit/src/table.rs table::Table::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+table::Table::remove(p0, &p1);
+crate::table::Table::remove(p0, &p1);
+<table::Table>::remove(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::remove_entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.remove_entry(&p1);
+table::Table::remove_entry(p0, &p1);
+crate::table::Table::remove_entry(p0, &p1);
+<table::Table>::remove_entry(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<table::Table as std::fmt::Display>::fmt(p0, p1);
+crate::<table::Table as std::fmt::Display>::fmt(p0, p1);
+<table::Table>::fmt(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::iter::Extend<(K, V)>>::extend
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<table::Table as std::iter::Extend<(K, V)>>::extend":{"K":["std::convert::Into","std::marker::Sized"],"T":["std::marker::Sized","std::iter::IntoIterator"],"V":["std::convert::Into","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::collections::hash_map::ValuesMut<'a, K, V>","std::vec::Splice<'_, I, A>","std::option::Iter<'a, A>","std::env::Vars","std::str::SplitN<'a, P>","std::str::Lines<'a>","std::sys_common::wstr::WStrUnits<'_>","std::os::unix::net::Messages<'a>","std::slice::GroupBy<'a, T, P>","std::collections::binary_heap::Iter<'a, T>","std::os::unix::net::ScmRights<'a>","std::collections::btree_set::IntoIter<T, A>","std::net::Incoming<'a>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::path::Ancestors<'a>","std::str::Split<'a, P>","std::slice::Split<'a, T, P>","std::iter::OnceWith<F>","std::path::Iter<'a>","std::env::ArgsOs","std::slice::SplitInclusive<'a, T, P>","std::str::SplitAsciiWhitespace<'a>","std::sys::unix::os::Env","std::iter::FromFn<F>","std::iter::Once<T>","std::collections::linked_list::IterMut<'a, T>","std::collections::hash_map::IntoKeys<K, V>","std::iter::Successors<T, F>","<&mut I as std::iter::Iterator>","std::iter::SkipWhile<I, P>","std::str::LinesAny<'a>","std::iter::FilterMap<I, F>","std::slice::ArrayChunksMut<'a, T, N>","std::iter::StepBy<I>","std::collections::hash_map::Keys<'a, K, V>","std::ascii::EscapeDefault","std::collections::btree_map::Range<'a, K, V>","std::iter::Flatten<I>","std::vec::DrainFilter<'_, T, F, A>","std::iter::Filter<I, P>","std::io::Lines<B>","std::iter::RepeatWith<F>","std::slice::EscapeAscii<'a>","std::char::EscapeUnicode","std::collections::hash_map::Values<'a, K, V>","std::char::ToUppercase","std::collections::hash_set::Drain<'a, K>","std::str::RSplit<'a, P>","std::str::Chars<'a>","std::iter::Fuse<I>","std::char::EscapeDebug","std::str::EscapeDebug<'a>","std::iter::Empty<T>","std::slice::RChunksExactMut<'a, T>","std::iter::Cloned<I>","std::result::IntoIter<T>","std::env::VarsOs","std::collections::binary_heap::DrainSorted<'_, T>","std::char::ToLowercase","std::collections::linked_list::DrainFilter<'_, T, F>","std::char::DecodeUtf16<I>","std::slice::ChunksExactMut<'a, T>","std::result::Iter<'a, T>","std::slice::RChunksExact<'a, T>","std::collections::btree_map::IterMut<'a, K, V>","std::fs::ReadDir","std::slice::GroupByMut<'a, T, P>","std::str::Matches<'a, P>","std::collections::hash_set::Union<'a, T, S>","std::collections::hash_set::IntoIter<K>","std::slice::SplitN<'a, T, P>","std::env::Args","std::sys::unix::fs::ReadDir","std::path::Components<'a>","std::collections::btree_map::Keys<'a, K, V>","std::sys::unix::process::process_common::CommandArgs<'a>","std::iter::Enumerate<I>","std::collections::btree_set::Iter<'a, T>","std::result::IterMut<'a, T>","std::option::IntoIter<A>","core::error::Source<'a>","std::slice::ChunksMut<'a, T>","std::iter::TakeWhile<I, P>","std::sys_common::net::LookupHost","std::slice::ArrayChunks<'a, T, N>","std::str::Utf8Chunks<'a>","std::sync::mpsc::IntoIter<T>","std::str::EncodeUtf16<'a>","std::iter::Intersperse<I>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::collections::btree_map::Values<'a, K, V>","std::slice::Windows<'a, T>","std::vec::IntoIter<T, A>","std::option::IterMut<'a, A>","std::sys::unix::args::Args","std::slice::Iter<'a, T>","std::process::CommandArgs<'a>","std::collections::binary_heap::IntoIter<T>","std::string::Drain<'_>","std::collections::hash_set::Iter<'a, K>","std::slice::ArrayWindows<'a, T, N>","std::char::EscapeDefault","std::collections::linked_list::Iter<'a, T>","std::iter::Skip<I>","std::str::CharIndices<'a>","std::slice::RChunksMut<'a, T>","core::slice::iter::GenericSplitN<I>","std::sync::mpsc::Iter<'a, T>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::btree_set::SymmetricDifference<'a, T>","std::slice::RSplit<'a, T, P>","std::str::SplitInclusive<'a, P>","std::str::EscapeDefault<'a>","std::slice::SplitMut<'a, T, P>","std::vec::Drain<'_, T, A>","std::collections::vec_deque::IterMut<'a, T>","std::io::Split<B>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::str::RSplitTerminator<'a, P>","std::collections::hash_map::IntoValues<K, V>","std::iter::ArrayChunks<I, N>","std::array::IntoIter<T, N>","std::iter::Chain<A, B>","std::collections::vec_deque::IntoIter<T, A>","std::collections::linked_list::IntoIter<T>","std::collections::vec_deque::Iter<'a, T>","std::char::CaseMappingIter","std::iter::IntersperseWith<I, G>","std::option::Item<A>","std::iter::Peekable<I>","std::net::IntoIncoming","std::collections::binary_heap::IntoIterSorted<T>","std::boxed::Box<I, A>","std::str::Bytes<'_>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::slice::SplitNMut<'a, T, P>","std::str::EscapeUnicode<'a>","std::slice::ChunksExact<'a, T>","std::os::unix::net::ScmCredentials<'a>","std::ops::Range<A>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::iter::Take<I>","std::slice::RSplitNMut<'a, T, P>","std::collections::hash_map::IntoIter<K, V>","std::iter::adapters::GenericShunt<'_, I, R>","std::slice::IterMut<'a, T>","std::iter::Repeat<A>","std::os::unix::net::Incoming<'a>","std::collections::binary_heap::Drain<'_, T>","std::iter::Cycle<I>","std::str::RSplitN<'a, P>","std::collections::btree_map::IntoValues<K, V, A>","std::io::Bytes<R>","std::iter::FlatMap<I, U, F>","std::collections::btree_set::Difference<'a, T, A>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::iter::Map<I, F>","std::slice::RChunks<'a, T>","std::collections::btree_set::Intersection<'a, T, A>","std::str::SplitTerminator<'a, P>","std::collections::btree_set::Range<'a, T>","std::iter::sources::from_generator::FromGenerator<G>","std::str::MatchIndices<'a, P>","std::ops::RangeInclusive<A>","std::iter::Zip<A, B>","std::iter::ByRefSized<'_, I>","std::slice::SplitInclusiveMut<'a, T, P>","std::collections::hash_map::IterMut<'a, K, V>","std::str::SplitWhitespace<'a>","std::collections::hash_set::Difference<'a, T, S>","std::iter::Copied<I>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::sys::unix::os::SplitPaths<'a>","std::collections::vec_deque::Drain<'_, T, A>","std::collections::btree_map::Iter<'a, K, V>","std::collections::hash_map::Drain<'a, K, V>","std::iter::RepeatN<A>","std::slice::RSplitN<'a, T, P>","std::collections::btree_map::RangeMut<'a, K, V>","std::iter::Inspect<I, F>","std::str::RMatches<'a, P>","std::collections::hash_set::DrainFilter<'_, K, F>","std::collections::btree_map::IntoKeys<K, V, A>","std::env::SplitPaths<'a>","std::slice::Chunks<'a, T>","std::ops::RangeFrom<A>","std::collections::hash_set::Intersection<'a, T, S>","std::process::CommandEnvs<'a>","std::collections::hash_map::Iter<'a, K, V>","std::iter::Rev<I>","std::sys_common::wtf8::EncodeWide<'a>","std::collections::btree_map::IntoIter<K, V, A>","std::slice::RSplitMut<'a, T, P>","std::collections::btree_set::Union<'a, T>","std::ops::index_range::IndexRange","std::iter::MapWhile<I, P>","std::str::RMatchIndices<'a, P>","std::iter::Scan<I, St, F>","std::sync::mpsc::TryIter<'a, T>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<table::Table as std::iter::Extend<(K, V)>>::extend":{"K":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"],"T":["<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","array::Array","inline_table::InlineTable","table::Table","array_of_tables::ArrayOfTables","<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>"],"V":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<table::Table as std::iter::Extend<(K, V)>>::extend(p0, p1);
+crate::<table::Table as std::iter::Extend<(K, V)>>::extend(p0, p1);
+<table::Table>::extend(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::iter::FromIterator<(K, V)>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<table::Table as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["std::marker::Sized","std::iter::IntoIterator"],"K":["std::marker::Sized","std::convert::Into"],"V":["std::convert::Into","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::slice::ArrayChunks<'a, T, N>","std::char::ToLowercase","std::slice::RSplit<'a, T, P>","std::str::SplitN<'a, P>","std::collections::btree_set::Difference<'a, T, A>","std::iter::StepBy<I>","std::str::SplitAsciiWhitespace<'a>","std::sys_common::net::LookupHost","std::option::Item<A>","std::collections::hash_set::Union<'a, T, S>","std::str::Chars<'a>","std::iter::Intersperse<I>","std::sync::mpsc::TryIter<'a, T>","std::str::EscapeUnicode<'a>","std::slice::IterMut<'a, T>","std::iter::MapWhile<I, P>","std::slice::RChunksExact<'a, T>","std::slice::GroupByMut<'a, T, P>","std::iter::OnceWith<F>","std::os::unix::net::Incoming<'a>","std::str::CharIndices<'a>","std::vec::IntoIter<T, A>","std::io::Split<B>","std::net::Incoming<'a>","std::path::Iter<'a>","std::option::IntoIter<A>","std::collections::btree_set::Range<'a, T>","std::str::Split<'a, P>","std::iter::Repeat<A>","std::collections::btree_set::IntoIter<T, A>","std::iter::Copied<I>","std::collections::btree_set::Union<'a, T>","std::vec::Splice<'_, I, A>","std::str::SplitWhitespace<'a>","std::str::SplitTerminator<'a, P>","std::collections::hash_map::IntoIter<K, V>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::sys_common::wtf8::EncodeWide<'a>","std::vec::Drain<'_, T, A>","std::slice::GroupBy<'a, T, P>","std::slice::EscapeAscii<'a>","std::collections::linked_list::IterMut<'a, T>","std::collections::btree_set::DrainFilter<'_, T, F, A>","<&mut I as std::iter::Iterator>","std::str::MatchIndices<'a, P>","std::str::EscapeDebug<'a>","std::iter::Flatten<I>","std::iter::IntersperseWith<I, G>","std::collections::hash_set::Iter<'a, K>","std::slice::ArrayWindows<'a, T, N>","std::slice::Iter<'a, T>","std::collections::hash_set::Difference<'a, T, S>","std::str::RSplitN<'a, P>","std::iter::FilterMap<I, F>","std::collections::hash_set::Drain<'a, K>","std::env::VarsOs","std::iter::ArrayChunks<I, N>","std::slice::SplitN<'a, T, P>","std::str::LinesAny<'a>","std::os::unix::net::Messages<'a>","std::collections::hash_set::DrainFilter<'_, K, F>","std::slice::ChunksExactMut<'a, T>","std::str::SplitInclusive<'a, P>","std::iter::FromFn<F>","std::collections::hash_map::IntoValues<K, V>","std::collections::btree_map::IntoKeys<K, V, A>","core::slice::iter::GenericSplitN<I>","std::char::CaseMappingIter","std::collections::hash_set::IntoIter<K>","std::array::IntoIter<T, N>","std::collections::btree_set::Intersection<'a, T, A>","std::collections::btree_map::RangeMut<'a, K, V>","std::collections::hash_map::Drain<'a, K, V>","std::collections::vec_deque::Drain<'_, T, A>","std::str::Bytes<'_>","std::char::ToUppercase","std::iter::Map<I, F>","std::fs::ReadDir","std::iter::Enumerate<I>","std::iter::Fuse<I>","std::str::RMatches<'a, P>","core::error::Source<'a>","std::sync::mpsc::IntoIter<T>","std::option::Iter<'a, A>","std::sync::mpsc::Iter<'a, T>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::sys_common::wstr::WStrUnits<'_>","std::slice::Split<'a, T, P>","std::collections::btree_map::IntoIter<K, V, A>","std::iter::Zip<A, B>","std::collections::btree_map::Iter<'a, K, V>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::vec::DrainFilter<'_, T, F, A>","std::slice::SplitInclusiveMut<'a, T, P>","std::iter::Filter<I, P>","std::collections::binary_heap::Iter<'a, T>","std::slice::Chunks<'a, T>","std::slice::Windows<'a, T>","std::iter::Rev<I>","std::process::CommandArgs<'a>","std::str::Utf8Chunks<'a>","std::slice::RChunksExactMut<'a, T>","std::iter::ByRefSized<'_, I>","std::collections::hash_map::Keys<'a, K, V>","std::iter::adapters::GenericShunt<'_, I, R>","std::ascii::EscapeDefault","std::char::EscapeUnicode","std::env::ArgsOs","std::collections::binary_heap::Drain<'_, T>","std::result::IntoIter<T>","std::slice::ChunksMut<'a, T>","std::collections::hash_map::ValuesMut<'a, K, V>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::slice::RSplitMut<'a, T, P>","std::collections::btree_map::Values<'a, K, V>","std::slice::ArrayChunksMut<'a, T, N>","std::char::EscapeDefault","std::iter::Inspect<I, F>","std::str::Matches<'a, P>","std::char::DecodeUtf16<I>","std::iter::Once<T>","std::result::Iter<'a, T>","std::sys::unix::process::process_common::CommandArgs<'a>","std::option::IterMut<'a, A>","std::str::EncodeUtf16<'a>","std::ops::index_range::IndexRange","std::env::SplitPaths<'a>","std::collections::binary_heap::IntoIterSorted<T>","std::slice::RChunksMut<'a, T>","std::collections::vec_deque::Iter<'a, T>","std::iter::Cloned<I>","std::iter::Empty<T>","std::collections::vec_deque::IntoIter<T, A>","std::os::unix::net::ScmCredentials<'a>","std::str::RSplit<'a, P>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::linked_list::IntoIter<T>","std::slice::SplitMut<'a, T, P>","std::path::Components<'a>","std::collections::vec_deque::IterMut<'a, T>","std::iter::RepeatWith<F>","std::slice::SplitInclusive<'a, T, P>","std::collections::binary_heap::DrainSorted<'_, T>","std::sys::unix::os::Env","std::slice::RChunks<'a, T>","std::collections::binary_heap::IntoIter<T>","std::os::unix::net::ScmRights<'a>","std::iter::sources::from_generator::FromGenerator<G>","std::collections::hash_map::Iter<'a, K, V>","std::result::IterMut<'a, T>","std::collections::linked_list::DrainFilter<'_, T, F>","std::iter::SkipWhile<I, P>","std::iter::TakeWhile<I, P>","std::slice::SplitNMut<'a, T, P>","std::char::EscapeDebug","std::iter::Successors<T, F>","std::iter::Peekable<I>","std::iter::Skip<I>","std::slice::ChunksExact<'a, T>","std::slice::RSplitNMut<'a, T, P>","std::iter::Cycle<I>","std::collections::btree_map::IntoValues<K, V, A>","std::collections::hash_set::Intersection<'a, T, S>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::net::IntoIncoming","std::io::Lines<B>","std::collections::btree_map::IterMut<'a, K, V>","std::collections::btree_map::Range<'a, K, V>","std::io::Bytes<R>","std::sys::unix::fs::ReadDir","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::ops::RangeFrom<A>","std::iter::Scan<I, St, F>","std::iter::FlatMap<I, U, F>","std::iter::RepeatN<A>","std::str::Lines<'a>","std::sys::unix::os::SplitPaths<'a>","std::env::Args","std::string::Drain<'_>","std::iter::Take<I>","std::str::EscapeDefault<'a>","std::process::CommandEnvs<'a>","std::path::Ancestors<'a>","std::sys::unix::args::Args","std::slice::RSplitN<'a, T, P>","std::iter::Chain<A, B>","std::ops::Range<A>","std::collections::hash_map::IterMut<'a, K, V>","std::boxed::Box<I, A>","std::collections::btree_set::Iter<'a, T>","std::collections::hash_map::Values<'a, K, V>","std::str::RSplitTerminator<'a, P>","std::collections::btree_set::SymmetricDifference<'a, T>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::collections::btree_map::Keys<'a, K, V>","std::env::Vars","std::str::RMatchIndices<'a, P>","std::collections::hash_map::IntoKeys<K, V>","std::collections::linked_list::Iter<'a, T>","std::ops::RangeInclusive<A>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<table::Table as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["table::Table","<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>","array_of_tables::ArrayOfTables","inline_table::InlineTable","<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>","array::Array"],"K":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"],"V":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<table::Table as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+crate::<table::Table as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+<table::Table>::from_iter(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Table
+p0.into_iter();
+<table::Table as std::iter::IntoIterator>::into_iter(p0);
+crate::<table::Table as std::iter::IntoIterator>::into_iter(p0);
+<table::Table>::into_iter(p0);
-----------------
crates/toml_edit/src/table.rs <&'s table::Table as std::iter::IntoIterator>::into_iter
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.into_iter();
+<&'s table::Table as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'s table::Table as std::iter::IntoIterator>::into_iter(p0);
+<&'s table::Table>::into_iter(p0);
-----------------
crates/toml_edit/src/table.rs <table::TableKeyValue as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::TableKeyValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<table::TableKeyValue as std::fmt::Debug>::fmt(p0, p1);
+crate::<table::TableKeyValue as std::fmt::Debug>::fmt(p0, p1);
+<table::TableKeyValue>::fmt(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::TableKeyValue as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::TableKeyValue
+p0.clone();
+<table::TableKeyValue as std::clone::Clone>::clone(p0);
+crate::<table::TableKeyValue as std::clone::Clone>::clone(p0);
+<table::TableKeyValue>::clone(p0);
-----------------
crates/toml_edit/src/table.rs table::TableKeyValue::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+table::TableKeyValue::new(p0, p1);
+crate::table::TableKeyValue::new(p0, p1);
+<table::TableKeyValue>::new(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.iter();
+<table::Table as table::TableLike>::iter(p0);
+crate::<table::Table as table::TableLike>::iter(p0);
+<table::Table>::iter(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.iter_mut();
+<table::Table as table::TableLike>::iter_mut(p0);
+crate::<table::Table as table::TableLike>::iter_mut(p0);
+<table::Table>::iter_mut(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.clear();
+<table::Table as table::TableLike>::clear(p0);
+crate::<table::Table as table::TableLike>::clear(p0);
+<table::Table>::clear(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.entry(&p1);
+<table::Table as table::TableLike>::entry(p0, &p1);
+crate::<table::Table as table::TableLike>::entry(p0, &p1);
+<table::Table>::entry(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::entry_format
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+<table::Table as table::TableLike>::entry_format(p0, p1);
+crate::<table::Table as table::TableLike>::entry_format(p0, p1);
+<table::Table>::entry_format(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+<table::Table as table::TableLike>::get(p0, &p1);
+crate::<table::Table as table::TableLike>::get(p0, &p1);
+<table::Table>::get(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+<table::Table as table::TableLike>::get_mut(p0, &p1);
+crate::<table::Table as table::TableLike>::get_mut(p0, &p1);
+<table::Table>::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get_key_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+<table::Table as table::TableLike>::get_key_value(p0, &p1);
+crate::<table::Table as table::TableLike>::get_key_value(p0, &p1);
+<table::Table>::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get_key_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+<table::Table as table::TableLike>::get_key_value_mut(p0, &p1);
+crate::<table::Table as table::TableLike>::get_key_value_mut(p0, &p1);
+<table::Table>::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::contains_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+<table::Table as table::TableLike>::contains_key(p0, &p1);
+crate::<table::Table as table::TableLike>::contains_key(p0, &p1);
+<table::Table>::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(&p1, p2);
+<table::Table as table::TableLike>::insert(p0, &p1, p2);
+crate::<table::Table as table::TableLike>::insert(p0, &p1, p2);
+<table::Table>::insert(p0, &p1, p2);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+<table::Table as table::TableLike>::remove(p0, &p1);
+crate::<table::Table as table::TableLike>::remove(p0, &p1);
+<table::Table>::remove(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.get_values();
+<table::Table as table::TableLike>::get_values(p0);
+crate::<table::Table as table::TableLike>::get_values(p0);
+<table::Table>::get_values(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.fmt();
+<table::Table as table::TableLike>::fmt(p0);
+crate::<table::Table as table::TableLike>::fmt(p0);
+<table::Table>::fmt(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::sort_values
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.sort_values();
+<table::Table as table::TableLike>::sort_values(p0);
+crate::<table::Table as table::TableLike>::sort_values(p0);
+<table::Table>::sort_values(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::is_dotted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.is_dotted();
+<table::Table as table::TableLike>::is_dotted(p0);
+crate::<table::Table as table::TableLike>::is_dotted(p0);
+<table::Table>::is_dotted(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::set_dotted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+<table::Table as table::TableLike>::set_dotted(p0, p1);
+crate::<table::Table as table::TableLike>::set_dotted(p0, p1);
+<table::Table>::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::key_decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+<table::Table as table::TableLike>::key_decor_mut(p0, &p1);
+crate::<table::Table as table::TableLike>::key_decor_mut(p0, &p1);
+<table::Table>::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::key_decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+<table::Table as table::TableLike>::key_decor(p0, &p1);
+crate::<table::Table as table::TableLike>::key_decor(p0, &p1);
+<table::Table>::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Entry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Entry<'a>
+p0.key();
+table::Entry::<'a>::key(p0);
+crate::table::Entry::<'a>::key(p0);
+<table::Entry<'a>>::key(p0);
-----------------
crates/toml_edit/src/table.rs table::Entry::<'a>::or_insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.or_insert(p1);
+table::Entry::<'a>::or_insert(p0, p1);
+crate::table::Entry::<'a>::or_insert(p0, p1);
+<table::Entry<'a>>::or_insert(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Entry::<'a>::or_insert_with
'a
deps:{"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"table::Entry::<'a>::or_insert_with":{"F":["std::marker::Sized","std::ops::FnOnce"]}}
candidates:{"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"table::Entry::<'a>::or_insert_with":{"F":["core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeUnicode","std::panic::AssertUnwindSafe<F>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.or_insert_with(p1);
+table::Entry::<'a>::or_insert_with(p0, p1);
+crate::table::Entry::<'a>::or_insert_with(p0, p1);
+<table::Entry<'a>>::or_insert_with(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.key();
+table::OccupiedEntry::<'a>::key(p0);
+crate::table::OccupiedEntry::<'a>::key(p0);
+<table::OccupiedEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::key_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.key_mut();
+table::OccupiedEntry::<'a>::key_mut(p0);
+crate::table::OccupiedEntry::<'a>::key_mut(p0);
+<table::OccupiedEntry<'a>>::key_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::get
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.get();
+table::OccupiedEntry::<'a>::get(p0);
+crate::table::OccupiedEntry::<'a>::get(p0);
+<table::OccupiedEntry<'a>>::get(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::get_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.get_mut();
+table::OccupiedEntry::<'a>::get_mut(p0);
+crate::table::OccupiedEntry::<'a>::get_mut(p0);
+<table::OccupiedEntry<'a>>::get_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::into_mut
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.into_mut();
+table::OccupiedEntry::<'a>::into_mut(p0);
+crate::table::OccupiedEntry::<'a>::into_mut(p0);
+<table::OccupiedEntry<'a>>::into_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(p1);
+table::OccupiedEntry::<'a>::insert(p0, p1);
+crate::table::OccupiedEntry::<'a>::insert(p0, p1);
+<table::OccupiedEntry<'a>>::insert(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::remove
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.remove();
+table::OccupiedEntry::<'a>::remove(p0);
+crate::table::OccupiedEntry::<'a>::remove(p0);
+<table::OccupiedEntry<'a>>::remove(p0);
-----------------
crates/toml_edit/src/table.rs table::VacantEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::VacantEntry<'a>
+p0.key();
+table::VacantEntry::<'a>::key(p0);
+crate::table::VacantEntry::<'a>::key(p0);
+<table::VacantEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/table.rs table::VacantEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::VacantEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(p1);
+table::VacantEntry::<'a>::insert(p0, p1);
+crate::table::VacantEntry::<'a>::insert(p0, p1);
+<table::VacantEntry<'a>>::insert(p0, p1);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<value::Value as std::fmt::Debug>::fmt(p0, p1);
+crate::<value::Value as std::fmt::Debug>::fmt(p0, p1);
+<value::Value>::fmt(p0, p1);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.clone();
+<value::Value as std::clone::Clone>::clone(p0);
+crate::<value::Value as std::clone::Clone>::clone(p0);
+<value::Value>::clone(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::type_name
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.type_name();
+value::Value::type_name(p0);
+crate::value::Value::type_name(p0);
+<value::Value>::type_name(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_str();
+value::Value::as_str(p0);
+crate::value::Value::as_str(p0);
+<value::Value>::as_str(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_str();
+value::Value::is_str(p0);
+crate::value::Value::is_str(p0);
+<value::Value>::is_str(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_integer();
+value::Value::as_integer(p0);
+crate::value::Value::as_integer(p0);
+<value::Value>::as_integer(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_integer();
+value::Value::is_integer(p0);
+crate::value::Value::is_integer(p0);
+<value::Value>::is_integer(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_float();
+value::Value::as_float(p0);
+crate::value::Value::as_float(p0);
+<value::Value>::as_float(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_float();
+value::Value::is_float(p0);
+crate::value::Value::is_float(p0);
+<value::Value>::is_float(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_bool();
+value::Value::as_bool(p0);
+crate::value::Value::as_bool(p0);
+<value::Value>::as_bool(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_bool();
+value::Value::is_bool(p0);
+crate::value::Value::is_bool(p0);
+<value::Value>::is_bool(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_datetime();
+value::Value::as_datetime(p0);
+crate::value::Value::as_datetime(p0);
+<value::Value>::as_datetime(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_datetime();
+value::Value::is_datetime(p0);
+crate::value::Value::is_datetime(p0);
+<value::Value>::is_datetime(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_array();
+value::Value::as_array(p0);
+crate::value::Value::as_array(p0);
+<value::Value>::as_array(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_array_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_array_mut();
+value::Value::as_array_mut(p0);
+crate::value::Value::as_array_mut(p0);
+<value::Value>::as_array_mut(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_array();
+value::Value::is_array(p0);
+crate::value::Value::is_array(p0);
+<value::Value>::is_array(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_inline_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_inline_table();
+value::Value::as_inline_table(p0);
+crate::value::Value::as_inline_table(p0);
+<value::Value>::as_inline_table(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_inline_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_inline_table_mut();
+value::Value::as_inline_table_mut(p0);
+crate::value::Value::as_inline_table_mut(p0);
+<value::Value>::as_inline_table_mut(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_inline_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_inline_table();
+value::Value::is_inline_table(p0);
+crate::value::Value::is_inline_table(p0);
+<value::Value>::is_inline_table(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.decor_mut();
+value::Value::decor_mut(p0);
+crate::value::Value::decor_mut(p0);
+<value::Value>::decor_mut(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.decor();
+value::Value::decor(p0);
+crate::value::Value::decor(p0);
+<value::Value>::decor(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::decorated
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"value::Value::decorated":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"value::Value::decorated":{"impl Into<RawString>":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.decorated(p1, p2);
+value::Value::decorated(p0, p1, p2);
+crate::value::Value::decorated(p0, p1, p2);
+<value::Value>::decorated(p0, p1, p2);
-----------------
crates/toml_edit/src/value.rs value::Value::decorate
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"value::Value::decorate":{"impl Into<RawString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"value::Value::decorate":{"impl Into<RawString>":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.decorate(p1, p2);
+value::Value::decorate(p0, p1, p2);
+crate::value::Value::decorate(p0, p1, p2);
+<value::Value>::decorate(p0, p1, p2);
-----------------
crates/toml_edit/src/value.rs value::Value::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.span();
+value::Value::span(p0);
+crate::value::Value::span(p0);
+<value::Value>::span(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+value::Value::despan(p0, &p1);
+crate::value::Value::despan(p0, &p1);
+<value::Value>::despan(p0, &p1);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<value::Value as std::str::FromStr>::from_str(&p0);
+crate::<value::Value as std::str::FromStr>::from_str(&p0);
+<value::Value>::from_str(&p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<&'b value::Value>>::from
'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+<value::Value as std::convert::From<&'b value::Value>>::from(p0);
+crate::<value::Value as std::convert::From<&'b value::Value>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<&'b str>>::from
'b
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<value::Value as std::convert::From<&'b str>>::from(&p0);
+crate::<value::Value as std::convert::From<&'b str>>::from(&p0);
+<value::Value>::from(&p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<&'b std::string::String>>::from
'b
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<value::Value as std::convert::From<&'b std::string::String>>::from(p0);
+crate::<value::Value as std::convert::From<&'b std::string::String>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<value::Value as std::convert::From<std::string::String>>::from(p0);
+crate::<value::Value as std::convert::From<std::string::String>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<&'b internal_string::InternalString>>::from
'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<value::Value as std::convert::From<&'b internal_string::InternalString>>::from(p0);
+crate::<value::Value as std::convert::From<&'b internal_string::InternalString>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<value::Value as std::convert::From<internal_string::InternalString>>::from(p0);
+crate::<value::Value as std::convert::From<internal_string::InternalString>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<i64>>::from
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<value::Value as std::convert::From<i64>>::from(p0);
+crate::<value::Value as std::convert::From<i64>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<f64>>::from
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<value::Value as std::convert::From<f64>>::from(p0);
+crate::<value::Value as std::convert::From<f64>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<bool>>::from
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+<value::Value as std::convert::From<bool>>::from(p0);
+crate::<value::Value as std::convert::From<bool>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<toml_datetime::Datetime>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_datetime::Datetime
+<value::Value as std::convert::From<toml_datetime::Datetime>>::from(p0);
+crate::<value::Value as std::convert::From<toml_datetime::Datetime>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<toml_datetime::Date>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_datetime::Date
+<value::Value as std::convert::From<toml_datetime::Date>>::from(p0);
+crate::<value::Value as std::convert::From<toml_datetime::Date>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<toml_datetime::Time>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_datetime::Time
+<value::Value as std::convert::From<toml_datetime::Time>>::from(p0);
+crate::<value::Value as std::convert::From<toml_datetime::Time>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<array::Array>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array::Array
+<value::Value as std::convert::From<array::Array>>::from(p0);
+crate::<value::Value as std::convert::From<array::Array>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<inline_table::InlineTable>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+<value::Value as std::convert::From<inline_table::InlineTable>>::from(p0);
+crate::<value::Value as std::convert::From<inline_table::InlineTable>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::iter::FromIterator<V>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<value::Value as std::iter::FromIterator<V>>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"],"V":["std::marker::Sized","std::convert::Into"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::MapWhile<I, P>","std::str::EscapeDebug<'a>","std::collections::hash_map::IntoKeys<K, V>","std::collections::btree_set::Difference<'a, T, A>","std::os::unix::net::Incoming<'a>","std::collections::linked_list::IntoIter<T>","std::slice::RSplitN<'a, T, P>","std::ops::Range<A>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::btree_map::IterMut<'a, K, V>","std::iter::adapters::GenericShunt<'_, I, R>","std::collections::btree_set::SymmetricDifference<'a, T>","std::str::EscapeDefault<'a>","std::option::IterMut<'a, A>","std::str::RMatches<'a, P>","std::iter::StepBy<I>","std::env::Vars","std::sync::mpsc::TryIter<'a, T>","std::sync::mpsc::IntoIter<T>","std::slice::GroupBy<'a, T, P>","std::iter::Rev<I>","std::ops::RangeFrom<A>","std::str::RSplitTerminator<'a, P>","std::collections::hash_map::Iter<'a, K, V>","std::iter::TakeWhile<I, P>","std::slice::EscapeAscii<'a>","std::collections::btree_set::Range<'a, T>","std::option::Item<A>","std::collections::btree_map::IntoIter<K, V, A>","std::iter::Fuse<I>","std::fs::ReadDir","std::collections::hash_set::Union<'a, T, S>","std::string::Drain<'_>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::slice::GroupByMut<'a, T, P>","std::slice::Iter<'a, T>","std::sys::unix::os::Env","std::str::Bytes<'_>","std::collections::hash_map::Keys<'a, K, V>","std::io::Lines<B>","std::iter::Copied<I>","std::iter::Once<T>","std::ops::RangeInclusive<A>","std::iter::Peekable<I>","std::char::EscapeUnicode","std::ops::index_range::IndexRange","std::iter::OnceWith<F>","std::iter::ByRefSized<'_, I>","std::array::IntoIter<T, N>","std::slice::SplitMut<'a, T, P>","std::path::Components<'a>","std::vec::Drain<'_, T, A>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::btree_set::Intersection<'a, T, A>","std::slice::ChunksMut<'a, T>","std::str::RSplitN<'a, P>","std::collections::hash_map::IntoIter<K, V>","std::path::Ancestors<'a>","std::collections::vec_deque::Iter<'a, T>","std::slice::IterMut<'a, T>","std::os::unix::net::Messages<'a>","std::collections::hash_set::DrainFilter<'_, K, F>","std::slice::ArrayChunks<'a, T, N>","std::slice::SplitInclusive<'a, T, P>","std::iter::Scan<I, St, F>","std::iter::Cycle<I>","std::iter::Empty<T>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","core::slice::iter::GenericSplitN<I>","std::slice::RSplit<'a, T, P>","std::sys::unix::fs::ReadDir","std::str::SplitN<'a, P>","std::collections::linked_list::IterMut<'a, T>","std::iter::FromFn<F>","std::collections::hash_map::Drain<'a, K, V>","core::error::Source<'a>","std::iter::FlatMap<I, U, F>","std::str::Matches<'a, P>","std::char::DecodeUtf16<I>","std::str::MatchIndices<'a, P>","std::iter::RepeatN<A>","std::collections::btree_set::Iter<'a, T>","std::iter::Successors<T, F>","std::env::SplitPaths<'a>","std::process::CommandEnvs<'a>","std::str::RSplit<'a, P>","std::net::Incoming<'a>","std::collections::vec_deque::IterMut<'a, T>","std::collections::binary_heap::Iter<'a, T>","std::iter::FilterMap<I, F>","std::str::Lines<'a>","std::iter::ArrayChunks<I, N>","std::slice::Split<'a, T, P>","std::char::EscapeDebug","std::char::CaseMappingIter","std::iter::Map<I, F>","std::path::Iter<'a>","std::collections::hash_set::Intersection<'a, T, S>","std::collections::linked_list::DrainFilter<'_, T, F>","std::iter::Cloned<I>","std::collections::btree_map::RangeMut<'a, K, V>","std::str::RMatchIndices<'a, P>","std::sys_common::wstr::WStrUnits<'_>","std::collections::vec_deque::IntoIter<T, A>","std::option::IntoIter<A>","std::collections::hash_map::ValuesMut<'a, K, V>","std::str::SplitInclusive<'a, P>","std::ascii::EscapeDefault","std::iter::SkipWhile<I, P>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::collections::hash_set::Difference<'a, T, S>","std::collections::linked_list::Iter<'a, T>","std::char::ToUppercase","std::slice::RChunksExact<'a, T>","std::iter::Flatten<I>","std::collections::btree_map::Range<'a, K, V>","std::iter::Skip<I>","std::iter::Chain<A, B>","std::env::Args","std::collections::btree_map::IntoKeys<K, V, A>","std::collections::hash_map::IntoValues<K, V>","std::sync::mpsc::Iter<'a, T>","std::collections::btree_map::Values<'a, K, V>","std::char::EscapeDefault","std::net::IntoIncoming","std::io::Split<B>","std::process::CommandArgs<'a>","std::os::unix::net::ScmRights<'a>","std::str::Utf8Chunks<'a>","std::iter::Zip<A, B>","std::result::IntoIter<T>","std::collections::btree_map::Keys<'a, K, V>","std::collections::btree_set::IntoIter<T, A>","std::iter::sources::from_generator::FromGenerator<G>","std::collections::hash_map::IterMut<'a, K, V>","std::slice::RSplitNMut<'a, T, P>","std::result::IterMut<'a, T>","std::collections::hash_map::Values<'a, K, V>","std::slice::RChunksMut<'a, T>","std::slice::Windows<'a, T>","std::collections::hash_set::Iter<'a, K>","std::env::VarsOs","std::sys::unix::args::Args","std::sys_common::net::LookupHost","std::vec::Splice<'_, I, A>","std::collections::hash_set::IntoIter<K>","std::char::ToLowercase","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::slice::RSplitMut<'a, T, P>","std::sys::unix::os::SplitPaths<'a>","std::iter::Filter<I, P>","std::slice::ChunksExact<'a, T>","std::collections::hash_set::Drain<'a, K>","std::slice::SplitNMut<'a, T, P>","std::str::EncodeUtf16<'a>","std::str::EscapeUnicode<'a>","std::str::LinesAny<'a>","std::collections::binary_heap::DrainSorted<'_, T>","std::os::unix::net::ScmCredentials<'a>","std::str::SplitWhitespace<'a>","std::collections::vec_deque::Drain<'_, T, A>","std::slice::RChunks<'a, T>","std::iter::Repeat<A>","std::sys_common::wtf8::EncodeWide<'a>","std::slice::RChunksExactMut<'a, T>","<&mut I as std::iter::Iterator>","std::result::Iter<'a, T>","std::vec::IntoIter<T, A>","std::iter::Intersperse<I>","std::sys::unix::process::process_common::CommandArgs<'a>","std::collections::hash_set::SymmetricDifference<'a, T, S>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::str::CharIndices<'a>","std::slice::ArrayWindows<'a, T, N>","std::str::SplitTerminator<'a, P>","std::collections::binary_heap::IntoIterSorted<T>","std::iter::Inspect<I, F>","std::collections::btree_set::Union<'a, T>","std::str::Split<'a, P>","std::slice::ArrayChunksMut<'a, T, N>","std::collections::btree_map::Iter<'a, K, V>","std::iter::Take<I>","std::iter::Enumerate<I>","std::boxed::Box<I, A>","std::slice::SplitN<'a, T, P>","std::iter::RepeatWith<F>","std::option::Iter<'a, A>","std::collections::binary_heap::IntoIter<T>","std::vec::DrainFilter<'_, T, F, A>","std::collections::btree_map::IntoValues<K, V, A>","std::slice::ChunksExactMut<'a, T>","std::str::Chars<'a>","std::collections::binary_heap::Drain<'_, T>","std::slice::Chunks<'a, T>","std::str::SplitAsciiWhitespace<'a>","std::iter::IntersperseWith<I, G>","std::slice::SplitInclusiveMut<'a, T, P>","std::env::ArgsOs","std::io::Bytes<R>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<value::Value as std::iter::FromIterator<V>>::from_iter":{"I":["inline_table::InlineTable","array_of_tables::ArrayOfTables","array::Array","<&'a std::result::Result<T, E> as std::iter::IntoIterator>","table::Table","<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>"],"V":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<value::Value as std::iter::FromIterator<V>>::from_iter(p0);
+crate::<value::Value as std::iter::FromIterator<V>>::from_iter(p0);
+<value::Value>::from_iter(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::iter::FromIterator<(K, V)>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<value::Value as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"],"K":["std::marker::Sized","std::convert::Into"],"V":["std::marker::Sized","std::convert::Into"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::boxed::Box<I, A>","std::option::IterMut<'a, A>","std::iter::Repeat<A>","std::str::Bytes<'_>","std::ops::RangeFrom<A>","std::collections::hash_map::Iter<'a, K, V>","std::net::Incoming<'a>","std::collections::btree_map::IntoIter<K, V, A>","std::sys::unix::os::Env","std::iter::SkipWhile<I, P>","std::slice::ArrayChunks<'a, T, N>","std::iter::FlatMap<I, U, F>","std::collections::btree_map::Keys<'a, K, V>","std::slice::ChunksMut<'a, T>","std::collections::linked_list::IntoIter<T>","std::collections::hash_map::IterMut<'a, K, V>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::collections::btree_set::IntoIter<T, A>","std::path::Iter<'a>","std::slice::EscapeAscii<'a>","std::collections::linked_list::Iter<'a, T>","std::slice::ArrayWindows<'a, T, N>","std::ops::index_range::IndexRange","std::collections::hash_set::IntoIter<K>","std::result::IntoIter<T>","std::str::MatchIndices<'a, P>","std::collections::btree_set::Range<'a, T>","core::slice::iter::GenericSplitN<I>","std::iter::FilterMap<I, F>","std::os::unix::net::Incoming<'a>","std::fs::ReadDir","std::iter::ByRefSized<'_, I>","std::iter::MapWhile<I, P>","core::error::Source<'a>","std::collections::vec_deque::IterMut<'a, T>","std::vec::IntoIter<T, A>","std::env::Vars","std::str::SplitWhitespace<'a>","std::ascii::EscapeDefault","std::iter::Cycle<I>","std::io::Lines<B>","std::iter::RepeatN<A>","std::str::RMatchIndices<'a, P>","std::vec::Drain<'_, T, A>","std::iter::TakeWhile<I, P>","std::env::Args","std::char::EscapeDebug","std::str::SplitInclusive<'a, P>","std::collections::btree_map::IntoKeys<K, V, A>","std::iter::Copied<I>","std::collections::btree_map::RangeMut<'a, K, V>","std::collections::hash_set::Iter<'a, K>","std::collections::hash_set::Union<'a, T, S>","std::collections::btree_set::Intersection<'a, T, A>","std::sys::unix::args::Args","std::slice::SplitNMut<'a, T, P>","std::vec::Splice<'_, I, A>","std::iter::RepeatWith<F>","std::slice::Windows<'a, T>","std::str::SplitTerminator<'a, P>","std::iter::Intersperse<I>","std::iter::Skip<I>","std::collections::vec_deque::Drain<'_, T, A>","std::iter::FromFn<F>","std::slice::SplitN<'a, T, P>","std::os::unix::net::ScmCredentials<'a>","std::vec::DrainFilter<'_, T, F, A>","std::collections::linked_list::IterMut<'a, T>","std::str::RSplitN<'a, P>","std::result::IterMut<'a, T>","std::sync::mpsc::TryIter<'a, T>","std::string::Drain<'_>","std::str::LinesAny<'a>","std::iter::Rev<I>","std::sys::unix::fs::ReadDir","std::slice::Split<'a, T, P>","std::collections::btree_set::Difference<'a, T, A>","std::char::CaseMappingIter","std::slice::SplitInclusiveMut<'a, T, P>","std::option::IntoIter<A>","std::str::Split<'a, P>","std::iter::adapters::GenericShunt<'_, I, R>","std::path::Components<'a>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::iter::Filter<I, P>","std::option::Iter<'a, A>","std::char::ToLowercase","std::env::VarsOs","std::collections::hash_set::Drain<'a, K>","std::slice::SplitMut<'a, T, P>","std::str::RSplitTerminator<'a, P>","std::char::ToUppercase","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::path::Ancestors<'a>","std::str::Lines<'a>","std::collections::hash_map::Values<'a, K, V>","std::char::DecodeUtf16<I>","std::iter::Chain<A, B>","std::slice::GroupByMut<'a, T, P>","std::str::Chars<'a>","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::vec_deque::IntoIter<T, A>","std::collections::hash_map::IntoValues<K, V>","std::collections::hash_map::IntoIter<K, V>","std::str::EscapeUnicode<'a>","std::iter::ArrayChunks<I, N>","std::slice::RChunksExactMut<'a, T>","std::iter::Peekable<I>","std::iter::Successors<T, F>","std::slice::RSplitN<'a, T, P>","std::sys_common::wstr::WStrUnits<'_>","std::ops::RangeInclusive<A>","std::iter::Flatten<I>","std::collections::hash_map::IntoKeys<K, V>","std::sync::mpsc::Iter<'a, T>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::btree_set::SymmetricDifference<'a, T>","std::process::CommandEnvs<'a>","std::slice::IterMut<'a, T>","std::env::SplitPaths<'a>","std::iter::OnceWith<F>","std::collections::linked_list::DrainFilter<'_, T, F>","std::collections::btree_map::Range<'a, K, V>","std::collections::hash_set::DrainFilter<'_, K, F>","std::iter::Zip<A, B>","std::str::EscapeDebug<'a>","std::slice::ArrayChunksMut<'a, T, N>","std::collections::btree_set::Iter<'a, T>","std::io::Split<B>","std::collections::hash_map::Drain<'a, K, V>","std::iter::sources::from_generator::FromGenerator<G>","std::slice::RSplit<'a, T, P>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::binary_heap::IntoIter<T>","std::str::EncodeUtf16<'a>","std::iter::Empty<T>","std::iter::StepBy<I>","std::collections::vec_deque::Iter<'a, T>","std::sync::mpsc::IntoIter<T>","std::collections::btree_set::Union<'a, T>","std::slice::Chunks<'a, T>","std::str::EscapeDefault<'a>","std::iter::IntersperseWith<I, G>","std::iter::Fuse<I>","std::char::EscapeDefault","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::net::IntoIncoming","std::collections::binary_heap::Drain<'_, T>","std::io::Bytes<R>","std::str::CharIndices<'a>","std::iter::Inspect<I, F>","std::slice::ChunksExact<'a, T>","std::str::SplitAsciiWhitespace<'a>","std::slice::RChunksExact<'a, T>","std::os::unix::net::ScmRights<'a>","std::iter::Take<I>","std::iter::Enumerate<I>","std::sys_common::net::LookupHost","std::iter::Map<I, F>","std::str::RMatches<'a, P>","std::collections::btree_map::IntoValues<K, V, A>","std::iter::Once<T>","std::str::RSplit<'a, P>","std::slice::Iter<'a, T>","std::slice::RSplitNMut<'a, T, P>","std::slice::SplitInclusive<'a, T, P>","std::collections::binary_heap::Iter<'a, T>","std::sys::unix::os::SplitPaths<'a>","std::process::CommandArgs<'a>","<&mut I as std::iter::Iterator>","std::iter::Scan<I, St, F>","std::collections::btree_map::IterMut<'a, K, V>","std::str::SplitN<'a, P>","std::slice::GroupBy<'a, T, P>","std::option::Item<A>","std::env::ArgsOs","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::str::Utf8Chunks<'a>","std::collections::hash_map::ValuesMut<'a, K, V>","std::sys::unix::process::process_common::CommandArgs<'a>","std::str::Matches<'a, P>","std::collections::btree_map::Values<'a, K, V>","std::iter::Cloned<I>","std::slice::ChunksExactMut<'a, T>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::slice::RSplitMut<'a, T, P>","std::char::EscapeUnicode","std::os::unix::net::Messages<'a>","std::sys_common::wtf8::EncodeWide<'a>","std::ops::Range<A>","std::collections::btree_map::Iter<'a, K, V>","std::collections::binary_heap::IntoIterSorted<T>","std::collections::hash_set::Difference<'a, T, S>","std::result::Iter<'a, T>","std::slice::RChunksMut<'a, T>","std::collections::hash_map::Keys<'a, K, V>","std::collections::hash_set::Intersection<'a, T, S>","std::array::IntoIter<T, N>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::slice::RChunks<'a, T>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<value::Value as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["table::Table","<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>","array::Array","array_of_tables::ArrayOfTables","<&'a std::option::Option<T> as std::iter::IntoIterator>","inline_table::InlineTable"],"K":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected"],"V":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<value::Value as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+crate::<value::Value as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+<value::Value>::from_iter(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<value::Value as std::fmt::Display>::fmt(p0, p1);
+crate::<value::Value as std::fmt::Display>::fmt(p0, p1);
+<value::Value>::fmt(p0, p1);
-----------------
crates/toml_edit/src/de/array.rs de::array::ArrayDeserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<item::Item>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::ops::Range<usize>>
+de::array::ArrayDeserializer::new(p0, p1);
+crate::de::array::ArrayDeserializer::new(p0, p1);
+<de::array::ArrayDeserializer>::new(p0, p1);
-----------------
crates/toml_edit/src/de/array.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_any(p0, p1);
-----------------
crates/toml_edit/src/de/array.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<de::array::ArrayDeserializer>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_option(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<de::array::ArrayDeserializer>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<de::array::ArrayDeserializer>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<de::array::ArrayDeserializer>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<de::array::ArrayDeserializer>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<de::array::ArrayDeserializer>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<de::array::ArrayDeserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<de::array::ArrayDeserializer>::deserialize_identifier(p0, p1);
-----------------
crates/toml_edit/src/de/array.rs <de::array::ArrayDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::array::ArrayDeserializer
+p0.into_deserializer();
+<de::array::ArrayDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+crate::<de::array::ArrayDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+<de::array::ArrayDeserializer>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/array.rs de::array::<impl array::Array>::into_deserializer
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array::Array
+p0.into_deserializer();
+de::array::<impl array::Array>::into_deserializer(p0);
+crate::de::array::<impl array::Array>::into_deserializer(p0);
+<array::Array>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/array.rs de::array::<impl array_of_tables::ArrayOfTables>::into_deserializer
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.into_deserializer();
+de::array::<impl array_of_tables::ArrayOfTables>::into_deserializer(p0);
+crate::de::array::<impl array_of_tables::ArrayOfTables>::into_deserializer(p0);
+<array_of_tables::ArrayOfTables>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/array.rs de::array::ArraySeqAccess::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<item::Item>
+de::array::ArraySeqAccess::new(p0);
+crate::de::array::ArraySeqAccess::new(p0);
+<de::array::ArraySeqAccess>::new(p0);
-----------------
crates/toml_edit/src/de/array.rs <de::array::ArraySeqAccess as serde::de::SeqAccess<'de>>::next_element_seed
'de
deps:{"<de::array::ArraySeqAccess as serde::de::SeqAccess<'de>>::next_element_seed":{"T":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<de::array::ArraySeqAccess as serde::de::SeqAccess<'de>>::next_element_seed":{"T":["std::marker::PhantomData<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::array::ArraySeqAccess
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_element_seed(p1);
+<de::array::ArraySeqAccess as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+crate::<de::array::ArraySeqAccess as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+<de::array::ArraySeqAccess>::next_element_seed(p0, p1);
-----------------
crates/toml_edit/src/de/datetime.rs de::datetime::DatetimeDeserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_datetime::Datetime
+de::datetime::DatetimeDeserializer::new(p0);
+crate::de::datetime::DatetimeDeserializer::new(p0);
+<de::datetime::DatetimeDeserializer>::new(p0);
-----------------
crates/toml_edit/src/de/datetime.rs <de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_key_seed
'de
deps:{"<de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_key_seed":{"K":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_key_seed":{"K":["std::marker::PhantomData<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::datetime::DatetimeDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.next_key_seed(p1);
+<de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+crate::<de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+<de::datetime::DatetimeDeserializer>::next_key_seed(p0, p1);
-----------------
crates/toml_edit/src/de/datetime.rs <de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_value_seed
'de
deps:{"<de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_value_seed":{"V":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_value_seed":{"V":["std::marker::PhantomData<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::datetime::DatetimeDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.next_value_seed(p1);
+<de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+crate::<de::datetime::DatetimeDeserializer as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+<de::datetime::DatetimeDeserializer>::next_value_seed(p0, p1);
-----------------
crates/toml_edit/src/de/key.rs de::key::KeyDeserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::ops::Range<usize>>
+de::key::KeyDeserializer::new(p0, p1);
+crate::de::key::KeyDeserializer::new(p0, p1);
+<de::key::KeyDeserializer>::new(p0, p1);
-----------------
crates/toml_edit/src/de/key.rs <de::key::KeyDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
+p0.into_deserializer();
+<de::key::KeyDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+crate::<de::key::KeyDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+<de::key::KeyDeserializer>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/key.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<de::key::KeyDeserializer>::deserialize_any(p0, p1);
-----------------
crates/toml_edit/src/de/key.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<de::key::KeyDeserializer>::deserialize_enum(p0, &p1, p2, p3);
-----------------
crates/toml_edit/src/de/key.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<de::key::KeyDeserializer>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<de::key::KeyDeserializer>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<de::key::KeyDeserializer>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<de::key::KeyDeserializer>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<de::key::KeyDeserializer>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<de::key::KeyDeserializer>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<de::key::KeyDeserializer>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<de::key::KeyDeserializer>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<de::key::KeyDeserializer>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<de::key::KeyDeserializer>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<de::key::KeyDeserializer>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<de::key::KeyDeserializer>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<de::key::KeyDeserializer>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<de::key::KeyDeserializer>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<de::key::KeyDeserializer>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<de::key::KeyDeserializer>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<de::key::KeyDeserializer>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<de::key::KeyDeserializer>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<de::key::KeyDeserializer>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<de::key::KeyDeserializer>::deserialize_option(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<de::key::KeyDeserializer>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<de::key::KeyDeserializer>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<de::key::KeyDeserializer>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<de::key::KeyDeserializer>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<de::key::KeyDeserializer>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<de::key::KeyDeserializer>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<de::key::KeyDeserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<de::key::KeyDeserializer>::deserialize_identifier(p0, p1);
-----------------
crates/toml_edit/src/de/key.rs <de::key::KeyDeserializer as serde::de::EnumAccess<'de>>::variant_seed
'de
deps:{"<de::key::KeyDeserializer as serde::de::EnumAccess<'de>>::variant_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<de::key::KeyDeserializer as serde::de::EnumAccess<'de>>::variant_seed":{"T":["std::marker::PhantomData<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::KeyDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.variant_seed(p1);
+<de::key::KeyDeserializer as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+crate::<de::key::KeyDeserializer as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+<de::key::KeyDeserializer>::variant_seed(p0, p1);
-----------------
crates/toml_edit/src/de/key.rs <de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::unit_variant
'de
deps:{"<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::unit_variant":{"E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::unit_variant":{"E":["de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::UnitOnly<E>
+p0.unit_variant();
+<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::unit_variant(p0);
+crate::<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::unit_variant(p0);
+<de::key::UnitOnly<E>>::unit_variant(p0);
-----------------
crates/toml_edit/src/de/key.rs <de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::newtype_variant_seed
'de
deps:{"<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"E":["serde::de::Error","std::marker::Sized"],"T":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"E":["de::Error"],"T":["std::marker::PhantomData<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::UnitOnly<E>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.newtype_variant_seed(p1);
+<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+crate::<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+<de::key::UnitOnly<E>>::newtype_variant_seed(p0, p1);
-----------------
crates/toml_edit/src/de/key.rs <de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::tuple_variant
'de
deps:{"<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::tuple_variant":{"E":["std::marker::Sized","serde::de::Error"],"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::tuple_variant":{"E":["de::Error"],"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::UnitOnly<E>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.tuple_variant(p1, p2);
+<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+crate::<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+<de::key::UnitOnly<E>>::tuple_variant(p0, p1, p2);
-----------------
crates/toml_edit/src/de/key.rs <de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::struct_variant
'de
deps:{"<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::struct_variant":{"E":["serde::de::Error","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::struct_variant":{"E":["de::Error"],"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::key::UnitOnly<E>
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.struct_variant(p1, p2);
+<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+crate::<de::key::UnitOnly<E> as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+<de::key::UnitOnly<E>>::struct_variant(p0, p1, p2);
-----------------
crates/toml_edit/src/de/spanned.rs de::spanned::SpannedDeserializer::<'de, T>::new
'de
deps:{"de::spanned::SpannedDeserializer::<'de, T>::new":{"T":["std::marker::Sized","serde::de::IntoDeserializer"]}}
candidates:{"de::spanned::SpannedDeserializer::<'de, T>::new":{"T":["value::Value","de::table::TableDeserializer","de::Deserializer","document::Document","de::key::KeyDeserializer","de::array::ArrayDeserializer","de::value::ValueDeserializer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+de::spanned::SpannedDeserializer::<'de, T>::new(p0, p1);
+crate::de::spanned::SpannedDeserializer::<'de, T>::new(p0, p1);
+<de::spanned::SpannedDeserializer<'de, T>>::new(p0, p1);
-----------------
crates/toml_edit/src/de/spanned.rs <de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_key_seed
'de
deps:{"<de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_key_seed":{"K":["std::marker::Sized","serde::de::DeserializeSeed"],"T":["std::marker::Sized","serde::de::IntoDeserializer"]}}
candidates:{"<de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_key_seed":{"K":["std::marker::PhantomData<T>"],"T":["de::table::TableDeserializer","de::Deserializer","de::value::ValueDeserializer","document::Document","de::key::KeyDeserializer","de::array::ArrayDeserializer","value::Value"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::spanned::SpannedDeserializer<'de, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.next_key_seed(p1);
+<de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+crate::<de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+<de::spanned::SpannedDeserializer<'de, T>>::next_key_seed(p0, p1);
-----------------
crates/toml_edit/src/de/spanned.rs <de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_value_seed
'de
deps:{"<de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_value_seed":{"T":["std::marker::Sized","serde::de::IntoDeserializer"],"V":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_value_seed":{"T":["de::key::KeyDeserializer","document::Document","value::Value","de::array::ArrayDeserializer","de::Deserializer","de::table::TableDeserializer","de::value::ValueDeserializer"],"V":["std::marker::PhantomData<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::spanned::SpannedDeserializer<'de, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.next_value_seed(p1);
+<de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+crate::<de::spanned::SpannedDeserializer<'de, T> as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+<de::spanned::SpannedDeserializer<'de, T>>::next_value_seed(p0, p1);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<de::table::TableDeserializer>::deserialize_any(p0, p1);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<de::table::TableDeserializer>::deserialize_option(p0, p1);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<de::table::TableDeserializer>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<de::table::TableDeserializer>::deserialize_struct(p0, &p1, p2, p3);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<de::table::TableDeserializer>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<de::table::TableDeserializer>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<de::table::TableDeserializer>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<de::table::TableDeserializer>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<de::table::TableDeserializer>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<de::table::TableDeserializer>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<de::table::TableDeserializer>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<de::table::TableDeserializer>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<de::table::TableDeserializer>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<de::table::TableDeserializer>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<de::table::TableDeserializer>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<de::table::TableDeserializer>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<de::table::TableDeserializer>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<de::table::TableDeserializer>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<de::table::TableDeserializer>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<de::table::TableDeserializer>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<de::table::TableDeserializer>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<de::table::TableDeserializer>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<de::table::TableDeserializer>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<de::table::TableDeserializer>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<de::table::TableDeserializer>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<de::table::TableDeserializer>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<de::table::TableDeserializer>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<de::table::TableDeserializer>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<de::table::TableDeserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<de::table::TableDeserializer>::deserialize_identifier(p0, p1);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
+p0.into_deserializer();
+<de::table::TableDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+crate::<de::table::TableDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+<de::table::TableDeserializer>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/table.rs de::table::<impl table::Table>::into_deserializer
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Table
+p0.into_deserializer();
+de::table::<impl table::Table>::into_deserializer(p0);
+crate::de::table::<impl table::Table>::into_deserializer(p0);
+<table::Table>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/table.rs de::table::<impl inline_table::InlineTable>::into_deserializer
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.into_deserializer();
+de::table::<impl inline_table::InlineTable>::into_deserializer(p0);
+crate::de::table::<impl inline_table::InlineTable>::into_deserializer(p0);
+<inline_table::InlineTable>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/table.rs de::table::TableMapAccess::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableDeserializer
+de::table::TableMapAccess::new(p0);
+crate::de::table::TableMapAccess::new(p0);
+<de::table::TableMapAccess>::new(p0);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_key_seed
'de
deps:{"<de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_key_seed":{"K":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_key_seed":{"K":["std::marker::PhantomData<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::table::TableMapAccess
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.next_key_seed(p1);
+<de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+crate::<de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+<de::table::TableMapAccess>::next_key_seed(p0, p1);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_value_seed
'de
deps:{"<de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_value_seed":{"V":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_value_seed":{"V":["std::marker::PhantomData<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::table::TableMapAccess
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.next_value_seed(p1);
+<de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+crate::<de::table::TableMapAccess as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+<de::table::TableMapAccess>::next_value_seed(p0, p1);
-----------------
crates/toml_edit/src/de/table.rs <de::table::TableMapAccess as serde::de::EnumAccess<'de>>::variant_seed
'de
deps:{"<de::table::TableMapAccess as serde::de::EnumAccess<'de>>::variant_seed":{"V":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<de::table::TableMapAccess as serde::de::EnumAccess<'de>>::variant_seed":{"V":["std::marker::PhantomData<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table::TableMapAccess
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.variant_seed(p1);
+<de::table::TableMapAccess as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+crate::<de::table::TableMapAccess as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+<de::table::TableMapAccess>::variant_seed(p0, p1);
-----------------
crates/toml_edit/src/de/table_enum.rs de::table_enum::TableEnumDeserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+de::table_enum::TableEnumDeserializer::new(p0);
+crate::de::table_enum::TableEnumDeserializer::new(p0);
+<de::table_enum::TableEnumDeserializer>::new(p0);
-----------------
crates/toml_edit/src/de/table_enum.rs <de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table_enum::TableEnumDeserializer
+p0.unit_variant();
+<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant(p0);
+crate::<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant(p0);
+<de::table_enum::TableEnumDeserializer>::unit_variant(p0);
-----------------
crates/toml_edit/src/de/table_enum.rs <de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed
'de
deps:{"<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["std::marker::PhantomData<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table_enum::TableEnumDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.newtype_variant_seed(p1);
+<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+crate::<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+<de::table_enum::TableEnumDeserializer>::newtype_variant_seed(p0, p1);
-----------------
crates/toml_edit/src/de/table_enum.rs <de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant
'de
deps:{"<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table_enum::TableEnumDeserializer
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.tuple_variant(p1, p2);
+<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+crate::<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+<de::table_enum::TableEnumDeserializer>::tuple_variant(p0, p1, p2);
-----------------
crates/toml_edit/src/de/table_enum.rs <de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant
'de
deps:{"<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::table_enum::TableEnumDeserializer
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.struct_variant(p1, p2);
+<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+crate::<de::table_enum::TableEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+<de::table_enum::TableEnumDeserializer>::struct_variant(p0, p1, p2);
-----------------
crates/toml_edit/src/de/value.rs de::value::ValueDeserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+de::value::ValueDeserializer::new(p0);
+crate::de::value::ValueDeserializer::new(p0);
+<de::value::ValueDeserializer>::new(p0);
-----------------
crates/toml_edit/src/de/value.rs de::value::ValueDeserializer::with_struct_key_validation
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
+p0.with_struct_key_validation();
+de::value::ValueDeserializer::with_struct_key_validation(p0);
+crate::de::value::ValueDeserializer::with_struct_key_validation(p0);
+<de::value::ValueDeserializer>::with_struct_key_validation(p0);
-----------------
crates/toml_edit/src/de/value.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<de::value::ValueDeserializer>::deserialize_any(p0, p1);
-----------------
crates/toml_edit/src/de/value.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<de::value::ValueDeserializer>::deserialize_option(p0, p1);
-----------------
crates/toml_edit/src/de/value.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<de::value::ValueDeserializer>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/de/value.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<de::value::ValueDeserializer>::deserialize_struct(p0, &p1, p2, p3);
-----------------
crates/toml_edit/src/de/value.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<de::value::ValueDeserializer>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<de::value::ValueDeserializer>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<de::value::ValueDeserializer>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<de::value::ValueDeserializer>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<de::value::ValueDeserializer>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<de::value::ValueDeserializer>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<de::value::ValueDeserializer>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<de::value::ValueDeserializer>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<de::value::ValueDeserializer>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<de::value::ValueDeserializer>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<de::value::ValueDeserializer>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<de::value::ValueDeserializer>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<de::value::ValueDeserializer>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<de::value::ValueDeserializer>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<de::value::ValueDeserializer>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<de::value::ValueDeserializer>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<de::value::ValueDeserializer>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<de::value::ValueDeserializer>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<de::value::ValueDeserializer>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<de::value::ValueDeserializer>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<de::value::ValueDeserializer>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<de::value::ValueDeserializer>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<de::value::ValueDeserializer>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<de::value::ValueDeserializer>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<de::value::ValueDeserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<de::value::ValueDeserializer>::deserialize_identifier(p0, p1);
-----------------
crates/toml_edit/src/de/value.rs <de::value::ValueDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::value::ValueDeserializer
+p0.into_deserializer();
+<de::value::ValueDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+crate::<de::value::ValueDeserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+<de::value::ValueDeserializer>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/value.rs de::value::<impl serde::de::IntoDeserializer<'de, de::Error> for value::Value>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.into_deserializer();
+de::value::<impl serde::de::IntoDeserializer<'de, de::Error> for value::Value>::into_deserializer(p0);
+crate::de::value::<impl serde::de::IntoDeserializer<'de, de::Error> for value::Value>::into_deserializer(p0);
+<value::Value>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/value.rs de::value::<impl item::Item>::into_deserializer
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.into_deserializer();
+de::value::<impl item::Item>::into_deserializer(p0);
+crate::de::value::<impl item::Item>::into_deserializer(p0);
+<item::Item>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/value.rs <de::value::ValueDeserializer as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<de::value::ValueDeserializer as std::str::FromStr>::from_str(&p0);
+crate::<de::value::ValueDeserializer as std::str::FromStr>::from_str(&p0);
+<de::value::ValueDeserializer>::from_str(&p0);
-----------------
crates/toml_edit/src/de/mod.rs <de::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<de::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<de::Error as std::fmt::Debug>::fmt(p0, p1);
+<de::Error>::fmt(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs <de::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.clone();
+<de::Error as std::clone::Clone>::clone(p0);
+crate::<de::Error as std::clone::Clone>::clone(p0);
+<de::Error>::clone(p0);
-----------------
crates/toml_edit/src/de/mod.rs <de::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.eq(p1);
+<de::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<de::Error as std::cmp::PartialEq>::eq(p0, p1);
+<de::Error>::eq(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs <de::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.assert_receiver_is_total_eq();
+<de::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<de::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<de::Error>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::Error::custom
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"de::Error::custom":{"T":["std::marker::Sized","std::fmt::Display"]},"repr::Formatted":{"T":["std::hash::Hash","repr::ValueRepr","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"de::Error::custom":{"T":["de::Error","<&T as std::fmt::Display>","repr::Formatted","array_of_tables::ArrayOfTables","parser::errors::ParserError","array::Array","document::Document","parser::errors::CustomError","internal_string::InternalString","parser::errors::TomlError","value::Value","inline_table::InlineTable","key::Key","key::KeyMut","<&mut T as std::fmt::Display>","parser::errors::ParserValue","table::Table","ser::Error","item::Item"]},"repr::Formatted":{"T":["bool","i64"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::ops::Range<usize>>
+de::Error::custom(p0, p1);
+crate::de::Error::custom(p0, p1);
+<de::Error>::custom(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs de::Error::add_key
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = std::string::String::new(); // None+std::string::String
+p0.add_key(p1);
+de::Error::add_key(p0, p1);
+crate::de::Error::add_key(p0, p1);
+<de::Error>::add_key(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs de::Error::message
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.message();
+de::Error::message(p0);
+crate::de::Error::message(p0);
+<de::Error>::message(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::Error::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.span();
+de::Error::span(p0);
+crate::de::Error::span(p0);
+<de::Error>::span(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::Error::set_span
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::ops::Range<usize>>
+p0.set_span(p1);
+de::Error::set_span(p0, p1);
+crate::de::Error::set_span(p0, p1);
+<de::Error>::set_span(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs <de::Error as serde::de::Error>::custom
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<de::Error as serde::de::Error>::custom":{"T":["std::marker::Sized","std::fmt::Display"]},"repr::Formatted":{"T":["repr::ValueRepr","std::hash::Hash","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<de::Error as serde::de::Error>::custom":{"T":["key::KeyMut","parser::errors::ParserError","<&T as std::fmt::Display>","inline_table::InlineTable","value::Value","array_of_tables::ArrayOfTables","parser::errors::CustomError","document::Document","internal_string::InternalString","ser::Error","item::Item","key::Key","table::Table","parser::errors::TomlError","repr::Formatted","de::Error","<&mut T as std::fmt::Display>","parser::errors::ParserValue","array::Array"]},"repr::Formatted":{"T":["i64","bool"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<de::Error as serde::de::Error>::custom(p0);
+crate::<de::Error as serde::de::Error>::custom(p0);
+<de::Error>::custom(p0);
-----------------
crates/toml_edit/src/de/mod.rs <de::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<de::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<de::Error as std::fmt::Display>::fmt(p0, p1);
+<de::Error>::fmt(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs <de::Error as std::convert::From<parser::errors::TomlError>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+<de::Error as std::convert::From<parser::errors::TomlError>>::from(p0);
+crate::<de::Error as std::convert::From<parser::errors::TomlError>>::from(p0);
+<de::Error>::from(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::<impl std::convert::From<de::Error> for parser::errors::TomlError>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Error
+de::<impl std::convert::From<de::Error> for parser::errors::TomlError>::from(p0);
+crate::de::<impl std::convert::From<de::Error> for parser::errors::TomlError>::from(p0);
+<parser::errors::TomlError>::from(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::Deserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // document::Document
+de::Deserializer::new(p0);
+crate::de::Deserializer::new(p0);
+<de::Deserializer>::new(p0);
-----------------
crates/toml_edit/src/de/mod.rs <de::Deserializer as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<de::Deserializer as std::str::FromStr>::from_str(&p0);
+crate::<de::Deserializer as std::str::FromStr>::from_str(&p0);
+<de::Deserializer>::from_str(&p0);
-----------------
crates/toml_edit/src/de/mod.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<de::Deserializer>::deserialize_any(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_option":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<de::Deserializer>::deserialize_option(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<de::Deserializer>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/de/mod.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<de::Deserializer>::deserialize_struct(p0, &p1, p2, p3);
-----------------
crates/toml_edit/src/de/mod.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_enum":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<de::Deserializer>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_bool":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<de::Deserializer>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_u8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<de::Deserializer>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_u16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<de::Deserializer>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_u32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<de::Deserializer>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_u64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<de::Deserializer>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_i8":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<de::Deserializer>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_i16":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<de::Deserializer>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_i32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<de::Deserializer>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_i64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<de::Deserializer>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_f32":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<de::Deserializer>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_f64":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<de::Deserializer>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_char":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<de::Deserializer>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_str":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<de::Deserializer>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_string":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<de::Deserializer>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_seq":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<de::Deserializer>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_bytes":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<de::Deserializer>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<de::Deserializer>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_map":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<de::Deserializer>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_unit":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<de::Deserializer>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<de::Deserializer>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<de::Deserializer>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<de::Deserializer>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<de::Deserializer>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer as serde::Deserializer<'de>>::deserialize_identifier":{"V":["internal_string::StringVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<de::Deserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<de::Deserializer as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<de::Deserializer>::deserialize_identifier(p0, p1);
-----------------
crates/toml_edit/src/de/mod.rs <de::Deserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer
+p0.into_deserializer();
+<de::Deserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+crate::<de::Deserializer as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+<de::Deserializer>::into_deserializer(p0);
-----------------
crates/toml_edit/src/de/mod.rs de::<impl serde::de::IntoDeserializer<'de, de::Error> for document::Document>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // document::Document
+p0.into_deserializer();
+de::<impl serde::de::IntoDeserializer<'de, de::Error> for document::Document>::into_deserializer(p0);
+crate::de::<impl serde::de::IntoDeserializer<'de, de::Error> for document::Document>::into_deserializer(p0);
+<document::Document>::into_deserializer(p0);
-----------------
crates/toml_edit/src/ser/array.rs ser::array::SerializeValueArray::new
deps:{}
candidates:{}
+ser::array::SerializeValueArray::new();
+crate::ser::array::SerializeValueArray::new();
+<ser::array::SerializeValueArray>::new();
-----------------
crates/toml_edit/src/ser/array.rs ser::array::SerializeValueArray::with_capacity
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+ser::array::SerializeValueArray::with_capacity(p0);
+crate::ser::array::SerializeValueArray::with_capacity(p0);
+<ser::array::SerializeValueArray>::with_capacity(p0);
-----------------
crates/toml_edit/src/ser/array.rs <ser::array::SerializeValueArray as serde::ser::SerializeSeq>::serialize_element
deps:{"<ser::array::SerializeValueArray as serde::ser::SerializeSeq>::serialize_element":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::array::SerializeValueArray as serde::ser::SerializeSeq>::serialize_element":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::array::SerializeValueArray
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<ser::array::SerializeValueArray as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+crate::<ser::array::SerializeValueArray as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+<ser::array::SerializeValueArray>::serialize_element(p0, p1);
-----------------
crates/toml_edit/src/ser/array.rs <ser::array::SerializeValueArray as serde::ser::SerializeSeq>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::array::SerializeValueArray
+p0.end();
+<ser::array::SerializeValueArray as serde::ser::SerializeSeq>::end(p0);
+crate::<ser::array::SerializeValueArray as serde::ser::SerializeSeq>::end(p0);
+<ser::array::SerializeValueArray>::end(p0);
-----------------
crates/toml_edit/src/ser/array.rs <ser::array::SerializeValueArray as serde::ser::SerializeTuple>::serialize_element
deps:{"<ser::array::SerializeValueArray as serde::ser::SerializeTuple>::serialize_element":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::array::SerializeValueArray as serde::ser::SerializeTuple>::serialize_element":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::array::SerializeValueArray
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<ser::array::SerializeValueArray as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+crate::<ser::array::SerializeValueArray as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+<ser::array::SerializeValueArray>::serialize_element(p0, p1);
-----------------
crates/toml_edit/src/ser/array.rs <ser::array::SerializeValueArray as serde::ser::SerializeTuple>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::array::SerializeValueArray
+p0.end();
+<ser::array::SerializeValueArray as serde::ser::SerializeTuple>::end(p0);
+crate::<ser::array::SerializeValueArray as serde::ser::SerializeTuple>::end(p0);
+<ser::array::SerializeValueArray>::end(p0);
-----------------
crates/toml_edit/src/ser/array.rs <ser::array::SerializeValueArray as serde::ser::SerializeTupleVariant>::serialize_field
deps:{"<ser::array::SerializeValueArray as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::array::SerializeValueArray as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::array::SerializeValueArray
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<ser::array::SerializeValueArray as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+crate::<ser::array::SerializeValueArray as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+<ser::array::SerializeValueArray>::serialize_field(p0, p1);
-----------------
crates/toml_edit/src/ser/array.rs <ser::array::SerializeValueArray as serde::ser::SerializeTupleVariant>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::array::SerializeValueArray
+p0.end();
+<ser::array::SerializeValueArray as serde::ser::SerializeTupleVariant>::end(p0);
+crate::<ser::array::SerializeValueArray as serde::ser::SerializeTupleVariant>::end(p0);
+<ser::array::SerializeValueArray>::end(p0);
-----------------
crates/toml_edit/src/ser/array.rs <ser::array::SerializeValueArray as serde::ser::SerializeTupleStruct>::serialize_field
deps:{"<ser::array::SerializeValueArray as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::array::SerializeValueArray as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::array::SerializeValueArray
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<ser::array::SerializeValueArray as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+crate::<ser::array::SerializeValueArray as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+<ser::array::SerializeValueArray>::serialize_field(p0, p1);
-----------------
crates/toml_edit/src/ser/array.rs <ser::array::SerializeValueArray as serde::ser::SerializeTupleStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::array::SerializeValueArray
+p0.end();
+<ser::array::SerializeValueArray as serde::ser::SerializeTupleStruct>::end(p0);
+crate::<ser::array::SerializeValueArray as serde::ser::SerializeTupleStruct>::end(p0);
+<ser::array::SerializeValueArray>::end(p0);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_bool
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_bool(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_bool(p0, p1);
+<ser::key::KeySerializer>::serialize_bool(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_i8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_i8(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_i8(p0, p1);
+<ser::key::KeySerializer>::serialize_i8(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_i16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_i16(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_i16(p0, p1);
+<ser::key::KeySerializer>::serialize_i16(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_i32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_i32(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_i32(p0, p1);
+<ser::key::KeySerializer>::serialize_i32(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_i64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_i64(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_i64(p0, p1);
+<ser::key::KeySerializer>::serialize_i64(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_u8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_u8(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_u8(p0, p1);
+<ser::key::KeySerializer>::serialize_u8(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_u16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_u16(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_u16(p0, p1);
+<ser::key::KeySerializer>::serialize_u16(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_u32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_u32(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_u32(p0, p1);
+<ser::key::KeySerializer>::serialize_u32(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_u64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_u64(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_u64(p0, p1);
+<ser::key::KeySerializer>::serialize_u64(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_f32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_f32(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_f32(p0, p1);
+<ser::key::KeySerializer>::serialize_f32(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_f64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_f64(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_f64(p0, p1);
+<ser::key::KeySerializer>::serialize_f64(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_char(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_char(p0, p1);
+<ser::key::KeySerializer>::serialize_char(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_str
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_str(p0, &p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_str(p0, &p1);
+<ser::key::KeySerializer>::serialize_str(p0, &p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_bytes(p0, p1);
+<ser::key::KeySerializer>::serialize_bytes(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
+p0.serialize_none();
+<ser::key::KeySerializer as serde::Serializer>::serialize_none(p0);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_none(p0);
+<ser::key::KeySerializer>::serialize_none(p0);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_some
deps:{"<ser::key::KeySerializer as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::key::KeySerializer as serde::Serializer>::serialize_some":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_some(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_some(p0, p1);
+<ser::key::KeySerializer>::serialize_some(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_unit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
+p0.serialize_unit();
+<ser::key::KeySerializer as serde::Serializer>::serialize_unit(p0);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_unit(p0);
+<ser::key::KeySerializer>::serialize_unit(p0);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_unit_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<ser::key::KeySerializer>::serialize_unit_struct(p0, &p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_unit_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<ser::key::KeySerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<ser::key::KeySerializer>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_newtype_struct
deps:{"<ser::key::KeySerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::key::KeySerializer as serde::Serializer>::serialize_newtype_struct":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<ser::key::KeySerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<ser::key::KeySerializer>::serialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_newtype_variant
deps:{"<ser::key::KeySerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::key::KeySerializer as serde::Serializer>::serialize_newtype_variant":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<ser::key::KeySerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<ser::key::KeySerializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_seq
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_seq(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_seq(p0, p1);
+<ser::key::KeySerializer>::serialize_seq(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_tuple
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_tuple(p0, p1);
+<ser::key::KeySerializer>::serialize_tuple(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_tuple_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<ser::key::KeySerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<ser::key::KeySerializer>::serialize_tuple_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_tuple_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<ser::key::KeySerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<ser::key::KeySerializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_map
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<ser::key::KeySerializer as serde::Serializer>::serialize_map(p0, p1);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_map(p0, p1);
+<ser::key::KeySerializer>::serialize_map(p0, p1);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<ser::key::KeySerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<ser::key::KeySerializer>::serialize_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/key.rs <ser::key::KeySerializer as serde::Serializer>::serialize_struct_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::key::KeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<ser::key::KeySerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::key::KeySerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<ser::key::KeySerializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/map.rs ser::map::SerializeMap::table
deps:{}
candidates:{}
+ser::map::SerializeMap::table();
+crate::ser::map::SerializeMap::table();
+<ser::map::SerializeMap>::table();
-----------------
crates/toml_edit/src/ser/map.rs ser::map::SerializeMap::table_with_capacity
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+ser::map::SerializeMap::table_with_capacity(p0);
+crate::ser::map::SerializeMap::table_with_capacity(p0);
+<ser::map::SerializeMap>::table_with_capacity(p0);
-----------------
crates/toml_edit/src/ser/map.rs ser::map::SerializeMap::datetime
deps:{}
candidates:{}
+ser::map::SerializeMap::datetime();
+crate::ser::map::SerializeMap::datetime();
+<ser::map::SerializeMap>::datetime();
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_key
deps:{"<ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_key":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_key":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<ser::map::SerializeMap>::serialize_key(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_value
deps:{"<ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_value":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_value":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<ser::map::SerializeMap as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<ser::map::SerializeMap>::serialize_value(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeMap as serde::ser::SerializeMap>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::SerializeMap
+p0.end();
+<ser::map::SerializeMap as serde::ser::SerializeMap>::end(p0);
+crate::<ser::map::SerializeMap as serde::ser::SerializeMap>::end(p0);
+<ser::map::SerializeMap>::end(p0);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeMap as serde::ser::SerializeStruct>::serialize_field
deps:{"<ser::map::SerializeMap as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeMap as serde::ser::SerializeStruct>::serialize_field":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeMap
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<ser::map::SerializeMap as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<ser::map::SerializeMap as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<ser::map::SerializeMap>::serialize_field(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeMap as serde::ser::SerializeStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::SerializeMap
+p0.end();
+<ser::map::SerializeMap as serde::ser::SerializeStruct>::end(p0);
+crate::<ser::map::SerializeMap as serde::ser::SerializeStruct>::end(p0);
+<ser::map::SerializeMap>::end(p0);
-----------------
crates/toml_edit/src/ser/map.rs ser::map::SerializeDatetime::new
deps:{}
candidates:{}
+ser::map::SerializeDatetime::new();
+crate::ser::map::SerializeDatetime::new();
+<ser::map::SerializeDatetime>::new();
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_key
deps:{"<ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_key":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_key":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeDatetime
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<ser::map::SerializeDatetime>::serialize_key(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_value
deps:{"<ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_value":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_value":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeDatetime
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<ser::map::SerializeDatetime as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<ser::map::SerializeDatetime>::serialize_value(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeDatetime as serde::ser::SerializeMap>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::SerializeDatetime
+p0.end();
+<ser::map::SerializeDatetime as serde::ser::SerializeMap>::end(p0);
+crate::<ser::map::SerializeDatetime as serde::ser::SerializeMap>::end(p0);
+<ser::map::SerializeDatetime>::end(p0);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeDatetime as serde::ser::SerializeStruct>::serialize_field
deps:{"<ser::map::SerializeDatetime as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeDatetime as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeDatetime
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<ser::map::SerializeDatetime as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<ser::map::SerializeDatetime as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<ser::map::SerializeDatetime>::serialize_field(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeDatetime as serde::ser::SerializeStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::SerializeDatetime
+p0.end();
+<ser::map::SerializeDatetime as serde::ser::SerializeStruct>::end(p0);
+crate::<ser::map::SerializeDatetime as serde::ser::SerializeStruct>::end(p0);
+<ser::map::SerializeDatetime>::end(p0);
-----------------
crates/toml_edit/src/ser/map.rs ser::map::SerializeInlineTable::new
deps:{}
candidates:{}
+ser::map::SerializeInlineTable::new();
+crate::ser::map::SerializeInlineTable::new();
+<ser::map::SerializeInlineTable>::new();
-----------------
crates/toml_edit/src/ser/map.rs ser::map::SerializeInlineTable::with_capacity
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+ser::map::SerializeInlineTable::with_capacity(p0);
+crate::ser::map::SerializeInlineTable::with_capacity(p0);
+<ser::map::SerializeInlineTable>::with_capacity(p0);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_key
deps:{"<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_key":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_key":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeInlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<ser::map::SerializeInlineTable>::serialize_key(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_value
deps:{"<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_value":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_value":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeInlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<ser::map::SerializeInlineTable>::serialize_value(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeInlineTable as serde::ser::SerializeMap>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::SerializeInlineTable
+p0.end();
+<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::end(p0);
+crate::<ser::map::SerializeInlineTable as serde::ser::SerializeMap>::end(p0);
+<ser::map::SerializeInlineTable>::end(p0);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeInlineTable as serde::ser::SerializeStruct>::serialize_field
deps:{"<ser::map::SerializeInlineTable as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::SerializeInlineTable as serde::ser::SerializeStruct>::serialize_field":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::map::SerializeInlineTable
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<ser::map::SerializeInlineTable as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<ser::map::SerializeInlineTable as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<ser::map::SerializeInlineTable>::serialize_field(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::SerializeInlineTable as serde::ser::SerializeStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::SerializeInlineTable
+p0.end();
+<ser::map::SerializeInlineTable as serde::ser::SerializeStruct>::end(p0);
+crate::<ser::map::SerializeInlineTable as serde::ser::SerializeStruct>::end(p0);
+<ser::map::SerializeInlineTable>::end(p0);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as std::default::Default>::default
deps:{}
candidates:{}
+<ser::map::DatetimeFieldSerializer as std::default::Default>::default();
+crate::<ser::map::DatetimeFieldSerializer as std::default::Default>::default();
+<ser::map::DatetimeFieldSerializer>::default();
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_bool
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_bool(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_bool(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_bool(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i8(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i8(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_i8(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i16(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i16(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_i16(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i32(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i32(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_i32(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i64(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_i64(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_i64(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u8(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u8(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_u8(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u16(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u16(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_u16(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u32(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u32(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_u32(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u64(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_u64(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_u64(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_f32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_f32(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_f32(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_f32(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_f64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_f64(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_f64(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_f64(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_char(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_char(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_char(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_str
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_str(p0, &p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_str(p0, &p1);
+<ser::map::DatetimeFieldSerializer>::serialize_str(p0, &p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_bytes(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_bytes(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
+p0.serialize_none();
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_none(p0);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_none(p0);
+<ser::map::DatetimeFieldSerializer>::serialize_none(p0);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_some
deps:{"<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_some":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_some(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_some(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_some(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
+p0.serialize_unit();
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit(p0);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit(p0);
+<ser::map::DatetimeFieldSerializer>::serialize_unit(p0);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<ser::map::DatetimeFieldSerializer>::serialize_unit_struct(p0, &p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<ser::map::DatetimeFieldSerializer>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_struct
deps:{"<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<ser::map::DatetimeFieldSerializer>::serialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_variant
deps:{"<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<ser::map::DatetimeFieldSerializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_seq
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_seq(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_seq(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_seq(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_tuple(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<ser::map::DatetimeFieldSerializer>::serialize_tuple_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<ser::map::DatetimeFieldSerializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_map
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_map(p0, p1);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_map(p0, p1);
+<ser::map::DatetimeFieldSerializer>::serialize_map(p0, p1);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<ser::map::DatetimeFieldSerializer>::serialize_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/map.rs <ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_struct_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::map::DatetimeFieldSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::map::DatetimeFieldSerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<ser::map::DatetimeFieldSerializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/pretty.rs <ser::pretty::Pretty as visit_mut::VisitMut>::visit_document_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::pretty::Pretty
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.visit_document_mut(p1);
+<ser::pretty::Pretty as visit_mut::VisitMut>::visit_document_mut(p0, p1);
+crate::<ser::pretty::Pretty as visit_mut::VisitMut>::visit_document_mut(p0, p1);
+<ser::pretty::Pretty>::visit_document_mut(p0, p1);
-----------------
crates/toml_edit/src/ser/pretty.rs <ser::pretty::Pretty as visit_mut::VisitMut>::visit_item_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::pretty::Pretty
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_item_mut(p1);
+<ser::pretty::Pretty as visit_mut::VisitMut>::visit_item_mut(p0, p1);
+crate::<ser::pretty::Pretty as visit_mut::VisitMut>::visit_item_mut(p0, p1);
+<ser::pretty::Pretty>::visit_item_mut(p0, p1);
-----------------
crates/toml_edit/src/ser/pretty.rs <ser::pretty::Pretty as visit_mut::VisitMut>::visit_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::pretty::Pretty
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.visit_table_mut(p1);
+<ser::pretty::Pretty as visit_mut::VisitMut>::visit_table_mut(p0, p1);
+crate::<ser::pretty::Pretty as visit_mut::VisitMut>::visit_table_mut(p0, p1);
+<ser::pretty::Pretty>::visit_table_mut(p0, p1);
-----------------
crates/toml_edit/src/ser/pretty.rs <ser::pretty::Pretty as visit_mut::VisitMut>::visit_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::pretty::Pretty
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.visit_value_mut(p1);
+<ser::pretty::Pretty as visit_mut::VisitMut>::visit_value_mut(p0, p1);
+crate::<ser::pretty::Pretty as visit_mut::VisitMut>::visit_value_mut(p0, p1);
+<ser::pretty::Pretty>::visit_value_mut(p0, p1);
-----------------
crates/toml_edit/src/ser/pretty.rs <ser::pretty::Pretty as visit_mut::VisitMut>::visit_array_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::pretty::Pretty
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.visit_array_mut(p1);
+<ser::pretty::Pretty as visit_mut::VisitMut>::visit_array_mut(p0, p1);
+crate::<ser::pretty::Pretty as visit_mut::VisitMut>::visit_array_mut(p0, p1);
+<ser::pretty::Pretty>::visit_array_mut(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as std::default::Default>::default
deps:{}
candidates:{}
+<ser::value::ValueSerializer as std::default::Default>::default();
+crate::<ser::value::ValueSerializer as std::default::Default>::default();
+<ser::value::ValueSerializer>::default();
-----------------
crates/toml_edit/src/ser/value.rs ser::value::ValueSerializer::new
deps:{}
candidates:{}
+ser::value::ValueSerializer::new();
+crate::ser::value::ValueSerializer::new();
+<ser::value::ValueSerializer>::new();
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_bool
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_bool(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_bool(p0, p1);
+<ser::value::ValueSerializer>::serialize_bool(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_i8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_i8(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_i8(p0, p1);
+<ser::value::ValueSerializer>::serialize_i8(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_i16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_i16(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_i16(p0, p1);
+<ser::value::ValueSerializer>::serialize_i16(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_i32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_i32(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_i32(p0, p1);
+<ser::value::ValueSerializer>::serialize_i32(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_i64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_i64(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_i64(p0, p1);
+<ser::value::ValueSerializer>::serialize_i64(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_u8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_u8(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_u8(p0, p1);
+<ser::value::ValueSerializer>::serialize_u8(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_u16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_u16(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_u16(p0, p1);
+<ser::value::ValueSerializer>::serialize_u16(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_u32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_u32(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_u32(p0, p1);
+<ser::value::ValueSerializer>::serialize_u32(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_u64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_u64(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_u64(p0, p1);
+<ser::value::ValueSerializer>::serialize_u64(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_f32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_f32(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_f32(p0, p1);
+<ser::value::ValueSerializer>::serialize_f32(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_f64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_f64(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_f64(p0, p1);
+<ser::value::ValueSerializer>::serialize_f64(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_char(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_char(p0, p1);
+<ser::value::ValueSerializer>::serialize_char(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_str
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_str(p0, &p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_str(p0, &p1);
+<ser::value::ValueSerializer>::serialize_str(p0, &p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_bytes(p0, p1);
+<ser::value::ValueSerializer>::serialize_bytes(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
+p0.serialize_none();
+<ser::value::ValueSerializer as serde::Serializer>::serialize_none(p0);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_none(p0);
+<ser::value::ValueSerializer>::serialize_none(p0);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_some
deps:{"<ser::value::ValueSerializer as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::value::ValueSerializer as serde::Serializer>::serialize_some":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_some(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_some(p0, p1);
+<ser::value::ValueSerializer>::serialize_some(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_unit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
+p0.serialize_unit();
+<ser::value::ValueSerializer as serde::Serializer>::serialize_unit(p0);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_unit(p0);
+<ser::value::ValueSerializer>::serialize_unit(p0);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_unit_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<ser::value::ValueSerializer>::serialize_unit_struct(p0, &p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_unit_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<ser::value::ValueSerializer>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_struct
deps:{"<ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_struct":{"T":["internal_string::InternalString","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<ser::value::ValueSerializer>::serialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_variant
deps:{"<ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","internal_string::InternalString"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<ser::value::ValueSerializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_seq
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_seq(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_seq(p0, p1);
+<ser::value::ValueSerializer>::serialize_seq(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_tuple
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_tuple(p0, p1);
+<ser::value::ValueSerializer>::serialize_tuple(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_tuple_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<ser::value::ValueSerializer>::serialize_tuple_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_tuple_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<ser::value::ValueSerializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_map
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_map(p0, p1);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_map(p0, p1);
+<ser::value::ValueSerializer>::serialize_map(p0, p1);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<ser::value::ValueSerializer>::serialize_struct(p0, &p1, p2);
-----------------
crates/toml_edit/src/ser/value.rs <ser::value::ValueSerializer as serde::Serializer>::serialize_struct_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<ser::value::ValueSerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::value::ValueSerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<ser::value::ValueSerializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml_edit/src/ser/mod.rs <ser::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ser::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<ser::Error as std::fmt::Debug>::fmt(p0, p1);
+<ser::Error>::fmt(p0, p1);
-----------------
crates/toml_edit/src/ser/mod.rs <ser::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
+p0.clone();
+<ser::Error as std::clone::Clone>::clone(p0);
+crate::<ser::Error as std::clone::Clone>::clone(p0);
+<ser::Error>::clone(p0);
-----------------
crates/toml_edit/src/ser/mod.rs <ser::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // ser::Error
+p0.eq(p1);
+<ser::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ser::Error as std::cmp::PartialEq>::eq(p0, p1);
+<ser::Error>::eq(p0, p1);
-----------------
crates/toml_edit/src/ser/mod.rs <ser::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
+p0.assert_receiver_is_total_eq();
+<ser::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ser::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ser::Error>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/ser/mod.rs ser::Error::custom
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"repr::Formatted":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","repr::ValueRepr","std::clone::Clone","std::hash::Hash"]},"ser::Error::custom":{"T":["std::marker::Sized","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"repr::Formatted":{"T":["i64","bool"]},"ser::Error::custom":{"T":["item::Item","ser::Error","parser::errors::ParserError","repr::Formatted","array::Array","value::Value","document::Document","table::Table","internal_string::InternalString","parser::errors::TomlError","parser::errors::ParserValue","parser::errors::CustomError","inline_table::InlineTable","key::Key","key::KeyMut","<&T as std::fmt::Display>","array_of_tables::ArrayOfTables","de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+ser::Error::custom(p0);
+crate::ser::Error::custom(p0);
+<ser::Error>::custom(p0);
-----------------
crates/toml_edit/src/ser/mod.rs <ser::Error as serde::ser::Error>::custom
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<ser::Error as serde::ser::Error>::custom":{"T":["std::marker::Sized","std::fmt::Display"]},"repr::Formatted":{"T":["std::fmt::Debug","std::marker::Sized","repr::ValueRepr","std::cmp::PartialEq","std::cmp::Eq","std::hash::Hash","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<ser::Error as serde::ser::Error>::custom":{"T":["parser::errors::ParserValue","table::Table","parser::errors::ParserError","parser::errors::CustomError","internal_string::InternalString","array::Array","de::Error","key::KeyMut","inline_table::InlineTable","ser::Error","key::Key","<&T as std::fmt::Display>","document::Document","value::Value","item::Item","repr::Formatted","array_of_tables::ArrayOfTables","<&mut T as std::fmt::Display>","parser::errors::TomlError"]},"repr::Formatted":{"T":["i64","bool"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<ser::Error as serde::ser::Error>::custom(p0);
+crate::<ser::Error as serde::ser::Error>::custom(p0);
+<ser::Error>::custom(p0);
-----------------
crates/toml_edit/src/ser/mod.rs <ser::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ser::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<ser::Error as std::fmt::Display>::fmt(p0, p1);
+<ser::Error>::fmt(p0, p1);
-----------------
crates/toml_edit/src/ser/mod.rs <ser::Error as std::convert::From<parser::errors::TomlError>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+<ser::Error as std::convert::From<parser::errors::TomlError>>::from(p0);
+crate::<ser::Error as std::convert::From<parser::errors::TomlError>>::from(p0);
+<ser::Error>::from(p0);
-----------------
crates/toml_edit/src/ser/mod.rs ser::<impl std::convert::From<ser::Error> for parser::errors::TomlError>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Error
+ser::<impl std::convert::From<ser::Error> for parser::errors::TomlError>::from(p0);
+crate::ser::<impl std::convert::From<ser::Error> for parser::errors::TomlError>::from(p0);
+<parser::errors::TomlError>::from(p0);
-----------------
crates/toml/src/de.rs de::from_str
deps:{"<T as serde::de::DeserializeOwned>":{"T":["serde::Deserialize","std::marker::Sized"]},"de::from_str":{"T":["std::marker::Sized","serde::de::DeserializeOwned"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<T as serde::de::DeserializeOwned>":{"T":["map::Map","value::Value"]},"de::from_str":{"T":["<T as serde::de::DeserializeOwned>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = "sample"; // None+&str
+de::from_str(&p0);
+crate::de::from_str(&p0);
+crate::de::from_str(&p0);
-----------------
crates/toml/src/ser.rs ser::to_string
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"ser::to_string":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"ser::to_string":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value","map::Map"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_string(p0);
+crate::ser::to_string(p0);
+crate::ser::to_string(p0);
-----------------
crates/toml/src/ser.rs ser::to_string_pretty
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"ser::to_string_pretty":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"ser::to_string_pretty":{"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_string_pretty(p0);
+crate::ser::to_string_pretty(p0);
+crate::ser::to_string_pretty(p0);
-----------------
crates/toml/src/ser.rs ser::internal::write_document
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = MaybeUninit::uninit().assume_init(); // fmt::DocumentFormatter
let mut p2 = MaybeUninit::uninit().assume_init(); // std::result::Result<toml_edit::Value, toml_edit::ser::Error>
+ser::internal::write_document(p0, p1, p2);
+crate::ser::internal::write_document(p0, p1, p2);
+crate::ser::internal::write_document(p0, p1, p2);
-----------------
crates/toml/src/ser.rs ser::internal::write_value
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = MaybeUninit::uninit().assume_init(); // std::result::Result<toml_edit::Value, toml_edit::ser::Error>
+ser::internal::write_value(p0, p1);
+crate::ser::internal::write_value(p0, p1);
+crate::ser::internal::write_value(p0, p1);
-----------------
crates/toml/src/macros.rs macros::insert_toml
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & ["a"].as_mut_slice(); // None+[&str]
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+macros::insert_toml(p0, p1, p2);
+crate::macros::insert_toml(p0, p1, p2);
+crate::macros::insert_toml(p0, p1, p2);
-----------------
crates/toml/src/macros.rs macros::push_toml
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & ["a"].as_mut_slice(); // None+[&str]
+macros::push_toml(p0, p1);
+crate::macros::push_toml(p0, p1);
+crate::macros::push_toml(p0, p1);
-----------------
crates/toml/src/macros.rs macros::traverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & ["a"].as_mut_slice(); // None+[&str]
+macros::traverse(p0, p1);
+crate::macros::traverse(p0, p1);
+crate::macros::traverse(p0, p1);
-----------------
crates/toml/src/value.rs value::Index::index
deps:{"value::Index::index":{"Self":["value::Sealed","value::Index"]}}
candidates:{"value::Index::index":{"Self":["std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index(p1);
+value::Index::index(p0, p1);
+crate::value::Index::index(p0, p1);
+crate::value::Index::index(p0, p1);
-----------------
crates/toml/src/value.rs value::Index::index_mut
deps:{"value::Index::index_mut":{"Self":["value::Sealed","value::Index"]}}
candidates:{"value::Index::index_mut":{"Self":["std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_mut(p1);
+value::Index::index_mut(p0, p1);
+crate::value::Index::index_mut(p0, p1);
+crate::value::Index::index_mut(p0, p1);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::new
deps:{}
candidates:{}
+map::Map::<std::string::String, value::Value>::new();
+crate::map::Map::<std::string::String, value::Value>::new();
+<map::Map<std::string::String, value::Value>>::new();
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::with_capacity
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+map::Map::<std::string::String, value::Value>::with_capacity(p0);
+crate::map::Map::<std::string::String, value::Value>::with_capacity(p0);
+<map::Map<std::string::String, value::Value>>::with_capacity(p0);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::clear
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.clear();
+map::Map::<std::string::String, value::Value>::clear(p0);
+crate::map::Map::<std::string::String, value::Value>::clear(p0);
+<map::Map<std::string::String, value::Value>>::clear(p0);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::get
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get":{"Q":["std::hash::Hash","std::cmp::Eq","std::cmp::Ord"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get":{"Q":["bool","u16","std::hash::impls::<impl std::hash::Hash for *mut T>","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","i64","std::hash::impls::<impl std::hash::Hash for *const T>","u64","usize","u8","char","i16","i8","u32","i32"],"std::string::String":["std::ffi::CString","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","serde_spanned::Spanned<std::string::String>","std::path::PathBuf","std::borrow::Cow<'a, B>","std::string::String","std::rc::Rc<T>","std::sync::Arc<T>","std::ffi::OsString"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.get(p1);
+map::Map::<std::string::String, value::Value>::get(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::get(p0, p1);
+<map::Map<std::string::String, value::Value>>::get(p0, p1);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::contains_key
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::contains_key":{"Q":["std::cmp::Ord","std::cmp::Eq","std::hash::Hash"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::contains_key":{"Q":["u16","char","i32","std::hash::impls::<impl std::hash::Hash for *mut T>","u64","i64","usize","i8","i16","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","bool","u32","u8","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>"],"std::string::String":["std::vec::Vec<T, A>","std::path::PathBuf","serde_spanned::Spanned<std::string::String>","std::ffi::CString","std::ffi::OsString","std::sync::Arc<T>","std::string::String","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>"]},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.contains_key(p1);
+map::Map::<std::string::String, value::Value>::contains_key(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::contains_key(p0, p1);
+<map::Map<std::string::String, value::Value>>::contains_key(p0, p1);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::get_mut
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get_mut":{"Q":["std::cmp::Eq","std::hash::Hash","std::cmp::Ord"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get_mut":{"Q":["i64","usize","std::hash::impls::<impl std::hash::Hash for *mut T>","i16","u16","i8","char","u64","i32","u32","u8","std::hash::impls::<impl std::hash::Hash for *const T>","bool"],"std::string::String":["std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::path::PathBuf","std::rc::Rc<T>","serde_spanned::Spanned<std::string::String>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.get_mut(p1);
+map::Map::<std::string::String, value::Value>::get_mut(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::get_mut(p0, p1);
+<map::Map<std::string::String, value::Value>>::get_mut(p0, p1);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::insert
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = std::string::String::new(); // None+std::string::String
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1, p2);
+map::Map::<std::string::String, value::Value>::insert(p0, p1, p2);
+crate::map::Map::<std::string::String, value::Value>::insert(p0, p1, p2);
+<map::Map<std::string::String, value::Value>>::insert(p0, p1, p2);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::remove
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::remove":{"Q":["std::cmp::Eq","std::hash::Hash","std::cmp::Ord"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::remove":{"Q":["i8","usize","std::hash::impls::<impl std::hash::Hash for *const T>","i16","u64","bool","i64","std::hash::impls::<impl std::hash::Hash for *mut T>","u32","u8","i32","u16","char"],"std::string::String":["serde_spanned::Spanned<std::string::String>","std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::ffi::CString","std::string::String","std::boxed::Box<T, A>"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.remove(p1);
+map::Map::<std::string::String, value::Value>::remove(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::remove(p0, p1);
+<map::Map<std::string::String, value::Value>>::remove(p0, p1);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::entry
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"map::Map::<std::string::String, value::Value>::entry":{"S":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"map::Map::<std::string::String, value::Value>::entry":{"S":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.entry(p1);
+map::Map::<std::string::String, value::Value>::entry(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::entry(p0, p1);
+<map::Map<std::string::String, value::Value>>::entry(p0, p1);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::len
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.len();
+map::Map::<std::string::String, value::Value>::len(p0);
+crate::map::Map::<std::string::String, value::Value>::len(p0);
+<map::Map<std::string::String, value::Value>>::len(p0);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::is_empty
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.is_empty();
+map::Map::<std::string::String, value::Value>::is_empty(p0);
+crate::map::Map::<std::string::String, value::Value>::is_empty(p0);
+<map::Map<std::string::String, value::Value>>::is_empty(p0);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::iter
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.iter();
+map::Map::<std::string::String, value::Value>::iter(p0);
+crate::map::Map::<std::string::String, value::Value>::iter(p0);
+<map::Map<std::string::String, value::Value>>::iter(p0);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.iter_mut();
+map::Map::<std::string::String, value::Value>::iter_mut(p0);
+crate::map::Map::<std::string::String, value::Value>::iter_mut(p0);
+<map::Map<std::string::String, value::Value>>::iter_mut(p0);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::keys
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.keys();
+map::Map::<std::string::String, value::Value>::keys(p0);
+crate::map::Map::<std::string::String, value::Value>::keys(p0);
+<map::Map<std::string::String, value::Value>>::keys(p0);
-----------------
crates/toml/src/map.rs map::Map::<std::string::String, value::Value>::values
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.values();
+map::Map::<std::string::String, value::Value>::values(p0);
+crate::map::Map::<std::string::String, value::Value>::values(p0);
+<map::Map<std::string::String, value::Value>>::values(p0);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::default::Default>::default
deps:{}
candidates:{}
+<map::Map<std::string::String, value::Value> as std::default::Default>::default();
+crate::<map::Map<std::string::String, value::Value> as std::default::Default>::default();
+<map::Map<std::string::String, value::Value>>::default();
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.clone();
+<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone(p0);
+crate::<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone(p0);
+<map::Map<std::string::String, value::Value>>::clone(p0);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.eq(p1);
+<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq(p0, p1);
+<map::Map<std::string::String, value::Value>>::eq(p0, p1);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":{"Q":["std::hash::Hash","std::cmp::Ord","std::cmp::Eq"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":{"Q":["u32","i32","char","i16","i64","std::hash::impls::<impl std::hash::Hash for *mut T>","u64","bool","usize","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","i8","u16","u8"],"std::string::String":["serde_spanned::Spanned<std::string::String>","<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::ffi::CString","std::sync::Arc<T>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::string::String","std::path::PathBuf","std::vec::Vec<T, A>","std::boxed::Box<T, A>"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.index(p1);
+<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index(p0, p1);
+<map::Map<std::string::String, value::Value>>::index(p0, p1);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":{"Q":["std::cmp::Eq","std::cmp::Ord","std::hash::Hash"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":{"Q":["usize","u32","u64","char","i8","i64","std::hash::impls::<impl std::hash::Hash for *mut T>","u16","i32","std::hash::impls::<impl std::hash::Hash for *const T>","bool","u8","i16","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>"],"std::string::String":["std::ffi::CString","std::path::PathBuf","std::sync::Arc<T>","std::rc::Rc<T>","std::ffi::OsString","serde_spanned::Spanned<std::string::String>","std::borrow::Cow<'a, B>","std::string::String","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.index_mut(p1);
+<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut(p0, p1);
+<map::Map<std::string::String, value::Value>>::index_mut(p0, p1);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt(p0, p1);
+<map::Map<std::string::String, value::Value>>::fmt(p0, p1);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as serde::Serialize>::serialize
deps:{"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":{"S":["serde::Serializer","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":{"S":["value::ValueSerializer","ser::Serializer","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","value::TableSerializer","ser::ValueSerializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize(p0, p1);
+<map::Map<std::string::String, value::Value>>::serialize(p0, p1);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize
'de
deps:{"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":{"D":["table::Table","de::Deserializer","value::Value","de::ValueDeserializer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize(p0);
+crate::<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize(p0);
+<map::Map<std::string::String, value::Value>>::deserialize(p0);
-----------------
crates/toml/src/map.rs <<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor>::expecting(p0, p1);
-----------------
crates/toml/src/map.rs <<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit
'de
deps:{"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":{"E":["de::Error"]}}
let mut p0 = std::string::String::new(); // None+<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor
+p0.visit_unit();
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit(p0);
+crate::<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit(p0);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor>::visit_unit(p0);
-----------------
crates/toml/src/map.rs <<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":{"V":["std::marker::Sized","serde::de::MapAccess"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":{"V":["value::MapDeserializer","<&'a mut A as serde::de::MapAccess<'de>>"]}}
let mut p0 = std::string::String::new(); // None+<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit_map(p1);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor>::visit_map(p0, p1);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter
deps:{"<&'a indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::slice::Slice<T> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::core::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":{"T":["std::marker::Sized","std::iter::IntoIterator"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::map::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::map::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::set::IndexSet<T, S>>":{},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&'a indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::slice::Slice<T> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::core::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["map::Values","map::Iter","<&mut I as std::iter::Iterator>","map::IterMut","map::IntoIter","map::Keys","<&'a mut winnow::combinator::core::ParserIterator<F, I, O, E> as std::iter::Iterator>"]},"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":{"T":["<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","map::Map","<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::map::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::map::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::set::IndexSet<T, S>>":{},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter(p0);
+crate::<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter(p0);
+<map::Map<std::string::String, value::Value>>::from_iter(p0);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend
deps:{"<&'a indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::slice::Slice<T> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::core::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":{"T":["std::marker::Sized","std::iter::IntoIterator"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::map::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::map::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::set::IndexSet<T, S>>":{},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&'a indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::slice::Slice<T> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::core::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["map::IntoIter","<&mut I as std::iter::Iterator>","map::Values","map::Keys","map::Iter","map::IterMut"]},"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":{"T":["indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::map::IndexMap<K, V, S>>","map::Map","<&'a indexmap::map::slice::Slice<K, V> as std::iter::IntoIterator>"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::map::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::map::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::set::IndexSet<T, S>>":{},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend(p0, p1);
+<map::Map<std::string::String, value::Value>>::extend(p0, p1);
-----------------
crates/toml/src/map.rs map::Entry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Entry<'a>
+p0.key();
+map::Entry::<'a>::key(p0);
+crate::map::Entry::<'a>::key(p0);
+<map::Entry<'a>>::key(p0);
-----------------
crates/toml/src/map.rs map::Entry::<'a>::or_insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.or_insert(p1);
+map::Entry::<'a>::or_insert(p0, p1);
+crate::map::Entry::<'a>::or_insert(p0, p1);
+<map::Entry<'a>>::or_insert(p0, p1);
-----------------
crates/toml/src/map.rs map::Entry::<'a>::or_insert_with
'a
deps:{"map::Entry::<'a>::or_insert_with":{"F":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"map::Entry::<'a>::or_insert_with":{"F":["std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.or_insert_with(p1);
+map::Entry::<'a>::or_insert_with(p0, p1);
+crate::map::Entry::<'a>::or_insert_with(p0, p1);
+<map::Entry<'a>>::or_insert_with(p0, p1);
-----------------
crates/toml/src/map.rs map::VacantEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::VacantEntry<'a>
+p0.key();
+map::VacantEntry::<'a>::key(p0);
+crate::map::VacantEntry::<'a>::key(p0);
+<map::VacantEntry<'a>>::key(p0);
-----------------
crates/toml/src/map.rs map::VacantEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::VacantEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1);
+map::VacantEntry::<'a>::insert(p0, p1);
+crate::map::VacantEntry::<'a>::insert(p0, p1);
+<map::VacantEntry<'a>>::insert(p0, p1);
-----------------
crates/toml/src/map.rs map::OccupiedEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.key();
+map::OccupiedEntry::<'a>::key(p0);
+crate::map::OccupiedEntry::<'a>::key(p0);
+<map::OccupiedEntry<'a>>::key(p0);
-----------------
crates/toml/src/map.rs map::OccupiedEntry::<'a>::get
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.get();
+map::OccupiedEntry::<'a>::get(p0);
+crate::map::OccupiedEntry::<'a>::get(p0);
+<map::OccupiedEntry<'a>>::get(p0);
-----------------
crates/toml/src/map.rs map::OccupiedEntry::<'a>::get_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.get_mut();
+map::OccupiedEntry::<'a>::get_mut(p0);
+crate::map::OccupiedEntry::<'a>::get_mut(p0);
+<map::OccupiedEntry<'a>>::get_mut(p0);
-----------------
crates/toml/src/map.rs map::OccupiedEntry::<'a>::into_mut
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.into_mut();
+map::OccupiedEntry::<'a>::into_mut(p0);
+crate::map::OccupiedEntry::<'a>::into_mut(p0);
+<map::OccupiedEntry<'a>>::into_mut(p0);
-----------------
crates/toml/src/map.rs map::OccupiedEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1);
+map::OccupiedEntry::<'a>::insert(p0, p1);
+crate::map::OccupiedEntry::<'a>::insert(p0, p1);
+<map::OccupiedEntry<'a>>::insert(p0, p1);
-----------------
crates/toml/src/map.rs map::OccupiedEntry::<'a>::remove
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.remove();
+map::OccupiedEntry::<'a>::remove(p0);
+crate::map::OccupiedEntry::<'a>::remove(p0);
+<map::OccupiedEntry<'a>>::remove(p0);
-----------------
crates/toml/src/map.rs <&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.into_iter();
+<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+<&'a map::Map<std::string::String, value::Value>>::into_iter(p0);
-----------------
crates/toml/src/map.rs <map::Iter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Iter<'a>
+p0.next();
+<map::Iter<'a> as std::iter::Iterator>::next(p0);
+crate::<map::Iter<'a> as std::iter::Iterator>::next(p0);
+<map::Iter<'a>>::next(p0);
-----------------
crates/toml/src/map.rs <map::Iter<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Iter<'a>
+p0.size_hint();
+<map::Iter<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::Iter<'a> as std::iter::Iterator>::size_hint(p0);
+<map::Iter<'a>>::size_hint(p0);
-----------------
crates/toml/src/map.rs <map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Iter<'a>
+p0.next_back();
+<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::Iter<'a>>::next_back(p0);
-----------------
crates/toml/src/map.rs <map::Iter<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Iter<'a>
+p0.len();
+<map::Iter<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::Iter<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::Iter<'a>>::len(p0);
-----------------
crates/toml/src/map.rs <&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.into_iter();
+<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+<&'a mut map::Map<std::string::String, value::Value>>::into_iter(p0);
-----------------
crates/toml/src/map.rs <map::IterMut<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::IterMut<'a>
+p0.next();
+<map::IterMut<'a> as std::iter::Iterator>::next(p0);
+crate::<map::IterMut<'a> as std::iter::Iterator>::next(p0);
+<map::IterMut<'a>>::next(p0);
-----------------
crates/toml/src/map.rs <map::IterMut<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::IterMut<'a>
+p0.size_hint();
+<map::IterMut<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::IterMut<'a> as std::iter::Iterator>::size_hint(p0);
+<map::IterMut<'a>>::size_hint(p0);
-----------------
crates/toml/src/map.rs <map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::IterMut<'a>
+p0.next_back();
+<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::IterMut<'a>>::next_back(p0);
-----------------
crates/toml/src/map.rs <map::IterMut<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::IterMut<'a>
+p0.len();
+<map::IterMut<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::IterMut<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::IterMut<'a>>::len(p0);
-----------------
crates/toml/src/map.rs <map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.into_iter();
+<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+crate::<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+<map::Map<std::string::String, value::Value>>::into_iter(p0);
-----------------
crates/toml/src/map.rs <map::IntoIter as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::IntoIter
+p0.next();
+<map::IntoIter as std::iter::Iterator>::next(p0);
+crate::<map::IntoIter as std::iter::Iterator>::next(p0);
+<map::IntoIter>::next(p0);
-----------------
crates/toml/src/map.rs <map::IntoIter as std::iter::Iterator>::size_hint
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::IntoIter
+p0.size_hint();
+<map::IntoIter as std::iter::Iterator>::size_hint(p0);
+crate::<map::IntoIter as std::iter::Iterator>::size_hint(p0);
+<map::IntoIter>::size_hint(p0);
-----------------
crates/toml/src/map.rs <map::IntoIter as std::iter::DoubleEndedIterator>::next_back
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::IntoIter
+p0.next_back();
+<map::IntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::IntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::IntoIter>::next_back(p0);
-----------------
crates/toml/src/map.rs <map::IntoIter as std::iter::ExactSizeIterator>::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::IntoIter
+p0.len();
+<map::IntoIter as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::IntoIter as std::iter::ExactSizeIterator>::len(p0);
+<map::IntoIter>::len(p0);
-----------------
crates/toml/src/map.rs <map::Keys<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Keys<'a>
+p0.next();
+<map::Keys<'a> as std::iter::Iterator>::next(p0);
+crate::<map::Keys<'a> as std::iter::Iterator>::next(p0);
+<map::Keys<'a>>::next(p0);
-----------------
crates/toml/src/map.rs <map::Keys<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Keys<'a>
+p0.size_hint();
+<map::Keys<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::Keys<'a> as std::iter::Iterator>::size_hint(p0);
+<map::Keys<'a>>::size_hint(p0);
-----------------
crates/toml/src/map.rs <map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Keys<'a>
+p0.next_back();
+<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::Keys<'a>>::next_back(p0);
-----------------
crates/toml/src/map.rs <map::Keys<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Keys<'a>
+p0.len();
+<map::Keys<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::Keys<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::Keys<'a>>::len(p0);
-----------------
crates/toml/src/map.rs <map::Values<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Values<'a>
+p0.next();
+<map::Values<'a> as std::iter::Iterator>::next(p0);
+crate::<map::Values<'a> as std::iter::Iterator>::next(p0);
+<map::Values<'a>>::next(p0);
-----------------
crates/toml/src/map.rs <map::Values<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Values<'a>
+p0.size_hint();
+<map::Values<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::Values<'a> as std::iter::Iterator>::size_hint(p0);
+<map::Values<'a>>::size_hint(p0);
-----------------
crates/toml/src/map.rs <map::Values<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Values<'a>
+p0.next_back();
+<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::Values<'a>>::next_back(p0);
-----------------
crates/toml/src/map.rs <map::Values<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Values<'a>
+p0.len();
+<map::Values<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::Values<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::Values<'a>>::len(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+<value::Value as std::cmp::PartialEq>::eq(p0, p1);
+crate::<value::Value as std::cmp::PartialEq>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.clone();
+<value::Value as std::clone::Clone>::clone(p0);
+crate::<value::Value as std::clone::Clone>::clone(p0);
+<value::Value>::clone(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<value::Value as std::fmt::Debug>::fmt(p0, p1);
+crate::<value::Value as std::fmt::Debug>::fmt(p0, p1);
+<value::Value>::fmt(p0, p1);
-----------------
crates/toml/src/value.rs value::Value::try_from
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"value::Value::try_from":{"T":["std::marker::Sized","serde::Serialize"]}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"value::Value::try_from":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+value::Value::try_from(p0);
+crate::value::Value::try_from(p0);
+<value::Value>::try_from(p0);
-----------------
crates/toml/src/value.rs value::Value::try_into
'de
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"value::Value::try_into":{"T":["std::marker::Sized","serde::Deserialize"]}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"value::Value::try_into":{"T":["map::Map","value::Value"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.try_into();
+value::Value::try_into(p0);
+crate::value::Value::try_into(p0);
+<value::Value>::try_into(p0);
-----------------
crates/toml/src/value.rs value::Value::get
deps:{"<&'s T as value::Index>":{},"value::Value::get":{"I":["std::marker::Sized","value::Index"]}}
candidates:{"<&'s T as value::Index>":{},"value::Value::get":{"I":["<&'s T as value::Index>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.get(p1);
+value::Value::get(p0, p1);
+crate::value::Value::get(p0, p1);
+<value::Value>::get(p0, p1);
-----------------
crates/toml/src/value.rs value::Value::get_mut
deps:{"<&'s T as value::Index>":{},"value::Value::get_mut":{"I":["value::Index","std::marker::Sized"]}}
candidates:{"<&'s T as value::Index>":{},"value::Value::get_mut":{"I":["<&'s T as value::Index>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.get_mut(p1);
+value::Value::get_mut(p0, p1);
+crate::value::Value::get_mut(p0, p1);
+<value::Value>::get_mut(p0, p1);
-----------------
crates/toml/src/value.rs value::Value::as_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_integer();
+value::Value::as_integer(p0);
+crate::value::Value::as_integer(p0);
+<value::Value>::as_integer(p0);
-----------------
crates/toml/src/value.rs value::Value::is_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_integer();
+value::Value::is_integer(p0);
+crate::value::Value::is_integer(p0);
+<value::Value>::is_integer(p0);
-----------------
crates/toml/src/value.rs value::Value::as_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_float();
+value::Value::as_float(p0);
+crate::value::Value::as_float(p0);
+<value::Value>::as_float(p0);
-----------------
crates/toml/src/value.rs value::Value::is_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_float();
+value::Value::is_float(p0);
+crate::value::Value::is_float(p0);
+<value::Value>::is_float(p0);
-----------------
crates/toml/src/value.rs value::Value::as_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_bool();
+value::Value::as_bool(p0);
+crate::value::Value::as_bool(p0);
+<value::Value>::as_bool(p0);
-----------------
crates/toml/src/value.rs value::Value::is_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_bool();
+value::Value::is_bool(p0);
+crate::value::Value::is_bool(p0);
+<value::Value>::is_bool(p0);
-----------------
crates/toml/src/value.rs value::Value::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_str();
+value::Value::as_str(p0);
+crate::value::Value::as_str(p0);
+<value::Value>::as_str(p0);
-----------------
crates/toml/src/value.rs value::Value::is_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_str();
+value::Value::is_str(p0);
+crate::value::Value::is_str(p0);
+<value::Value>::is_str(p0);
-----------------
crates/toml/src/value.rs value::Value::as_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_datetime();
+value::Value::as_datetime(p0);
+crate::value::Value::as_datetime(p0);
+<value::Value>::as_datetime(p0);
-----------------
crates/toml/src/value.rs value::Value::is_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_datetime();
+value::Value::is_datetime(p0);
+crate::value::Value::is_datetime(p0);
+<value::Value>::is_datetime(p0);
-----------------
crates/toml/src/value.rs value::Value::as_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_array();
+value::Value::as_array(p0);
+crate::value::Value::as_array(p0);
+<value::Value>::as_array(p0);
-----------------
crates/toml/src/value.rs value::Value::as_array_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_array_mut();
+value::Value::as_array_mut(p0);
+crate::value::Value::as_array_mut(p0);
+<value::Value>::as_array_mut(p0);
-----------------
crates/toml/src/value.rs value::Value::is_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_array();
+value::Value::is_array(p0);
+crate::value::Value::is_array(p0);
+<value::Value>::is_array(p0);
-----------------
crates/toml/src/value.rs value::Value::as_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_table();
+value::Value::as_table(p0);
+crate::value::Value::as_table(p0);
+<value::Value>::as_table(p0);
-----------------
crates/toml/src/value.rs value::Value::as_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_table_mut();
+value::Value::as_table_mut(p0);
+crate::value::Value::as_table_mut(p0);
+<value::Value>::as_table_mut(p0);
-----------------
crates/toml/src/value.rs value::Value::is_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_table();
+value::Value::is_table(p0);
+crate::value::Value::is_table(p0);
+<value::Value>::is_table(p0);
-----------------
crates/toml/src/value.rs value::Value::same_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.same_type(p1);
+value::Value::same_type(p0, p1);
+crate::value::Value::same_type(p0, p1);
+<value::Value>::same_type(p0, p1);
-----------------
crates/toml/src/value.rs value::Value::type_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.type_str();
+value::Value::type_str(p0);
+crate::value::Value::type_str(p0);
+<value::Value>::type_str(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::ops::Index<I>>::index
deps:{"<&'s T as value::Index>":{},"<value::Value as std::ops::Index<I>>::index":{"I":["value::Index","std::marker::Sized"]}}
candidates:{"<&'s T as value::Index>":{},"<value::Value as std::ops::Index<I>>::index":{"I":["<&'s T as value::Index>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.index(p1);
+<value::Value as std::ops::Index<I>>::index(p0, p1);
+crate::<value::Value as std::ops::Index<I>>::index(p0, p1);
+<value::Value>::index(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as std::ops::IndexMut<I>>::index_mut
deps:{"<&'s T as value::Index>":{},"<value::Value as std::ops::IndexMut<I>>::index_mut":{"I":["std::marker::Sized","value::Index"]}}
candidates:{"<&'s T as value::Index>":{},"<value::Value as std::ops::IndexMut<I>>::index_mut":{"I":["<&'s T as value::Index>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.index_mut(p1);
+<value::Value as std::ops::IndexMut<I>>::index_mut(p0, p1);
+crate::<value::Value as std::ops::IndexMut<I>>::index_mut(p0, p1);
+<value::Value>::index_mut(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<&'a str>>::from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<value::Value as std::convert::From<&'a str>>::from(&p0);
+crate::<value::Value as std::convert::From<&'a str>>::from(&p0);
+<value::Value>::from(&p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<std::vec::Vec<V>>>::from
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<value::Value as std::convert::From<std::vec::Vec<V>>>::from":{"V":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<value::Value as std::convert::From<std::vec::Vec<V>>>::from":{"V":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<V>
+<value::Value as std::convert::From<std::vec::Vec<V>>>::from(p0);
+crate::<value::Value as std::convert::From<std::vec::Vec<V>>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<std::collections::BTreeMap<S, V>>>::from
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<value::Value as std::convert::From<std::collections::BTreeMap<S, V>>>::from":{"S":["std::marker::Sized","std::convert::Into"],"V":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<value::Value as std::convert::From<std::collections::BTreeMap<S, V>>>::from":{"S":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"],"V":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::collections::BTreeMap<S, V>
+<value::Value as std::convert::From<std::collections::BTreeMap<S, V>>>::from(p0);
+crate::<value::Value as std::convert::From<std::collections::BTreeMap<S, V>>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<std::collections::HashMap<S, V>>>::from
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<value::Value as std::convert::From<std::collections::HashMap<S, V>>>::from":{"S":["std::marker::Sized","std::hash::Hash","std::convert::Into","std::cmp::Eq"],"V":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<value::Value as std::convert::From<std::collections::HashMap<S, V>>>::from":{"S":["gimli::read::endian_slice::EndianSlice<'input, Endian>"],"V":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::collections::HashMap<S, V>
+<value::Value as std::convert::From<std::collections::HashMap<S, V>>>::from(p0);
+crate::<value::Value as std::convert::From<std::collections::HashMap<S, V>>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<value::Value as std::convert::From<std::string::String>>::from(p0);
+crate::<value::Value as std::convert::From<std::string::String>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<i64>>::from
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<value::Value as std::convert::From<i64>>::from(p0);
+crate::<value::Value as std::convert::From<i64>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<i32>>::from
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<value::Value as std::convert::From<i32>>::from(p0);
+crate::<value::Value as std::convert::From<i32>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<i8>>::from
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<value::Value as std::convert::From<i8>>::from(p0);
+crate::<value::Value as std::convert::From<i8>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<u8>>::from
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<value::Value as std::convert::From<u8>>::from(p0);
+crate::<value::Value as std::convert::From<u8>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<u32>>::from
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<value::Value as std::convert::From<u32>>::from(p0);
+crate::<value::Value as std::convert::From<u32>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<f64>>::from
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<value::Value as std::convert::From<f64>>::from(p0);
+crate::<value::Value as std::convert::From<f64>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<f32>>::from
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<value::Value as std::convert::From<f32>>::from(p0);
+crate::<value::Value as std::convert::From<f32>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<bool>>::from
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+<value::Value as std::convert::From<bool>>::from(p0);
+crate::<value::Value as std::convert::From<bool>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<toml_datetime::Datetime>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_datetime::Datetime
+<value::Value as std::convert::From<toml_datetime::Datetime>>::from(p0);
+crate::<value::Value as std::convert::From<toml_datetime::Datetime>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <value::Value as std::convert::From<map::Map<std::string::String, value::Value>>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+<value::Value as std::convert::From<map::Map<std::string::String, value::Value>>>::from(p0);
+crate::<value::Value as std::convert::From<map::Map<std::string::String, value::Value>>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml/src/value.rs <usize as value::Index>::index
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index(p1);
+<usize as value::Index>::index(p0, p1);
+crate::<usize as value::Index>::index(p0, p1);
+<usize>::index(p0, p1);
-----------------
crates/toml/src/value.rs <usize as value::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_mut(p1);
+<usize as value::Index>::index_mut(p0, p1);
+crate::<usize as value::Index>::index_mut(p0, p1);
+<usize>::index_mut(p0, p1);
-----------------
crates/toml/src/value.rs <str as value::Index>::index
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index(p1);
+<str as value::Index>::index(&p0, p1);
+crate::<str as value::Index>::index(&p0, p1);
+<str>::index(&p0, p1);
-----------------
crates/toml/src/value.rs <str as value::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_mut(p1);
+<str as value::Index>::index_mut(&p0, p1);
+crate::<str as value::Index>::index_mut(&p0, p1);
+<str>::index_mut(&p0, p1);
-----------------
crates/toml/src/value.rs <std::string::String as value::Index>::index
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index(p1);
+<std::string::String as value::Index>::index(p0, p1);
+crate::<std::string::String as value::Index>::index(p0, p1);
+<std::string::String>::index(p0, p1);
-----------------
crates/toml/src/value.rs <std::string::String as value::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_mut(p1);
+<std::string::String as value::Index>::index_mut(p0, p1);
+crate::<std::string::String as value::Index>::index_mut(p0, p1);
+<std::string::String>::index_mut(p0, p1);
-----------------
crates/toml/src/value.rs <&'s T as value::Index>::index
's
deps:{"<&'s T as value::Index>":{},"<&'s T as value::Index>::index":{"T":["value::Index"]}}
candidates:{"<&'s T as value::Index>":{},"<&'s T as value::Index>::index":{"T":["std::string::String","<&'s T as value::Index>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index(p1);
+<&'s T as value::Index>::index(p0, p1);
+crate::<&'s T as value::Index>::index(p0, p1);
+<&'s T>::index(p0, p1);
-----------------
crates/toml/src/value.rs <&'s T as value::Index>::index_mut
's
deps:{"<&'s T as value::Index>":{},"<&'s T as value::Index>::index_mut":{"T":["value::Index"]}}
candidates:{"<&'s T as value::Index>":{},"<&'s T as value::Index>::index_mut":{"T":["std::string::String","<&'s T as value::Index>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_mut(p1);
+<&'s T as value::Index>::index_mut(p0, p1);
+crate::<&'s T as value::Index>::index_mut(p0, p1);
+<&'s T>::index_mut(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<value::Value as std::fmt::Display>::fmt(p0, p1);
+crate::<value::Value as std::fmt::Display>::fmt(p0, p1);
+<value::Value>::fmt(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<value::Value as std::str::FromStr>::from_str(&p0);
+crate::<value::Value as std::str::FromStr>::from_str(&p0);
+<value::Value>::from_str(&p0);
-----------------
crates/toml/src/value.rs <value::Value as serde::Serialize>::serialize
deps:{"<value::Value as serde::Serialize>::serialize":{"S":["serde::Serializer","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
candidates:{"<value::Value as serde::Serialize>::serialize":{"S":["ser::Serializer","ser::ValueSerializer","serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>","value::TableSerializer","value::ValueSerializer"]},"serde::ser::fmt::<impl serde::Serializer for &'a mut std::fmt::Formatter<'b>>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+<value::Value as serde::Serialize>::serialize(p0, p1);
+crate::<value::Value as serde::Serialize>::serialize(p0, p1);
+<value::Value>::serialize(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as serde::Deserialize<'de>>::deserialize
'de
deps:{"<value::Value as serde::Deserialize<'de>>::deserialize":{"D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserialize<'de>>::deserialize":{"D":["table::Table","de::ValueDeserializer","de::Deserializer","value::Value"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<value::Value as serde::Deserialize<'de>>::deserialize(p0);
+crate::<value::Value as serde::Deserialize<'de>>::deserialize(p0);
+<value::Value>::deserialize(p0);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::expecting(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":{"E":["std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = true; // None+bool
+p0.visit_bool(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_bool(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":{"E":["std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = 0i64; // None+i64
+p0.visit_i64(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_i64(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":{"E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":{"E":["de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_u64(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u32
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u32":{"E":["std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u32":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = 0u32; // None+u32
+p0.visit_u32(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u32(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u32(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_u32(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i32
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i32":{"E":["std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i32":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = 0i32; // None+i32
+p0.visit_i32(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i32(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i32(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_i32(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":{"E":["std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = 0f64; // None+f64
+p0.visit_f64(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_f64(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_str(p0, &p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":{"E":["std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = std::string::String::new(); // None+std::string::String
+p0.visit_string(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_string(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some
'de
deps:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":{"D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":{"D":["de::ValueDeserializer","table::Table","value::Value","de::Deserializer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = MaybeUninit::uninit().assume_init(); // D
+p0.visit_some(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_some(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":{"V":["serde::de::SeqAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::SeqAccess<'de>>":{},"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":{"V":["value::SeqDeserializer","<&'a mut A as serde::de::SeqAccess<'de>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit_seq(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_seq(p0, p1);
-----------------
crates/toml/src/value.rs <<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":{"V":["serde::de::MapAccess","std::marker::Sized"]}}
candidates:{"<&'a mut A as serde::de::MapAccess<'de>>":{},"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":{"V":["<&'a mut A as serde::de::MapAccess<'de>>","value::MapDeserializer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit_map(p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor>::visit_map(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_any":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<value::Value>::deserialize_any(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_enum":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_enum":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<value::Value as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<value::Value>::deserialize_enum(p0, &p1, p2, p3);
-----------------
crates/toml/src/value.rs <value::Value as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_option":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<value::Value>::deserialize_option(p0, p1);
-----------------
crates/toml/src/value.rs <value::Value as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<value::Value as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<value::Value>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_bool":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_bool":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<value::Value>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_u8":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<value::Value>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_u16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_u16":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<value::Value>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_u32":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<value::Value>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_u64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_u64":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<value::Value>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_i8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_i8":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<value::Value>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_i16":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<value::Value>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_i32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_i32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<value::Value>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_i64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_i64":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<value::Value>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_f32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_f32":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<value::Value>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_f64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_f64":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<value::Value>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_char":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<value::Value>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_str":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_str":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<value::Value>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_string":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<value::Value>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_unit":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<value::Value>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_seq":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<value::Value>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_bytes":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_bytes":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<value::Value>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<value::Value>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_map":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<value::Value>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<value::Value as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<value::Value>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<value::Value as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<value::Value>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_struct":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<value::Value as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<value::Value>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_tuple":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_tuple":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<value::Value as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<value::Value>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<value::Value>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <value::Value as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<value::Value as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::Value as serde::Deserializer<'de>>::deserialize_identifier":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<value::Value as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<value::Value as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<value::Value>::deserialize_identifier(p0, p1);
-----------------
crates/toml/src/value.rs value::SeqDeserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<value::Value>
+value::SeqDeserializer::new(p0);
+crate::value::SeqDeserializer::new(p0);
+<value::SeqDeserializer>::new(p0);
-----------------
crates/toml/src/value.rs <value::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed
'de
deps:{"<value::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":{"T":["value::DatetimeOrTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::SeqDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_element_seed(p1);
+<value::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+crate::<value::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+<value::SeqDeserializer>::next_element_seed(p0, p1);
-----------------
crates/toml/src/value.rs <value::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::SeqDeserializer
+p0.size_hint();
+<value::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint(p0);
+crate::<value::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint(p0);
+<value::SeqDeserializer>::size_hint(p0);
-----------------
crates/toml/src/value.rs value::MapDeserializer::new
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+value::MapDeserializer::new(p0);
+crate::value::MapDeserializer::new(p0);
+<value::MapDeserializer>::new(p0);
-----------------
crates/toml/src/value.rs <value::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed
'de
deps:{"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":{"T":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":{"T":["value::DatetimeOrTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::MapDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_key_seed(p1);
+<value::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+crate::<value::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+<value::MapDeserializer>::next_key_seed(p0, p1);
-----------------
crates/toml/src/value.rs <value::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed
'de
deps:{"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":{"T":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":{"T":["value::DatetimeOrTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::MapDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_value_seed(p1);
+<value::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+crate::<value::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+<value::MapDeserializer>::next_value_seed(p0, p1);
-----------------
crates/toml/src/value.rs <value::MapDeserializer as serde::de::MapAccess<'de>>::size_hint
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::MapDeserializer
+p0.size_hint();
+<value::MapDeserializer as serde::de::MapAccess<'de>>::size_hint(p0);
+crate::<value::MapDeserializer as serde::de::MapAccess<'de>>::size_hint(p0);
+<value::MapDeserializer>::size_hint(p0);
-----------------
crates/toml/src/value.rs <value::MapDeserializer as serde::de::EnumAccess<'de>>::variant_seed
'de
deps:{"<value::MapDeserializer as serde::de::EnumAccess<'de>>::variant_seed":{"V":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::MapDeserializer as serde::de::EnumAccess<'de>>::variant_seed":{"V":["value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::MapDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.variant_seed(p1);
+<value::MapDeserializer as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+crate::<value::MapDeserializer as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+<value::MapDeserializer>::variant_seed(p0, p1);
-----------------
crates/toml/src/value.rs value::MapEnumDeserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
+value::MapEnumDeserializer::new(p0);
+crate::value::MapEnumDeserializer::new(p0);
+<value::MapEnumDeserializer>::new(p0);
-----------------
crates/toml/src/value.rs <value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::MapEnumDeserializer
+p0.unit_variant();
+<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant(p0);
+crate::<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant(p0);
+<value::MapEnumDeserializer>::unit_variant(p0);
-----------------
crates/toml/src/value.rs <value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed
'de
deps:{"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::MapEnumDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.newtype_variant_seed(p1);
+<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+crate::<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+<value::MapEnumDeserializer>::newtype_variant_seed(p0, p1);
-----------------
crates/toml/src/value.rs <value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant
'de
deps:{"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::MapEnumDeserializer
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.tuple_variant(p1, p2);
+<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+crate::<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+<value::MapEnumDeserializer>::tuple_variant(p0, p1, p2);
-----------------
crates/toml/src/value.rs <value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant
'de
deps:{"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::MapEnumDeserializer
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.struct_variant(p1, p2);
+<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+crate::<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+<value::MapEnumDeserializer>::struct_variant(p0, p1, p2);
-----------------
crates/toml/src/value.rs <value::Value as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.into_deserializer();
+<value::Value as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+crate::<value::Value as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer(p0);
+<value::Value>::into_deserializer(p0);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_bool
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_bool(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_bool(p0, p1);
+<value::ValueSerializer>::serialize_bool(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_i8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_i8(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_i8(p0, p1);
+<value::ValueSerializer>::serialize_i8(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_i16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_i16(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_i16(p0, p1);
+<value::ValueSerializer>::serialize_i16(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_i32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_i32(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_i32(p0, p1);
+<value::ValueSerializer>::serialize_i32(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_i64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_i64(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_i64(p0, p1);
+<value::ValueSerializer>::serialize_i64(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_u8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_u8(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_u8(p0, p1);
+<value::ValueSerializer>::serialize_u8(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_u16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_u16(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_u16(p0, p1);
+<value::ValueSerializer>::serialize_u16(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_u32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_u32(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_u32(p0, p1);
+<value::ValueSerializer>::serialize_u32(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_u64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_u64(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_u64(p0, p1);
+<value::ValueSerializer>::serialize_u64(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_f32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_f32(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_f32(p0, p1);
+<value::ValueSerializer>::serialize_f32(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_f64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_f64(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_f64(p0, p1);
+<value::ValueSerializer>::serialize_f64(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_char(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_char(p0, p1);
+<value::ValueSerializer>::serialize_char(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_str
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<value::ValueSerializer as serde::Serializer>::serialize_str(p0, &p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_str(p0, &p1);
+<value::ValueSerializer>::serialize_str(p0, &p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_bytes(p0, p1);
+<value::ValueSerializer>::serialize_bytes(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_unit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
+p0.serialize_unit();
+<value::ValueSerializer as serde::Serializer>::serialize_unit(p0);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_unit(p0);
+<value::ValueSerializer>::serialize_unit(p0);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_unit_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<value::ValueSerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<value::ValueSerializer>::serialize_unit_struct(p0, &p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_unit_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<value::ValueSerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<value::ValueSerializer>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_newtype_struct
deps:{"<value::ValueSerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<value::ValueSerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<value::ValueSerializer>::serialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_newtype_variant
deps:{"<value::ValueSerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializer as serde::Serializer>::serialize_newtype_variant":{"T":["value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<value::ValueSerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<value::ValueSerializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
+p0.serialize_none();
+<value::ValueSerializer as serde::Serializer>::serialize_none(p0);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_none(p0);
+<value::ValueSerializer>::serialize_none(p0);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_some
deps:{"<value::ValueSerializer as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializer as serde::Serializer>::serialize_some":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_some(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_some(p0, p1);
+<value::ValueSerializer>::serialize_some(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_seq
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_seq(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_seq(p0, p1);
+<value::ValueSerializer>::serialize_seq(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_tuple
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_tuple(p0, p1);
+<value::ValueSerializer>::serialize_tuple(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_tuple_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<value::ValueSerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<value::ValueSerializer>::serialize_tuple_struct(p0, &p1, p2);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_tuple_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<value::ValueSerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<value::ValueSerializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_map
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<value::ValueSerializer as serde::Serializer>::serialize_map(p0, p1);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_map(p0, p1);
+<value::ValueSerializer>::serialize_map(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<value::ValueSerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<value::ValueSerializer>::serialize_struct(p0, &p1, p2);
-----------------
crates/toml/src/value.rs <value::ValueSerializer as serde::Serializer>::serialize_struct_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<value::ValueSerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ValueSerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<value::ValueSerializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_bool
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<value::TableSerializer as serde::Serializer>::serialize_bool(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_bool(p0, p1);
+<value::TableSerializer>::serialize_bool(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_i8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<value::TableSerializer as serde::Serializer>::serialize_i8(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_i8(p0, p1);
+<value::TableSerializer>::serialize_i8(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_i16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<value::TableSerializer as serde::Serializer>::serialize_i16(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_i16(p0, p1);
+<value::TableSerializer>::serialize_i16(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_i32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<value::TableSerializer as serde::Serializer>::serialize_i32(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_i32(p0, p1);
+<value::TableSerializer>::serialize_i32(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_i64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<value::TableSerializer as serde::Serializer>::serialize_i64(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_i64(p0, p1);
+<value::TableSerializer>::serialize_i64(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_u8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<value::TableSerializer as serde::Serializer>::serialize_u8(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_u8(p0, p1);
+<value::TableSerializer>::serialize_u8(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_u16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<value::TableSerializer as serde::Serializer>::serialize_u16(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_u16(p0, p1);
+<value::TableSerializer>::serialize_u16(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_u32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<value::TableSerializer as serde::Serializer>::serialize_u32(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_u32(p0, p1);
+<value::TableSerializer>::serialize_u32(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_u64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<value::TableSerializer as serde::Serializer>::serialize_u64(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_u64(p0, p1);
+<value::TableSerializer>::serialize_u64(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_f32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<value::TableSerializer as serde::Serializer>::serialize_f32(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_f32(p0, p1);
+<value::TableSerializer>::serialize_f32(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_f64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<value::TableSerializer as serde::Serializer>::serialize_f64(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_f64(p0, p1);
+<value::TableSerializer>::serialize_f64(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<value::TableSerializer as serde::Serializer>::serialize_char(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_char(p0, p1);
+<value::TableSerializer>::serialize_char(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_str
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<value::TableSerializer as serde::Serializer>::serialize_str(p0, &p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_str(p0, &p1);
+<value::TableSerializer>::serialize_str(p0, &p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<value::TableSerializer as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_bytes(p0, p1);
+<value::TableSerializer>::serialize_bytes(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_unit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
+p0.serialize_unit();
+<value::TableSerializer as serde::Serializer>::serialize_unit(p0);
+crate::<value::TableSerializer as serde::Serializer>::serialize_unit(p0);
+<value::TableSerializer>::serialize_unit(p0);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_unit_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<value::TableSerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<value::TableSerializer>::serialize_unit_struct(p0, &p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_unit_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<value::TableSerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<value::TableSerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<value::TableSerializer>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_newtype_struct
deps:{"<value::TableSerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::TableSerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<value::TableSerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<value::TableSerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<value::TableSerializer>::serialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_newtype_variant
deps:{"<value::TableSerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::TableSerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<value::TableSerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<value::TableSerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<value::TableSerializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
+p0.serialize_none();
+<value::TableSerializer as serde::Serializer>::serialize_none(p0);
+crate::<value::TableSerializer as serde::Serializer>::serialize_none(p0);
+<value::TableSerializer>::serialize_none(p0);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_some
deps:{"<value::TableSerializer as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::TableSerializer as serde::Serializer>::serialize_some":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<value::TableSerializer as serde::Serializer>::serialize_some(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_some(p0, p1);
+<value::TableSerializer>::serialize_some(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_seq
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<value::TableSerializer as serde::Serializer>::serialize_seq(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_seq(p0, p1);
+<value::TableSerializer>::serialize_seq(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_tuple
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<value::TableSerializer as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_tuple(p0, p1);
+<value::TableSerializer>::serialize_tuple(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_tuple_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<value::TableSerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<value::TableSerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<value::TableSerializer>::serialize_tuple_struct(p0, &p1, p2);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_tuple_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<value::TableSerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<value::TableSerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<value::TableSerializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_map
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<value::TableSerializer as serde::Serializer>::serialize_map(p0, p1);
+crate::<value::TableSerializer as serde::Serializer>::serialize_map(p0, p1);
+<value::TableSerializer>::serialize_map(p0, p1);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<value::TableSerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<value::TableSerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<value::TableSerializer>::serialize_struct(p0, &p1, p2);
-----------------
crates/toml/src/value.rs <value::TableSerializer as serde::Serializer>::serialize_struct_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::TableSerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<value::TableSerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<value::TableSerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<value::TableSerializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/value.rs <value::ValueSerializeVec as serde::ser::SerializeSeq>::serialize_element
deps:{"<value::ValueSerializeVec as serde::ser::SerializeSeq>::serialize_element":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializeVec as serde::ser::SerializeSeq>::serialize_element":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ValueSerializeVec
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<value::ValueSerializeVec as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+crate::<value::ValueSerializeVec as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+<value::ValueSerializeVec>::serialize_element(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializeVec as serde::ser::SerializeSeq>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializeVec
+p0.end();
+<value::ValueSerializeVec as serde::ser::SerializeSeq>::end(p0);
+crate::<value::ValueSerializeVec as serde::ser::SerializeSeq>::end(p0);
+<value::ValueSerializeVec>::end(p0);
-----------------
crates/toml/src/value.rs <value::ValueSerializeVec as serde::ser::SerializeTuple>::serialize_element
deps:{"<value::ValueSerializeVec as serde::ser::SerializeTuple>::serialize_element":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializeVec as serde::ser::SerializeTuple>::serialize_element":{"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ValueSerializeVec
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<value::ValueSerializeVec as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+crate::<value::ValueSerializeVec as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+<value::ValueSerializeVec>::serialize_element(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializeVec as serde::ser::SerializeTuple>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializeVec
+p0.end();
+<value::ValueSerializeVec as serde::ser::SerializeTuple>::end(p0);
+crate::<value::ValueSerializeVec as serde::ser::SerializeTuple>::end(p0);
+<value::ValueSerializeVec>::end(p0);
-----------------
crates/toml/src/value.rs <value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::serialize_field
deps:{"<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ValueSerializeVec
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+crate::<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+<value::ValueSerializeVec>::serialize_field(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializeVec
+p0.end();
+<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::end(p0);
+crate::<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::end(p0);
+<value::ValueSerializeVec>::end(p0);
-----------------
crates/toml/src/value.rs <value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::serialize_field
deps:{"<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ValueSerializeVec
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+crate::<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+<value::ValueSerializeVec>::serialize_field(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializeVec
+p0.end();
+<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::end(p0);
+crate::<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::end(p0);
+<value::ValueSerializeVec>::end(p0);
-----------------
crates/toml/src/value.rs <value::SerializeMap as serde::ser::SerializeMap>::serialize_key
deps:{"<value::SerializeMap as serde::ser::SerializeMap>::serialize_key":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::SerializeMap as serde::ser::SerializeMap>::serialize_key":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::SerializeMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<value::SerializeMap as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<value::SerializeMap as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<value::SerializeMap>::serialize_key(p0, p1);
-----------------
crates/toml/src/value.rs <value::SerializeMap as serde::ser::SerializeMap>::serialize_value
deps:{"<value::SerializeMap as serde::ser::SerializeMap>::serialize_value":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::SerializeMap as serde::ser::SerializeMap>::serialize_value":{"T":["value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::SerializeMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<value::SerializeMap as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<value::SerializeMap as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<value::SerializeMap>::serialize_value(p0, p1);
-----------------
crates/toml/src/value.rs <value::SerializeMap as serde::ser::SerializeMap>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::SerializeMap
+p0.end();
+<value::SerializeMap as serde::ser::SerializeMap>::end(p0);
+crate::<value::SerializeMap as serde::ser::SerializeMap>::end(p0);
+<value::SerializeMap>::end(p0);
-----------------
crates/toml/src/value.rs <value::SerializeMap as serde::ser::SerializeStruct>::serialize_field
deps:{"<value::SerializeMap as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::SerializeMap as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::SerializeMap
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<value::SerializeMap as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<value::SerializeMap as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<value::SerializeMap>::serialize_field(p0, &p1, p2);
-----------------
crates/toml/src/value.rs <value::SerializeMap as serde::ser::SerializeStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::SerializeMap
+p0.end();
+<value::SerializeMap as serde::ser::SerializeStruct>::end(p0);
+crate::<value::SerializeMap as serde::ser::SerializeStruct>::end(p0);
+<value::SerializeMap>::end(p0);
-----------------
crates/toml/src/value.rs <value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_key
deps:{"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_key":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_key":{"T":["value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ValueSerializeMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<value::ValueSerializeMap>::serialize_key(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_value
deps:{"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_value":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_value":{"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ValueSerializeMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<value::ValueSerializeMap>::serialize_value(p0, p1);
-----------------
crates/toml/src/value.rs <value::ValueSerializeMap as serde::ser::SerializeMap>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializeMap
+p0.end();
+<value::ValueSerializeMap as serde::ser::SerializeMap>::end(p0);
+crate::<value::ValueSerializeMap as serde::ser::SerializeMap>::end(p0);
+<value::ValueSerializeMap>::end(p0);
-----------------
crates/toml/src/value.rs <value::ValueSerializeMap as serde::ser::SerializeStruct>::serialize_field
deps:{"<value::ValueSerializeMap as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ValueSerializeMap as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ValueSerializeMap
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<value::ValueSerializeMap as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<value::ValueSerializeMap as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<value::ValueSerializeMap>::serialize_field(p0, &p1, p2);
-----------------
crates/toml/src/value.rs <value::ValueSerializeMap as serde::ser::SerializeStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ValueSerializeMap
+p0.end();
+<value::ValueSerializeMap as serde::ser::SerializeStruct>::end(p0);
+crate::<value::ValueSerializeMap as serde::ser::SerializeStruct>::end(p0);
+<value::ValueSerializeMap>::end(p0);
-----------------
crates/toml/src/value.rs <value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::deserialize
'a,'de
deps:{"<value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::deserialize":{"D":["serde::Deserializer","std::marker::Sized"]}}
candidates:{"<value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::deserialize":{"D":["de::Deserializer","value::Value","table::Table","de::ValueDeserializer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::DatetimeOrTable<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // D
+p0.deserialize(p1);
+<value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::deserialize(p0, p1);
+crate::<value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::deserialize(p0, p1);
+<value::DatetimeOrTable<'a>>::deserialize(p0, p1);
-----------------
crates/toml/src/value.rs <value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::expecting
'a,'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::DatetimeOrTable<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::expecting(p0, p1);
+<value::DatetimeOrTable<'a>>::expecting(p0, p1);
-----------------
crates/toml/src/value.rs <value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_str
'a,'de
deps:{"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_str":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_str":{"E":["de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::DatetimeOrTable<'a>
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<value::DatetimeOrTable<'a>>::visit_str(p0, &p1);
-----------------
crates/toml/src/value.rs <value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_string
'a,'de
deps:{"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_string":{"E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_string":{"E":["de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::DatetimeOrTable<'a>
let mut p1 = std::string::String::new(); // None+std::string::String
+p0.visit_string(p1);
+<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_string(p0, p1);
+crate::<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_string(p0, p1);
+<value::DatetimeOrTable<'a>>::visit_string(p0, p1);
-----------------
crates/toml/src/de.rs <de::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<de::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<de::Error as std::fmt::Debug>::fmt(p0, p1);
+<de::Error>::fmt(p0, p1);
-----------------
crates/toml/src/de.rs <de::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.eq(p1);
+<de::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<de::Error as std::cmp::PartialEq>::eq(p0, p1);
+<de::Error>::eq(p0, p1);
-----------------
crates/toml/src/de.rs <de::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.assert_receiver_is_total_eq();
+<de::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<de::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<de::Error>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml/src/de.rs <de::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.clone();
+<de::Error as std::clone::Clone>::clone(p0);
+crate::<de::Error as std::clone::Clone>::clone(p0);
+<de::Error>::clone(p0);
-----------------
crates/toml/src/de.rs de::Error::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_edit::de::Error
+de::Error::new(p0);
+crate::de::Error::new(p0);
+<de::Error>::new(p0);
-----------------
crates/toml/src/de.rs de::Error::add_key
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = std::string::String::new(); // None+std::string::String
+p0.add_key(p1);
+de::Error::add_key(p0, p1);
+crate::de::Error::add_key(p0, p1);
+<de::Error>::add_key(p0, p1);
-----------------
crates/toml/src/de.rs de::Error::message
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.message();
+de::Error::message(p0);
+crate::de::Error::message(p0);
+<de::Error>::message(p0);
-----------------
crates/toml/src/de.rs de::Error::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
+p0.span();
+de::Error::span(p0);
+crate::de::Error::span(p0);
+<de::Error>::span(p0);
-----------------
crates/toml/src/de.rs <de::Error as serde::de::Error>::custom
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<de::Error as serde::de::Error>::custom":{"T":["std::marker::Sized","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<de::Error as serde::de::Error>::custom":{"T":["table::Table","<&T as std::fmt::Display>","ser::Error","value::Value","de::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<de::Error as serde::de::Error>::custom(p0);
+crate::<de::Error as serde::de::Error>::custom(p0);
+<de::Error>::custom(p0);
-----------------
crates/toml/src/de.rs <de::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<de::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<de::Error as std::fmt::Display>::fmt(p0, p1);
+<de::Error>::fmt(p0, p1);
-----------------
crates/toml/src/de.rs de::Deserializer::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+de::Deserializer::<'a>::new(&p0);
+crate::de::Deserializer::<'a>::new(&p0);
+<de::Deserializer<'a>>::new(&p0);
-----------------
crates/toml/src/de.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_any
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_any":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<de::Deserializer<'a>>::deserialize_any(p0, p1);
-----------------
crates/toml/src/de.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_option
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_option":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_option":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<de::Deserializer<'a>>::deserialize_option(p0, p1);
-----------------
crates/toml/src/de.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<de::Deserializer<'a>>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml/src/de.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_struct
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<de::Deserializer<'a>>::deserialize_struct(p0, &p1, p2, p3);
-----------------
crates/toml/src/de.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_enum
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<de::Deserializer<'a>>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bool
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<de::Deserializer<'a>>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u8
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<de::Deserializer<'a>>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u16
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<de::Deserializer<'a>>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u32
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<de::Deserializer<'a>>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u64
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<de::Deserializer<'a>>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i8
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<de::Deserializer<'a>>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i16
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<de::Deserializer<'a>>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i32
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<de::Deserializer<'a>>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i64
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<de::Deserializer<'a>>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f32
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<de::Deserializer<'a>>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f64
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<de::Deserializer<'a>>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_char
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_char":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<de::Deserializer<'a>>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_str
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_str":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<de::Deserializer<'a>>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_string
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_string":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<de::Deserializer<'a>>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_seq
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<de::Deserializer<'a>>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<de::Deserializer<'a>>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<de::Deserializer<'a>>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_map
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_map":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<de::Deserializer<'a>>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<de::Deserializer<'a>>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<de::Deserializer<'a>>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<de::Deserializer<'a>>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<de::Deserializer<'a>>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<de::Deserializer<'a>>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier
'de,'a
deps:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<de::Deserializer<'a>>::deserialize_identifier(p0, p1);
-----------------
crates/toml/src/de.rs de::ValueDeserializer::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+de::ValueDeserializer::<'a>::new(&p0);
+crate::de::ValueDeserializer::<'a>::new(&p0);
+<de::ValueDeserializer<'a>>::new(&p0);
-----------------
crates/toml/src/de.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_any
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_any":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_any(p0, p1);
-----------------
crates/toml/src/de.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_option
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_option":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_option(p0, p1);
-----------------
crates/toml/src/de.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<de::ValueDeserializer<'a>>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml/src/de.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_struct
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<de::ValueDeserializer<'a>>::deserialize_struct(p0, &p1, p2, p3);
-----------------
crates/toml/src/de.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_enum
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<de::ValueDeserializer<'a>>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bool
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u8
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u16
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u32
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u64
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i8
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i16
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i32
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i64
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f32
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f64
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_char
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_char":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_char":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_str
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_str":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_string
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_string":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_seq
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_map
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_map":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<de::ValueDeserializer<'a>>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<de::ValueDeserializer<'a>>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<de::ValueDeserializer<'a>>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs <de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier
'de,'a
deps:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ValueDeserializer<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<de::ValueDeserializer<'a>>::deserialize_identifier(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ser::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<ser::Error as std::fmt::Debug>::fmt(p0, p1);
+<ser::Error>::fmt(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
+p0.clone();
+<ser::Error as std::clone::Clone>::clone(p0);
+crate::<ser::Error as std::clone::Clone>::clone(p0);
+<ser::Error>::clone(p0);
-----------------
crates/toml/src/ser.rs <ser::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // ser::Error
+p0.eq(p1);
+<ser::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ser::Error as std::cmp::PartialEq>::eq(p0, p1);
+<ser::Error>::eq(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
+p0.assert_receiver_is_total_eq();
+<ser::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ser::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ser::Error>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml/src/ser.rs ser::Error::new
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"ser::Error::new":{"impl std::fmt::Display":["std::marker::Sized","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"ser::Error::new":{"impl std::fmt::Display":["table::Table","de::Error","value::Value","ser::Error","<&T as std::fmt::Display>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl std::fmt::Display
+ser::Error::new(p0);
+crate::ser::Error::new(p0);
+<ser::Error>::new(p0);
-----------------
crates/toml/src/ser.rs ser::Error::wrap
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_edit::ser::Error
+ser::Error::wrap(p0);
+crate::ser::Error::wrap(p0);
+<ser::Error>::wrap(p0);
-----------------
crates/toml/src/ser.rs ser::Error::unsupported_type
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<&'static str>
+ser::Error::unsupported_type(p0);
+crate::ser::Error::unsupported_type(p0);
+<ser::Error>::unsupported_type(p0);
-----------------
crates/toml/src/ser.rs ser::Error::unsupported_none
deps:{}
candidates:{}
+ser::Error::unsupported_none();
+crate::ser::Error::unsupported_none();
+<ser::Error>::unsupported_none();
-----------------
crates/toml/src/ser.rs ser::Error::key_not_string
deps:{}
candidates:{}
+ser::Error::key_not_string();
+crate::ser::Error::key_not_string();
+<ser::Error>::key_not_string();
-----------------
crates/toml/src/ser.rs <ser::Error as serde::ser::Error>::custom
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<ser::Error as serde::ser::Error>::custom":{"T":["std::marker::Sized","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<ser::Error as serde::ser::Error>::custom":{"T":["value::Value","table::Table","<&mut T as std::fmt::Display>","ser::Error","de::Error","<&T as std::fmt::Display>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<ser::Error as serde::ser::Error>::custom(p0);
+crate::<ser::Error as serde::ser::Error>::custom(p0);
+<ser::Error>::custom(p0);
-----------------
crates/toml/src/ser.rs <ser::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ser::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<ser::Error as std::fmt::Display>::fmt(p0, p1);
+<ser::Error>::fmt(p0, p1);
-----------------
crates/toml/src/ser.rs ser::Serializer::<'d>::new
'd
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
+ser::Serializer::<'d>::new(p0);
+crate::ser::Serializer::<'d>::new(p0);
+<ser::Serializer<'d>>::new(p0);
-----------------
crates/toml/src/ser.rs ser::Serializer::<'d>::pretty
'd
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
+ser::Serializer::<'d>::pretty(p0);
+crate::ser::Serializer::<'d>::pretty(p0);
+<ser::Serializer<'d>>::pretty(p0);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_bool
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_bool(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_bool(p0, p1);
+<ser::Serializer<'d>>::serialize_bool(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_i8
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_i8(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_i8(p0, p1);
+<ser::Serializer<'d>>::serialize_i8(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_i16
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_i16(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_i16(p0, p1);
+<ser::Serializer<'d>>::serialize_i16(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_i32
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_i32(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_i32(p0, p1);
+<ser::Serializer<'d>>::serialize_i32(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_i64
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_i64(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_i64(p0, p1);
+<ser::Serializer<'d>>::serialize_i64(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_u8
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_u8(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_u8(p0, p1);
+<ser::Serializer<'d>>::serialize_u8(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_u16
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_u16(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_u16(p0, p1);
+<ser::Serializer<'d>>::serialize_u16(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_u32
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_u32(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_u32(p0, p1);
+<ser::Serializer<'d>>::serialize_u32(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_u64
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_u64(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_u64(p0, p1);
+<ser::Serializer<'d>>::serialize_u64(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_f32
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_f32(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_f32(p0, p1);
+<ser::Serializer<'d>>::serialize_f32(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_f64
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_f64(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_f64(p0, p1);
+<ser::Serializer<'d>>::serialize_f64(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_char
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_char(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_char(p0, p1);
+<ser::Serializer<'d>>::serialize_char(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_str
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_str(p0, &p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_str(p0, &p1);
+<ser::Serializer<'d>>::serialize_str(p0, &p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_bytes
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_bytes(p0, p1);
+<ser::Serializer<'d>>::serialize_bytes(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_none
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
+p0.serialize_none();
+<ser::Serializer<'d> as serde::Serializer>::serialize_none(p0);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_none(p0);
+<ser::Serializer<'d>>::serialize_none(p0);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_some
'd
deps:{"<ser::Serializer<'d> as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::Serializer<'d> as serde::Serializer>::serialize_some":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_some(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_some(p0, p1);
+<ser::Serializer<'d>>::serialize_some(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_unit
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
+p0.serialize_unit();
+<ser::Serializer<'d> as serde::Serializer>::serialize_unit(p0);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_unit(p0);
+<ser::Serializer<'d>>::serialize_unit(p0);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_unit_struct
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<ser::Serializer<'d>>::serialize_unit_struct(p0, &p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_unit_variant
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<ser::Serializer<'d> as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<ser::Serializer<'d>>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_newtype_struct
'd
deps:{"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_struct":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<ser::Serializer<'d>>::serialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_newtype_variant
'd
deps:{"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_variant":{"T":["value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<ser::Serializer<'d>>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_seq
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_seq(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_seq(p0, p1);
+<ser::Serializer<'d>>::serialize_seq(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_tuple
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_tuple(p0, p1);
+<ser::Serializer<'d>>::serialize_tuple(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_tuple_struct
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<ser::Serializer<'d>>::serialize_tuple_struct(p0, &p1, p2);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_tuple_variant
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<ser::Serializer<'d>>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_map
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<ser::Serializer<'d> as serde::Serializer>::serialize_map(p0, p1);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_map(p0, p1);
+<ser::Serializer<'d>>::serialize_map(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_struct
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<ser::Serializer<'d> as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<ser::Serializer<'d>>::serialize_struct(p0, &p1, p2);
-----------------
crates/toml/src/ser.rs <ser::Serializer<'d> as serde::Serializer>::serialize_struct_variant
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<ser::Serializer<'d> as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::Serializer<'d> as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<ser::Serializer<'d>>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/ser.rs ser::ValueSerializer::<'d>::new
'd
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
+ser::ValueSerializer::<'d>::new(p0);
+crate::ser::ValueSerializer::<'d>::new(p0);
+<ser::ValueSerializer<'d>>::new(p0);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_bool
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bool(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bool(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_bool(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_i8
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i8(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i8(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_i8(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_i16
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i16(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i16(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_i16(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_i32
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i32(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i32(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_i32(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_i64
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i64(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i64(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_i64(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_u8
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u8(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u8(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_u8(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_u16
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u16(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u16(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_u16(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_u32
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u32(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u32(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_u32(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_u64
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u64(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u64(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_u64(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_f32
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f32(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f32(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_f32(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_f64
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f64(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f64(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_f64(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_char
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_char(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_char(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_char(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_str
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_str(p0, &p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_str(p0, &p1);
+<ser::ValueSerializer<'d>>::serialize_str(p0, &p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_bytes
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bytes(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_bytes(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_none
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
+p0.serialize_none();
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_none(p0);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_none(p0);
+<ser::ValueSerializer<'d>>::serialize_none(p0);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_some
'd
deps:{"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_some":{"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_some(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_some(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_some(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
+p0.serialize_unit();
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit(p0);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit(p0);
+<ser::ValueSerializer<'d>>::serialize_unit(p0);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_struct
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<ser::ValueSerializer<'d>>::serialize_unit_struct(p0, &p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_variant
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<ser::ValueSerializer<'d>>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_struct
'd
deps:{"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_struct":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<ser::ValueSerializer<'d>>::serialize_newtype_struct(p0, &p1, p2);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_variant
'd
deps:{"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_variant":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<ser::ValueSerializer<'d>>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_seq
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_seq(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_seq(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_seq(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_tuple(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_struct
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<ser::ValueSerializer<'d>>::serialize_tuple_struct(p0, &p1, p2);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_variant
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<ser::ValueSerializer<'d>>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_map
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_map(p0, p1);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_map(p0, p1);
+<ser::ValueSerializer<'d>>::serialize_map(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<ser::ValueSerializer<'d>>::serialize_struct(p0, &p1, p2);
-----------------
crates/toml/src/ser.rs <ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct_variant
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<ser::ValueSerializer<'d>>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
crates/toml/src/ser.rs ser::internal::SerializeDocumentArray::<'d>::new
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = MaybeUninit::uninit().assume_init(); // <toml_edit::ser::ValueSerializer as serde::Serializer>::SerializeSeq
+ser::internal::SerializeDocumentArray::<'d>::new(p0, p1);
+crate::ser::internal::SerializeDocumentArray::<'d>::new(p0, p1);
+<ser::internal::SerializeDocumentArray<'d>>::new(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::serialize_element
'd
deps:{"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::serialize_element":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::serialize_element":{"T":["value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentArray<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+crate::<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+<ser::internal::SerializeDocumentArray<'d>>::serialize_element(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentArray<'d>
+p0.end();
+<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::end(p0);
+crate::<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::end(p0);
+<ser::internal::SerializeDocumentArray<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::serialize_element
'd
deps:{"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::serialize_element":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::serialize_element":{"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentArray<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+crate::<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+<ser::internal::SerializeDocumentArray<'d>>::serialize_element(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentArray<'d>
+p0.end();
+<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::end(p0);
+crate::<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::end(p0);
+<ser::internal::SerializeDocumentArray<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field
'd
deps:{"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentArray<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+crate::<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+<ser::internal::SerializeDocumentArray<'d>>::serialize_field(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentArray<'d>
+p0.end();
+<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::end(p0);
+crate::<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::end(p0);
+<ser::internal::SerializeDocumentArray<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field
'd
deps:{"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentArray<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+crate::<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+<ser::internal::SerializeDocumentArray<'d>>::serialize_field(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentArray<'d>
+p0.end();
+<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::end(p0);
+crate::<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::end(p0);
+<ser::internal::SerializeDocumentArray<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs ser::internal::SerializeDocumentTable::<'d>::new
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<'d>
let mut p1 = MaybeUninit::uninit().assume_init(); // <toml_edit::ser::ValueSerializer as serde::Serializer>::SerializeMap
+ser::internal::SerializeDocumentTable::<'d>::new(p0, p1);
+crate::ser::internal::SerializeDocumentTable::<'d>::new(p0, p1);
+<ser::internal::SerializeDocumentTable<'d>>::new(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_key
'd
deps:{"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_key":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_key":{"T":["map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentTable<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<ser::internal::SerializeDocumentTable<'d>>::serialize_key(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_value
'd
deps:{"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_value":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_value":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentTable<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<ser::internal::SerializeDocumentTable<'d>>::serialize_value(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentTable<'d>
+p0.end();
+<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::end(p0);
+crate::<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::end(p0);
+<ser::internal::SerializeDocumentTable<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::serialize_field
'd
deps:{"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentTable<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<ser::internal::SerializeDocumentTable<'d>>::serialize_field(p0, &p1, p2);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeDocumentTable<'d>
+p0.end();
+<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::end(p0);
+crate::<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::end(p0);
+<ser::internal::SerializeDocumentTable<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs ser::internal::SerializeValueArray::<'d>::new
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = MaybeUninit::uninit().assume_init(); // <toml_edit::ser::ValueSerializer as serde::Serializer>::SerializeSeq
+ser::internal::SerializeValueArray::<'d>::new(p0, p1);
+crate::ser::internal::SerializeValueArray::<'d>::new(p0, p1);
+<ser::internal::SerializeValueArray<'d>>::new(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::serialize_element
'd
deps:{"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::serialize_element":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::serialize_element":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueArray<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+crate::<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+<ser::internal::SerializeValueArray<'d>>::serialize_element(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueArray<'d>
+p0.end();
+<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::end(p0);
+crate::<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::end(p0);
+<ser::internal::SerializeValueArray<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::serialize_element
'd
deps:{"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::serialize_element":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::serialize_element":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueArray<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+crate::<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+<ser::internal::SerializeValueArray<'d>>::serialize_element(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueArray<'d>
+p0.end();
+<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::end(p0);
+crate::<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::end(p0);
+<ser::internal::SerializeValueArray<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field
'd
deps:{"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueArray<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+crate::<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+<ser::internal::SerializeValueArray<'d>>::serialize_field(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueArray<'d>
+p0.end();
+<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::end(p0);
+crate::<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::end(p0);
+<ser::internal::SerializeValueArray<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field
'd
deps:{"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueArray<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+crate::<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+<ser::internal::SerializeValueArray<'d>>::serialize_field(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueArray<'d>
+p0.end();
+<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::end(p0);
+crate::<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::end(p0);
+<ser::internal::SerializeValueArray<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs ser::internal::SerializeValueTable::<'d>::new
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::ValueSerializer<'d>
let mut p1 = MaybeUninit::uninit().assume_init(); // <toml_edit::ser::ValueSerializer as serde::Serializer>::SerializeMap
+ser::internal::SerializeValueTable::<'d>::new(p0, p1);
+crate::ser::internal::SerializeValueTable::<'d>::new(p0, p1);
+<ser::internal::SerializeValueTable<'d>>::new(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_key
'd
deps:{"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_key":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_key":{"T":["value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueTable<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<ser::internal::SerializeValueTable<'d>>::serialize_key(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_value
'd
deps:{"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_value":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_value":{"T":["map::Map","serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueTable<'d>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<ser::internal::SerializeValueTable<'d>>::serialize_value(p0, p1);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueTable<'d>
+p0.end();
+<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::end(p0);
+crate::<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::end(p0);
+<ser::internal::SerializeValueTable<'d>>::end(p0);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::serialize_field
'd
deps:{"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueTable<'d>
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<ser::internal::SerializeValueTable<'d>>::serialize_field(p0, &p1, p2);
-----------------
crates/toml/src/ser.rs <ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::end
'd
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::internal::SerializeValueTable<'d>
+p0.end();
+<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::end(p0);
+crate::<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::end(p0);
+<ser::internal::SerializeValueTable<'d>>::end(p0);
-----------------
crates/toml/src/fmt.rs <fmt::DocumentFormatter as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // fmt::DocumentFormatter
+p0.clone();
+<fmt::DocumentFormatter as std::clone::Clone>::clone(p0);
+crate::<fmt::DocumentFormatter as std::clone::Clone>::clone(p0);
+<fmt::DocumentFormatter>::clone(p0);
-----------------
crates/toml/src/fmt.rs <fmt::DocumentFormatter as std::default::Default>::default
deps:{}
candidates:{}
+<fmt::DocumentFormatter as std::default::Default>::default();
+crate::<fmt::DocumentFormatter as std::default::Default>::default();
+<fmt::DocumentFormatter>::default();
-----------------
crates/toml/src/fmt.rs <fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_document_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fmt::DocumentFormatter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // toml_edit::Document
+p0.visit_document_mut(p1);
+<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_document_mut(p0, p1);
+crate::<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_document_mut(p0, p1);
+<fmt::DocumentFormatter>::visit_document_mut(p0, p1);
-----------------
crates/toml/src/fmt.rs <fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_item_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fmt::DocumentFormatter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // toml_edit::Item
+p0.visit_item_mut(p1);
+<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_item_mut(p0, p1);
+crate::<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_item_mut(p0, p1);
+<fmt::DocumentFormatter>::visit_item_mut(p0, p1);
-----------------
crates/toml/src/fmt.rs <fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fmt::DocumentFormatter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // toml_edit::Table
+p0.visit_table_mut(p1);
+<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_table_mut(p0, p1);
+crate::<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_table_mut(p0, p1);
+<fmt::DocumentFormatter>::visit_table_mut(p0, p1);
-----------------
crates/toml/src/fmt.rs <fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fmt::DocumentFormatter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // toml_edit::Value
+p0.visit_value_mut(p1);
+<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_value_mut(p0, p1);
+crate::<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_value_mut(p0, p1);
+<fmt::DocumentFormatter>::visit_value_mut(p0, p1);
-----------------
crates/toml/src/fmt.rs <fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_array_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // fmt::DocumentFormatter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // toml_edit::Array
+p0.visit_array_mut(p1);
+<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_array_mut(p0, p1);
+crate::<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_array_mut(p0, p1);
+<fmt::DocumentFormatter>::visit_array_mut(p0, p1);
-----------------
crates/toml/src/table.rs table::<impl map::Map<std::string::String, value::Value>>::try_from
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"table::<impl map::Map<std::string::String, value::Value>>::try_from":{"T":["std::marker::Sized","serde::Serialize"]}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"table::<impl map::Map<std::string::String, value::Value>>::try_from":{"T":["serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value","map::Map"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+table::<impl map::Map<std::string::String, value::Value>>::try_from(p0);
+crate::table::<impl map::Map<std::string::String, value::Value>>::try_from(p0);
+<map::Map<std::string::String, value::Value>>::try_from(p0);
-----------------
crates/toml/src/table.rs table::<impl map::Map<std::string::String, value::Value>>::try_into
'de
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"table::<impl map::Map<std::string::String, value::Value>>::try_into":{"T":["serde::Deserialize","std::marker::Sized"]}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"table::<impl map::Map<std::string::String, value::Value>>::try_into":{"T":["map::Map","value::Value"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.try_into();
+table::<impl map::Map<std::string::String, value::Value>>::try_into(p0);
+crate::table::<impl map::Map<std::string::String, value::Value>>::try_into(p0);
+<map::Map<std::string::String, value::Value>>::try_into(p0);
-----------------
crates/toml/src/table.rs table::<impl std::fmt::Display for map::Map<std::string::String, value::Value>>::fmt
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+table::<impl std::fmt::Display for map::Map<std::string::String, value::Value>>::fmt(p0, p1);
+crate::table::<impl std::fmt::Display for map::Map<std::string::String, value::Value>>::fmt(p0, p1);
+<map::Map<std::string::String, value::Value>>::fmt(p0, p1);
-----------------
crates/toml/src/table.rs table::<impl std::str::FromStr for map::Map<std::string::String, value::Value>>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+table::<impl std::str::FromStr for map::Map<std::string::String, value::Value>>::from_str(&p0);
+crate::table::<impl std::str::FromStr for map::Map<std::string::String, value::Value>>::from_str(&p0);
+<map::Map<std::string::String, value::Value>>::from_str(&p0);
-----------------
crates/toml/src/table.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_any
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_any":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_any(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_any(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_any(p0, p1);
-----------------
crates/toml/src/table.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_enum
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_enum":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_enum":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_enum(p0, &p1, p2, p3);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_enum(p0, &p1, p2, p3);
+<map::Map<std::string::String, value::Value>>::deserialize_enum(p0, &p1, p2, p3);
-----------------
crates/toml/src/table.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_option
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_option":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_option":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_option(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_option(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_option(p0, p1);
-----------------
crates/toml/src/table.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_newtype_struct
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_newtype_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_newtype_struct":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_newtype_struct(p0, &p1, p2);
+<map::Map<std::string::String, value::Value>>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bool
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bool":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bool(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bool(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_bool(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u8
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u8":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u8(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u8(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_u8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u16
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u16":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u16(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u16(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_u16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u32
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u32":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u32(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u32(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_u32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u64
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u64":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u64(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u64(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_u64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i8
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i8":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i8(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i8(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_i8(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i16
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i16":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i16(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i16(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_i16(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i32
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i32(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i32(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_i32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i64
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i64":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i64(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i64(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_i64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f32
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f32":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f32(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f32(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_f32(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f64
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f64":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f64(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f64(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_f64(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_char
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_char":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_char(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_char(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_char(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_str
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_str":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_str(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_str(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_str(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_string
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_string":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_string":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_string(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_string(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_string(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_unit(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_seq
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_seq":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_seq":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_seq(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_seq(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_seq(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bytes
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bytes":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bytes":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bytes(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bytes(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_bytes(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_byte_buf
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_byte_buf":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_byte_buf(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_byte_buf(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_byte_buf(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_map
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_map":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_map":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_map(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_map(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_map(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit_struct
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit_struct":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit_struct(p0, &p1, p2);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit_struct(p0, &p1, p2);
+<map::Map<std::string::String, value::Value>>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple_struct
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple_struct":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<map::Map<std::string::String, value::Value>>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_struct
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_struct":{"V":["value::DatetimeOrTable","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_struct(p0, &p1, p2, p3);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_struct(p0, &p1, p2, p3);
+<map::Map<std::string::String, value::Value>>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple(p0, p1, p2);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple(p0, p1, p2);
+<map::Map<std::string::String, value::Value>>::deserialize_tuple(p0, p1, p2);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_ignored_any
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_ignored_any":{"V":["value::DatetimeOrTable","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_ignored_any(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_ignored_any(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_ignored_any(p0, p1);
-----------------
/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_identifier
'de
deps:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_identifier":{"V":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::DatetimeOrTable"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_identifier(p0, p1);
+crate::table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_identifier(p0, p1);
+<map::Map<std::string::String, value::Value>>::deserialize_identifier(p0, p1);
-----------------
crates/toml/src/table.rs table::<impl serde::de::IntoDeserializer<'de, de::Error> for map::Map<std::string::String, value::Value>>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.into_deserializer();
+table::<impl serde::de::IntoDeserializer<'de, de::Error> for map::Map<std::string::String, value::Value>>::into_deserializer(p0);
+crate::table::<impl serde::de::IntoDeserializer<'de, de::Error> for map::Map<std::string::String, value::Value>>::into_deserializer(p0);
+<map::Map<std::string::String, value::Value>>::into_deserializer(p0);