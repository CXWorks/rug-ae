-----------------
src/cast.rs cast::cast
deps:{"cast::cast":{"T":["std::marker::Sized","cast::NumCast"],"U":["std::marker::Sized","cast::NumCast"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","ops::wrapping::WrappingMul","bounds::Bounded","identities::Zero","cast::NumCast","sign::Signed","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","Num","cast::ToPrimitive","cast::FromPrimitive","std::marker::Sized","sign::Unsigned","ops::wrapping::WrappingSub","ops::wrapping::WrappingShr","identities::One"]}}
candidates:{"cast::cast":{"T":["std::num::Wrapping"],"U":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+cast::cast(p0);
+crate::cast::cast(p0);
+crate::cast::cast(p0);
-----------------
src/float.rs float::integer_decode_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+float::integer_decode_f32(p0);
+crate::float::integer_decode_f32(p0);
+crate::float::integer_decode_f32(p0);
-----------------
src/float.rs float::integer_decode_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+float::integer_decode_f64(p0);
+crate::float::integer_decode_f64(p0);
+crate::float::integer_decode_f64(p0);
-----------------
src/identities.rs identities::zero
deps:{"identities::zero":{"T":["std::marker::Sized","identities::Zero"]},"std::num::Wrapping":{"T":["cast::NumCast","ops::wrapping::WrappingShr","std::marker::Sized","ops::wrapping::WrappingAdd","bounds::Bounded","identities::One","ops::wrapping::WrappingSub","sign::Signed","cast::FromPrimitive","cast::ToPrimitive","ops::wrapping::WrappingMul","Num","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","identities::Zero","sign::Unsigned"]}}
candidates:{"identities::zero":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+identities::zero();
+crate::identities::zero();
+crate::identities::zero();
-----------------
src/identities.rs identities::one
deps:{"identities::one":{"T":["std::marker::Sized","identities::One"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","cast::FromPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","cast::ToPrimitive","cast::NumCast","std::marker::Sized","ops::wrapping::WrappingMul","identities::Zero","ops::wrapping::WrappingAdd","Num","ops::wrapping::WrappingSub","sign::Signed","identities::One","bounds::Bounded","sign::Unsigned"]}}
candidates:{"identities::one":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+identities::one();
+crate::identities::one();
+crate::identities::one();
-----------------
src/int.rs int::one_per_byte
deps:{"int::one_per_byte":{"P":["int::PrimInt","std::marker::Sized"]}}
candidates:{"int::one_per_byte":{"P":[]}}
+int::one_per_byte();
+crate::int::one_per_byte();
+crate::int::one_per_byte();
-----------------
src/int.rs int::reverse_bits_fallback
deps:{"int::reverse_bits_fallback":{"P":["std::marker::Sized","int::PrimInt"]}}
candidates:{"int::reverse_bits_fallback":{"P":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
+int::reverse_bits_fallback(p0);
+crate::int::reverse_bits_fallback(p0);
+crate::int::reverse_bits_fallback(p0);
-----------------
src/pow.rs pow::pow
deps:{"pow::pow":{"T":["std::clone::Clone","identities::One","std::ops::Mul","std::marker::Sized"]}}
candidates:{"pow::pow":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+pow::pow(p0, p1);
+crate::pow::pow(p0, p1);
+crate::pow::pow(p0, p1);
-----------------
src/pow.rs pow::checked_pow
deps:{"pow::checked_pow":{"T":["std::marker::Sized","ops::checked::CheckedMul","identities::One","std::clone::Clone"]}}
candidates:{"pow::checked_pow":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+pow::checked_pow(p0, p1);
+crate::pow::checked_pow(p0, p1);
+crate::pow::checked_pow(p0, p1);
-----------------
src/sign.rs sign::abs
deps:{"sign::abs":{"T":["std::marker::Sized","sign::Signed"]},"std::num::Wrapping":{"T":["std::marker::Sized","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","Num","sign::Signed","bounds::Bounded","identities::One","ops::wrapping::WrappingSub","cast::FromPrimitive","cast::ToPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","sign::Unsigned","cast::NumCast","ops::wrapping::WrappingShr","identities::Zero"]}}
candidates:{"sign::abs":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+sign::abs(p0);
+crate::sign::abs(p0);
+crate::sign::abs(p0);
-----------------
src/sign.rs sign::abs_sub
deps:{"sign::abs_sub":{"T":["sign::Signed","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::NumCast","std::marker::Sized","Num","sign::Unsigned","cast::ToPrimitive","sign::Signed","identities::Zero","cast::FromPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","bounds::Bounded","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","ops::wrapping::WrappingAdd","identities::One"]}}
candidates:{"sign::abs_sub":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+sign::abs_sub(p0, p1);
+crate::sign::abs_sub(p0, p1);
+crate::sign::abs_sub(p0, p1);
-----------------
src/sign.rs sign::signum
deps:{"sign::signum":{"T":["sign::Signed","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingSub","cast::ToPrimitive","bounds::Bounded","identities::Zero","sign::Unsigned","ops::wrapping::WrappingShl","sign::Signed","ops::wrapping::WrappingShr","std::marker::Sized","ops::wrapping::WrappingNeg","identities::One","cast::FromPrimitive","cast::NumCast","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","Num"]}}
candidates:{"sign::signum":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+sign::signum(p0);
+crate::sign::signum(p0);
+crate::sign::signum(p0);
-----------------
src/lib.rs str_to_ascii_lower_eq_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = "sample"; // None+&str
+str_to_ascii_lower_eq_str(&p0, &p1);
+crate::str_to_ascii_lower_eq_str(&p0, &p1);
+crate::str_to_ascii_lower_eq_str(&p0, &p1);
-----------------
src/lib.rs <f32 as Num>::from_str_radix::slice_shift_char
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<f32 as Num>::from_str_radix::slice_shift_char(&p0);
+crate::<f32 as Num>::from_str_radix::slice_shift_char(&p0);
+<f32>::from_str_radix::slice_shift_char(&p0);
-----------------
src/lib.rs <f32 as Num>::from_str_radix::pow
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0usize; // None+usize
+<f32 as Num>::from_str_radix::pow(p0, p1);
+crate::<f32 as Num>::from_str_radix::pow(p0, p1);
+<f32>::from_str_radix::pow(p0, p1);
-----------------
src/lib.rs <f64 as Num>::from_str_radix::slice_shift_char
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<f64 as Num>::from_str_radix::slice_shift_char(&p0);
+crate::<f64 as Num>::from_str_radix::slice_shift_char(&p0);
+<f64>::from_str_radix::slice_shift_char(&p0);
-----------------
src/lib.rs <f64 as Num>::from_str_radix::pow
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0usize; // None+usize
+<f64 as Num>::from_str_radix::pow(p0, p1);
+crate::<f64 as Num>::from_str_radix::pow(p0, p1);
+<f64>::from_str_radix::pow(p0, p1);
-----------------
src/lib.rs clamp
deps:{"clamp":{"T":["std::marker::Sized","std::cmp::PartialOrd"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"clamp":{"T":["bool","i8","i32","char","std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>","usize","u64","i16","u32","i64","u8","u16","std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+clamp(p0, p1, p2);
+crate::clamp(p0, p1, p2);
+crate::clamp(p0, p1, p2);
-----------------
src/lib.rs clamp_min
deps:{"clamp_min":{"T":["std::marker::Sized","std::cmp::PartialOrd"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"clamp_min":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","u64","std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>","u8","u16","i32","i64","i16","i8","char","usize","u32","bool"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+clamp_min(p0, p1);
+crate::clamp_min(p0, p1);
+crate::clamp_min(p0, p1);
-----------------
src/lib.rs clamp_max
deps:{"clamp_max":{"T":["std::marker::Sized","std::cmp::PartialOrd"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"clamp_max":{"T":["usize","i8","bool","i32","u64","u32","i16","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","char","i64","u16","u8"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+clamp_max(p0, p1);
+crate::clamp_max(p0, p1);
+crate::clamp_max(p0, p1);
-----------------
src/bounds.rs bounds::Bounded::min_value
deps:{"bounds::Bounded::min_value":{"Self":["bounds::Bounded"]},"std::num::Wrapping":{"T":["sign::Unsigned","std::marker::Sized","identities::One","sign::Signed","cast::FromPrimitive","Num","cast::ToPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","identities::Zero","cast::NumCast","ops::wrapping::WrappingShr","bounds::Bounded"]}}
candidates:{"bounds::Bounded::min_value":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+bounds::Bounded::min_value();
+crate::bounds::Bounded::min_value();
+crate::bounds::Bounded::min_value();
-----------------
src/bounds.rs bounds::Bounded::max_value
deps:{"bounds::Bounded::max_value":{"Self":["bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","bounds::Bounded","cast::FromPrimitive","cast::ToPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","ops::wrapping::WrappingAdd","identities::One","ops::wrapping::WrappingMul","sign::Signed","ops::wrapping::WrappingNeg","Num","identities::Zero","sign::Unsigned","std::marker::Sized","cast::NumCast"]}}
candidates:{"bounds::Bounded::max_value":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+bounds::Bounded::max_value();
+crate::bounds::Bounded::max_value();
+crate::bounds::Bounded::max_value();
-----------------
src/bounds.rs bounds::LowerBounded::min_value
deps:{"<T as bounds::LowerBounded>":{"T":["std::marker::Sized","bounds::Bounded"]},"bounds::LowerBounded::min_value":{"Self":["bounds::LowerBounded"]},"std::num::Wrapping":{"T":["sign::Unsigned","bounds::Bounded","cast::NumCast","identities::One","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","std::marker::Sized","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShr","Num","ops::wrapping::WrappingNeg","identities::Zero","cast::FromPrimitive","ops::wrapping::WrappingMul","cast::ToPrimitive","sign::Signed"]}}
candidates:{"<T as bounds::LowerBounded>":{"T":["std::num::Wrapping"]},"bounds::LowerBounded::min_value":{"Self":["<T as bounds::LowerBounded>"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+bounds::LowerBounded::min_value();
+crate::bounds::LowerBounded::min_value();
+crate::bounds::LowerBounded::min_value();
-----------------
src/bounds.rs bounds::UpperBounded::max_value
deps:{"<T as bounds::UpperBounded>":{"T":["std::marker::Sized","bounds::Bounded"]},"bounds::UpperBounded::max_value":{"Self":["bounds::UpperBounded"]},"std::num::Wrapping":{"T":["sign::Unsigned","identities::One","ops::wrapping::WrappingMul","sign::Signed","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","identities::Zero","bounds::Bounded","cast::NumCast","ops::wrapping::WrappingShl","ops::wrapping::WrappingAdd","Num","cast::FromPrimitive","ops::wrapping::WrappingShr","std::marker::Sized","cast::ToPrimitive"]}}
candidates:{"<T as bounds::UpperBounded>":{"T":["std::num::Wrapping"]},"bounds::UpperBounded::max_value":{"Self":["<T as bounds::UpperBounded>"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+bounds::UpperBounded::max_value();
+crate::bounds::UpperBounded::max_value();
+crate::bounds::UpperBounded::max_value();
-----------------
src/cast.rs cast::ToPrimitive::to_isize
deps:{"cast::ToPrimitive::to_isize":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","sign::Signed","bounds::Bounded","identities::One","ops::wrapping::WrappingNeg","cast::NumCast","Num","ops::wrapping::WrappingShl","std::marker::Sized","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","cast::FromPrimitive","cast::ToPrimitive","sign::Unsigned","ops::wrapping::WrappingMul","identities::Zero"]}}
candidates:{"cast::ToPrimitive::to_isize":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_isize();
+cast::ToPrimitive::to_isize(p0);
+crate::cast::ToPrimitive::to_isize(p0);
+crate::cast::ToPrimitive::to_isize(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_i8
deps:{"cast::ToPrimitive::to_i8":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["identities::Zero","sign::Signed","std::marker::Sized","ops::wrapping::WrappingShr","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","ops::wrapping::WrappingAdd","bounds::Bounded","ops::wrapping::WrappingSub","sign::Unsigned","Num","cast::ToPrimitive","cast::FromPrimitive","cast::NumCast","ops::wrapping::WrappingNeg","identities::One"]}}
candidates:{"cast::ToPrimitive::to_i8":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_i8();
+cast::ToPrimitive::to_i8(p0);
+crate::cast::ToPrimitive::to_i8(p0);
+crate::cast::ToPrimitive::to_i8(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_i16
deps:{"cast::ToPrimitive::to_i16":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["sign::Signed","cast::FromPrimitive","ops::wrapping::WrappingMul","cast::ToPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","cast::NumCast","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","sign::Unsigned","bounds::Bounded","ops::wrapping::WrappingAdd","Num","identities::One","std::marker::Sized","identities::Zero"]}}
candidates:{"cast::ToPrimitive::to_i16":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_i16();
+cast::ToPrimitive::to_i16(p0);
+crate::cast::ToPrimitive::to_i16(p0);
+crate::cast::ToPrimitive::to_i16(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_i32
deps:{"cast::ToPrimitive::to_i32":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["std::marker::Sized","ops::wrapping::WrappingNeg","bounds::Bounded","cast::FromPrimitive","ops::wrapping::WrappingShr","identities::Zero","ops::wrapping::WrappingMul","cast::ToPrimitive","ops::wrapping::WrappingShl","identities::One","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","sign::Unsigned","Num","sign::Signed","cast::NumCast"]}}
candidates:{"cast::ToPrimitive::to_i32":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_i32();
+cast::ToPrimitive::to_i32(p0);
+crate::cast::ToPrimitive::to_i32(p0);
+crate::cast::ToPrimitive::to_i32(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_i64
deps:{"cast::ToPrimitive::to_i64":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["std::marker::Sized","cast::NumCast","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","Num","identities::Zero","sign::Signed","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","cast::FromPrimitive","identities::One","sign::Unsigned","cast::ToPrimitive","bounds::Bounded"]}}
candidates:{"cast::ToPrimitive::to_i64":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_i64();
+cast::ToPrimitive::to_i64(p0);
+crate::cast::ToPrimitive::to_i64(p0);
+crate::cast::ToPrimitive::to_i64(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_i128
deps:{"cast::ToPrimitive::to_i128":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShr","bounds::Bounded","sign::Unsigned","ops::wrapping::WrappingMul","cast::NumCast","ops::wrapping::WrappingShl","identities::Zero","cast::ToPrimitive","Num","std::marker::Sized","ops::wrapping::WrappingNeg","sign::Signed","ops::wrapping::WrappingSub","identities::One"]}}
candidates:{"cast::ToPrimitive::to_i128":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_i128();
+cast::ToPrimitive::to_i128(p0);
+crate::cast::ToPrimitive::to_i128(p0);
+crate::cast::ToPrimitive::to_i128(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_usize
deps:{"cast::ToPrimitive::to_usize":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["identities::One","bounds::Bounded","cast::NumCast","cast::ToPrimitive","ops::wrapping::WrappingShr","cast::FromPrimitive","ops::wrapping::WrappingMul","sign::Unsigned","ops::wrapping::WrappingShl","sign::Signed","std::marker::Sized","ops::wrapping::WrappingAdd","Num","ops::wrapping::WrappingSub","identities::Zero","ops::wrapping::WrappingNeg"]}}
candidates:{"cast::ToPrimitive::to_usize":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_usize();
+cast::ToPrimitive::to_usize(p0);
+crate::cast::ToPrimitive::to_usize(p0);
+crate::cast::ToPrimitive::to_usize(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_u8
deps:{"cast::ToPrimitive::to_u8":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","ops::wrapping::WrappingNeg","identities::Zero","identities::One","ops::wrapping::WrappingMul","ops::wrapping::WrappingSub","cast::NumCast","cast::ToPrimitive","ops::wrapping::WrappingShl","std::marker::Sized","sign::Signed","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","sign::Unsigned","bounds::Bounded","Num"]}}
candidates:{"cast::ToPrimitive::to_u8":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_u8();
+cast::ToPrimitive::to_u8(p0);
+crate::cast::ToPrimitive::to_u8(p0);
+crate::cast::ToPrimitive::to_u8(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_u16
deps:{"cast::ToPrimitive::to_u16":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["sign::Signed","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","cast::ToPrimitive","sign::Unsigned","ops::wrapping::WrappingSub","ops::wrapping::WrappingShr","cast::NumCast","identities::Zero","std::marker::Sized","bounds::Bounded","ops::wrapping::WrappingAdd","cast::FromPrimitive","identities::One","ops::wrapping::WrappingNeg","Num"]}}
candidates:{"cast::ToPrimitive::to_u16":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_u16();
+cast::ToPrimitive::to_u16(p0);
+crate::cast::ToPrimitive::to_u16(p0);
+crate::cast::ToPrimitive::to_u16(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_u32
deps:{"cast::ToPrimitive::to_u32":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["sign::Unsigned","ops::wrapping::WrappingShr","std::marker::Sized","ops::wrapping::WrappingShl","identities::Zero","Num","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","cast::FromPrimitive","cast::ToPrimitive","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","sign::Signed","bounds::Bounded","identities::One","cast::NumCast"]}}
candidates:{"cast::ToPrimitive::to_u32":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_u32();
+cast::ToPrimitive::to_u32(p0);
+crate::cast::ToPrimitive::to_u32(p0);
+crate::cast::ToPrimitive::to_u32(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_u64
deps:{"cast::ToPrimitive::to_u64":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["identities::One","ops::wrapping::WrappingSub","sign::Unsigned","cast::FromPrimitive","cast::ToPrimitive","std::marker::Sized","cast::NumCast","identities::Zero","ops::wrapping::WrappingShl","sign::Signed","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","bounds::Bounded","Num"]}}
candidates:{"cast::ToPrimitive::to_u64":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_u64();
+cast::ToPrimitive::to_u64(p0);
+crate::cast::ToPrimitive::to_u64(p0);
+crate::cast::ToPrimitive::to_u64(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_u128
deps:{"cast::ToPrimitive::to_u128":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["cast::NumCast","cast::ToPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShr","bounds::Bounded","sign::Signed","ops::wrapping::WrappingAdd","sign::Unsigned","cast::FromPrimitive","ops::wrapping::WrappingSub","std::marker::Sized","ops::wrapping::WrappingShl","ops::wrapping::WrappingMul","identities::One","Num","identities::Zero"]}}
candidates:{"cast::ToPrimitive::to_u128":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_u128();
+cast::ToPrimitive::to_u128(p0);
+crate::cast::ToPrimitive::to_u128(p0);
+crate::cast::ToPrimitive::to_u128(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_f32
deps:{"cast::ToPrimitive::to_f32":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","cast::ToPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","sign::Unsigned","ops::wrapping::WrappingShl","cast::NumCast","sign::Signed","bounds::Bounded","ops::wrapping::WrappingMul","identities::Zero","identities::One","Num","std::marker::Sized","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg"]}}
candidates:{"cast::ToPrimitive::to_f32":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_f32();
+cast::ToPrimitive::to_f32(p0);
+crate::cast::ToPrimitive::to_f32(p0);
+crate::cast::ToPrimitive::to_f32(p0);
-----------------
src/cast.rs cast::ToPrimitive::to_f64
deps:{"cast::ToPrimitive::to_f64":{"Self":["cast::ToPrimitive"]},"std::num::Wrapping":{"T":["sign::Signed","identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingSub","Num","bounds::Bounded","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","cast::FromPrimitive","ops::wrapping::WrappingNeg","std::marker::Sized","identities::One","ops::wrapping::WrappingShl","sign::Unsigned","cast::NumCast"]}}
candidates:{"cast::ToPrimitive::to_f64":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_f64();
+cast::ToPrimitive::to_f64(p0);
+crate::cast::ToPrimitive::to_f64(p0);
+crate::cast::ToPrimitive::to_f64(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_isize
deps:{"cast::FromPrimitive::from_isize":{"Self":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","Num","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","sign::Signed","identities::Zero","ops::wrapping::WrappingShl","cast::NumCast","std::marker::Sized","bounds::Bounded","cast::FromPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","sign::Unsigned","cast::ToPrimitive","identities::One"]}}
candidates:{"cast::FromPrimitive::from_isize":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0isize; // None+isize
+cast::FromPrimitive::from_isize(p0);
+crate::cast::FromPrimitive::from_isize(p0);
+crate::cast::FromPrimitive::from_isize(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_i8
deps:{"cast::FromPrimitive::from_i8":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["bounds::Bounded","cast::FromPrimitive","identities::One","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","identities::Zero","sign::Signed","Num","std::marker::Sized","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","ops::wrapping::WrappingShr","cast::NumCast","ops::wrapping::WrappingShl","sign::Unsigned","cast::ToPrimitive"]}}
candidates:{"cast::FromPrimitive::from_i8":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i8; // None+i8
+cast::FromPrimitive::from_i8(p0);
+crate::cast::FromPrimitive::from_i8(p0);
+crate::cast::FromPrimitive::from_i8(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_i16
deps:{"cast::FromPrimitive::from_i16":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["std::marker::Sized","cast::NumCast","cast::ToPrimitive","sign::Unsigned","ops::wrapping::WrappingShr","sign::Signed","cast::FromPrimitive","ops::wrapping::WrappingShl","ops::wrapping::WrappingNeg","identities::Zero","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","Num","identities::One","bounds::Bounded"]}}
candidates:{"cast::FromPrimitive::from_i16":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i16; // None+i16
+cast::FromPrimitive::from_i16(p0);
+crate::cast::FromPrimitive::from_i16(p0);
+crate::cast::FromPrimitive::from_i16(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_i32
deps:{"cast::FromPrimitive::from_i32":{"Self":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["sign::Signed","sign::Unsigned","identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingNeg","identities::One","bounds::Bounded","ops::wrapping::WrappingShl","cast::NumCast","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShr","cast::FromPrimitive","std::marker::Sized","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","Num"]}}
candidates:{"cast::FromPrimitive::from_i32":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i32; // None+i32
+cast::FromPrimitive::from_i32(p0);
+crate::cast::FromPrimitive::from_i32(p0);
+crate::cast::FromPrimitive::from_i32(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_i64
deps:{"cast::FromPrimitive::from_i64":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","std::marker::Sized","sign::Signed","identities::Zero","ops::wrapping::WrappingMul","Num","bounds::Bounded","cast::FromPrimitive","ops::wrapping::WrappingSub","sign::Unsigned","identities::One","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","cast::NumCast","cast::ToPrimitive","ops::wrapping::WrappingAdd"]}}
candidates:{"cast::FromPrimitive::from_i64":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i64; // None+i64
+cast::FromPrimitive::from_i64(p0);
+crate::cast::FromPrimitive::from_i64(p0);
+crate::cast::FromPrimitive::from_i64(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_i128
deps:{"cast::FromPrimitive::from_i128":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","ops::wrapping::WrappingMul","identities::One","bounds::Bounded","cast::FromPrimitive","std::marker::Sized","ops::wrapping::WrappingSub","cast::ToPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","sign::Signed","Num","identities::Zero","cast::NumCast","sign::Unsigned"]}}
candidates:{"cast::FromPrimitive::from_i128":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i128; // None+i128
+cast::FromPrimitive::from_i128(p0);
+crate::cast::FromPrimitive::from_i128(p0);
+crate::cast::FromPrimitive::from_i128(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_usize
deps:{"cast::FromPrimitive::from_usize":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingAdd","ops::wrapping::WrappingShl","identities::One","sign::Signed","std::marker::Sized","cast::NumCast","ops::wrapping::WrappingMul","identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingShr","sign::Unsigned","bounds::Bounded","cast::FromPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","Num"]}}
candidates:{"cast::FromPrimitive::from_usize":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0usize; // None+usize
+cast::FromPrimitive::from_usize(p0);
+crate::cast::FromPrimitive::from_usize(p0);
+crate::cast::FromPrimitive::from_usize(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_u8
deps:{"cast::FromPrimitive::from_u8":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","std::marker::Sized","ops::wrapping::WrappingSub","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","Num","cast::ToPrimitive","cast::FromPrimitive","bounds::Bounded","identities::Zero","identities::One","sign::Signed","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","sign::Unsigned","cast::NumCast"]}}
candidates:{"cast::FromPrimitive::from_u8":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u8; // None+u8
+cast::FromPrimitive::from_u8(p0);
+crate::cast::FromPrimitive::from_u8(p0);
+crate::cast::FromPrimitive::from_u8(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_u16
deps:{"cast::FromPrimitive::from_u16":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["identities::Zero","ops::wrapping::WrappingShr","sign::Signed","cast::NumCast","ops::wrapping::WrappingNeg","std::marker::Sized","cast::ToPrimitive","cast::FromPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","identities::One","sign::Unsigned","Num","bounds::Bounded","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShl"]}}
candidates:{"cast::FromPrimitive::from_u16":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u16; // None+u16
+cast::FromPrimitive::from_u16(p0);
+crate::cast::FromPrimitive::from_u16(p0);
+crate::cast::FromPrimitive::from_u16(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_u32
deps:{"cast::FromPrimitive::from_u32":{"Self":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::One","ops::wrapping::WrappingShr","ops::wrapping::WrappingMul","sign::Signed","sign::Unsigned","Num","std::marker::Sized","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","ops::wrapping::WrappingNeg","cast::NumCast","bounds::Bounded","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingAdd","cast::ToPrimitive"]}}
candidates:{"cast::FromPrimitive::from_u32":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u32; // None+u32
+cast::FromPrimitive::from_u32(p0);
+crate::cast::FromPrimitive::from_u32(p0);
+crate::cast::FromPrimitive::from_u32(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_u64
deps:{"cast::FromPrimitive::from_u64":{"Self":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","sign::Unsigned","Num","bounds::Bounded","sign::Signed","identities::One","ops::wrapping::WrappingNeg","ops::wrapping::WrappingAdd","cast::NumCast","std::marker::Sized","identities::Zero","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","ops::wrapping::WrappingMul","ops::wrapping::WrappingSub","cast::ToPrimitive"]}}
candidates:{"cast::FromPrimitive::from_u64":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u64; // None+u64
+cast::FromPrimitive::from_u64(p0);
+crate::cast::FromPrimitive::from_u64(p0);
+crate::cast::FromPrimitive::from_u64(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_u128
deps:{"cast::FromPrimitive::from_u128":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","ops::wrapping::WrappingNeg","cast::ToPrimitive","sign::Signed","identities::One","cast::FromPrimitive","std::marker::Sized","ops::wrapping::WrappingSub","cast::NumCast","ops::wrapping::WrappingMul","sign::Unsigned","identities::Zero","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShr","Num","bounds::Bounded"]}}
candidates:{"cast::FromPrimitive::from_u128":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u128; // None+u128
+cast::FromPrimitive::from_u128(p0);
+crate::cast::FromPrimitive::from_u128(p0);
+crate::cast::FromPrimitive::from_u128(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_f32
deps:{"cast::FromPrimitive::from_f32":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["bounds::Bounded","ops::wrapping::WrappingShl","std::marker::Sized","cast::NumCast","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","sign::Signed","Num","sign::Unsigned","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingShr","identities::One","cast::ToPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul"]}}
candidates:{"cast::FromPrimitive::from_f32":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0f32; // None+f32
+cast::FromPrimitive::from_f32(p0);
+crate::cast::FromPrimitive::from_f32(p0);
+crate::cast::FromPrimitive::from_f32(p0);
-----------------
src/cast.rs cast::FromPrimitive::from_f64
deps:{"cast::FromPrimitive::from_f64":{"Self":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["bounds::Bounded","std::marker::Sized","sign::Signed","sign::Unsigned","Num","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","cast::FromPrimitive","cast::ToPrimitive","identities::Zero","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","cast::NumCast","ops::wrapping::WrappingShl","identities::One","ops::wrapping::WrappingAdd"]}}
candidates:{"cast::FromPrimitive::from_f64":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0f64; // None+f64
+cast::FromPrimitive::from_f64(p0);
+crate::cast::FromPrimitive::from_f64(p0);
+crate::cast::FromPrimitive::from_f64(p0);
-----------------
src/cast.rs cast::NumCast::from
deps:{"cast::NumCast::from":{"Self":["cast::NumCast","std::marker::Sized","cast::ToPrimitive"],"T":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","ops::wrapping::WrappingMul","identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","Num","std::marker::Sized","sign::Signed","ops::wrapping::WrappingShl","ops::wrapping::WrappingAdd","cast::NumCast","identities::One","sign::Unsigned","bounds::Bounded","ops::wrapping::WrappingNeg"]}}
candidates:{"cast::NumCast::from":{"Self":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+cast::NumCast::from(p0);
+crate::cast::NumCast::from(p0);
+crate::cast::NumCast::from(p0);
-----------------
src/cast.rs cast::AsPrimitive::as_
deps:{"cast::AsPrimitive::as_":{"Self":["cast::AsPrimitive","std::marker::Copy"],"T":["std::marker::Sized","std::marker::Copy"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
candidates:{"cast::AsPrimitive::as_":{"T":["i64","u8","u32","u16","usize","std::marker::copy_impls::<impl std::marker::Copy for &T>","i8","i32","i16","std::marker::copy_impls::<impl std::marker::Copy for *const T>","u64","char","bool"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.as_();
+cast::AsPrimitive::as_(p0);
+crate::cast::AsPrimitive::as_(p0);
+crate::cast::AsPrimitive::as_(p0);
-----------------
src/float.rs float::FloatCore::infinity
deps:{"float::FloatCore::infinity":{"Self":["std::marker::Copy","std::ops::Neg","std::cmp::PartialOrd","float::FloatCore","Num","cast::NumCast"]}}
candidates:{"float::FloatCore::infinity":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::FloatCore::infinity();
+crate::float::FloatCore::infinity();
+crate::float::FloatCore::infinity();
-----------------
src/float.rs float::FloatCore::neg_infinity
deps:{"float::FloatCore::neg_infinity":{"Self":["float::FloatCore","Num","std::cmp::PartialOrd","cast::NumCast","std::marker::Copy","std::ops::Neg"]}}
candidates:{"float::FloatCore::neg_infinity":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::FloatCore::neg_infinity();
+crate::float::FloatCore::neg_infinity();
+crate::float::FloatCore::neg_infinity();
-----------------
src/float.rs float::FloatCore::nan
deps:{"float::FloatCore::nan":{"Self":["std::cmp::PartialOrd","std::marker::Copy","float::FloatCore","std::ops::Neg","Num","cast::NumCast"]}}
candidates:{"float::FloatCore::nan":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::FloatCore::nan();
+crate::float::FloatCore::nan();
+crate::float::FloatCore::nan();
-----------------
src/float.rs float::FloatCore::neg_zero
deps:{"float::FloatCore::neg_zero":{"Self":["std::cmp::PartialOrd","Num","std::marker::Copy","std::ops::Neg","float::FloatCore","cast::NumCast"]}}
candidates:{"float::FloatCore::neg_zero":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::FloatCore::neg_zero();
+crate::float::FloatCore::neg_zero();
+crate::float::FloatCore::neg_zero();
-----------------
src/float.rs float::FloatCore::min_value
deps:{"float::FloatCore::min_value":{"Self":["float::FloatCore","Num","std::ops::Neg","std::cmp::PartialOrd","cast::NumCast","std::marker::Copy"]}}
candidates:{"float::FloatCore::min_value":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::FloatCore::min_value();
+crate::float::FloatCore::min_value();
+crate::float::FloatCore::min_value();
-----------------
src/float.rs float::FloatCore::min_positive_value
deps:{"float::FloatCore::min_positive_value":{"Self":["Num","std::ops::Neg","std::cmp::PartialOrd","float::FloatCore","cast::NumCast","std::marker::Copy"]}}
candidates:{"float::FloatCore::min_positive_value":{"Self":[]}}
+float::FloatCore::min_positive_value();
+crate::float::FloatCore::min_positive_value();
+crate::float::FloatCore::min_positive_value();
-----------------
src/float.rs float::FloatCore::epsilon
deps:{"float::FloatCore::epsilon":{"Self":["std::cmp::PartialOrd","std::ops::Neg","cast::NumCast","Num","float::FloatCore","std::marker::Copy"]}}
candidates:{"float::FloatCore::epsilon":{"Self":[]}}
+float::FloatCore::epsilon();
+crate::float::FloatCore::epsilon();
+crate::float::FloatCore::epsilon();
-----------------
src/float.rs float::FloatCore::max_value
deps:{"float::FloatCore::max_value":{"Self":["float::FloatCore","Num","std::cmp::PartialOrd","cast::NumCast","std::ops::Neg","std::marker::Copy"]}}
candidates:{"float::FloatCore::max_value":{"Self":[]}}
+float::FloatCore::max_value();
+crate::float::FloatCore::max_value();
+crate::float::FloatCore::max_value();
-----------------
src/float.rs float::FloatCore::is_nan
deps:{"float::FloatCore::is_nan":{"Self":["Num","std::cmp::PartialOrd","cast::NumCast","std::marker::Copy","std::ops::Neg","float::FloatCore"]}}
candidates:{"float::FloatCore::is_nan":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_nan();
+float::FloatCore::is_nan(p0);
+crate::float::FloatCore::is_nan(p0);
+crate::float::FloatCore::is_nan(p0);
-----------------
src/float.rs float::FloatCore::is_infinite
deps:{"float::FloatCore::is_infinite":{"Self":["std::marker::Copy","Num","std::cmp::PartialOrd","std::ops::Neg","cast::NumCast","float::FloatCore"]}}
candidates:{"float::FloatCore::is_infinite":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_infinite();
+float::FloatCore::is_infinite(p0);
+crate::float::FloatCore::is_infinite(p0);
+crate::float::FloatCore::is_infinite(p0);
-----------------
src/float.rs float::FloatCore::is_finite
deps:{"float::FloatCore::is_finite":{"Self":["cast::NumCast","std::cmp::PartialOrd","std::ops::Neg","std::marker::Copy","float::FloatCore","Num"]}}
candidates:{"float::FloatCore::is_finite":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_finite();
+float::FloatCore::is_finite(p0);
+crate::float::FloatCore::is_finite(p0);
+crate::float::FloatCore::is_finite(p0);
-----------------
src/float.rs float::FloatCore::is_normal
deps:{"float::FloatCore::is_normal":{"Self":["float::FloatCore","Num","cast::NumCast","std::cmp::PartialOrd","std::ops::Neg","std::marker::Copy"]}}
candidates:{"float::FloatCore::is_normal":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_normal();
+float::FloatCore::is_normal(p0);
+crate::float::FloatCore::is_normal(p0);
+crate::float::FloatCore::is_normal(p0);
-----------------
src/float.rs float::FloatCore::classify
deps:{"float::FloatCore::classify":{"Self":["std::cmp::PartialOrd","float::FloatCore","Num","std::marker::Copy","cast::NumCast","std::ops::Neg"]}}
candidates:{"float::FloatCore::classify":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.classify();
+float::FloatCore::classify(p0);
+crate::float::FloatCore::classify(p0);
+crate::float::FloatCore::classify(p0);
-----------------
src/float.rs float::FloatCore::floor
deps:{"float::FloatCore::floor":{"Self":["std::ops::Neg","float::FloatCore","Num","cast::NumCast","std::cmp::PartialOrd","std::marker::Copy"]}}
candidates:{"float::FloatCore::floor":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.floor();
+float::FloatCore::floor(p0);
+crate::float::FloatCore::floor(p0);
+crate::float::FloatCore::floor(p0);
-----------------
src/float.rs float::FloatCore::ceil
deps:{"float::FloatCore::ceil":{"Self":["Num","cast::NumCast","std::cmp::PartialOrd","float::FloatCore","std::ops::Neg","std::marker::Copy"]}}
candidates:{"float::FloatCore::ceil":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.ceil();
+float::FloatCore::ceil(p0);
+crate::float::FloatCore::ceil(p0);
+crate::float::FloatCore::ceil(p0);
-----------------
src/float.rs float::FloatCore::round
deps:{"float::FloatCore::round":{"Self":["Num","std::marker::Copy","float::FloatCore","cast::NumCast","std::cmp::PartialOrd","std::ops::Neg"]}}
candidates:{"float::FloatCore::round":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.round();
+float::FloatCore::round(p0);
+crate::float::FloatCore::round(p0);
+crate::float::FloatCore::round(p0);
-----------------
src/float.rs float::FloatCore::trunc
deps:{"float::FloatCore::trunc":{"Self":["std::ops::Neg","cast::NumCast","Num","std::cmp::PartialOrd","std::marker::Copy","float::FloatCore"]}}
candidates:{"float::FloatCore::trunc":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.trunc();
+float::FloatCore::trunc(p0);
+crate::float::FloatCore::trunc(p0);
+crate::float::FloatCore::trunc(p0);
-----------------
src/float.rs float::FloatCore::fract
deps:{"float::FloatCore::fract":{"Self":["Num","std::marker::Copy","float::FloatCore","std::ops::Neg","cast::NumCast","std::cmp::PartialOrd"]}}
candidates:{"float::FloatCore::fract":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.fract();
+float::FloatCore::fract(p0);
+crate::float::FloatCore::fract(p0);
+crate::float::FloatCore::fract(p0);
-----------------
src/float.rs float::FloatCore::abs
deps:{"float::FloatCore::abs":{"Self":["cast::NumCast","std::cmp::PartialOrd","std::ops::Neg","float::FloatCore","std::marker::Copy","Num"]}}
candidates:{"float::FloatCore::abs":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.abs();
+float::FloatCore::abs(p0);
+crate::float::FloatCore::abs(p0);
+crate::float::FloatCore::abs(p0);
-----------------
src/float.rs float::FloatCore::signum
deps:{"float::FloatCore::signum":{"Self":["std::marker::Copy","float::FloatCore","std::cmp::PartialOrd","Num","cast::NumCast","std::ops::Neg"]}}
candidates:{"float::FloatCore::signum":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.signum();
+float::FloatCore::signum(p0);
+crate::float::FloatCore::signum(p0);
+crate::float::FloatCore::signum(p0);
-----------------
src/float.rs float::FloatCore::is_sign_positive
deps:{"float::FloatCore::is_sign_positive":{"Self":["std::cmp::PartialOrd","Num","float::FloatCore","std::marker::Copy","cast::NumCast","std::ops::Neg"]}}
candidates:{"float::FloatCore::is_sign_positive":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_sign_positive();
+float::FloatCore::is_sign_positive(p0);
+crate::float::FloatCore::is_sign_positive(p0);
+crate::float::FloatCore::is_sign_positive(p0);
-----------------
src/float.rs float::FloatCore::is_sign_negative
deps:{"float::FloatCore::is_sign_negative":{"Self":["Num","std::ops::Neg","float::FloatCore","std::cmp::PartialOrd","std::marker::Copy","cast::NumCast"]}}
candidates:{"float::FloatCore::is_sign_negative":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_sign_negative();
+float::FloatCore::is_sign_negative(p0);
+crate::float::FloatCore::is_sign_negative(p0);
+crate::float::FloatCore::is_sign_negative(p0);
-----------------
src/float.rs float::FloatCore::min
deps:{"float::FloatCore::min":{"Self":["Num","std::ops::Neg","std::cmp::PartialOrd","std::marker::Copy","cast::NumCast","float::FloatCore"]}}
candidates:{"float::FloatCore::min":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.min(p1);
+float::FloatCore::min(p0, p1);
+crate::float::FloatCore::min(p0, p1);
+crate::float::FloatCore::min(p0, p1);
-----------------
src/float.rs float::FloatCore::max
deps:{"float::FloatCore::max":{"Self":["cast::NumCast","float::FloatCore","std::cmp::PartialOrd","Num","std::marker::Copy","std::ops::Neg"]}}
candidates:{"float::FloatCore::max":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.max(p1);
+float::FloatCore::max(p0, p1);
+crate::float::FloatCore::max(p0, p1);
+crate::float::FloatCore::max(p0, p1);
-----------------
src/float.rs float::FloatCore::recip
deps:{"float::FloatCore::recip":{"Self":["float::FloatCore","std::ops::Neg","std::marker::Copy","cast::NumCast","Num","std::cmp::PartialOrd"]}}
candidates:{"float::FloatCore::recip":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.recip();
+float::FloatCore::recip(p0);
+crate::float::FloatCore::recip(p0);
+crate::float::FloatCore::recip(p0);
-----------------
src/float.rs float::FloatCore::powi
deps:{"float::FloatCore::powi":{"Self":["std::cmp::PartialOrd","std::marker::Copy","float::FloatCore","Num","cast::NumCast","std::ops::Neg"]}}
candidates:{"float::FloatCore::powi":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
+p0.powi(p1);
+float::FloatCore::powi(p0, p1);
+crate::float::FloatCore::powi(p0, p1);
+crate::float::FloatCore::powi(p0, p1);
-----------------
src/float.rs float::FloatCore::to_degrees
deps:{"float::FloatCore::to_degrees":{"Self":["cast::NumCast","std::cmp::PartialOrd","float::FloatCore","Num","std::ops::Neg","std::marker::Copy"]}}
candidates:{"float::FloatCore::to_degrees":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.to_degrees();
+float::FloatCore::to_degrees(p0);
+crate::float::FloatCore::to_degrees(p0);
+crate::float::FloatCore::to_degrees(p0);
-----------------
src/float.rs float::FloatCore::to_radians
deps:{"float::FloatCore::to_radians":{"Self":["Num","cast::NumCast","std::ops::Neg","std::marker::Copy","std::cmp::PartialOrd","float::FloatCore"]}}
candidates:{"float::FloatCore::to_radians":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.to_radians();
+float::FloatCore::to_radians(p0);
+crate::float::FloatCore::to_radians(p0);
+crate::float::FloatCore::to_radians(p0);
-----------------
src/float.rs float::FloatCore::integer_decode
deps:{"float::FloatCore::integer_decode":{"Self":["float::FloatCore","std::cmp::PartialOrd","Num","cast::NumCast","std::ops::Neg","std::marker::Copy"]}}
candidates:{"float::FloatCore::integer_decode":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.integer_decode();
+float::FloatCore::integer_decode(p0);
+crate::float::FloatCore::integer_decode(p0);
+crate::float::FloatCore::integer_decode(p0);
-----------------
src/float.rs float::Float::nan
deps:{"float::Float::nan":{"Self":["std::cmp::PartialOrd","cast::NumCast","std::marker::Copy","std::ops::Neg","float::Float","Num"]}}
candidates:{"float::Float::nan":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::Float::nan();
+crate::float::Float::nan();
+crate::float::Float::nan();
-----------------
src/float.rs float::Float::infinity
deps:{"float::Float::infinity":{"Self":["std::ops::Neg","std::cmp::PartialOrd","float::Float","std::marker::Copy","Num","cast::NumCast"]}}
candidates:{"float::Float::infinity":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::Float::infinity();
+crate::float::Float::infinity();
+crate::float::Float::infinity();
-----------------
src/float.rs float::Float::neg_infinity
deps:{"float::Float::neg_infinity":{"Self":["std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg","cast::NumCast","Num","float::Float"]}}
candidates:{"float::Float::neg_infinity":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::Float::neg_infinity();
+crate::float::Float::neg_infinity();
+crate::float::Float::neg_infinity();
-----------------
src/float.rs float::Float::neg_zero
deps:{"float::Float::neg_zero":{"Self":["std::cmp::PartialOrd","std::marker::Copy","Num","std::ops::Neg","float::Float","cast::NumCast"]}}
candidates:{"float::Float::neg_zero":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::Float::neg_zero();
+crate::float::Float::neg_zero();
+crate::float::Float::neg_zero();
-----------------
src/float.rs float::Float::min_value
deps:{"float::Float::min_value":{"Self":["Num","float::Float","std::cmp::PartialOrd","cast::NumCast","std::marker::Copy","std::ops::Neg"]}}
candidates:{"float::Float::min_value":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::Float::min_value();
+crate::float::Float::min_value();
+crate::float::Float::min_value();
-----------------
src/float.rs float::Float::min_positive_value
deps:{"float::Float::min_positive_value":{"Self":["std::ops::Neg","std::marker::Copy","cast::NumCast","Num","std::cmp::PartialOrd","float::Float"]}}
candidates:{"float::Float::min_positive_value":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+float::Float::min_positive_value();
+crate::float::Float::min_positive_value();
+crate::float::Float::min_positive_value();
-----------------
src/float.rs float::Float::epsilon
deps:{"float::Float::epsilon":{"Self":["float::Float","cast::NumCast","std::marker::Copy","std::ops::Neg","Num","std::cmp::PartialOrd"]}}
candidates:{"float::Float::epsilon":{"Self":[]}}
+float::Float::epsilon();
+crate::float::Float::epsilon();
+crate::float::Float::epsilon();
-----------------
src/float.rs float::Float::max_value
deps:{"float::Float::max_value":{"Self":["Num","cast::NumCast","std::cmp::PartialOrd","std::ops::Neg","float::Float","std::marker::Copy"]}}
candidates:{"float::Float::max_value":{"Self":[]}}
+float::Float::max_value();
+crate::float::Float::max_value();
+crate::float::Float::max_value();
-----------------
src/float.rs float::Float::is_nan
deps:{"float::Float::is_nan":{"Self":["std::ops::Neg","std::marker::Copy","Num","cast::NumCast","std::cmp::PartialOrd","float::Float"]}}
candidates:{"float::Float::is_nan":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_nan();
+float::Float::is_nan(p0);
+crate::float::Float::is_nan(p0);
+crate::float::Float::is_nan(p0);
-----------------
src/float.rs float::Float::is_infinite
deps:{"float::Float::is_infinite":{"Self":["cast::NumCast","std::ops::Neg","float::Float","Num","std::cmp::PartialOrd","std::marker::Copy"]}}
candidates:{"float::Float::is_infinite":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_infinite();
+float::Float::is_infinite(p0);
+crate::float::Float::is_infinite(p0);
+crate::float::Float::is_infinite(p0);
-----------------
src/float.rs float::Float::is_finite
deps:{"float::Float::is_finite":{"Self":["std::ops::Neg","Num","std::cmp::PartialOrd","float::Float","std::marker::Copy","cast::NumCast"]}}
candidates:{"float::Float::is_finite":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_finite();
+float::Float::is_finite(p0);
+crate::float::Float::is_finite(p0);
+crate::float::Float::is_finite(p0);
-----------------
src/float.rs float::Float::is_normal
deps:{"float::Float::is_normal":{"Self":["Num","std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg","float::Float","cast::NumCast"]}}
candidates:{"float::Float::is_normal":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_normal();
+float::Float::is_normal(p0);
+crate::float::Float::is_normal(p0);
+crate::float::Float::is_normal(p0);
-----------------
src/float.rs float::Float::classify
deps:{"float::Float::classify":{"Self":["std::ops::Neg","cast::NumCast","Num","std::marker::Copy","float::Float","std::cmp::PartialOrd"]}}
candidates:{"float::Float::classify":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.classify();
+float::Float::classify(p0);
+crate::float::Float::classify(p0);
+crate::float::Float::classify(p0);
-----------------
src/float.rs float::Float::floor
deps:{"float::Float::floor":{"Self":["std::marker::Copy","Num","cast::NumCast","float::Float","std::cmp::PartialOrd","std::ops::Neg"]}}
candidates:{"float::Float::floor":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.floor();
+float::Float::floor(p0);
+crate::float::Float::floor(p0);
+crate::float::Float::floor(p0);
-----------------
src/float.rs float::Float::ceil
deps:{"float::Float::ceil":{"Self":["Num","std::ops::Neg","cast::NumCast","std::cmp::PartialOrd","float::Float","std::marker::Copy"]}}
candidates:{"float::Float::ceil":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.ceil();
+float::Float::ceil(p0);
+crate::float::Float::ceil(p0);
+crate::float::Float::ceil(p0);
-----------------
src/float.rs float::Float::round
deps:{"float::Float::round":{"Self":["std::ops::Neg","std::marker::Copy","std::cmp::PartialOrd","Num","float::Float","cast::NumCast"]}}
candidates:{"float::Float::round":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.round();
+float::Float::round(p0);
+crate::float::Float::round(p0);
+crate::float::Float::round(p0);
-----------------
src/float.rs float::Float::trunc
deps:{"float::Float::trunc":{"Self":["std::cmp::PartialOrd","std::ops::Neg","float::Float","Num","cast::NumCast","std::marker::Copy"]}}
candidates:{"float::Float::trunc":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.trunc();
+float::Float::trunc(p0);
+crate::float::Float::trunc(p0);
+crate::float::Float::trunc(p0);
-----------------
src/float.rs float::Float::fract
deps:{"float::Float::fract":{"Self":["cast::NumCast","std::ops::Neg","Num","std::marker::Copy","std::cmp::PartialOrd","float::Float"]}}
candidates:{"float::Float::fract":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.fract();
+float::Float::fract(p0);
+crate::float::Float::fract(p0);
+crate::float::Float::fract(p0);
-----------------
src/float.rs float::Float::abs
deps:{"float::Float::abs":{"Self":["cast::NumCast","std::marker::Copy","float::Float","Num","std::cmp::PartialOrd","std::ops::Neg"]}}
candidates:{"float::Float::abs":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.abs();
+float::Float::abs(p0);
+crate::float::Float::abs(p0);
+crate::float::Float::abs(p0);
-----------------
src/float.rs float::Float::signum
deps:{"float::Float::signum":{"Self":["float::Float","std::cmp::PartialOrd","cast::NumCast","std::marker::Copy","Num","std::ops::Neg"]}}
candidates:{"float::Float::signum":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.signum();
+float::Float::signum(p0);
+crate::float::Float::signum(p0);
+crate::float::Float::signum(p0);
-----------------
src/float.rs float::Float::is_sign_positive
deps:{"float::Float::is_sign_positive":{"Self":["Num","cast::NumCast","float::Float","std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg"]}}
candidates:{"float::Float::is_sign_positive":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_sign_positive();
+float::Float::is_sign_positive(p0);
+crate::float::Float::is_sign_positive(p0);
+crate::float::Float::is_sign_positive(p0);
-----------------
src/float.rs float::Float::is_sign_negative
deps:{"float::Float::is_sign_negative":{"Self":["std::cmp::PartialOrd","cast::NumCast","Num","std::marker::Copy","std::ops::Neg","float::Float"]}}
candidates:{"float::Float::is_sign_negative":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_sign_negative();
+float::Float::is_sign_negative(p0);
+crate::float::Float::is_sign_negative(p0);
+crate::float::Float::is_sign_negative(p0);
-----------------
src/float.rs float::Float::mul_add
deps:{"float::Float::mul_add":{"Self":["std::ops::Neg","Num","cast::NumCast","std::marker::Copy","float::Float","std::cmp::PartialOrd"]}}
candidates:{"float::Float::mul_add":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
let mut p2 = MaybeUninit::uninit().assume_init(); // Self
+p0.mul_add(p1, p2);
+float::Float::mul_add(p0, p1, p2);
+crate::float::Float::mul_add(p0, p1, p2);
+crate::float::Float::mul_add(p0, p1, p2);
-----------------
src/float.rs float::Float::recip
deps:{"float::Float::recip":{"Self":["std::cmp::PartialOrd","std::ops::Neg","cast::NumCast","float::Float","Num","std::marker::Copy"]}}
candidates:{"float::Float::recip":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.recip();
+float::Float::recip(p0);
+crate::float::Float::recip(p0);
+crate::float::Float::recip(p0);
-----------------
src/float.rs float::Float::powi
deps:{"float::Float::powi":{"Self":["std::cmp::PartialOrd","Num","std::ops::Neg","float::Float","cast::NumCast","std::marker::Copy"]}}
candidates:{"float::Float::powi":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
+p0.powi(p1);
+float::Float::powi(p0, p1);
+crate::float::Float::powi(p0, p1);
+crate::float::Float::powi(p0, p1);
-----------------
src/float.rs float::Float::powf
deps:{"float::Float::powf":{"Self":["std::cmp::PartialOrd","std::marker::Copy","std::ops::Neg","float::Float","Num","cast::NumCast"]}}
candidates:{"float::Float::powf":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.powf(p1);
+float::Float::powf(p0, p1);
+crate::float::Float::powf(p0, p1);
+crate::float::Float::powf(p0, p1);
-----------------
src/float.rs float::Float::sqrt
deps:{"float::Float::sqrt":{"Self":["std::cmp::PartialOrd","Num","std::marker::Copy","float::Float","cast::NumCast","std::ops::Neg"]}}
candidates:{"float::Float::sqrt":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.sqrt();
+float::Float::sqrt(p0);
+crate::float::Float::sqrt(p0);
+crate::float::Float::sqrt(p0);
-----------------
src/float.rs float::Float::exp
deps:{"float::Float::exp":{"Self":["float::Float","std::cmp::PartialOrd","std::ops::Neg","std::marker::Copy","Num","cast::NumCast"]}}
candidates:{"float::Float::exp":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.exp();
+float::Float::exp(p0);
+crate::float::Float::exp(p0);
+crate::float::Float::exp(p0);
-----------------
src/float.rs float::Float::exp2
deps:{"float::Float::exp2":{"Self":["std::ops::Neg","std::marker::Copy","cast::NumCast","Num","std::cmp::PartialOrd","float::Float"]}}
candidates:{"float::Float::exp2":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.exp2();
+float::Float::exp2(p0);
+crate::float::Float::exp2(p0);
+crate::float::Float::exp2(p0);
-----------------
src/float.rs float::Float::ln
deps:{"float::Float::ln":{"Self":["std::cmp::PartialOrd","float::Float","std::marker::Copy","Num","cast::NumCast","std::ops::Neg"]}}
candidates:{"float::Float::ln":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.ln();
+float::Float::ln(p0);
+crate::float::Float::ln(p0);
+crate::float::Float::ln(p0);
-----------------
src/float.rs float::Float::log
deps:{"float::Float::log":{"Self":["std::cmp::PartialOrd","cast::NumCast","std::marker::Copy","Num","std::ops::Neg","float::Float"]}}
candidates:{"float::Float::log":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.log(p1);
+float::Float::log(p0, p1);
+crate::float::Float::log(p0, p1);
+crate::float::Float::log(p0, p1);
-----------------
src/float.rs float::Float::log2
deps:{"float::Float::log2":{"Self":["float::Float","std::cmp::PartialOrd","Num","std::ops::Neg","std::marker::Copy","cast::NumCast"]}}
candidates:{"float::Float::log2":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.log2();
+float::Float::log2(p0);
+crate::float::Float::log2(p0);
+crate::float::Float::log2(p0);
-----------------
src/float.rs float::Float::log10
deps:{"float::Float::log10":{"Self":["std::cmp::PartialOrd","float::Float","std::marker::Copy","cast::NumCast","Num","std::ops::Neg"]}}
candidates:{"float::Float::log10":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.log10();
+float::Float::log10(p0);
+crate::float::Float::log10(p0);
+crate::float::Float::log10(p0);
-----------------
src/float.rs float::Float::to_degrees
deps:{"float::Float::to_degrees":{"Self":["std::cmp::PartialOrd","Num","cast::NumCast","std::ops::Neg","std::marker::Copy","float::Float"]}}
candidates:{"float::Float::to_degrees":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.to_degrees();
+float::Float::to_degrees(p0);
+crate::float::Float::to_degrees(p0);
+crate::float::Float::to_degrees(p0);
-----------------
src/float.rs float::Float::to_radians
deps:{"float::Float::to_radians":{"Self":["std::ops::Neg","cast::NumCast","float::Float","std::cmp::PartialOrd","std::marker::Copy","Num"]}}
candidates:{"float::Float::to_radians":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.to_radians();
+float::Float::to_radians(p0);
+crate::float::Float::to_radians(p0);
+crate::float::Float::to_radians(p0);
-----------------
src/float.rs float::Float::max
deps:{"float::Float::max":{"Self":["std::ops::Neg","std::cmp::PartialOrd","float::Float","std::marker::Copy","Num","cast::NumCast"]}}
candidates:{"float::Float::max":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.max(p1);
+float::Float::max(p0, p1);
+crate::float::Float::max(p0, p1);
+crate::float::Float::max(p0, p1);
-----------------
src/float.rs float::Float::min
deps:{"float::Float::min":{"Self":["std::cmp::PartialOrd","std::ops::Neg","cast::NumCast","float::Float","Num","std::marker::Copy"]}}
candidates:{"float::Float::min":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.min(p1);
+float::Float::min(p0, p1);
+crate::float::Float::min(p0, p1);
+crate::float::Float::min(p0, p1);
-----------------
src/float.rs float::Float::abs_sub
deps:{"float::Float::abs_sub":{"Self":["std::cmp::PartialOrd","float::Float","std::ops::Neg","cast::NumCast","Num","std::marker::Copy"]}}
candidates:{"float::Float::abs_sub":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.abs_sub(p1);
+float::Float::abs_sub(p0, p1);
+crate::float::Float::abs_sub(p0, p1);
+crate::float::Float::abs_sub(p0, p1);
-----------------
src/float.rs float::Float::cbrt
deps:{"float::Float::cbrt":{"Self":["std::marker::Copy","Num","std::cmp::PartialOrd","std::ops::Neg","float::Float","cast::NumCast"]}}
candidates:{"float::Float::cbrt":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.cbrt();
+float::Float::cbrt(p0);
+crate::float::Float::cbrt(p0);
+crate::float::Float::cbrt(p0);
-----------------
src/float.rs float::Float::hypot
deps:{"float::Float::hypot":{"Self":["cast::NumCast","std::cmp::PartialOrd","std::marker::Copy","float::Float","std::ops::Neg","Num"]}}
candidates:{"float::Float::hypot":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.hypot(p1);
+float::Float::hypot(p0, p1);
+crate::float::Float::hypot(p0, p1);
+crate::float::Float::hypot(p0, p1);
-----------------
src/float.rs float::Float::sin
deps:{"float::Float::sin":{"Self":["std::marker::Copy","float::Float","std::cmp::PartialOrd","cast::NumCast","std::ops::Neg","Num"]}}
candidates:{"float::Float::sin":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.sin();
+float::Float::sin(p0);
+crate::float::Float::sin(p0);
+crate::float::Float::sin(p0);
-----------------
src/float.rs float::Float::cos
deps:{"float::Float::cos":{"Self":["cast::NumCast","float::Float","Num","std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg"]}}
candidates:{"float::Float::cos":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.cos();
+float::Float::cos(p0);
+crate::float::Float::cos(p0);
+crate::float::Float::cos(p0);
-----------------
src/float.rs float::Float::tan
deps:{"float::Float::tan":{"Self":["std::marker::Copy","cast::NumCast","std::cmp::PartialOrd","std::ops::Neg","Num","float::Float"]}}
candidates:{"float::Float::tan":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.tan();
+float::Float::tan(p0);
+crate::float::Float::tan(p0);
+crate::float::Float::tan(p0);
-----------------
src/float.rs float::Float::asin
deps:{"float::Float::asin":{"Self":["std::cmp::PartialOrd","std::ops::Neg","cast::NumCast","Num","float::Float","std::marker::Copy"]}}
candidates:{"float::Float::asin":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.asin();
+float::Float::asin(p0);
+crate::float::Float::asin(p0);
+crate::float::Float::asin(p0);
-----------------
src/float.rs float::Float::acos
deps:{"float::Float::acos":{"Self":["Num","std::ops::Neg","std::marker::Copy","std::cmp::PartialOrd","float::Float","cast::NumCast"]}}
candidates:{"float::Float::acos":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.acos();
+float::Float::acos(p0);
+crate::float::Float::acos(p0);
+crate::float::Float::acos(p0);
-----------------
src/float.rs float::Float::atan
deps:{"float::Float::atan":{"Self":["std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg","float::Float","Num","cast::NumCast"]}}
candidates:{"float::Float::atan":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.atan();
+float::Float::atan(p0);
+crate::float::Float::atan(p0);
+crate::float::Float::atan(p0);
-----------------
src/float.rs float::Float::atan2
deps:{"float::Float::atan2":{"Self":["Num","std::ops::Neg","cast::NumCast","std::cmp::PartialOrd","float::Float","std::marker::Copy"]}}
candidates:{"float::Float::atan2":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.atan2(p1);
+float::Float::atan2(p0, p1);
+crate::float::Float::atan2(p0, p1);
+crate::float::Float::atan2(p0, p1);
-----------------
src/float.rs float::Float::sin_cos
deps:{"float::Float::sin_cos":{"Self":["std::ops::Neg","std::marker::Copy","std::cmp::PartialOrd","cast::NumCast","float::Float","Num"]}}
candidates:{"float::Float::sin_cos":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.sin_cos();
+float::Float::sin_cos(p0);
+crate::float::Float::sin_cos(p0);
+crate::float::Float::sin_cos(p0);
-----------------
src/float.rs float::Float::exp_m1
deps:{"float::Float::exp_m1":{"Self":["std::cmp::PartialOrd","float::Float","cast::NumCast","Num","std::marker::Copy","std::ops::Neg"]}}
candidates:{"float::Float::exp_m1":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.exp_m1();
+float::Float::exp_m1(p0);
+crate::float::Float::exp_m1(p0);
+crate::float::Float::exp_m1(p0);
-----------------
src/float.rs float::Float::ln_1p
deps:{"float::Float::ln_1p":{"Self":["Num","cast::NumCast","std::ops::Neg","float::Float","std::marker::Copy","std::cmp::PartialOrd"]}}
candidates:{"float::Float::ln_1p":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.ln_1p();
+float::Float::ln_1p(p0);
+crate::float::Float::ln_1p(p0);
+crate::float::Float::ln_1p(p0);
-----------------
src/float.rs float::Float::sinh
deps:{"float::Float::sinh":{"Self":["Num","std::cmp::PartialOrd","std::ops::Neg","std::marker::Copy","float::Float","cast::NumCast"]}}
candidates:{"float::Float::sinh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.sinh();
+float::Float::sinh(p0);
+crate::float::Float::sinh(p0);
+crate::float::Float::sinh(p0);
-----------------
src/float.rs float::Float::cosh
deps:{"float::Float::cosh":{"Self":["std::cmp::PartialOrd","std::marker::Copy","cast::NumCast","std::ops::Neg","Num","float::Float"]}}
candidates:{"float::Float::cosh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.cosh();
+float::Float::cosh(p0);
+crate::float::Float::cosh(p0);
+crate::float::Float::cosh(p0);
-----------------
src/float.rs float::Float::tanh
deps:{"float::Float::tanh":{"Self":["std::cmp::PartialOrd","Num","float::Float","cast::NumCast","std::ops::Neg","std::marker::Copy"]}}
candidates:{"float::Float::tanh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.tanh();
+float::Float::tanh(p0);
+crate::float::Float::tanh(p0);
+crate::float::Float::tanh(p0);
-----------------
src/float.rs float::Float::asinh
deps:{"float::Float::asinh":{"Self":["cast::NumCast","std::ops::Neg","std::marker::Copy","std::cmp::PartialOrd","float::Float","Num"]}}
candidates:{"float::Float::asinh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.asinh();
+float::Float::asinh(p0);
+crate::float::Float::asinh(p0);
+crate::float::Float::asinh(p0);
-----------------
src/float.rs float::Float::acosh
deps:{"float::Float::acosh":{"Self":["float::Float","Num","cast::NumCast","std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg"]}}
candidates:{"float::Float::acosh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.acosh();
+float::Float::acosh(p0);
+crate::float::Float::acosh(p0);
+crate::float::Float::acosh(p0);
-----------------
src/float.rs float::Float::atanh
deps:{"float::Float::atanh":{"Self":["cast::NumCast","std::cmp::PartialOrd","std::marker::Copy","std::ops::Neg","float::Float","Num"]}}
candidates:{"float::Float::atanh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.atanh();
+float::Float::atanh(p0);
+crate::float::Float::atanh(p0);
+crate::float::Float::atanh(p0);
-----------------
src/float.rs float::Float::integer_decode
deps:{"float::Float::integer_decode":{"Self":["std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg","float::Float","cast::NumCast","Num"]}}
candidates:{"float::Float::integer_decode":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.integer_decode();
+float::Float::integer_decode(p0);
+crate::float::Float::integer_decode(p0);
+crate::float::Float::integer_decode(p0);
-----------------
src/float.rs float::Float::copysign
deps:{"float::Float::copysign":{"Self":["std::cmp::PartialOrd","std::ops::Neg","std::marker::Copy","float::Float","Num","cast::NumCast"]}}
candidates:{"float::Float::copysign":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.copysign(p1);
+float::Float::copysign(p0, p1);
+crate::float::Float::copysign(p0, p1);
+crate::float::Float::copysign(p0, p1);
-----------------
src/float.rs float::FloatConst::E
deps:{"float::FloatConst::E":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::E":{"Self":[]}}
+float::FloatConst::E();
+crate::float::FloatConst::E();
+crate::float::FloatConst::E();
-----------------
src/float.rs float::FloatConst::FRAC_1_PI
deps:{"float::FloatConst::FRAC_1_PI":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_1_PI":{"Self":[]}}
+float::FloatConst::FRAC_1_PI();
+crate::float::FloatConst::FRAC_1_PI();
+crate::float::FloatConst::FRAC_1_PI();
-----------------
src/float.rs float::FloatConst::FRAC_1_SQRT_2
deps:{"float::FloatConst::FRAC_1_SQRT_2":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_1_SQRT_2":{"Self":[]}}
+float::FloatConst::FRAC_1_SQRT_2();
+crate::float::FloatConst::FRAC_1_SQRT_2();
+crate::float::FloatConst::FRAC_1_SQRT_2();
-----------------
src/float.rs float::FloatConst::FRAC_2_PI
deps:{"float::FloatConst::FRAC_2_PI":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_2_PI":{"Self":[]}}
+float::FloatConst::FRAC_2_PI();
+crate::float::FloatConst::FRAC_2_PI();
+crate::float::FloatConst::FRAC_2_PI();
-----------------
src/float.rs float::FloatConst::FRAC_2_SQRT_PI
deps:{"float::FloatConst::FRAC_2_SQRT_PI":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_2_SQRT_PI":{"Self":[]}}
+float::FloatConst::FRAC_2_SQRT_PI();
+crate::float::FloatConst::FRAC_2_SQRT_PI();
+crate::float::FloatConst::FRAC_2_SQRT_PI();
-----------------
src/float.rs float::FloatConst::FRAC_PI_2
deps:{"float::FloatConst::FRAC_PI_2":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_PI_2":{"Self":[]}}
+float::FloatConst::FRAC_PI_2();
+crate::float::FloatConst::FRAC_PI_2();
+crate::float::FloatConst::FRAC_PI_2();
-----------------
src/float.rs float::FloatConst::FRAC_PI_3
deps:{"float::FloatConst::FRAC_PI_3":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_PI_3":{"Self":[]}}
+float::FloatConst::FRAC_PI_3();
+crate::float::FloatConst::FRAC_PI_3();
+crate::float::FloatConst::FRAC_PI_3();
-----------------
src/float.rs float::FloatConst::FRAC_PI_4
deps:{"float::FloatConst::FRAC_PI_4":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_PI_4":{"Self":[]}}
+float::FloatConst::FRAC_PI_4();
+crate::float::FloatConst::FRAC_PI_4();
+crate::float::FloatConst::FRAC_PI_4();
-----------------
src/float.rs float::FloatConst::FRAC_PI_6
deps:{"float::FloatConst::FRAC_PI_6":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_PI_6":{"Self":[]}}
+float::FloatConst::FRAC_PI_6();
+crate::float::FloatConst::FRAC_PI_6();
+crate::float::FloatConst::FRAC_PI_6();
-----------------
src/float.rs float::FloatConst::FRAC_PI_8
deps:{"float::FloatConst::FRAC_PI_8":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::FRAC_PI_8":{"Self":[]}}
+float::FloatConst::FRAC_PI_8();
+crate::float::FloatConst::FRAC_PI_8();
+crate::float::FloatConst::FRAC_PI_8();
-----------------
src/float.rs float::FloatConst::LN_10
deps:{"float::FloatConst::LN_10":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::LN_10":{"Self":[]}}
+float::FloatConst::LN_10();
+crate::float::FloatConst::LN_10();
+crate::float::FloatConst::LN_10();
-----------------
src/float.rs float::FloatConst::LN_2
deps:{"float::FloatConst::LN_2":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::LN_2":{"Self":[]}}
+float::FloatConst::LN_2();
+crate::float::FloatConst::LN_2();
+crate::float::FloatConst::LN_2();
-----------------
src/float.rs float::FloatConst::LOG10_E
deps:{"float::FloatConst::LOG10_E":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::LOG10_E":{"Self":[]}}
+float::FloatConst::LOG10_E();
+crate::float::FloatConst::LOG10_E();
+crate::float::FloatConst::LOG10_E();
-----------------
src/float.rs float::FloatConst::LOG2_E
deps:{"float::FloatConst::LOG2_E":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::LOG2_E":{"Self":[]}}
+float::FloatConst::LOG2_E();
+crate::float::FloatConst::LOG2_E();
+crate::float::FloatConst::LOG2_E();
-----------------
src/float.rs float::FloatConst::PI
deps:{"float::FloatConst::PI":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::PI":{"Self":[]}}
+float::FloatConst::PI();
+crate::float::FloatConst::PI();
+crate::float::FloatConst::PI();
-----------------
src/float.rs float::FloatConst::SQRT_2
deps:{"float::FloatConst::SQRT_2":{"Self":["float::FloatConst"]}}
candidates:{"float::FloatConst::SQRT_2":{"Self":[]}}
+float::FloatConst::SQRT_2();
+crate::float::FloatConst::SQRT_2();
+crate::float::FloatConst::SQRT_2();
-----------------
src/float.rs float::FloatConst::TAU
deps:{"float::FloatConst::TAU":{"Self":["std::marker::Sized","float::FloatConst","std::ops::Add"]}}
candidates:{"float::FloatConst::TAU":{"Self":["i8","i16","usize","i32","u16","u8","u32","u64","i64"]}}
+float::FloatConst::TAU();
+crate::float::FloatConst::TAU();
+crate::float::FloatConst::TAU();
-----------------
src/float.rs float::FloatConst::LOG10_2
deps:{"float::FloatConst::LOG10_2":{"Self":["std::marker::Sized","std::ops::Div","float::FloatConst"]}}
candidates:{"float::FloatConst::LOG10_2":{"Self":["i32","i16","i8","i64"]}}
+float::FloatConst::LOG10_2();
+crate::float::FloatConst::LOG10_2();
+crate::float::FloatConst::LOG10_2();
-----------------
src/float.rs float::FloatConst::LOG2_10
deps:{"float::FloatConst::LOG2_10":{"Self":["std::marker::Sized","float::FloatConst","std::ops::Div"]}}
candidates:{"float::FloatConst::LOG2_10":{"Self":["i8","i64","i32","i16"]}}
+float::FloatConst::LOG2_10();
+crate::float::FloatConst::LOG2_10();
+crate::float::FloatConst::LOG2_10();
-----------------
src/identities.rs identities::Zero::zero
deps:{"identities::Zero::zero":{"Self":["std::marker::Sized","identities::Zero","std::ops::Add"]}}
candidates:{"identities::Zero::zero":{"Self":["std::num::Saturating<u64>","std::num::Saturating<i32>","std::num::Wrapping<i8>","std::num::Saturating<u128>","std::num::Saturating<u16>","std::num::Wrapping<u32>","std::num::Wrapping<u128>","std::num::Wrapping<u64>","std::num::Wrapping<isize>","std::num::Saturating<u8>","std::borrow::Cow<'a, str>","std::num::Saturating<i8>","std::num::Wrapping<i16>","std::num::Wrapping<u16>","std::num::Saturating<i16>","std::num::Saturating<isize>","std::num::Wrapping<i32>","std::num::Saturating<i128>","std::num::Saturating<usize>","std::num::Wrapping<i64>","std::num::Wrapping<u8>","std::num::Wrapping<usize>","std::num::Saturating<u32>","std::num::Saturating<i64>","std::num::Wrapping<i128>"]}}
+identities::Zero::zero();
+crate::identities::Zero::zero();
+crate::identities::Zero::zero();
-----------------
src/identities.rs identities::Zero::set_zero
deps:{"identities::Zero::set_zero":{"Self":["std::marker::Sized","identities::Zero","std::ops::Add"]}}
candidates:{"identities::Zero::set_zero":{"Self":["std::num::Saturating<i32>","std::num::Saturating<i8>","std::num::Wrapping<i16>","std::num::Wrapping<usize>","std::num::Saturating<u64>","std::num::Saturating<u128>","std::num::Saturating<u32>","std::num::Wrapping<u32>","std::num::Wrapping<u16>","std::num::Saturating<u8>","std::num::Wrapping<u128>","std::num::Wrapping<i32>","std::num::Saturating<u16>","std::num::Saturating<usize>","std::num::Wrapping<u8>","std::num::Wrapping<i128>","std::num::Wrapping<i64>","std::num::Saturating<i128>","std::num::Saturating<i64>","std::borrow::Cow<'a, str>","std::num::Wrapping<isize>","std::num::Saturating<isize>","std::num::Wrapping<u64>","std::num::Saturating<i16>","std::num::Wrapping<i8>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.set_zero();
+identities::Zero::set_zero(p0);
+crate::identities::Zero::set_zero(p0);
+crate::identities::Zero::set_zero(p0);
-----------------
src/identities.rs identities::Zero::is_zero
deps:{"identities::Zero::is_zero":{"Self":["std::ops::Add","std::marker::Sized","identities::Zero"]}}
candidates:{"identities::Zero::is_zero":{"Self":["std::num::Wrapping<i16>","std::num::Wrapping<i32>","std::num::Wrapping<i128>","std::num::Saturating<u64>","std::num::Wrapping<u128>","std::num::Saturating<usize>","std::num::Saturating<i16>","std::num::Saturating<u128>","std::num::Saturating<i32>","std::num::Saturating<i8>","std::num::Saturating<i64>","std::num::Wrapping<u8>","std::num::Saturating<isize>","std::num::Wrapping<u16>","std::num::Saturating<u16>","std::num::Wrapping<u64>","std::borrow::Cow<'a, str>","std::num::Wrapping<u32>","std::num::Wrapping<i64>","std::num::Saturating<i128>","std::num::Wrapping<isize>","std::num::Saturating<u32>","std::num::Wrapping<usize>","std::num::Wrapping<i8>","std::num::Saturating<u8>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_zero();
+identities::Zero::is_zero(p0);
+crate::identities::Zero::is_zero(p0);
+crate::identities::Zero::is_zero(p0);
-----------------
src/identities.rs identities::One::one
deps:{"identities::One::one":{"Self":["std::marker::Sized","std::ops::Mul","identities::One"]}}
candidates:{"identities::One::one":{"Self":["std::num::Wrapping<i8>","std::num::Saturating<i32>","std::num::Saturating<i128>","std::num::Saturating<u64>","std::num::Saturating<u32>","std::num::Saturating<usize>","std::num::Wrapping<u32>","std::num::Saturating<u16>","std::num::Saturating<isize>","std::num::Wrapping<u128>","std::num::Wrapping<i64>","std::num::Wrapping<i128>","std::num::Saturating<i8>","std::num::Wrapping<i32>","std::num::Wrapping<i16>","std::num::Wrapping<isize>","std::num::Saturating<i64>","std::num::Wrapping<u16>","std::num::Wrapping<usize>","std::num::Wrapping<u8>","std::num::Wrapping<u64>","std::num::Saturating<i16>","std::num::Saturating<u128>","std::num::Saturating<u8>"]}}
+identities::One::one();
+crate::identities::One::one();
+crate::identities::One::one();
-----------------
src/identities.rs identities::One::set_one
deps:{"identities::One::set_one":{"Self":["identities::One","std::ops::Mul","std::marker::Sized"]}}
candidates:{"identities::One::set_one":{"Self":["std::num::Saturating<i8>","std::num::Wrapping<i16>","std::num::Saturating<u64>","std::num::Saturating<i128>","std::num::Wrapping<u128>","std::num::Wrapping<i128>","std::num::Wrapping<usize>","std::num::Wrapping<isize>","std::num::Wrapping<i64>","std::num::Wrapping<u64>","std::num::Wrapping<u32>","std::num::Wrapping<u16>","std::num::Saturating<i16>","std::num::Saturating<u32>","std::num::Saturating<usize>","std::num::Saturating<u128>","std::num::Saturating<u16>","std::num::Saturating<i64>","std::num::Wrapping<i32>","std::num::Saturating<isize>","std::num::Wrapping<i8>","std::num::Saturating<i32>","std::num::Wrapping<u8>","std::num::Saturating<u8>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.set_one();
+identities::One::set_one(p0);
+crate::identities::One::set_one(p0);
+crate::identities::One::set_one(p0);
-----------------
src/identities.rs identities::One::is_one
deps:{"identities::One::is_one":{"Self":["std::cmp::PartialEq","std::marker::Sized","std::ops::Mul","identities::One"]}}
candidates:{"identities::One::is_one":{"Self":["&'a std::ffi::OsStr","std::borrow::Cow<'_, [T]>","std::borrow::Cow<'a, str>","std::net::IpAddr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_one();
+identities::One::is_one(p0);
+crate::identities::One::is_one(p0);
+crate::identities::One::is_one(p0);
-----------------
src/int.rs int::PrimInt::count_ones
deps:{"int::PrimInt::count_ones":{"Self":["std::cmp::PartialOrd","ops::saturating::Saturating","std::marker::Sized","std::ops::Shr","Num","cast::NumCast","ops::checked::CheckedSub","bounds::Bounded","std::ops::Shl","std::cmp::Ord","std::ops::BitAnd","std::ops::BitOr","std::marker::Copy","ops::checked::CheckedAdd","ops::checked::CheckedMul","std::ops::BitXor","ops::checked::CheckedDiv","int::PrimInt","std::ops::Not","std::cmp::Eq"]}}
candidates:{"int::PrimInt::count_ones":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.count_ones();
+int::PrimInt::count_ones(p0);
+crate::int::PrimInt::count_ones(p0);
+crate::int::PrimInt::count_ones(p0);
-----------------
src/int.rs int::PrimInt::count_zeros
deps:{"int::PrimInt::count_zeros":{"Self":["int::PrimInt","ops::checked::CheckedAdd","bounds::Bounded","std::ops::BitOr","std::cmp::Ord","std::marker::Copy","std::ops::Shr","Num","ops::checked::CheckedMul","std::ops::Not","std::marker::Sized","ops::checked::CheckedDiv","std::ops::Shl","std::cmp::PartialOrd","std::ops::BitXor","ops::saturating::Saturating","cast::NumCast","std::cmp::Eq","std::ops::BitAnd","ops::checked::CheckedSub"]}}
candidates:{"int::PrimInt::count_zeros":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.count_zeros();
+int::PrimInt::count_zeros(p0);
+crate::int::PrimInt::count_zeros(p0);
+crate::int::PrimInt::count_zeros(p0);
-----------------
src/int.rs int::PrimInt::leading_ones
deps:{"int::PrimInt::leading_ones":{"Self":["ops::checked::CheckedAdd","ops::checked::CheckedDiv","std::cmp::Ord","std::ops::Shr","ops::saturating::Saturating","std::ops::Not","std::cmp::PartialOrd","std::ops::BitXor","std::ops::BitOr","Num","ops::checked::CheckedSub","std::marker::Copy","int::PrimInt","cast::NumCast","ops::checked::CheckedMul","std::ops::BitAnd","std::marker::Sized","std::ops::Shl","bounds::Bounded","std::cmp::Eq"]}}
candidates:{"int::PrimInt::leading_ones":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.leading_ones();
+int::PrimInt::leading_ones(p0);
+crate::int::PrimInt::leading_ones(p0);
+crate::int::PrimInt::leading_ones(p0);
-----------------
src/int.rs int::PrimInt::leading_zeros
deps:{"int::PrimInt::leading_zeros":{"Self":["std::cmp::Eq","std::ops::Shl","std::ops::Shr","ops::checked::CheckedSub","Num","std::marker::Copy","ops::checked::CheckedDiv","std::ops::BitAnd","ops::saturating::Saturating","ops::checked::CheckedAdd","std::marker::Sized","ops::checked::CheckedMul","cast::NumCast","std::ops::BitOr","bounds::Bounded","std::cmp::PartialOrd","std::cmp::Ord","std::ops::Not","int::PrimInt","std::ops::BitXor"]}}
candidates:{"int::PrimInt::leading_zeros":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.leading_zeros();
+int::PrimInt::leading_zeros(p0);
+crate::int::PrimInt::leading_zeros(p0);
+crate::int::PrimInt::leading_zeros(p0);
-----------------
src/int.rs int::PrimInt::trailing_ones
deps:{"int::PrimInt::trailing_ones":{"Self":["ops::checked::CheckedDiv","Num","std::cmp::Ord","std::marker::Copy","std::ops::Shl","ops::checked::CheckedSub","bounds::Bounded","std::ops::BitXor","int::PrimInt","std::ops::BitAnd","std::ops::BitOr","std::cmp::Eq","std::marker::Sized","std::ops::Not","std::ops::Shr","cast::NumCast","ops::checked::CheckedAdd","ops::checked::CheckedMul","ops::saturating::Saturating","std::cmp::PartialOrd"]}}
candidates:{"int::PrimInt::trailing_ones":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.trailing_ones();
+int::PrimInt::trailing_ones(p0);
+crate::int::PrimInt::trailing_ones(p0);
+crate::int::PrimInt::trailing_ones(p0);
-----------------
src/int.rs int::PrimInt::trailing_zeros
deps:{"int::PrimInt::trailing_zeros":{"Self":["Num","std::cmp::PartialOrd","std::ops::Shl","ops::checked::CheckedMul","bounds::Bounded","std::marker::Copy","cast::NumCast","ops::checked::CheckedDiv","int::PrimInt","std::ops::BitAnd","std::ops::BitXor","std::ops::Not","std::ops::BitOr","ops::saturating::Saturating","ops::checked::CheckedAdd","std::marker::Sized","ops::checked::CheckedSub","std::cmp::Ord","std::cmp::Eq","std::ops::Shr"]}}
candidates:{"int::PrimInt::trailing_zeros":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.trailing_zeros();
+int::PrimInt::trailing_zeros(p0);
+crate::int::PrimInt::trailing_zeros(p0);
+crate::int::PrimInt::trailing_zeros(p0);
-----------------
src/int.rs int::PrimInt::rotate_left
deps:{"int::PrimInt::rotate_left":{"Self":["cast::NumCast","int::PrimInt","std::ops::Shl","std::ops::Not","ops::checked::CheckedMul","ops::checked::CheckedDiv","Num","std::marker::Sized","ops::checked::CheckedSub","std::ops::BitAnd","ops::checked::CheckedAdd","std::ops::BitXor","ops::saturating::Saturating","std::marker::Copy","std::ops::BitOr","std::cmp::Ord","std::ops::Shr","bounds::Bounded","std::cmp::Eq","std::cmp::PartialOrd"]}}
candidates:{"int::PrimInt::rotate_left":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+int::PrimInt::rotate_left(p0, p1);
+crate::int::PrimInt::rotate_left(p0, p1);
+crate::int::PrimInt::rotate_left(p0, p1);
-----------------
src/int.rs int::PrimInt::rotate_right
deps:{"int::PrimInt::rotate_right":{"Self":["std::ops::Not","ops::checked::CheckedAdd","Num","std::cmp::Eq","std::ops::Shl","std::marker::Copy","cast::NumCast","std::ops::BitOr","int::PrimInt","ops::checked::CheckedDiv","std::marker::Sized","std::ops::Shr","std::ops::BitXor","ops::checked::CheckedMul","std::ops::BitAnd","ops::saturating::Saturating","bounds::Bounded","std::cmp::Ord","std::cmp::PartialOrd","ops::checked::CheckedSub"]}}
candidates:{"int::PrimInt::rotate_right":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+int::PrimInt::rotate_right(p0, p1);
+crate::int::PrimInt::rotate_right(p0, p1);
+crate::int::PrimInt::rotate_right(p0, p1);
-----------------
src/int.rs int::PrimInt::signed_shl
deps:{"int::PrimInt::signed_shl":{"Self":["int::PrimInt","std::marker::Sized","cast::NumCast","bounds::Bounded","ops::checked::CheckedDiv","std::marker::Copy","std::ops::Shl","ops::checked::CheckedAdd","std::cmp::Ord","std::cmp::PartialOrd","std::ops::BitXor","ops::saturating::Saturating","std::ops::Shr","Num","std::cmp::Eq","std::ops::BitAnd","ops::checked::CheckedSub","std::ops::Not","std::ops::BitOr","ops::checked::CheckedMul"]}}
candidates:{"int::PrimInt::signed_shl":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+int::PrimInt::signed_shl(p0, p1);
+crate::int::PrimInt::signed_shl(p0, p1);
+crate::int::PrimInt::signed_shl(p0, p1);
-----------------
src/int.rs int::PrimInt::signed_shr
deps:{"int::PrimInt::signed_shr":{"Self":["std::ops::Not","std::cmp::Ord","std::marker::Copy","std::cmp::Eq","std::ops::Shl","cast::NumCast","std::ops::BitOr","std::ops::BitXor","ops::checked::CheckedAdd","std::marker::Sized","Num","int::PrimInt","bounds::Bounded","std::ops::Shr","ops::checked::CheckedMul","std::ops::BitAnd","ops::checked::CheckedSub","std::cmp::PartialOrd","ops::checked::CheckedDiv","ops::saturating::Saturating"]}}
candidates:{"int::PrimInt::signed_shr":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+int::PrimInt::signed_shr(p0, p1);
+crate::int::PrimInt::signed_shr(p0, p1);
+crate::int::PrimInt::signed_shr(p0, p1);
-----------------
src/int.rs int::PrimInt::unsigned_shl
deps:{"int::PrimInt::unsigned_shl":{"Self":["std::cmp::Eq","std::cmp::Ord","ops::checked::CheckedDiv","std::cmp::PartialOrd","std::ops::BitAnd","std::ops::BitOr","cast::NumCast","int::PrimInt","ops::checked::CheckedAdd","std::ops::Shl","ops::saturating::Saturating","std::ops::BitXor","std::ops::Not","std::marker::Copy","ops::checked::CheckedSub","ops::checked::CheckedMul","std::marker::Sized","bounds::Bounded","std::ops::Shr","Num"]}}
candidates:{"int::PrimInt::unsigned_shl":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+int::PrimInt::unsigned_shl(p0, p1);
+crate::int::PrimInt::unsigned_shl(p0, p1);
+crate::int::PrimInt::unsigned_shl(p0, p1);
-----------------
src/int.rs int::PrimInt::unsigned_shr
deps:{"int::PrimInt::unsigned_shr":{"Self":["ops::checked::CheckedSub","std::ops::BitXor","ops::checked::CheckedMul","ops::checked::CheckedDiv","int::PrimInt","cast::NumCast","std::cmp::Eq","ops::saturating::Saturating","Num","std::ops::Not","std::ops::BitOr","std::ops::Shl","std::cmp::Ord","std::marker::Copy","std::cmp::PartialOrd","std::ops::BitAnd","std::marker::Sized","ops::checked::CheckedAdd","bounds::Bounded","std::ops::Shr"]}}
candidates:{"int::PrimInt::unsigned_shr":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+int::PrimInt::unsigned_shr(p0, p1);
+crate::int::PrimInt::unsigned_shr(p0, p1);
+crate::int::PrimInt::unsigned_shr(p0, p1);
-----------------
src/int.rs int::PrimInt::swap_bytes
deps:{"int::PrimInt::swap_bytes":{"Self":["bounds::Bounded","std::ops::Shl","ops::checked::CheckedMul","int::PrimInt","std::cmp::Eq","std::ops::BitOr","std::ops::BitXor","cast::NumCast","std::marker::Copy","ops::checked::CheckedDiv","ops::saturating::Saturating","std::cmp::PartialOrd","ops::checked::CheckedSub","Num","std::ops::Not","std::ops::Shr","ops::checked::CheckedAdd","std::cmp::Ord","std::marker::Sized","std::ops::BitAnd"]}}
candidates:{"int::PrimInt::swap_bytes":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.swap_bytes();
+int::PrimInt::swap_bytes(p0);
+crate::int::PrimInt::swap_bytes(p0);
+crate::int::PrimInt::swap_bytes(p0);
-----------------
src/int.rs int::PrimInt::reverse_bits
deps:{"int::PrimInt::reverse_bits":{"Self":["std::ops::Shr","cast::NumCast","std::cmp::PartialOrd","ops::checked::CheckedSub","ops::checked::CheckedMul","ops::checked::CheckedDiv","bounds::Bounded","std::ops::Shl","std::ops::BitAnd","std::cmp::Ord","std::ops::BitOr","std::cmp::Eq","Num","ops::checked::CheckedAdd","std::marker::Copy","ops::saturating::Saturating","int::PrimInt","std::ops::Not","std::marker::Sized","std::ops::BitXor"]}}
candidates:{"int::PrimInt::reverse_bits":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.reverse_bits();
+int::PrimInt::reverse_bits(p0);
+crate::int::PrimInt::reverse_bits(p0);
+crate::int::PrimInt::reverse_bits(p0);
-----------------
src/int.rs int::PrimInt::from_be
deps:{"int::PrimInt::from_be":{"Self":["int::PrimInt","std::ops::BitOr","std::ops::Not","std::ops::BitXor","std::cmp::PartialOrd","std::ops::Shl","std::marker::Sized","std::ops::Shr","ops::checked::CheckedSub","ops::checked::CheckedMul","std::cmp::Ord","Num","std::marker::Copy","ops::checked::CheckedDiv","ops::saturating::Saturating","std::cmp::Eq","std::ops::BitAnd","ops::checked::CheckedAdd","cast::NumCast","bounds::Bounded"]}}
candidates:{"int::PrimInt::from_be":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+int::PrimInt::from_be(p0);
+crate::int::PrimInt::from_be(p0);
+crate::int::PrimInt::from_be(p0);
-----------------
src/int.rs int::PrimInt::from_le
deps:{"int::PrimInt::from_le":{"Self":["bounds::Bounded","std::marker::Copy","std::ops::BitAnd","std::ops::BitOr","std::ops::BitXor","ops::checked::CheckedSub","std::ops::Shl","std::cmp::PartialOrd","int::PrimInt","ops::saturating::Saturating","cast::NumCast","Num","std::ops::Shr","std::marker::Sized","ops::checked::CheckedAdd","std::cmp::Ord","std::ops::Not","ops::checked::CheckedMul","std::cmp::Eq","ops::checked::CheckedDiv"]}}
candidates:{"int::PrimInt::from_le":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+int::PrimInt::from_le(p0);
+crate::int::PrimInt::from_le(p0);
+crate::int::PrimInt::from_le(p0);
-----------------
src/int.rs int::PrimInt::to_be
deps:{"int::PrimInt::to_be":{"Self":["std::cmp::PartialOrd","bounds::Bounded","std::ops::BitOr","Num","ops::saturating::Saturating","std::ops::Shl","std::ops::Shr","std::marker::Copy","ops::checked::CheckedMul","ops::checked::CheckedSub","std::cmp::Ord","std::marker::Sized","std::ops::Not","std::ops::BitAnd","std::ops::BitXor","ops::checked::CheckedAdd","std::cmp::Eq","ops::checked::CheckedDiv","int::PrimInt","cast::NumCast"]}}
candidates:{"int::PrimInt::to_be":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.to_be();
+int::PrimInt::to_be(p0);
+crate::int::PrimInt::to_be(p0);
+crate::int::PrimInt::to_be(p0);
-----------------
src/int.rs int::PrimInt::to_le
deps:{"int::PrimInt::to_le":{"Self":["std::ops::Shr","std::cmp::Ord","bounds::Bounded","std::ops::Shl","std::ops::BitAnd","cast::NumCast","ops::saturating::Saturating","std::ops::BitXor","std::marker::Sized","int::PrimInt","std::cmp::PartialOrd","std::ops::Not","std::ops::BitOr","ops::checked::CheckedAdd","ops::checked::CheckedDiv","Num","std::marker::Copy","ops::checked::CheckedSub","std::cmp::Eq","ops::checked::CheckedMul"]}}
candidates:{"int::PrimInt::to_le":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.to_le();
+int::PrimInt::to_le(p0);
+crate::int::PrimInt::to_le(p0);
+crate::int::PrimInt::to_le(p0);
-----------------
src/int.rs int::PrimInt::pow
deps:{"int::PrimInt::pow":{"Self":["std::ops::BitAnd","std::ops::Shr","std::marker::Copy","cast::NumCast","ops::checked::CheckedDiv","ops::checked::CheckedSub","int::PrimInt","std::ops::BitOr","std::cmp::Ord","ops::checked::CheckedMul","std::cmp::PartialOrd","std::marker::Sized","Num","ops::saturating::Saturating","ops::checked::CheckedAdd","std::ops::BitXor","std::ops::Shl","std::cmp::Eq","bounds::Bounded","std::ops::Not"]}}
candidates:{"int::PrimInt::pow":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+int::PrimInt::pow(p0, p1);
+crate::int::PrimInt::pow(p0, p1);
+crate::int::PrimInt::pow(p0, p1);
-----------------
src/ops/checked.rs ops::checked::CheckedAdd::checked_add
deps:{"ops::checked::CheckedAdd::checked_add":{"Self":["ops::checked::CheckedAdd","std::marker::Sized","std::ops::Add"]}}
candidates:{"ops::checked::CheckedAdd::checked_add":{"Self":["std::num::Wrapping<usize>","std::num::Wrapping<u128>","std::num::Wrapping<u8>","std::num::Saturating<usize>","std::num::Wrapping<i32>","std::num::Saturating<i128>","std::num::Saturating<isize>","std::num::Saturating<u128>","std::num::Saturating<u64>","std::num::Wrapping<i16>","std::num::Wrapping<u16>","std::num::Saturating<u16>","std::num::Saturating<u8>","std::num::Wrapping<i64>","std::num::Saturating<i8>","std::num::Wrapping<i8>","std::num::Wrapping<i128>","std::num::Saturating<i32>","std::num::Wrapping<isize>","std::num::Saturating<i64>","std::num::Saturating<i16>","std::borrow::Cow<'a, str>","std::num::Wrapping<u64>","std::num::Wrapping<u32>","std::num::Saturating<u32>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.checked_add(p1);
+ops::checked::CheckedAdd::checked_add(p0, p1);
+crate::ops::checked::CheckedAdd::checked_add(p0, p1);
+crate::ops::checked::CheckedAdd::checked_add(p0, p1);
-----------------
src/ops/checked.rs ops::checked::CheckedSub::checked_sub
deps:{"ops::checked::CheckedSub::checked_sub":{"Self":["std::ops::Sub","ops::checked::CheckedSub","std::marker::Sized"]}}
candidates:{"ops::checked::CheckedSub::checked_sub":{"Self":["std::num::Saturating<u64>","std::num::Wrapping<i16>","std::num::Wrapping<i64>","std::num::Saturating<i64>","std::num::Wrapping<u64>","std::num::Saturating<i32>","std::num::Wrapping<u128>","std::num::Saturating<isize>","std::num::Saturating<u8>","std::num::Wrapping<u32>","std::num::Wrapping<i8>","std::num::Saturating<u16>","std::num::Saturating<u32>","std::num::Wrapping<i128>","std::num::Wrapping<isize>","std::num::Saturating<usize>","std::num::Wrapping<i32>","std::time::Instant","std::num::Saturating<i128>","std::num::Saturating<i16>","std::num::Wrapping<usize>","std::num::Wrapping<u8>","std::num::Saturating<i8>","std::num::Saturating<u128>","std::num::Wrapping<u16>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.checked_sub(p1);
+ops::checked::CheckedSub::checked_sub(p0, p1);
+crate::ops::checked::CheckedSub::checked_sub(p0, p1);
+crate::ops::checked::CheckedSub::checked_sub(p0, p1);
-----------------
src/ops/checked.rs ops::checked::CheckedMul::checked_mul
deps:{"ops::checked::CheckedMul::checked_mul":{"Self":["ops::checked::CheckedMul","std::marker::Sized","std::ops::Mul"]}}
candidates:{"ops::checked::CheckedMul::checked_mul":{"Self":["std::num::Saturating<u8>","std::num::Wrapping<i16>","std::num::Saturating<u32>","std::num::Saturating<usize>","std::num::Wrapping<u32>","std::num::Wrapping<u16>","std::num::Wrapping<usize>","std::num::Saturating<i128>","std::num::Wrapping<isize>","std::num::Saturating<i16>","std::num::Wrapping<i128>","std::num::Wrapping<u64>","std::num::Saturating<u16>","std::num::Wrapping<i64>","std::num::Wrapping<i32>","std::num::Wrapping<u128>","std::num::Saturating<i32>","std::num::Saturating<i64>","std::num::Wrapping<u8>","std::num::Saturating<u128>","std::num::Saturating<i8>","std::num::Wrapping<i8>","std::num::Saturating<u64>","std::num::Saturating<isize>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.checked_mul(p1);
+ops::checked::CheckedMul::checked_mul(p0, p1);
+crate::ops::checked::CheckedMul::checked_mul(p0, p1);
+crate::ops::checked::CheckedMul::checked_mul(p0, p1);
-----------------
src/ops/checked.rs ops::checked::CheckedDiv::checked_div
deps:{"ops::checked::CheckedDiv::checked_div":{"Self":["std::marker::Sized","std::ops::Div","ops::checked::CheckedDiv"]}}
candidates:{"ops::checked::CheckedDiv::checked_div":{"Self":["std::num::Wrapping<u8>","std::num::Saturating<isize>","std::num::Saturating<u8>","std::num::Saturating<i128>","std::num::Wrapping<u128>","std::num::Wrapping<u16>","std::num::Saturating<usize>","std::num::Wrapping<i8>","std::num::Wrapping<i16>","std::num::Wrapping<usize>","std::num::Saturating<i64>","std::num::Saturating<u16>","std::num::Wrapping<i32>","std::num::Wrapping<u32>","std::num::Saturating<i8>","std::num::Wrapping<isize>","std::num::Wrapping<i128>","std::num::Wrapping<u64>","std::num::Wrapping<i64>","std::num::Saturating<i32>","std::num::Saturating<u128>","std::num::Saturating<i16>","std::num::Saturating<u32>","std::num::Saturating<u64>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.checked_div(p1);
+ops::checked::CheckedDiv::checked_div(p0, p1);
+crate::ops::checked::CheckedDiv::checked_div(p0, p1);
+crate::ops::checked::CheckedDiv::checked_div(p0, p1);
-----------------
src/ops/checked.rs ops::checked::CheckedRem::checked_rem
deps:{"ops::checked::CheckedRem::checked_rem":{"Self":["std::marker::Sized","ops::checked::CheckedRem","std::ops::Rem"]}}
candidates:{"ops::checked::CheckedRem::checked_rem":{"Self":["std::num::Wrapping<i8>","std::num::Wrapping<i16>","std::num::Wrapping<i64>","std::num::Saturating<u8>","std::num::Saturating<usize>","std::num::Wrapping<i128>","std::num::Wrapping<usize>","std::num::Saturating<u32>","std::num::Saturating<i64>","std::num::Saturating<isize>","std::num::Saturating<i16>","std::num::Wrapping<u64>","std::num::Saturating<i32>","std::num::Wrapping<i32>","std::num::Saturating<u128>","std::num::Wrapping<u32>","std::num::Saturating<u64>","std::num::Saturating<i128>","std::num::Wrapping<u16>","std::num::Wrapping<u8>","std::num::Saturating<i8>","std::num::Wrapping<u128>","std::num::Wrapping<isize>","std::num::Saturating<u16>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.checked_rem(p1);
+ops::checked::CheckedRem::checked_rem(p0, p1);
+crate::ops::checked::CheckedRem::checked_rem(p0, p1);
+crate::ops::checked::CheckedRem::checked_rem(p0, p1);
-----------------
src/ops/checked.rs ops::checked::CheckedNeg::checked_neg
deps:{"ops::checked::CheckedNeg::checked_neg":{"Self":["std::marker::Sized","ops::checked::CheckedNeg"]}}
candidates:{"ops::checked::CheckedNeg::checked_neg":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.checked_neg();
+ops::checked::CheckedNeg::checked_neg(p0);
+crate::ops::checked::CheckedNeg::checked_neg(p0);
+crate::ops::checked::CheckedNeg::checked_neg(p0);
-----------------
src/ops/checked.rs ops::checked::CheckedShl::checked_shl
deps:{"ops::checked::CheckedShl::checked_shl":{"Self":["std::ops::Shl","std::marker::Sized","ops::checked::CheckedShl"]}}
candidates:{"ops::checked::CheckedShl::checked_shl":{"Self":["std::num::Saturating<isize>","std::num::Saturating<i16>","std::num::Wrapping<u16>","std::num::Wrapping<i32>","std::num::Wrapping<u8>","std::num::Saturating<u128>","std::num::Wrapping<usize>","std::num::Wrapping<u128>","std::num::Saturating<i128>","std::num::Wrapping<i128>","std::num::Wrapping<i16>","std::num::Saturating<u16>","std::num::Wrapping<isize>","std::num::Saturating<i32>","std::num::Saturating<u64>","std::num::Wrapping<u32>","std::num::Saturating<u32>","std::num::Saturating<u8>","std::num::Wrapping<u64>","std::num::Saturating<i64>","std::num::Wrapping<i64>","std::num::Saturating<usize>","std::num::Saturating<i8>","std::num::Wrapping<i8>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+ops::checked::CheckedShl::checked_shl(p0, p1);
+crate::ops::checked::CheckedShl::checked_shl(p0, p1);
+crate::ops::checked::CheckedShl::checked_shl(p0, p1);
-----------------
src/ops/checked.rs ops::checked::CheckedShr::checked_shr
deps:{"ops::checked::CheckedShr::checked_shr":{"Self":["ops::checked::CheckedShr","std::marker::Sized","std::ops::Shr"]}}
candidates:{"ops::checked::CheckedShr::checked_shr":{"Self":["std::num::Saturating<u64>","std::num::Saturating<i8>","std::num::Wrapping<u64>","std::num::Wrapping<i128>","std::num::Wrapping<usize>","std::num::Wrapping<u32>","std::num::Wrapping<i64>","std::num::Wrapping<i8>","std::num::Saturating<i16>","std::num::Saturating<i64>","std::num::Wrapping<u8>","std::num::Saturating<usize>","std::num::Wrapping<u16>","std::num::Saturating<u32>","std::num::Saturating<i32>","std::num::Wrapping<isize>","std::num::Saturating<u8>","std::num::Wrapping<i16>","std::num::Wrapping<u128>","std::num::Saturating<u128>","std::num::Saturating<u16>","std::num::Saturating<i128>","std::num::Wrapping<i32>","std::num::Saturating<isize>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+ops::checked::CheckedShr::checked_shr(p0, p1);
+crate::ops::checked::CheckedShr::checked_shr(p0, p1);
+crate::ops::checked::CheckedShr::checked_shr(p0, p1);
-----------------
src/ops/euclid.rs ops::euclid::Euclid::div_euclid
deps:{"ops::euclid::Euclid::div_euclid":{"Self":["std::marker::Sized","std::ops::Rem","std::ops::Div","ops::euclid::Euclid"]}}
candidates:{"ops::euclid::Euclid::div_euclid":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.div_euclid(p1);
+ops::euclid::Euclid::div_euclid(p0, p1);
+crate::ops::euclid::Euclid::div_euclid(p0, p1);
+crate::ops::euclid::Euclid::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs ops::euclid::Euclid::rem_euclid
deps:{"ops::euclid::Euclid::rem_euclid":{"Self":["ops::euclid::Euclid","std::ops::Div","std::ops::Rem","std::marker::Sized"]}}
candidates:{"ops::euclid::Euclid::rem_euclid":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.rem_euclid(p1);
+ops::euclid::Euclid::rem_euclid(p0, p1);
+crate::ops::euclid::Euclid::rem_euclid(p0, p1);
+crate::ops::euclid::Euclid::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs ops::euclid::CheckedEuclid::checked_div_euclid
deps:{"ops::euclid::CheckedEuclid::checked_div_euclid":{"Self":["ops::euclid::Euclid","ops::euclid::CheckedEuclid"]}}
candidates:{"ops::euclid::CheckedEuclid::checked_div_euclid":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.checked_div_euclid(p1);
+ops::euclid::CheckedEuclid::checked_div_euclid(p0, p1);
+crate::ops::euclid::CheckedEuclid::checked_div_euclid(p0, p1);
+crate::ops::euclid::CheckedEuclid::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs ops::euclid::CheckedEuclid::checked_rem_euclid
deps:{"ops::euclid::CheckedEuclid::checked_rem_euclid":{"Self":["ops::euclid::Euclid","ops::euclid::CheckedEuclid"]}}
candidates:{"ops::euclid::CheckedEuclid::checked_rem_euclid":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.checked_rem_euclid(p1);
+ops::euclid::CheckedEuclid::checked_rem_euclid(p0, p1);
+crate::ops::euclid::CheckedEuclid::checked_rem_euclid(p0, p1);
+crate::ops::euclid::CheckedEuclid::checked_rem_euclid(p0, p1);
-----------------
src/ops/inv.rs ops::inv::Inv::inv
deps:{"ops::inv::Inv::inv":{"Self":["ops::inv::Inv"]}}
candidates:{"ops::inv::Inv::inv":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.inv();
+ops::inv::Inv::inv(p0);
+crate::ops::inv::Inv::inv(p0);
+crate::ops::inv::Inv::inv(p0);
-----------------
src/ops/mul_add.rs ops::mul_add::MulAdd::mul_add
deps:{"ops::mul_add::MulAdd::mul_add":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"Self":["ops::mul_add::MulAdd"]}}
candidates:{"ops::mul_add::MulAdd::mul_add":{"A":["RUG_ANY"],"B":["RUG_ANY"],"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // A
let mut p2 = MaybeUninit::uninit().assume_init(); // B
+p0.mul_add(p1, p2);
+ops::mul_add::MulAdd::mul_add(p0, p1, p2);
+crate::ops::mul_add::MulAdd::mul_add(p0, p1, p2);
+crate::ops::mul_add::MulAdd::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs ops::mul_add::MulAddAssign::mul_add_assign
deps:{"ops::mul_add::MulAddAssign::mul_add_assign":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"Self":["ops::mul_add::MulAddAssign"]}}
candidates:{"ops::mul_add::MulAddAssign::mul_add_assign":{"A":["RUG_ANY"],"B":["RUG_ANY"],"Self":[]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // A
let mut p2 = MaybeUninit::uninit().assume_init(); // B
+p0.mul_add_assign(p1, p2);
+ops::mul_add::MulAddAssign::mul_add_assign(p0, p1, p2);
+crate::ops::mul_add::MulAddAssign::mul_add_assign(p0, p1, p2);
+crate::ops::mul_add::MulAddAssign::mul_add_assign(p0, p1, p2);
-----------------
src/ops/overflowing.rs ops::overflowing::OverflowingAdd::overflowing_add
deps:{"ops::overflowing::OverflowingAdd::overflowing_add":{"Self":["ops::overflowing::OverflowingAdd","std::marker::Sized","std::ops::Add"]}}
candidates:{"ops::overflowing::OverflowingAdd::overflowing_add":{"Self":["std::num::Wrapping<i16>","std::num::Wrapping<isize>","std::num::Wrapping<i32>","std::num::Saturating<usize>","std::num::Saturating<u32>","std::num::Saturating<i8>","std::num::Wrapping<i8>","std::num::Wrapping<i128>","std::num::Saturating<u16>","std::num::Saturating<u64>","std::num::Saturating<isize>","std::num::Wrapping<u16>","std::num::Saturating<i32>","std::num::Wrapping<u64>","std::borrow::Cow<'a, str>","std::num::Wrapping<u128>","std::num::Wrapping<u8>","std::num::Wrapping<usize>","std::num::Saturating<i128>","std::num::Saturating<i16>","std::num::Saturating<i64>","std::num::Wrapping<i64>","std::num::Saturating<u8>","std::num::Saturating<u128>","std::num::Wrapping<u32>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.overflowing_add(p1);
+ops::overflowing::OverflowingAdd::overflowing_add(p0, p1);
+crate::ops::overflowing::OverflowingAdd::overflowing_add(p0, p1);
+crate::ops::overflowing::OverflowingAdd::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs ops::overflowing::OverflowingSub::overflowing_sub
deps:{"ops::overflowing::OverflowingSub::overflowing_sub":{"Self":["ops::overflowing::OverflowingSub","std::ops::Sub","std::marker::Sized"]}}
candidates:{"ops::overflowing::OverflowingSub::overflowing_sub":{"Self":["std::num::Wrapping<usize>","std::num::Saturating<u128>","std::num::Saturating<u8>","std::num::Saturating<u32>","std::time::Instant","std::num::Wrapping<u16>","std::num::Saturating<isize>","std::num::Saturating<i64>","std::num::Wrapping<i64>","std::num::Wrapping<u32>","std::num::Saturating<u64>","std::num::Wrapping<u64>","std::num::Wrapping<i128>","std::num::Saturating<i8>","std::num::Wrapping<u8>","std::num::Saturating<usize>","std::num::Wrapping<i32>","std::num::Saturating<i16>","std::num::Wrapping<i8>","std::num::Saturating<u16>","std::num::Wrapping<isize>","std::num::Saturating<i32>","std::num::Wrapping<i16>","std::num::Wrapping<u128>","std::num::Saturating<i128>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.overflowing_sub(p1);
+ops::overflowing::OverflowingSub::overflowing_sub(p0, p1);
+crate::ops::overflowing::OverflowingSub::overflowing_sub(p0, p1);
+crate::ops::overflowing::OverflowingSub::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs ops::overflowing::OverflowingMul::overflowing_mul
deps:{"ops::overflowing::OverflowingMul::overflowing_mul":{"Self":["std::marker::Sized","std::ops::Mul","ops::overflowing::OverflowingMul"]}}
candidates:{"ops::overflowing::OverflowingMul::overflowing_mul":{"Self":["std::num::Saturating<isize>","std::num::Saturating<u32>","std::num::Saturating<u128>","std::num::Wrapping<u32>","std::num::Saturating<u8>","std::num::Wrapping<i8>","std::num::Saturating<i8>","std::num::Saturating<i128>","std::num::Saturating<i16>","std::num::Wrapping<usize>","std::num::Wrapping<i16>","std::num::Wrapping<isize>","std::num::Wrapping<i128>","std::num::Wrapping<u16>","std::num::Saturating<i64>","std::num::Wrapping<u8>","std::num::Wrapping<u64>","std::num::Wrapping<u128>","std::num::Saturating<u64>","std::num::Saturating<u16>","std::num::Wrapping<i64>","std::num::Saturating<i32>","std::num::Saturating<usize>","std::num::Wrapping<i32>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.overflowing_mul(p1);
+ops::overflowing::OverflowingMul::overflowing_mul(p0, p1);
+crate::ops::overflowing::OverflowingMul::overflowing_mul(p0, p1);
+crate::ops::overflowing::OverflowingMul::overflowing_mul(p0, p1);
-----------------
src/ops/saturating.rs ops::saturating::Saturating::saturating_add
deps:{"ops::saturating::Saturating::saturating_add":{"Self":["ops::saturating::Saturating"]}}
candidates:{"ops::saturating::Saturating::saturating_add":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.saturating_add(p1);
+ops::saturating::Saturating::saturating_add(p0, p1);
+crate::ops::saturating::Saturating::saturating_add(p0, p1);
+crate::ops::saturating::Saturating::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs ops::saturating::Saturating::saturating_sub
deps:{"ops::saturating::Saturating::saturating_sub":{"Self":["ops::saturating::Saturating"]}}
candidates:{"ops::saturating::Saturating::saturating_sub":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.saturating_sub(p1);
+ops::saturating::Saturating::saturating_sub(p0, p1);
+crate::ops::saturating::Saturating::saturating_sub(p0, p1);
+crate::ops::saturating::Saturating::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs ops::saturating::SaturatingAdd::saturating_add
deps:{"ops::saturating::SaturatingAdd::saturating_add":{"Self":["std::ops::Add","ops::saturating::SaturatingAdd","std::marker::Sized"]}}
candidates:{"ops::saturating::SaturatingAdd::saturating_add":{"Self":["std::num::Wrapping<i8>","std::num::Saturating<i16>","std::num::Saturating<i128>","std::num::Wrapping<i128>","std::num::Wrapping<u128>","std::num::Wrapping<i64>","std::num::Wrapping<usize>","std::num::Saturating<isize>","std::num::Wrapping<u8>","std::num::Wrapping<u32>","std::num::Saturating<i64>","std::num::Saturating<i8>","std::num::Saturating<i32>","std::num::Saturating<usize>","std::num::Saturating<u32>","std::num::Wrapping<i16>","std::num::Saturating<u128>","std::num::Saturating<u8>","std::num::Wrapping<u16>","std::num::Saturating<u64>","std::num::Wrapping<isize>","std::num::Wrapping<i32>","std::num::Saturating<u16>","std::num::Wrapping<u64>","std::borrow::Cow<'a, str>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.saturating_add(p1);
+ops::saturating::SaturatingAdd::saturating_add(p0, p1);
+crate::ops::saturating::SaturatingAdd::saturating_add(p0, p1);
+crate::ops::saturating::SaturatingAdd::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs ops::saturating::SaturatingSub::saturating_sub
deps:{"ops::saturating::SaturatingSub::saturating_sub":{"Self":["std::marker::Sized","std::ops::Sub","ops::saturating::SaturatingSub"]}}
candidates:{"ops::saturating::SaturatingSub::saturating_sub":{"Self":["std::num::Saturating<u16>","std::num::Saturating<u128>","std::time::Instant","std::num::Wrapping<u128>","std::num::Saturating<usize>","std::num::Wrapping<i8>","std::num::Saturating<i32>","std::num::Wrapping<i32>","std::num::Wrapping<i64>","std::num::Saturating<i8>","std::num::Saturating<u32>","std::num::Saturating<isize>","std::num::Wrapping<u8>","std::num::Wrapping<i128>","std::num::Wrapping<u32>","std::num::Saturating<i128>","std::num::Wrapping<i16>","std::num::Saturating<u64>","std::num::Wrapping<isize>","std::num::Saturating<i64>","std::num::Wrapping<u16>","std::num::Saturating<u8>","std::num::Wrapping<u64>","std::num::Saturating<i16>","std::num::Wrapping<usize>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.saturating_sub(p1);
+ops::saturating::SaturatingSub::saturating_sub(p0, p1);
+crate::ops::saturating::SaturatingSub::saturating_sub(p0, p1);
+crate::ops::saturating::SaturatingSub::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs ops::saturating::SaturatingMul::saturating_mul
deps:{"ops::saturating::SaturatingMul::saturating_mul":{"Self":["std::marker::Sized","std::ops::Mul","ops::saturating::SaturatingMul"]}}
candidates:{"ops::saturating::SaturatingMul::saturating_mul":{"Self":["std::num::Wrapping<u128>","std::num::Wrapping<u8>","std::num::Wrapping<u32>","std::num::Wrapping<isize>","std::num::Saturating<i8>","std::num::Wrapping<i64>","std::num::Saturating<i32>","std::num::Wrapping<usize>","std::num::Saturating<u8>","std::num::Saturating<u32>","std::num::Saturating<isize>","std::num::Wrapping<i16>","std::num::Wrapping<i32>","std::num::Wrapping<i128>","std::num::Saturating<usize>","std::num::Wrapping<u64>","std::num::Saturating<u128>","std::num::Saturating<i128>","std::num::Wrapping<i8>","std::num::Saturating<i64>","std::num::Wrapping<u16>","std::num::Saturating<i16>","std::num::Saturating<u64>","std::num::Saturating<u16>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.saturating_mul(p1);
+ops::saturating::SaturatingMul::saturating_mul(p0, p1);
+crate::ops::saturating::SaturatingMul::saturating_mul(p0, p1);
+crate::ops::saturating::SaturatingMul::saturating_mul(p0, p1);
-----------------
src/ops/wrapping.rs ops::wrapping::WrappingAdd::wrapping_add
deps:{"ops::wrapping::WrappingAdd::wrapping_add":{"Self":["std::ops::Add","ops::wrapping::WrappingAdd","std::marker::Sized"]}}
candidates:{"ops::wrapping::WrappingAdd::wrapping_add":{"Self":["std::num::Saturating<i128>","std::num::Saturating<u64>","std::num::Wrapping<usize>","std::num::Saturating<i16>","std::num::Wrapping<u64>","std::num::Wrapping<i16>","std::num::Saturating<u128>","std::num::Wrapping<i8>","std::num::Wrapping<u16>","std::num::Wrapping<i64>","std::num::Wrapping<u8>","std::num::Saturating<i32>","std::num::Wrapping<isize>","std::num::Saturating<isize>","std::num::Saturating<i8>","std::num::Saturating<usize>","std::num::Wrapping<u32>","std::num::Saturating<i64>","std::num::Wrapping<i32>","std::num::Saturating<u32>","std::num::Saturating<u8>","std::num::Wrapping<i128>","std::borrow::Cow<'a, str>","std::num::Wrapping<u128>","std::num::Saturating<u16>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.wrapping_add(p1);
+ops::wrapping::WrappingAdd::wrapping_add(p0, p1);
+crate::ops::wrapping::WrappingAdd::wrapping_add(p0, p1);
+crate::ops::wrapping::WrappingAdd::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs ops::wrapping::WrappingSub::wrapping_sub
deps:{"ops::wrapping::WrappingSub::wrapping_sub":{"Self":["std::marker::Sized","std::ops::Sub","ops::wrapping::WrappingSub"]}}
candidates:{"ops::wrapping::WrappingSub::wrapping_sub":{"Self":["std::num::Wrapping<u8>","std::num::Saturating<i16>","std::num::Wrapping<i64>","std::num::Wrapping<u16>","std::num::Saturating<i8>","std::num::Saturating<u16>","std::num::Saturating<i128>","std::num::Wrapping<i128>","std::num::Wrapping<i8>","std::num::Wrapping<u32>","std::num::Saturating<u128>","std::num::Saturating<i64>","std::num::Wrapping<i16>","std::num::Saturating<u64>","std::num::Saturating<isize>","std::num::Wrapping<usize>","std::num::Saturating<u8>","std::time::Instant","std::num::Saturating<u32>","std::num::Saturating<i32>","std::num::Wrapping<u64>","std::num::Wrapping<isize>","std::num::Saturating<usize>","std::num::Wrapping<i32>","std::num::Wrapping<u128>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.wrapping_sub(p1);
+ops::wrapping::WrappingSub::wrapping_sub(p0, p1);
+crate::ops::wrapping::WrappingSub::wrapping_sub(p0, p1);
+crate::ops::wrapping::WrappingSub::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs ops::wrapping::WrappingMul::wrapping_mul
deps:{"ops::wrapping::WrappingMul::wrapping_mul":{"Self":["std::ops::Mul","std::marker::Sized","ops::wrapping::WrappingMul"]}}
candidates:{"ops::wrapping::WrappingMul::wrapping_mul":{"Self":["std::num::Saturating<usize>","std::num::Saturating<i64>","std::num::Saturating<i16>","std::num::Saturating<i32>","std::num::Saturating<u64>","std::num::Wrapping<i32>","std::num::Saturating<u16>","std::num::Saturating<i8>","std::num::Saturating<u128>","std::num::Wrapping<i128>","std::num::Wrapping<u32>","std::num::Wrapping<isize>","std::num::Wrapping<i16>","std::num::Saturating<u32>","std::num::Wrapping<i64>","std::num::Wrapping<i8>","std::num::Saturating<i128>","std::num::Wrapping<u16>","std::num::Wrapping<u8>","std::num::Wrapping<u128>","std::num::Saturating<u8>","std::num::Saturating<isize>","std::num::Wrapping<u64>","std::num::Wrapping<usize>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.wrapping_mul(p1);
+ops::wrapping::WrappingMul::wrapping_mul(p0, p1);
+crate::ops::wrapping::WrappingMul::wrapping_mul(p0, p1);
+crate::ops::wrapping::WrappingMul::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs ops::wrapping::WrappingNeg::wrapping_neg
deps:{"ops::wrapping::WrappingNeg::wrapping_neg":{"Self":["ops::wrapping::WrappingNeg","std::marker::Sized"]},"std::num::Wrapping":{"T":["sign::Signed","cast::FromPrimitive","ops::wrapping::WrappingMul","Num","ops::wrapping::WrappingAdd","cast::ToPrimitive","bounds::Bounded","identities::One","ops::wrapping::WrappingSub","ops::wrapping::WrappingShr","sign::Unsigned","cast::NumCast","identities::Zero","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","std::marker::Sized"]}}
candidates:{"ops::wrapping::WrappingNeg::wrapping_neg":{"Self":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.wrapping_neg();
+ops::wrapping::WrappingNeg::wrapping_neg(p0);
+crate::ops::wrapping::WrappingNeg::wrapping_neg(p0);
+crate::ops::wrapping::WrappingNeg::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs ops::wrapping::WrappingShl::wrapping_shl
deps:{"ops::wrapping::WrappingShl::wrapping_shl":{"Self":["std::marker::Sized","std::ops::Shl","ops::wrapping::WrappingShl"]}}
candidates:{"ops::wrapping::WrappingShl::wrapping_shl":{"Self":["std::num::Saturating<u8>","std::num::Wrapping<u8>","std::num::Wrapping<u64>","std::num::Wrapping<u128>","std::num::Saturating<u128>","std::num::Wrapping<usize>","std::num::Saturating<u32>","std::num::Saturating<u64>","std::num::Wrapping<i32>","std::num::Saturating<u16>","std::num::Saturating<i32>","std::num::Saturating<i128>","std::num::Saturating<i8>","std::num::Saturating<i16>","std::num::Wrapping<i128>","std::num::Wrapping<i8>","std::num::Wrapping<i16>","std::num::Saturating<usize>","std::num::Wrapping<i64>","std::num::Saturating<isize>","std::num::Wrapping<u32>","std::num::Saturating<i64>","std::num::Wrapping<u16>","std::num::Wrapping<isize>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+ops::wrapping::WrappingShl::wrapping_shl(p0, p1);
+crate::ops::wrapping::WrappingShl::wrapping_shl(p0, p1);
+crate::ops::wrapping::WrappingShl::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs ops::wrapping::WrappingShr::wrapping_shr
deps:{"ops::wrapping::WrappingShr::wrapping_shr":{"Self":["std::marker::Sized","std::ops::Shr","ops::wrapping::WrappingShr"]}}
candidates:{"ops::wrapping::WrappingShr::wrapping_shr":{"Self":["std::num::Wrapping<isize>","std::num::Saturating<u32>","std::num::Wrapping<usize>","std::num::Saturating<i128>","std::num::Wrapping<u64>","std::num::Wrapping<u16>","std::num::Saturating<i32>","std::num::Wrapping<u32>","std::num::Saturating<usize>","std::num::Saturating<i8>","std::num::Saturating<i16>","std::num::Wrapping<u128>","std::num::Wrapping<i64>","std::num::Wrapping<i8>","std::num::Wrapping<i32>","std::num::Saturating<i64>","std::num::Wrapping<i16>","std::num::Saturating<u64>","std::num::Saturating<isize>","std::num::Saturating<u8>","std::num::Wrapping<i128>","std::num::Wrapping<u8>","std::num::Saturating<u128>","std::num::Saturating<u16>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+ops::wrapping::WrappingShr::wrapping_shr(p0, p1);
+crate::ops::wrapping::WrappingShr::wrapping_shr(p0, p1);
+crate::ops::wrapping::WrappingShr::wrapping_shr(p0, p1);
-----------------
src/pow.rs pow::Pow::pow
deps:{"pow::Pow::pow":{"RHS":["std::marker::Sized"],"Self":["pow::Pow"]}}
candidates:{"pow::Pow::pow":{"RHS":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // RHS
+p0.pow(p1);
+pow::Pow::pow(p0, p1);
+crate::pow::Pow::pow(p0, p1);
+crate::pow::Pow::pow(p0, p1);
-----------------
src/real.rs real::Real::min_value
deps:{"real::Real::min_value":{"Self":["std::ops::Neg","std::marker::Copy","std::cmp::PartialOrd","real::Real","cast::NumCast","Num"]}}
candidates:{"real::Real::min_value":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+real::Real::min_value();
+crate::real::Real::min_value();
+crate::real::Real::min_value();
-----------------
src/real.rs real::Real::min_positive_value
deps:{"real::Real::min_positive_value":{"Self":["real::Real","std::marker::Copy","Num","std::cmp::PartialOrd","std::ops::Neg","cast::NumCast"]}}
candidates:{"real::Real::min_positive_value":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+real::Real::min_positive_value();
+crate::real::Real::min_positive_value();
+crate::real::Real::min_positive_value();
-----------------
src/real.rs real::Real::epsilon
deps:{"real::Real::epsilon":{"Self":["std::cmp::PartialOrd","real::Real","std::ops::Neg","cast::NumCast","std::marker::Copy","Num"]}}
candidates:{"real::Real::epsilon":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+real::Real::epsilon();
+crate::real::Real::epsilon();
+crate::real::Real::epsilon();
-----------------
src/real.rs real::Real::max_value
deps:{"real::Real::max_value":{"Self":["std::marker::Copy","cast::NumCast","std::cmp::PartialOrd","real::Real","Num","std::ops::Neg"]}}
candidates:{"real::Real::max_value":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
+real::Real::max_value();
+crate::real::Real::max_value();
+crate::real::Real::max_value();
-----------------
src/real.rs real::Real::floor
deps:{"real::Real::floor":{"Self":["cast::NumCast","Num","std::cmp::PartialOrd","real::Real","std::marker::Copy","std::ops::Neg"]}}
candidates:{"real::Real::floor":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.floor();
+real::Real::floor(p0);
+crate::real::Real::floor(p0);
+crate::real::Real::floor(p0);
-----------------
src/real.rs real::Real::ceil
deps:{"real::Real::ceil":{"Self":["std::ops::Neg","real::Real","std::cmp::PartialOrd","cast::NumCast","std::marker::Copy","Num"]}}
candidates:{"real::Real::ceil":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.ceil();
+real::Real::ceil(p0);
+crate::real::Real::ceil(p0);
+crate::real::Real::ceil(p0);
-----------------
src/real.rs real::Real::round
deps:{"real::Real::round":{"Self":["Num","std::marker::Copy","std::cmp::PartialOrd","real::Real","cast::NumCast","std::ops::Neg"]}}
candidates:{"real::Real::round":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.round();
+real::Real::round(p0);
+crate::real::Real::round(p0);
+crate::real::Real::round(p0);
-----------------
src/real.rs real::Real::trunc
deps:{"real::Real::trunc":{"Self":["Num","real::Real","std::ops::Neg","std::cmp::PartialOrd","std::marker::Copy","cast::NumCast"]}}
candidates:{"real::Real::trunc":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.trunc();
+real::Real::trunc(p0);
+crate::real::Real::trunc(p0);
+crate::real::Real::trunc(p0);
-----------------
src/real.rs real::Real::fract
deps:{"real::Real::fract":{"Self":["std::marker::Copy","std::cmp::PartialOrd","cast::NumCast","std::ops::Neg","Num","real::Real"]}}
candidates:{"real::Real::fract":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.fract();
+real::Real::fract(p0);
+crate::real::Real::fract(p0);
+crate::real::Real::fract(p0);
-----------------
src/real.rs real::Real::abs
deps:{"real::Real::abs":{"Self":["cast::NumCast","real::Real","Num","std::cmp::PartialOrd","std::marker::Copy","std::ops::Neg"]}}
candidates:{"real::Real::abs":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.abs();
+real::Real::abs(p0);
+crate::real::Real::abs(p0);
+crate::real::Real::abs(p0);
-----------------
src/real.rs real::Real::signum
deps:{"real::Real::signum":{"Self":["std::marker::Copy","std::cmp::PartialOrd","Num","std::ops::Neg","real::Real","cast::NumCast"]}}
candidates:{"real::Real::signum":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.signum();
+real::Real::signum(p0);
+crate::real::Real::signum(p0);
+crate::real::Real::signum(p0);
-----------------
src/real.rs real::Real::is_sign_positive
deps:{"real::Real::is_sign_positive":{"Self":["std::cmp::PartialOrd","std::marker::Copy","std::ops::Neg","cast::NumCast","real::Real","Num"]}}
candidates:{"real::Real::is_sign_positive":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_sign_positive();
+real::Real::is_sign_positive(p0);
+crate::real::Real::is_sign_positive(p0);
+crate::real::Real::is_sign_positive(p0);
-----------------
src/real.rs real::Real::is_sign_negative
deps:{"real::Real::is_sign_negative":{"Self":["std::ops::Neg","std::marker::Copy","real::Real","Num","cast::NumCast","std::cmp::PartialOrd"]}}
candidates:{"real::Real::is_sign_negative":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_sign_negative();
+real::Real::is_sign_negative(p0);
+crate::real::Real::is_sign_negative(p0);
+crate::real::Real::is_sign_negative(p0);
-----------------
src/real.rs real::Real::mul_add
deps:{"real::Real::mul_add":{"Self":["real::Real","std::marker::Copy","cast::NumCast","std::ops::Neg","Num","std::cmp::PartialOrd"]}}
candidates:{"real::Real::mul_add":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
let mut p2 = MaybeUninit::uninit().assume_init(); // Self
+p0.mul_add(p1, p2);
+real::Real::mul_add(p0, p1, p2);
+crate::real::Real::mul_add(p0, p1, p2);
+crate::real::Real::mul_add(p0, p1, p2);
-----------------
src/real.rs real::Real::recip
deps:{"real::Real::recip":{"Self":["std::ops::Neg","std::marker::Copy","std::cmp::PartialOrd","real::Real","cast::NumCast","Num"]}}
candidates:{"real::Real::recip":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.recip();
+real::Real::recip(p0);
+crate::real::Real::recip(p0);
+crate::real::Real::recip(p0);
-----------------
src/real.rs real::Real::powi
deps:{"real::Real::powi":{"Self":["std::cmp::PartialOrd","real::Real","std::marker::Copy","cast::NumCast","std::ops::Neg","Num"]}}
candidates:{"real::Real::powi":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
+p0.powi(p1);
+real::Real::powi(p0, p1);
+crate::real::Real::powi(p0, p1);
+crate::real::Real::powi(p0, p1);
-----------------
src/real.rs real::Real::powf
deps:{"real::Real::powf":{"Self":["real::Real","cast::NumCast","Num","std::marker::Copy","std::ops::Neg","std::cmp::PartialOrd"]}}
candidates:{"real::Real::powf":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.powf(p1);
+real::Real::powf(p0, p1);
+crate::real::Real::powf(p0, p1);
+crate::real::Real::powf(p0, p1);
-----------------
src/real.rs real::Real::sqrt
deps:{"real::Real::sqrt":{"Self":["std::ops::Neg","real::Real","cast::NumCast","std::cmp::PartialOrd","std::marker::Copy","Num"]}}
candidates:{"real::Real::sqrt":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.sqrt();
+real::Real::sqrt(p0);
+crate::real::Real::sqrt(p0);
+crate::real::Real::sqrt(p0);
-----------------
src/real.rs real::Real::exp
deps:{"real::Real::exp":{"Self":["std::marker::Copy","real::Real","Num","std::cmp::PartialOrd","std::ops::Neg","cast::NumCast"]}}
candidates:{"real::Real::exp":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.exp();
+real::Real::exp(p0);
+crate::real::Real::exp(p0);
+crate::real::Real::exp(p0);
-----------------
src/real.rs real::Real::exp2
deps:{"real::Real::exp2":{"Self":["Num","std::cmp::PartialOrd","std::ops::Neg","std::marker::Copy","real::Real","cast::NumCast"]}}
candidates:{"real::Real::exp2":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.exp2();
+real::Real::exp2(p0);
+crate::real::Real::exp2(p0);
+crate::real::Real::exp2(p0);
-----------------
src/real.rs real::Real::ln
deps:{"real::Real::ln":{"Self":["real::Real","std::ops::Neg","cast::NumCast","std::marker::Copy","std::cmp::PartialOrd","Num"]}}
candidates:{"real::Real::ln":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.ln();
+real::Real::ln(p0);
+crate::real::Real::ln(p0);
+crate::real::Real::ln(p0);
-----------------
src/real.rs real::Real::log
deps:{"real::Real::log":{"Self":["real::Real","std::cmp::PartialOrd","std::marker::Copy","std::ops::Neg","Num","cast::NumCast"]}}
candidates:{"real::Real::log":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.log(p1);
+real::Real::log(p0, p1);
+crate::real::Real::log(p0, p1);
+crate::real::Real::log(p0, p1);
-----------------
src/real.rs real::Real::log2
deps:{"real::Real::log2":{"Self":["Num","std::ops::Neg","real::Real","cast::NumCast","std::marker::Copy","std::cmp::PartialOrd"]}}
candidates:{"real::Real::log2":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.log2();
+real::Real::log2(p0);
+crate::real::Real::log2(p0);
+crate::real::Real::log2(p0);
-----------------
src/real.rs real::Real::log10
deps:{"real::Real::log10":{"Self":["cast::NumCast","Num","std::ops::Neg","real::Real","std::cmp::PartialOrd","std::marker::Copy"]}}
candidates:{"real::Real::log10":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.log10();
+real::Real::log10(p0);
+crate::real::Real::log10(p0);
+crate::real::Real::log10(p0);
-----------------
src/real.rs real::Real::to_degrees
deps:{"real::Real::to_degrees":{"Self":["std::cmp::PartialOrd","std::marker::Copy","real::Real","Num","std::ops::Neg","cast::NumCast"]}}
candidates:{"real::Real::to_degrees":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.to_degrees();
+real::Real::to_degrees(p0);
+crate::real::Real::to_degrees(p0);
+crate::real::Real::to_degrees(p0);
-----------------
src/real.rs real::Real::to_radians
deps:{"real::Real::to_radians":{"Self":["Num","std::marker::Copy","real::Real","std::cmp::PartialOrd","cast::NumCast","std::ops::Neg"]}}
candidates:{"real::Real::to_radians":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.to_radians();
+real::Real::to_radians(p0);
+crate::real::Real::to_radians(p0);
+crate::real::Real::to_radians(p0);
-----------------
src/real.rs real::Real::max
deps:{"real::Real::max":{"Self":["real::Real","Num","std::cmp::PartialOrd","std::marker::Copy","cast::NumCast","std::ops::Neg"]}}
candidates:{"real::Real::max":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.max(p1);
+real::Real::max(p0, p1);
+crate::real::Real::max(p0, p1);
+crate::real::Real::max(p0, p1);
-----------------
src/real.rs real::Real::min
deps:{"real::Real::min":{"Self":["std::marker::Copy","Num","std::cmp::PartialOrd","std::ops::Neg","real::Real","cast::NumCast"]}}
candidates:{"real::Real::min":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.min(p1);
+real::Real::min(p0, p1);
+crate::real::Real::min(p0, p1);
+crate::real::Real::min(p0, p1);
-----------------
src/real.rs real::Real::abs_sub
deps:{"real::Real::abs_sub":{"Self":["std::marker::Copy","std::cmp::PartialOrd","Num","std::ops::Neg","cast::NumCast","real::Real"]}}
candidates:{"real::Real::abs_sub":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.abs_sub(p1);
+real::Real::abs_sub(p0, p1);
+crate::real::Real::abs_sub(p0, p1);
+crate::real::Real::abs_sub(p0, p1);
-----------------
src/real.rs real::Real::cbrt
deps:{"real::Real::cbrt":{"Self":["Num","std::cmp::PartialOrd","cast::NumCast","std::ops::Neg","std::marker::Copy","real::Real"]}}
candidates:{"real::Real::cbrt":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.cbrt();
+real::Real::cbrt(p0);
+crate::real::Real::cbrt(p0);
+crate::real::Real::cbrt(p0);
-----------------
src/real.rs real::Real::hypot
deps:{"real::Real::hypot":{"Self":["real::Real","std::cmp::PartialOrd","std::marker::Copy","Num","std::ops::Neg","cast::NumCast"]}}
candidates:{"real::Real::hypot":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.hypot(p1);
+real::Real::hypot(p0, p1);
+crate::real::Real::hypot(p0, p1);
+crate::real::Real::hypot(p0, p1);
-----------------
src/real.rs real::Real::sin
deps:{"real::Real::sin":{"Self":["real::Real","Num","cast::NumCast","std::cmp::PartialOrd","std::marker::Copy","std::ops::Neg"]}}
candidates:{"real::Real::sin":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.sin();
+real::Real::sin(p0);
+crate::real::Real::sin(p0);
+crate::real::Real::sin(p0);
-----------------
src/real.rs real::Real::cos
deps:{"real::Real::cos":{"Self":["std::marker::Copy","Num","cast::NumCast","std::ops::Neg","std::cmp::PartialOrd","real::Real"]}}
candidates:{"real::Real::cos":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.cos();
+real::Real::cos(p0);
+crate::real::Real::cos(p0);
+crate::real::Real::cos(p0);
-----------------
src/real.rs real::Real::tan
deps:{"real::Real::tan":{"Self":["std::marker::Copy","cast::NumCast","std::cmp::PartialOrd","std::ops::Neg","real::Real","Num"]}}
candidates:{"real::Real::tan":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.tan();
+real::Real::tan(p0);
+crate::real::Real::tan(p0);
+crate::real::Real::tan(p0);
-----------------
src/real.rs real::Real::asin
deps:{"real::Real::asin":{"Self":["std::ops::Neg","real::Real","std::marker::Copy","cast::NumCast","std::cmp::PartialOrd","Num"]}}
candidates:{"real::Real::asin":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.asin();
+real::Real::asin(p0);
+crate::real::Real::asin(p0);
+crate::real::Real::asin(p0);
-----------------
src/real.rs real::Real::acos
deps:{"real::Real::acos":{"Self":["std::marker::Copy","std::cmp::PartialOrd","Num","cast::NumCast","std::ops::Neg","real::Real"]}}
candidates:{"real::Real::acos":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.acos();
+real::Real::acos(p0);
+crate::real::Real::acos(p0);
+crate::real::Real::acos(p0);
-----------------
src/real.rs real::Real::atan
deps:{"real::Real::atan":{"Self":["std::ops::Neg","cast::NumCast","std::marker::Copy","Num","std::cmp::PartialOrd","real::Real"]}}
candidates:{"real::Real::atan":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.atan();
+real::Real::atan(p0);
+crate::real::Real::atan(p0);
+crate::real::Real::atan(p0);
-----------------
src/real.rs real::Real::atan2
deps:{"real::Real::atan2":{"Self":["real::Real","cast::NumCast","std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg","Num"]}}
candidates:{"real::Real::atan2":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.atan2(p1);
+real::Real::atan2(p0, p1);
+crate::real::Real::atan2(p0, p1);
+crate::real::Real::atan2(p0, p1);
-----------------
src/real.rs real::Real::sin_cos
deps:{"real::Real::sin_cos":{"Self":["std::marker::Copy","Num","cast::NumCast","real::Real","std::ops::Neg","std::cmp::PartialOrd"]}}
candidates:{"real::Real::sin_cos":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.sin_cos();
+real::Real::sin_cos(p0);
+crate::real::Real::sin_cos(p0);
+crate::real::Real::sin_cos(p0);
-----------------
src/real.rs real::Real::exp_m1
deps:{"real::Real::exp_m1":{"Self":["Num","std::cmp::PartialOrd","real::Real","std::marker::Copy","std::ops::Neg","cast::NumCast"]}}
candidates:{"real::Real::exp_m1":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.exp_m1();
+real::Real::exp_m1(p0);
+crate::real::Real::exp_m1(p0);
+crate::real::Real::exp_m1(p0);
-----------------
src/real.rs real::Real::ln_1p
deps:{"real::Real::ln_1p":{"Self":["cast::NumCast","Num","real::Real","std::marker::Copy","std::cmp::PartialOrd","std::ops::Neg"]}}
candidates:{"real::Real::ln_1p":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.ln_1p();
+real::Real::ln_1p(p0);
+crate::real::Real::ln_1p(p0);
+crate::real::Real::ln_1p(p0);
-----------------
src/real.rs real::Real::sinh
deps:{"real::Real::sinh":{"Self":["std::cmp::PartialOrd","cast::NumCast","std::ops::Neg","std::marker::Copy","Num","real::Real"]}}
candidates:{"real::Real::sinh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.sinh();
+real::Real::sinh(p0);
+crate::real::Real::sinh(p0);
+crate::real::Real::sinh(p0);
-----------------
src/real.rs real::Real::cosh
deps:{"real::Real::cosh":{"Self":["std::cmp::PartialOrd","std::marker::Copy","std::ops::Neg","real::Real","Num","cast::NumCast"]}}
candidates:{"real::Real::cosh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.cosh();
+real::Real::cosh(p0);
+crate::real::Real::cosh(p0);
+crate::real::Real::cosh(p0);
-----------------
src/real.rs real::Real::tanh
deps:{"real::Real::tanh":{"Self":["std::marker::Copy","std::cmp::PartialOrd","Num","std::ops::Neg","cast::NumCast","real::Real"]}}
candidates:{"real::Real::tanh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.tanh();
+real::Real::tanh(p0);
+crate::real::Real::tanh(p0);
+crate::real::Real::tanh(p0);
-----------------
src/real.rs real::Real::asinh
deps:{"real::Real::asinh":{"Self":["std::cmp::PartialOrd","real::Real","std::marker::Copy","cast::NumCast","std::ops::Neg","Num"]}}
candidates:{"real::Real::asinh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.asinh();
+real::Real::asinh(p0);
+crate::real::Real::asinh(p0);
+crate::real::Real::asinh(p0);
-----------------
src/real.rs real::Real::acosh
deps:{"real::Real::acosh":{"Self":["std::ops::Neg","real::Real","cast::NumCast","std::marker::Copy","std::cmp::PartialOrd","Num"]}}
candidates:{"real::Real::acosh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.acosh();
+real::Real::acosh(p0);
+crate::real::Real::acosh(p0);
+crate::real::Real::acosh(p0);
-----------------
src/real.rs real::Real::atanh
deps:{"real::Real::atanh":{"Self":["Num","std::cmp::PartialOrd","std::ops::Neg","real::Real","std::marker::Copy","cast::NumCast"]}}
candidates:{"real::Real::atanh":{"Self":["std::borrow::Cow<'a, std::path::Path>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.atanh();
+real::Real::atanh(p0);
+crate::real::Real::atanh(p0);
+crate::real::Real::atanh(p0);
-----------------
src/sign.rs sign::Signed::abs
deps:{"sign::Signed::abs":{"Self":["std::ops::Neg","sign::Signed","std::marker::Sized","Num"]}}
candidates:{"sign::Signed::abs":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.abs();
+sign::Signed::abs(p0);
+crate::sign::Signed::abs(p0);
+crate::sign::Signed::abs(p0);
-----------------
src/sign.rs sign::Signed::abs_sub
deps:{"sign::Signed::abs_sub":{"Self":["sign::Signed","Num","std::ops::Neg","std::marker::Sized"]}}
candidates:{"sign::Signed::abs_sub":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.abs_sub(p1);
+sign::Signed::abs_sub(p0, p1);
+crate::sign::Signed::abs_sub(p0, p1);
+crate::sign::Signed::abs_sub(p0, p1);
-----------------
src/sign.rs sign::Signed::signum
deps:{"sign::Signed::signum":{"Self":["Num","std::marker::Sized","sign::Signed","std::ops::Neg"]}}
candidates:{"sign::Signed::signum":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.signum();
+sign::Signed::signum(p0);
+crate::sign::Signed::signum(p0);
+crate::sign::Signed::signum(p0);
-----------------
src/sign.rs sign::Signed::is_positive
deps:{"sign::Signed::is_positive":{"Self":["std::marker::Sized","std::ops::Neg","sign::Signed","Num"]}}
candidates:{"sign::Signed::is_positive":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_positive();
+sign::Signed::is_positive(p0);
+crate::sign::Signed::is_positive(p0);
+crate::sign::Signed::is_positive(p0);
-----------------
src/sign.rs sign::Signed::is_negative
deps:{"sign::Signed::is_negative":{"Self":["std::ops::Neg","sign::Signed","std::marker::Sized","Num"]}}
candidates:{"sign::Signed::is_negative":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_negative();
+sign::Signed::is_negative(p0);
+crate::sign::Signed::is_negative(p0);
+crate::sign::Signed::is_negative(p0);
-----------------
src/lib.rs Num::from_str_radix
deps:{"Num::from_str_radix":{"Self":["Num","identities::One","identities::Zero","std::cmp::PartialEq","NumOps"]}}
candidates:{"Num::from_str_radix":{"Self":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]}}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+Num::from_str_radix(&p0, p1);
+crate::Num::from_str_radix(&p0, p1);
+crate::Num::from_str_radix(&p0, p1);
-----------------
src/bounds.rs <T as bounds::LowerBounded>::min_value
deps:{"<T as bounds::LowerBounded>::min_value":{"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","cast::NumCast","sign::Signed","std::marker::Sized","sign::Unsigned","identities::One","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","cast::FromPrimitive","ops::wrapping::WrappingAdd","identities::Zero","bounds::Bounded","Num","cast::ToPrimitive"]}}
candidates:{"<T as bounds::LowerBounded>::min_value":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<T as bounds::LowerBounded>::min_value();
+crate::<T as bounds::LowerBounded>::min_value();
+<T>::min_value();
-----------------
src/bounds.rs <T as bounds::UpperBounded>::max_value
deps:{"<T as bounds::UpperBounded>::max_value":{"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingAdd","std::marker::Sized","sign::Signed","ops::wrapping::WrappingMul","identities::Zero","ops::wrapping::WrappingSub","identities::One","ops::wrapping::WrappingShl","sign::Unsigned","ops::wrapping::WrappingShr","ops::wrapping::WrappingNeg","cast::NumCast","cast::FromPrimitive","Num","cast::ToPrimitive","bounds::Bounded"]}}
candidates:{"<T as bounds::UpperBounded>::max_value":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<T as bounds::UpperBounded>::max_value();
+crate::<T as bounds::UpperBounded>::max_value();
+<T>::max_value();
-----------------
src/bounds.rs <usize as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<usize as bounds::Bounded>::min_value();
+crate::<usize as bounds::Bounded>::min_value();
+<usize>::min_value();
-----------------
src/bounds.rs <usize as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<usize as bounds::Bounded>::max_value();
+crate::<usize as bounds::Bounded>::max_value();
+<usize>::max_value();
-----------------
src/bounds.rs <u8 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<u8 as bounds::Bounded>::min_value();
+crate::<u8 as bounds::Bounded>::min_value();
+<u8>::min_value();
-----------------
src/bounds.rs <u8 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<u8 as bounds::Bounded>::max_value();
+crate::<u8 as bounds::Bounded>::max_value();
+<u8>::max_value();
-----------------
src/bounds.rs <u16 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<u16 as bounds::Bounded>::min_value();
+crate::<u16 as bounds::Bounded>::min_value();
+<u16>::min_value();
-----------------
src/bounds.rs <u16 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<u16 as bounds::Bounded>::max_value();
+crate::<u16 as bounds::Bounded>::max_value();
+<u16>::max_value();
-----------------
src/bounds.rs <u32 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<u32 as bounds::Bounded>::min_value();
+crate::<u32 as bounds::Bounded>::min_value();
+<u32>::min_value();
-----------------
src/bounds.rs <u32 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<u32 as bounds::Bounded>::max_value();
+crate::<u32 as bounds::Bounded>::max_value();
+<u32>::max_value();
-----------------
src/bounds.rs <u64 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<u64 as bounds::Bounded>::min_value();
+crate::<u64 as bounds::Bounded>::min_value();
+<u64>::min_value();
-----------------
src/bounds.rs <u64 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<u64 as bounds::Bounded>::max_value();
+crate::<u64 as bounds::Bounded>::max_value();
+<u64>::max_value();
-----------------
src/bounds.rs <u128 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<u128 as bounds::Bounded>::min_value();
+crate::<u128 as bounds::Bounded>::min_value();
+<u128>::min_value();
-----------------
src/bounds.rs <u128 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<u128 as bounds::Bounded>::max_value();
+crate::<u128 as bounds::Bounded>::max_value();
+<u128>::max_value();
-----------------
src/bounds.rs <isize as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<isize as bounds::Bounded>::min_value();
+crate::<isize as bounds::Bounded>::min_value();
+<isize>::min_value();
-----------------
src/bounds.rs <isize as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<isize as bounds::Bounded>::max_value();
+crate::<isize as bounds::Bounded>::max_value();
+<isize>::max_value();
-----------------
src/bounds.rs <i8 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<i8 as bounds::Bounded>::min_value();
+crate::<i8 as bounds::Bounded>::min_value();
+<i8>::min_value();
-----------------
src/bounds.rs <i8 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<i8 as bounds::Bounded>::max_value();
+crate::<i8 as bounds::Bounded>::max_value();
+<i8>::max_value();
-----------------
src/bounds.rs <i16 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<i16 as bounds::Bounded>::min_value();
+crate::<i16 as bounds::Bounded>::min_value();
+<i16>::min_value();
-----------------
src/bounds.rs <i16 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<i16 as bounds::Bounded>::max_value();
+crate::<i16 as bounds::Bounded>::max_value();
+<i16>::max_value();
-----------------
src/bounds.rs <i32 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<i32 as bounds::Bounded>::min_value();
+crate::<i32 as bounds::Bounded>::min_value();
+<i32>::min_value();
-----------------
src/bounds.rs <i32 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<i32 as bounds::Bounded>::max_value();
+crate::<i32 as bounds::Bounded>::max_value();
+<i32>::max_value();
-----------------
src/bounds.rs <i64 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<i64 as bounds::Bounded>::min_value();
+crate::<i64 as bounds::Bounded>::min_value();
+<i64>::min_value();
-----------------
src/bounds.rs <i64 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<i64 as bounds::Bounded>::max_value();
+crate::<i64 as bounds::Bounded>::max_value();
+<i64>::max_value();
-----------------
src/bounds.rs <i128 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<i128 as bounds::Bounded>::min_value();
+crate::<i128 as bounds::Bounded>::min_value();
+<i128>::min_value();
-----------------
src/bounds.rs <i128 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<i128 as bounds::Bounded>::max_value();
+crate::<i128 as bounds::Bounded>::max_value();
+<i128>::max_value();
-----------------
src/bounds.rs <std::num::Wrapping<T> as bounds::Bounded>::min_value
deps:{"<std::num::Wrapping<T> as bounds::Bounded>::min_value":{"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingShr","sign::Unsigned","identities::One","Num","sign::Signed","cast::FromPrimitive","std::marker::Sized","cast::NumCast","ops::wrapping::WrappingShl","bounds::Bounded","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul"]}}
candidates:{"<std::num::Wrapping<T> as bounds::Bounded>::min_value":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<std::num::Wrapping<T> as bounds::Bounded>::min_value();
+crate::<std::num::Wrapping<T> as bounds::Bounded>::min_value();
+<std::num::Wrapping<T>>::min_value();
-----------------
src/bounds.rs <std::num::Wrapping<T> as bounds::Bounded>::max_value
deps:{"<std::num::Wrapping<T> as bounds::Bounded>::max_value":{"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingAdd","bounds::Bounded","ops::wrapping::WrappingShl","sign::Signed","std::marker::Sized","identities::One","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","Num","ops::wrapping::WrappingNeg","identities::Zero","sign::Unsigned","cast::NumCast","cast::FromPrimitive","cast::ToPrimitive"]}}
candidates:{"<std::num::Wrapping<T> as bounds::Bounded>::max_value":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<std::num::Wrapping<T> as bounds::Bounded>::max_value();
+crate::<std::num::Wrapping<T> as bounds::Bounded>::max_value();
+<std::num::Wrapping<T>>::max_value();
-----------------
src/bounds.rs <f32 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<f32 as bounds::Bounded>::min_value();
+crate::<f32 as bounds::Bounded>::min_value();
+<f32>::min_value();
-----------------
src/bounds.rs <f32 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<f32 as bounds::Bounded>::max_value();
+crate::<f32 as bounds::Bounded>::max_value();
+<f32>::max_value();
-----------------
src/bounds.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"A":["bounds::Bounded","std::marker::Sized"],"B":["bounds::Bounded","std::marker::Sized"],"C":["std::marker::Sized","bounds::Bounded"],"D":["std::marker::Sized","bounds::Bounded"],"E":["bounds::Bounded","std::marker::Sized"],"F":["bounds::Bounded","std::marker::Sized"],"G":["std::marker::Sized","bounds::Bounded"],"H":["bounds::Bounded","std::marker::Sized"],"I":["std::marker::Sized","bounds::Bounded"],"J":["bounds::Bounded","std::marker::Sized"],"K":["std::marker::Sized","bounds::Bounded"],"L":["std::marker::Sized","bounds::Bounded"],"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["bounds::Bounded","std::marker::Sized"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","Num","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","identities::One","std::marker::Sized","cast::NumCast","ops::wrapping::WrappingShl","ops::wrapping::WrappingMul","identities::Zero","cast::FromPrimitive","sign::Unsigned","bounds::Bounded","cast::ToPrimitive","sign::Signed"]}}
candidates:{"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"A":["std::num::Wrapping"],"B":["std::num::Wrapping"],"C":["std::num::Wrapping"],"D":["std::num::Wrapping"],"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"A":["std::marker::Sized","bounds::Bounded"],"B":["bounds::Bounded","std::marker::Sized"],"C":["std::marker::Sized","bounds::Bounded"],"D":["std::marker::Sized","bounds::Bounded"],"E":["bounds::Bounded","std::marker::Sized"],"F":["std::marker::Sized","bounds::Bounded"],"G":["std::marker::Sized","bounds::Bounded"],"H":["std::marker::Sized","bounds::Bounded"],"I":["std::marker::Sized","bounds::Bounded"],"J":["std::marker::Sized","bounds::Bounded"],"K":["bounds::Bounded","std::marker::Sized"],"L":["std::marker::Sized","bounds::Bounded"],"M":["bounds::Bounded","std::marker::Sized"],"N":["std::marker::Sized","bounds::Bounded"],"O":["bounds::Bounded","std::marker::Sized"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","cast::ToPrimitive","identities::One","cast::FromPrimitive","std::marker::Sized","identities::Zero","ops::wrapping::WrappingAdd","sign::Unsigned","Num","sign::Signed","bounds::Bounded","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","cast::NumCast","ops::wrapping::WrappingNeg"]}}
candidates:{"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"A":["std::num::Wrapping"],"B":["std::num::Wrapping"],"C":["std::num::Wrapping"],"D":["std::num::Wrapping"],"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"B":["std::marker::Sized","bounds::Bounded"],"C":["bounds::Bounded","std::marker::Sized"],"D":["std::marker::Sized","bounds::Bounded"],"E":["std::marker::Sized","bounds::Bounded"],"F":["std::marker::Sized","bounds::Bounded"],"G":["bounds::Bounded","std::marker::Sized"],"H":["std::marker::Sized","bounds::Bounded"],"I":["bounds::Bounded","std::marker::Sized"],"J":["bounds::Bounded","std::marker::Sized"],"K":["bounds::Bounded","std::marker::Sized"],"L":["std::marker::Sized","bounds::Bounded"],"M":["bounds::Bounded","std::marker::Sized"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","std::marker::Sized","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","cast::ToPrimitive","identities::Zero","ops::wrapping::WrappingNeg","bounds::Bounded","ops::wrapping::WrappingMul","sign::Unsigned","Num","ops::wrapping::WrappingShr","sign::Signed","cast::NumCast","identities::One","ops::wrapping::WrappingShl"]}}
candidates:{"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"B":["std::num::Wrapping"],"C":["std::num::Wrapping"],"D":["std::num::Wrapping"],"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"B":["std::marker::Sized","bounds::Bounded"],"C":["std::marker::Sized","bounds::Bounded"],"D":["bounds::Bounded","std::marker::Sized"],"E":["std::marker::Sized","bounds::Bounded"],"F":["std::marker::Sized","bounds::Bounded"],"G":["bounds::Bounded","std::marker::Sized"],"H":["std::marker::Sized","bounds::Bounded"],"I":["bounds::Bounded","std::marker::Sized"],"J":["bounds::Bounded","std::marker::Sized"],"K":["bounds::Bounded","std::marker::Sized"],"L":["std::marker::Sized","bounds::Bounded"],"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["std::marker::Sized","bounds::Bounded"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["Num","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","std::marker::Sized","sign::Unsigned","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","sign::Signed","ops::wrapping::WrappingSub","cast::NumCast","identities::One","bounds::Bounded","cast::ToPrimitive"]}}
candidates:{"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"B":["std::num::Wrapping"],"C":["std::num::Wrapping"],"D":["std::num::Wrapping"],"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"C":["std::marker::Sized","bounds::Bounded"],"D":["bounds::Bounded","std::marker::Sized"],"E":["bounds::Bounded","std::marker::Sized"],"F":["bounds::Bounded","std::marker::Sized"],"G":["std::marker::Sized","bounds::Bounded"],"H":["bounds::Bounded","std::marker::Sized"],"I":["std::marker::Sized","bounds::Bounded"],"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["bounds::Bounded","std::marker::Sized"],"M":["bounds::Bounded","std::marker::Sized"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingAdd","bounds::Bounded","ops::wrapping::WrappingShl","cast::NumCast","ops::wrapping::WrappingNeg","sign::Signed","identities::Zero","cast::FromPrimitive","ops::wrapping::WrappingShr","cast::ToPrimitive","Num","identities::One","ops::wrapping::WrappingMul","std::marker::Sized","sign::Unsigned","ops::wrapping::WrappingSub"]}}
candidates:{"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"C":["std::num::Wrapping"],"D":["std::num::Wrapping"],"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"C":["std::marker::Sized","bounds::Bounded"],"D":["bounds::Bounded","std::marker::Sized"],"E":["bounds::Bounded","std::marker::Sized"],"F":["bounds::Bounded","std::marker::Sized"],"G":["bounds::Bounded","std::marker::Sized"],"H":["std::marker::Sized","bounds::Bounded"],"I":["bounds::Bounded","std::marker::Sized"],"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["bounds::Bounded","std::marker::Sized"],"M":["bounds::Bounded","std::marker::Sized"],"N":["std::marker::Sized","bounds::Bounded"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["bounds::Bounded","std::marker::Sized"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::NumCast","sign::Unsigned","ops::wrapping::WrappingShl","Num","cast::ToPrimitive","ops::wrapping::WrappingNeg","bounds::Bounded","sign::Signed","identities::Zero","identities::One","ops::wrapping::WrappingMul","cast::FromPrimitive","std::marker::Sized","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub"]}}
candidates:{"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"C":["std::num::Wrapping"],"D":["std::num::Wrapping"],"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"D":["bounds::Bounded","std::marker::Sized"],"E":["std::marker::Sized","bounds::Bounded"],"F":["bounds::Bounded","std::marker::Sized"],"G":["bounds::Bounded","std::marker::Sized"],"H":["std::marker::Sized","bounds::Bounded"],"I":["std::marker::Sized","bounds::Bounded"],"J":["bounds::Bounded","std::marker::Sized"],"K":["bounds::Bounded","std::marker::Sized"],"L":["std::marker::Sized","bounds::Bounded"],"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["bounds::Bounded","std::marker::Sized"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["std::marker::Sized","cast::ToPrimitive","sign::Unsigned","ops::wrapping::WrappingSub","Num","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","sign::Signed","identities::Zero","cast::FromPrimitive","cast::NumCast","bounds::Bounded","ops::wrapping::WrappingNeg","identities::One","ops::wrapping::WrappingAdd"]}}
candidates:{"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"D":["std::num::Wrapping"],"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"D":["bounds::Bounded","std::marker::Sized"],"E":["bounds::Bounded","std::marker::Sized"],"F":["std::marker::Sized","bounds::Bounded"],"G":["std::marker::Sized","bounds::Bounded"],"H":["bounds::Bounded","std::marker::Sized"],"I":["std::marker::Sized","bounds::Bounded"],"J":["bounds::Bounded","std::marker::Sized"],"K":["std::marker::Sized","bounds::Bounded"],"L":["std::marker::Sized","bounds::Bounded"],"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["std::marker::Sized","bounds::Bounded"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","identities::One","cast::FromPrimitive","sign::Signed","ops::wrapping::WrappingShl","identities::Zero","sign::Unsigned","ops::wrapping::WrappingSub","ops::wrapping::WrappingShr","std::marker::Sized","cast::ToPrimitive","bounds::Bounded","Num","cast::NumCast","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul"]}}
candidates:{"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"D":["std::num::Wrapping"],"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"E":["std::marker::Sized","bounds::Bounded"],"F":["std::marker::Sized","bounds::Bounded"],"G":["std::marker::Sized","bounds::Bounded"],"H":["std::marker::Sized","bounds::Bounded"],"I":["bounds::Bounded","std::marker::Sized"],"J":["std::marker::Sized","bounds::Bounded"],"K":["bounds::Bounded","std::marker::Sized"],"L":["std::marker::Sized","bounds::Bounded"],"M":["bounds::Bounded","std::marker::Sized"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingSub","cast::ToPrimitive","ops::wrapping::WrappingAdd","sign::Signed","ops::wrapping::WrappingShl","ops::wrapping::WrappingNeg","identities::One","identities::Zero","bounds::Bounded","cast::NumCast","sign::Unsigned","cast::FromPrimitive","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","Num","std::marker::Sized"]}}
candidates:{"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"E":["std::marker::Sized","bounds::Bounded"],"F":["std::marker::Sized","bounds::Bounded"],"G":["std::marker::Sized","bounds::Bounded"],"H":["bounds::Bounded","std::marker::Sized"],"I":["bounds::Bounded","std::marker::Sized"],"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["bounds::Bounded","std::marker::Sized"],"M":["bounds::Bounded","std::marker::Sized"],"N":["bounds::Bounded","std::marker::Sized"],"O":["bounds::Bounded","std::marker::Sized"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["cast::ToPrimitive","std::marker::Sized","ops::wrapping::WrappingShr","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","Num","ops::wrapping::WrappingMul","sign::Signed","cast::FromPrimitive","cast::NumCast","ops::wrapping::WrappingShl","sign::Unsigned","ops::wrapping::WrappingAdd","identities::Zero","identities::One","bounds::Bounded"]}}
candidates:{"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"E":["std::num::Wrapping"],"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"F":["bounds::Bounded","std::marker::Sized"],"G":["std::marker::Sized","bounds::Bounded"],"H":["std::marker::Sized","bounds::Bounded"],"I":["bounds::Bounded","std::marker::Sized"],"J":["std::marker::Sized","bounds::Bounded"],"K":["bounds::Bounded","std::marker::Sized"],"L":["bounds::Bounded","std::marker::Sized"],"M":["std::marker::Sized","bounds::Bounded"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","sign::Unsigned","cast::NumCast","cast::ToPrimitive","sign::Signed","bounds::Bounded","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShr","std::marker::Sized","Num","ops::wrapping::WrappingSub","identities::One","identities::Zero","cast::FromPrimitive","ops::wrapping::WrappingShl"]}}
candidates:{"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"F":["std::marker::Sized","bounds::Bounded"],"G":["bounds::Bounded","std::marker::Sized"],"H":["bounds::Bounded","std::marker::Sized"],"I":["std::marker::Sized","bounds::Bounded"],"J":["bounds::Bounded","std::marker::Sized"],"K":["bounds::Bounded","std::marker::Sized"],"L":["std::marker::Sized","bounds::Bounded"],"M":["bounds::Bounded","std::marker::Sized"],"N":["std::marker::Sized","bounds::Bounded"],"O":["bounds::Bounded","std::marker::Sized"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingMul","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","std::marker::Sized","sign::Unsigned","ops::wrapping::WrappingNeg","identities::One","cast::NumCast","sign::Signed","Num","bounds::Bounded","identities::Zero","cast::FromPrimitive","cast::ToPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShr"]}}
candidates:{"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"F":["std::num::Wrapping"],"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"G":["bounds::Bounded","std::marker::Sized"],"H":["std::marker::Sized","bounds::Bounded"],"I":["std::marker::Sized","bounds::Bounded"],"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["std::marker::Sized","bounds::Bounded"],"M":["bounds::Bounded","std::marker::Sized"],"N":["bounds::Bounded","std::marker::Sized"],"O":["bounds::Bounded","std::marker::Sized"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["bounds::Bounded","std::marker::Sized"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["Num","identities::One","identities::Zero","bounds::Bounded","ops::wrapping::WrappingSub","cast::ToPrimitive","cast::NumCast","ops::wrapping::WrappingMul","std::marker::Sized","ops::wrapping::WrappingShr","cast::FromPrimitive","ops::wrapping::WrappingNeg","sign::Unsigned","ops::wrapping::WrappingShl","sign::Signed","ops::wrapping::WrappingAdd"]}}
candidates:{"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"G":["bounds::Bounded","std::marker::Sized"],"H":["bounds::Bounded","std::marker::Sized"],"I":["bounds::Bounded","std::marker::Sized"],"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["std::marker::Sized","bounds::Bounded"],"M":["bounds::Bounded","std::marker::Sized"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["bounds::Bounded","std::marker::Sized"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::Zero","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","sign::Unsigned","identities::One","Num","cast::FromPrimitive","bounds::Bounded","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","cast::ToPrimitive","cast::NumCast","ops::wrapping::WrappingAdd","sign::Signed","ops::wrapping::WrappingNeg","std::marker::Sized"]}}
candidates:{"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"G":["std::num::Wrapping"],"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"H":["bounds::Bounded","std::marker::Sized"],"I":["std::marker::Sized","bounds::Bounded"],"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["std::marker::Sized","bounds::Bounded"],"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["bounds::Bounded","std::marker::Sized"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["bounds::Bounded","std::marker::Sized"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingSub","sign::Signed","Num","bounds::Bounded","sign::Unsigned","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShl","cast::FromPrimitive","ops::wrapping::WrappingNeg","identities::One","identities::Zero","cast::ToPrimitive","std::marker::Sized","ops::wrapping::WrappingShr","cast::NumCast","ops::wrapping::WrappingMul"]}}
candidates:{"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(H, I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"H":["bounds::Bounded","std::marker::Sized"],"I":["std::marker::Sized","bounds::Bounded"],"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["bounds::Bounded","std::marker::Sized"],"M":["std::marker::Sized","bounds::Bounded"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["bounds::Bounded","std::marker::Sized"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["Num","identities::Zero","bounds::Bounded","cast::FromPrimitive","identities::One","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShr","cast::NumCast","ops::wrapping::WrappingMul","sign::Unsigned","cast::ToPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","std::marker::Sized","ops::wrapping::WrappingShl","sign::Signed"]}}
candidates:{"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"H":["std::num::Wrapping"],"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(H, I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"I":["std::marker::Sized","bounds::Bounded"],"J":["bounds::Bounded","std::marker::Sized"],"K":["std::marker::Sized","bounds::Bounded"],"L":["bounds::Bounded","std::marker::Sized"],"M":["std::marker::Sized","bounds::Bounded"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","std::marker::Sized","identities::Zero","Num","cast::ToPrimitive","sign::Unsigned","ops::wrapping::WrappingShr","identities::One","cast::FromPrimitive","ops::wrapping::WrappingSub","bounds::Bounded","ops::wrapping::WrappingNeg","sign::Signed","ops::wrapping::WrappingMul","cast::NumCast","ops::wrapping::WrappingAdd"]}}
candidates:{"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(I, J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"I":["std::marker::Sized","bounds::Bounded"],"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["bounds::Bounded","std::marker::Sized"],"M":["bounds::Bounded","std::marker::Sized"],"N":["bounds::Bounded","std::marker::Sized"],"O":["bounds::Bounded","std::marker::Sized"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::NumCast","ops::wrapping::WrappingMul","bounds::Bounded","std::marker::Sized","sign::Unsigned","Num","cast::ToPrimitive","sign::Signed","identities::One","ops::wrapping::WrappingShr","cast::FromPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","ops::wrapping::WrappingAdd","identities::Zero"]}}
candidates:{"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"I":["std::num::Wrapping"],"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(I, J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"J":["std::marker::Sized","bounds::Bounded"],"K":["bounds::Bounded","std::marker::Sized"],"L":["bounds::Bounded","std::marker::Sized"],"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["bounds::Bounded","std::marker::Sized"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::Zero","cast::FromPrimitive","sign::Unsigned","cast::ToPrimitive","ops::wrapping::WrappingShr","sign::Signed","identities::One","bounds::Bounded","std::marker::Sized","Num","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","cast::NumCast","ops::wrapping::WrappingNeg","ops::wrapping::WrappingAdd"]}}
candidates:{"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(J, K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"J":["std::marker::Sized","bounds::Bounded"],"K":["std::marker::Sized","bounds::Bounded"],"L":["bounds::Bounded","std::marker::Sized"],"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["std::marker::Sized","bounds::Bounded"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingMul","cast::NumCast","identities::One","cast::ToPrimitive","sign::Unsigned","identities::Zero","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","ops::wrapping::WrappingAdd","Num","ops::wrapping::WrappingNeg","cast::FromPrimitive","bounds::Bounded","std::marker::Sized","sign::Signed","ops::wrapping::WrappingShl"]}}
candidates:{"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"J":["std::num::Wrapping"],"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(J, K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"K":["std::marker::Sized","bounds::Bounded"],"L":["bounds::Bounded","std::marker::Sized"],"M":["bounds::Bounded","std::marker::Sized"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","ops::wrapping::WrappingNeg","cast::NumCast","ops::wrapping::WrappingMul","Num","ops::wrapping::WrappingSub","cast::ToPrimitive","sign::Signed","bounds::Bounded","identities::Zero","ops::wrapping::WrappingAdd","sign::Unsigned","identities::One","std::marker::Sized","cast::FromPrimitive"]}}
candidates:{"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(K, L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"K":["bounds::Bounded","std::marker::Sized"],"L":["std::marker::Sized","bounds::Bounded"],"M":["bounds::Bounded","std::marker::Sized"],"N":["std::marker::Sized","bounds::Bounded"],"O":["bounds::Bounded","std::marker::Sized"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","std::marker::Sized","cast::ToPrimitive","bounds::Bounded","sign::Unsigned","identities::One","ops::wrapping::WrappingMul","sign::Signed","cast::NumCast","Num","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingNeg"]}}
candidates:{"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"K":["std::num::Wrapping"],"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(K, L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"L":["bounds::Bounded","std::marker::Sized"],"M":["std::marker::Sized","bounds::Bounded"],"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["Num","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","std::marker::Sized","identities::One","sign::Unsigned","ops::wrapping::WrappingShl","bounds::Bounded","identities::Zero","sign::Signed","cast::NumCast","ops::wrapping::WrappingShr","ops::wrapping::WrappingMul","cast::FromPrimitive","cast::ToPrimitive","ops::wrapping::WrappingAdd"]}}
candidates:{"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(L, M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"L":["std::marker::Sized","bounds::Bounded"],"M":["std::marker::Sized","bounds::Bounded"],"N":["bounds::Bounded","std::marker::Sized"],"O":["bounds::Bounded","std::marker::Sized"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["std::marker::Sized","bounds::Bounded"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingMul","ops::wrapping::WrappingSub","Num","sign::Unsigned","ops::wrapping::WrappingShl","bounds::Bounded","std::marker::Sized","cast::ToPrimitive","identities::Zero","cast::FromPrimitive","ops::wrapping::WrappingShr","identities::One","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","cast::NumCast","sign::Signed"]}}
candidates:{"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"L":["std::num::Wrapping"],"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(L, M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["std::marker::Sized","bounds::Bounded"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","std::marker::Sized","cast::NumCast","identities::One","ops::wrapping::WrappingShr","cast::ToPrimitive","ops::wrapping::WrappingAdd","identities::Zero","Num","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","sign::Signed","sign::Unsigned","cast::FromPrimitive","bounds::Bounded","ops::wrapping::WrappingMul"]}}
candidates:{"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(M, N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"M":["std::marker::Sized","bounds::Bounded"],"N":["std::marker::Sized","bounds::Bounded"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","std::marker::Sized","ops::wrapping::WrappingSub","sign::Signed","identities::Zero","ops::wrapping::WrappingMul","cast::ToPrimitive","bounds::Bounded","ops::wrapping::WrappingNeg","identities::One","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","Num","cast::NumCast","sign::Unsigned"]}}
candidates:{"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"M":["std::num::Wrapping"],"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(M, N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(N, O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"N":["bounds::Bounded","std::marker::Sized"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::ToPrimitive","Num","sign::Signed","cast::NumCast","bounds::Bounded","cast::FromPrimitive","sign::Unsigned","std::marker::Sized","ops::wrapping::WrappingSub","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","identities::Zero","ops::wrapping::WrappingShl","identities::One","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShr"]}}
candidates:{"<(N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(N, O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(N, O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(N, O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"N":["std::marker::Sized","bounds::Bounded"],"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["identities::Zero","cast::NumCast","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","identities::One","std::marker::Sized","Num","cast::FromPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","bounds::Bounded","cast::ToPrimitive","ops::wrapping::WrappingAdd","sign::Unsigned","ops::wrapping::WrappingMul","sign::Signed"]}}
candidates:{"<(N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"N":["std::num::Wrapping"],"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(N, O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(N, O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(O, P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"O":["std::marker::Sized","bounds::Bounded"],"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","Num","std::marker::Sized","cast::NumCast","ops::wrapping::WrappingShr","bounds::Bounded","cast::ToPrimitive","sign::Signed","sign::Unsigned","ops::wrapping::WrappingSub","identities::One","ops::wrapping::WrappingShl"]}}
candidates:{"<(O, P, Q, R, S, T) as bounds::Bounded>::min_value":{"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(O, P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(O, P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(O, P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"O":["bounds::Bounded","std::marker::Sized"],"P":["bounds::Bounded","std::marker::Sized"],"Q":["bounds::Bounded","std::marker::Sized"],"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["cast::ToPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","std::marker::Sized","ops::wrapping::WrappingNeg","bounds::Bounded","cast::FromPrimitive","sign::Signed","sign::Unsigned","identities::Zero","ops::wrapping::WrappingShr","Num","ops::wrapping::WrappingShl","ops::wrapping::WrappingMul","cast::NumCast","identities::One"]}}
candidates:{"<(O, P, Q, R, S, T) as bounds::Bounded>::max_value":{"O":["std::num::Wrapping"],"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(O, P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(O, P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(P, Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(P, Q, R, S, T) as bounds::Bounded>::min_value":{"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","ops::wrapping::WrappingShr","ops::wrapping::WrappingMul","bounds::Bounded","cast::NumCast","std::marker::Sized","ops::wrapping::WrappingSub","sign::Unsigned","ops::wrapping::WrappingAdd","Num","cast::ToPrimitive","cast::FromPrimitive","ops::wrapping::WrappingShl","identities::Zero","sign::Signed","identities::One"]}}
candidates:{"<(P, Q, R, S, T) as bounds::Bounded>::min_value":{"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(P, Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(P, Q, R, S, T) as bounds::Bounded>::min_value();
+<(P, Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(P, Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(P, Q, R, S, T) as bounds::Bounded>::max_value":{"P":["std::marker::Sized","bounds::Bounded"],"Q":["std::marker::Sized","bounds::Bounded"],"R":["bounds::Bounded","std::marker::Sized"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::One","ops::wrapping::WrappingMul","sign::Signed","ops::wrapping::WrappingShl","identities::Zero","cast::FromPrimitive","bounds::Bounded","cast::ToPrimitive","Num","ops::wrapping::WrappingAdd","sign::Unsigned","ops::wrapping::WrappingShr","std::marker::Sized","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","cast::NumCast"]}}
candidates:{"<(P, Q, R, S, T) as bounds::Bounded>::max_value":{"P":["std::num::Wrapping"],"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(P, Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(P, Q, R, S, T) as bounds::Bounded>::max_value();
+<(P, Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(Q, R, S, T) as bounds::Bounded>::min_value
deps:{"<(Q, R, S, T) as bounds::Bounded>::min_value":{"Q":["bounds::Bounded","std::marker::Sized"],"R":["bounds::Bounded","std::marker::Sized"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["identities::One","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShr","bounds::Bounded","ops::wrapping::WrappingSub","std::marker::Sized","sign::Unsigned","ops::wrapping::WrappingShl","Num","cast::ToPrimitive","ops::wrapping::WrappingMul","cast::NumCast","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingAdd","sign::Signed"]}}
candidates:{"<(Q, R, S, T) as bounds::Bounded>::min_value":{"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(Q, R, S, T) as bounds::Bounded>::min_value();
+crate::<(Q, R, S, T) as bounds::Bounded>::min_value();
+<(Q, R, S, T)>::min_value();
-----------------
src/bounds.rs <(Q, R, S, T) as bounds::Bounded>::max_value
deps:{"<(Q, R, S, T) as bounds::Bounded>::max_value":{"Q":["std::marker::Sized","bounds::Bounded"],"R":["std::marker::Sized","bounds::Bounded"],"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","cast::FromPrimitive","ops::wrapping::WrappingNeg","sign::Signed","ops::wrapping::WrappingMul","Num","identities::One","sign::Unsigned","identities::Zero","ops::wrapping::WrappingShr","std::marker::Sized","cast::NumCast","ops::wrapping::WrappingSub","bounds::Bounded","ops::wrapping::WrappingAdd","cast::ToPrimitive"]}}
candidates:{"<(Q, R, S, T) as bounds::Bounded>::max_value":{"Q":["std::num::Wrapping"],"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(Q, R, S, T) as bounds::Bounded>::max_value();
+crate::<(Q, R, S, T) as bounds::Bounded>::max_value();
+<(Q, R, S, T)>::max_value();
-----------------
src/bounds.rs <(R, S, T) as bounds::Bounded>::min_value
deps:{"<(R, S, T) as bounds::Bounded>::min_value":{"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","sign::Unsigned","ops::wrapping::WrappingSub","Num","std::marker::Sized","identities::Zero","bounds::Bounded","identities::One","sign::Signed","cast::FromPrimitive","cast::NumCast","ops::wrapping::WrappingAdd","cast::ToPrimitive"]}}
candidates:{"<(R, S, T) as bounds::Bounded>::min_value":{"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(R, S, T) as bounds::Bounded>::min_value();
+crate::<(R, S, T) as bounds::Bounded>::min_value();
+<(R, S, T)>::min_value();
-----------------
src/bounds.rs <(R, S, T) as bounds::Bounded>::max_value
deps:{"<(R, S, T) as bounds::Bounded>::max_value":{"R":["std::marker::Sized","bounds::Bounded"],"S":["bounds::Bounded","std::marker::Sized"],"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingSub","identities::Zero","cast::ToPrimitive","cast::FromPrimitive","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","sign::Signed","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","bounds::Bounded","identities::One","ops::wrapping::WrappingAdd","sign::Unsigned","cast::NumCast","std::marker::Sized","Num"]}}
candidates:{"<(R, S, T) as bounds::Bounded>::max_value":{"R":["std::num::Wrapping"],"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(R, S, T) as bounds::Bounded>::max_value();
+crate::<(R, S, T) as bounds::Bounded>::max_value();
+<(R, S, T)>::max_value();
-----------------
src/bounds.rs <(S, T) as bounds::Bounded>::min_value
deps:{"<(S, T) as bounds::Bounded>::min_value":{"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","sign::Signed","ops::wrapping::WrappingMul","identities::One","ops::wrapping::WrappingShl","std::marker::Sized","ops::wrapping::WrappingSub","sign::Unsigned","Num","cast::NumCast","cast::FromPrimitive","cast::ToPrimitive","ops::wrapping::WrappingShr","identities::Zero","bounds::Bounded"]}}
candidates:{"<(S, T) as bounds::Bounded>::min_value":{"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(S, T) as bounds::Bounded>::min_value();
+crate::<(S, T) as bounds::Bounded>::min_value();
+<(S, T)>::min_value();
-----------------
src/bounds.rs <(S, T) as bounds::Bounded>::max_value
deps:{"<(S, T) as bounds::Bounded>::max_value":{"S":["std::marker::Sized","bounds::Bounded"],"T":["std::marker::Sized","bounds::Bounded"]},"std::num::Wrapping":{"T":["identities::Zero","std::marker::Sized","cast::FromPrimitive","Num","sign::Signed","ops::wrapping::WrappingNeg","bounds::Bounded","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","cast::ToPrimitive","ops::wrapping::WrappingMul","cast::NumCast","identities::One","ops::wrapping::WrappingSub","sign::Unsigned"]}}
candidates:{"<(S, T) as bounds::Bounded>::max_value":{"S":["std::num::Wrapping"],"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(S, T) as bounds::Bounded>::max_value();
+crate::<(S, T) as bounds::Bounded>::max_value();
+<(S, T)>::max_value();
-----------------
src/bounds.rs <(T,) as bounds::Bounded>::min_value
deps:{"<(T,) as bounds::Bounded>::min_value":{"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","cast::NumCast","bounds::Bounded","cast::FromPrimitive","ops::wrapping::WrappingAdd","identities::One","ops::wrapping::WrappingShr","std::marker::Sized","cast::ToPrimitive","sign::Signed","identities::Zero","ops::wrapping::WrappingNeg","sign::Unsigned","Num","ops::wrapping::WrappingSub"]}}
candidates:{"<(T,) as bounds::Bounded>::min_value":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(T,) as bounds::Bounded>::min_value();
+crate::<(T,) as bounds::Bounded>::min_value();
+<(T,)>::min_value();
-----------------
src/bounds.rs <(T,) as bounds::Bounded>::max_value
deps:{"<(T,) as bounds::Bounded>::max_value":{"T":["bounds::Bounded","std::marker::Sized"]},"std::num::Wrapping":{"T":["bounds::Bounded","identities::Zero","identities::One","ops::wrapping::WrappingShr","sign::Signed","cast::FromPrimitive","cast::NumCast","sign::Unsigned","Num","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","ops::wrapping::WrappingNeg","cast::ToPrimitive","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","std::marker::Sized"]}}
candidates:{"<(T,) as bounds::Bounded>::max_value":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<(T,) as bounds::Bounded>::max_value();
+crate::<(T,) as bounds::Bounded>::max_value();
+<(T,)>::max_value();
-----------------
src/bounds.rs <() as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<() as bounds::Bounded>::min_value();
+crate::<() as bounds::Bounded>::min_value();
+<()>::min_value();
-----------------
src/bounds.rs <() as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<() as bounds::Bounded>::max_value();
+crate::<() as bounds::Bounded>::max_value();
+<()>::max_value();
-----------------
src/bounds.rs <f64 as bounds::Bounded>::min_value
deps:{}
candidates:{}
+<f64 as bounds::Bounded>::min_value();
+crate::<f64 as bounds::Bounded>::min_value();
+<f64>::min_value();
-----------------
src/bounds.rs <f64 as bounds::Bounded>::max_value
deps:{}
candidates:{}
+<f64 as bounds::Bounded>::max_value();
+crate::<f64 as bounds::Bounded>::max_value();
+<f64>::max_value();
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_isize();
+<isize as cast::ToPrimitive>::to_isize(p0);
+crate::<isize as cast::ToPrimitive>::to_isize(p0);
+<isize>::to_isize(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_i8();
+<isize as cast::ToPrimitive>::to_i8(p0);
+crate::<isize as cast::ToPrimitive>::to_i8(p0);
+<isize>::to_i8(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_i16();
+<isize as cast::ToPrimitive>::to_i16(p0);
+crate::<isize as cast::ToPrimitive>::to_i16(p0);
+<isize>::to_i16(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_i32();
+<isize as cast::ToPrimitive>::to_i32(p0);
+crate::<isize as cast::ToPrimitive>::to_i32(p0);
+<isize>::to_i32(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_i64();
+<isize as cast::ToPrimitive>::to_i64(p0);
+crate::<isize as cast::ToPrimitive>::to_i64(p0);
+<isize>::to_i64(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_i128();
+<isize as cast::ToPrimitive>::to_i128(p0);
+crate::<isize as cast::ToPrimitive>::to_i128(p0);
+<isize>::to_i128(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_usize();
+<isize as cast::ToPrimitive>::to_usize(p0);
+crate::<isize as cast::ToPrimitive>::to_usize(p0);
+<isize>::to_usize(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_u8();
+<isize as cast::ToPrimitive>::to_u8(p0);
+crate::<isize as cast::ToPrimitive>::to_u8(p0);
+<isize>::to_u8(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_u16();
+<isize as cast::ToPrimitive>::to_u16(p0);
+crate::<isize as cast::ToPrimitive>::to_u16(p0);
+<isize>::to_u16(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_u32();
+<isize as cast::ToPrimitive>::to_u32(p0);
+crate::<isize as cast::ToPrimitive>::to_u32(p0);
+<isize>::to_u32(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_u64();
+<isize as cast::ToPrimitive>::to_u64(p0);
+crate::<isize as cast::ToPrimitive>::to_u64(p0);
+<isize>::to_u64(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_u128();
+<isize as cast::ToPrimitive>::to_u128(p0);
+crate::<isize as cast::ToPrimitive>::to_u128(p0);
+<isize>::to_u128(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_f32();
+<isize as cast::ToPrimitive>::to_f32(p0);
+crate::<isize as cast::ToPrimitive>::to_f32(p0);
+<isize>::to_f32(p0);
-----------------
src/cast.rs <isize as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.to_f64();
+<isize as cast::ToPrimitive>::to_f64(p0);
+crate::<isize as cast::ToPrimitive>::to_f64(p0);
+<isize>::to_f64(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_isize();
+<i8 as cast::ToPrimitive>::to_isize(p0);
+crate::<i8 as cast::ToPrimitive>::to_isize(p0);
+<i8>::to_isize(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_i8();
+<i8 as cast::ToPrimitive>::to_i8(p0);
+crate::<i8 as cast::ToPrimitive>::to_i8(p0);
+<i8>::to_i8(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_i16();
+<i8 as cast::ToPrimitive>::to_i16(p0);
+crate::<i8 as cast::ToPrimitive>::to_i16(p0);
+<i8>::to_i16(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_i32();
+<i8 as cast::ToPrimitive>::to_i32(p0);
+crate::<i8 as cast::ToPrimitive>::to_i32(p0);
+<i8>::to_i32(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_i64();
+<i8 as cast::ToPrimitive>::to_i64(p0);
+crate::<i8 as cast::ToPrimitive>::to_i64(p0);
+<i8>::to_i64(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_i128();
+<i8 as cast::ToPrimitive>::to_i128(p0);
+crate::<i8 as cast::ToPrimitive>::to_i128(p0);
+<i8>::to_i128(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_usize();
+<i8 as cast::ToPrimitive>::to_usize(p0);
+crate::<i8 as cast::ToPrimitive>::to_usize(p0);
+<i8>::to_usize(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_u8();
+<i8 as cast::ToPrimitive>::to_u8(p0);
+crate::<i8 as cast::ToPrimitive>::to_u8(p0);
+<i8>::to_u8(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_u16();
+<i8 as cast::ToPrimitive>::to_u16(p0);
+crate::<i8 as cast::ToPrimitive>::to_u16(p0);
+<i8>::to_u16(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_u32();
+<i8 as cast::ToPrimitive>::to_u32(p0);
+crate::<i8 as cast::ToPrimitive>::to_u32(p0);
+<i8>::to_u32(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_u64();
+<i8 as cast::ToPrimitive>::to_u64(p0);
+crate::<i8 as cast::ToPrimitive>::to_u64(p0);
+<i8>::to_u64(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_u128();
+<i8 as cast::ToPrimitive>::to_u128(p0);
+crate::<i8 as cast::ToPrimitive>::to_u128(p0);
+<i8>::to_u128(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_f32();
+<i8 as cast::ToPrimitive>::to_f32(p0);
+crate::<i8 as cast::ToPrimitive>::to_f32(p0);
+<i8>::to_f32(p0);
-----------------
src/cast.rs <i8 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.to_f64();
+<i8 as cast::ToPrimitive>::to_f64(p0);
+crate::<i8 as cast::ToPrimitive>::to_f64(p0);
+<i8>::to_f64(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_isize();
+<i16 as cast::ToPrimitive>::to_isize(p0);
+crate::<i16 as cast::ToPrimitive>::to_isize(p0);
+<i16>::to_isize(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_i8();
+<i16 as cast::ToPrimitive>::to_i8(p0);
+crate::<i16 as cast::ToPrimitive>::to_i8(p0);
+<i16>::to_i8(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_i16();
+<i16 as cast::ToPrimitive>::to_i16(p0);
+crate::<i16 as cast::ToPrimitive>::to_i16(p0);
+<i16>::to_i16(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_i32();
+<i16 as cast::ToPrimitive>::to_i32(p0);
+crate::<i16 as cast::ToPrimitive>::to_i32(p0);
+<i16>::to_i32(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_i64();
+<i16 as cast::ToPrimitive>::to_i64(p0);
+crate::<i16 as cast::ToPrimitive>::to_i64(p0);
+<i16>::to_i64(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_i128();
+<i16 as cast::ToPrimitive>::to_i128(p0);
+crate::<i16 as cast::ToPrimitive>::to_i128(p0);
+<i16>::to_i128(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_usize();
+<i16 as cast::ToPrimitive>::to_usize(p0);
+crate::<i16 as cast::ToPrimitive>::to_usize(p0);
+<i16>::to_usize(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_u8();
+<i16 as cast::ToPrimitive>::to_u8(p0);
+crate::<i16 as cast::ToPrimitive>::to_u8(p0);
+<i16>::to_u8(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_u16();
+<i16 as cast::ToPrimitive>::to_u16(p0);
+crate::<i16 as cast::ToPrimitive>::to_u16(p0);
+<i16>::to_u16(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_u32();
+<i16 as cast::ToPrimitive>::to_u32(p0);
+crate::<i16 as cast::ToPrimitive>::to_u32(p0);
+<i16>::to_u32(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_u64();
+<i16 as cast::ToPrimitive>::to_u64(p0);
+crate::<i16 as cast::ToPrimitive>::to_u64(p0);
+<i16>::to_u64(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_u128();
+<i16 as cast::ToPrimitive>::to_u128(p0);
+crate::<i16 as cast::ToPrimitive>::to_u128(p0);
+<i16>::to_u128(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_f32();
+<i16 as cast::ToPrimitive>::to_f32(p0);
+crate::<i16 as cast::ToPrimitive>::to_f32(p0);
+<i16>::to_f32(p0);
-----------------
src/cast.rs <i16 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.to_f64();
+<i16 as cast::ToPrimitive>::to_f64(p0);
+crate::<i16 as cast::ToPrimitive>::to_f64(p0);
+<i16>::to_f64(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_isize();
+<i32 as cast::ToPrimitive>::to_isize(p0);
+crate::<i32 as cast::ToPrimitive>::to_isize(p0);
+<i32>::to_isize(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_i8();
+<i32 as cast::ToPrimitive>::to_i8(p0);
+crate::<i32 as cast::ToPrimitive>::to_i8(p0);
+<i32>::to_i8(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_i16();
+<i32 as cast::ToPrimitive>::to_i16(p0);
+crate::<i32 as cast::ToPrimitive>::to_i16(p0);
+<i32>::to_i16(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_i32();
+<i32 as cast::ToPrimitive>::to_i32(p0);
+crate::<i32 as cast::ToPrimitive>::to_i32(p0);
+<i32>::to_i32(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_i64();
+<i32 as cast::ToPrimitive>::to_i64(p0);
+crate::<i32 as cast::ToPrimitive>::to_i64(p0);
+<i32>::to_i64(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_i128();
+<i32 as cast::ToPrimitive>::to_i128(p0);
+crate::<i32 as cast::ToPrimitive>::to_i128(p0);
+<i32>::to_i128(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_usize();
+<i32 as cast::ToPrimitive>::to_usize(p0);
+crate::<i32 as cast::ToPrimitive>::to_usize(p0);
+<i32>::to_usize(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_u8();
+<i32 as cast::ToPrimitive>::to_u8(p0);
+crate::<i32 as cast::ToPrimitive>::to_u8(p0);
+<i32>::to_u8(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_u16();
+<i32 as cast::ToPrimitive>::to_u16(p0);
+crate::<i32 as cast::ToPrimitive>::to_u16(p0);
+<i32>::to_u16(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_u32();
+<i32 as cast::ToPrimitive>::to_u32(p0);
+crate::<i32 as cast::ToPrimitive>::to_u32(p0);
+<i32>::to_u32(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_u64();
+<i32 as cast::ToPrimitive>::to_u64(p0);
+crate::<i32 as cast::ToPrimitive>::to_u64(p0);
+<i32>::to_u64(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_u128();
+<i32 as cast::ToPrimitive>::to_u128(p0);
+crate::<i32 as cast::ToPrimitive>::to_u128(p0);
+<i32>::to_u128(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_f32();
+<i32 as cast::ToPrimitive>::to_f32(p0);
+crate::<i32 as cast::ToPrimitive>::to_f32(p0);
+<i32>::to_f32(p0);
-----------------
src/cast.rs <i32 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.to_f64();
+<i32 as cast::ToPrimitive>::to_f64(p0);
+crate::<i32 as cast::ToPrimitive>::to_f64(p0);
+<i32>::to_f64(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_isize();
+<i64 as cast::ToPrimitive>::to_isize(p0);
+crate::<i64 as cast::ToPrimitive>::to_isize(p0);
+<i64>::to_isize(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_i8();
+<i64 as cast::ToPrimitive>::to_i8(p0);
+crate::<i64 as cast::ToPrimitive>::to_i8(p0);
+<i64>::to_i8(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_i16();
+<i64 as cast::ToPrimitive>::to_i16(p0);
+crate::<i64 as cast::ToPrimitive>::to_i16(p0);
+<i64>::to_i16(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_i32();
+<i64 as cast::ToPrimitive>::to_i32(p0);
+crate::<i64 as cast::ToPrimitive>::to_i32(p0);
+<i64>::to_i32(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_i64();
+<i64 as cast::ToPrimitive>::to_i64(p0);
+crate::<i64 as cast::ToPrimitive>::to_i64(p0);
+<i64>::to_i64(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_i128();
+<i64 as cast::ToPrimitive>::to_i128(p0);
+crate::<i64 as cast::ToPrimitive>::to_i128(p0);
+<i64>::to_i128(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_usize();
+<i64 as cast::ToPrimitive>::to_usize(p0);
+crate::<i64 as cast::ToPrimitive>::to_usize(p0);
+<i64>::to_usize(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_u8();
+<i64 as cast::ToPrimitive>::to_u8(p0);
+crate::<i64 as cast::ToPrimitive>::to_u8(p0);
+<i64>::to_u8(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_u16();
+<i64 as cast::ToPrimitive>::to_u16(p0);
+crate::<i64 as cast::ToPrimitive>::to_u16(p0);
+<i64>::to_u16(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_u32();
+<i64 as cast::ToPrimitive>::to_u32(p0);
+crate::<i64 as cast::ToPrimitive>::to_u32(p0);
+<i64>::to_u32(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_u64();
+<i64 as cast::ToPrimitive>::to_u64(p0);
+crate::<i64 as cast::ToPrimitive>::to_u64(p0);
+<i64>::to_u64(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_u128();
+<i64 as cast::ToPrimitive>::to_u128(p0);
+crate::<i64 as cast::ToPrimitive>::to_u128(p0);
+<i64>::to_u128(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_f32();
+<i64 as cast::ToPrimitive>::to_f32(p0);
+crate::<i64 as cast::ToPrimitive>::to_f32(p0);
+<i64>::to_f32(p0);
-----------------
src/cast.rs <i64 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_f64();
+<i64 as cast::ToPrimitive>::to_f64(p0);
+crate::<i64 as cast::ToPrimitive>::to_f64(p0);
+<i64>::to_f64(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_isize();
+<i128 as cast::ToPrimitive>::to_isize(p0);
+crate::<i128 as cast::ToPrimitive>::to_isize(p0);
+<i128>::to_isize(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_i8();
+<i128 as cast::ToPrimitive>::to_i8(p0);
+crate::<i128 as cast::ToPrimitive>::to_i8(p0);
+<i128>::to_i8(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_i16();
+<i128 as cast::ToPrimitive>::to_i16(p0);
+crate::<i128 as cast::ToPrimitive>::to_i16(p0);
+<i128>::to_i16(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_i32();
+<i128 as cast::ToPrimitive>::to_i32(p0);
+crate::<i128 as cast::ToPrimitive>::to_i32(p0);
+<i128>::to_i32(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_i64();
+<i128 as cast::ToPrimitive>::to_i64(p0);
+crate::<i128 as cast::ToPrimitive>::to_i64(p0);
+<i128>::to_i64(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_i128();
+<i128 as cast::ToPrimitive>::to_i128(p0);
+crate::<i128 as cast::ToPrimitive>::to_i128(p0);
+<i128>::to_i128(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_usize();
+<i128 as cast::ToPrimitive>::to_usize(p0);
+crate::<i128 as cast::ToPrimitive>::to_usize(p0);
+<i128>::to_usize(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_u8();
+<i128 as cast::ToPrimitive>::to_u8(p0);
+crate::<i128 as cast::ToPrimitive>::to_u8(p0);
+<i128>::to_u8(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_u16();
+<i128 as cast::ToPrimitive>::to_u16(p0);
+crate::<i128 as cast::ToPrimitive>::to_u16(p0);
+<i128>::to_u16(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_u32();
+<i128 as cast::ToPrimitive>::to_u32(p0);
+crate::<i128 as cast::ToPrimitive>::to_u32(p0);
+<i128>::to_u32(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_u64();
+<i128 as cast::ToPrimitive>::to_u64(p0);
+crate::<i128 as cast::ToPrimitive>::to_u64(p0);
+<i128>::to_u64(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_u128();
+<i128 as cast::ToPrimitive>::to_u128(p0);
+crate::<i128 as cast::ToPrimitive>::to_u128(p0);
+<i128>::to_u128(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_f32();
+<i128 as cast::ToPrimitive>::to_f32(p0);
+crate::<i128 as cast::ToPrimitive>::to_f32(p0);
+<i128>::to_f32(p0);
-----------------
src/cast.rs <i128 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.to_f64();
+<i128 as cast::ToPrimitive>::to_f64(p0);
+crate::<i128 as cast::ToPrimitive>::to_f64(p0);
+<i128>::to_f64(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_isize();
+<usize as cast::ToPrimitive>::to_isize(p0);
+crate::<usize as cast::ToPrimitive>::to_isize(p0);
+<usize>::to_isize(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_i8();
+<usize as cast::ToPrimitive>::to_i8(p0);
+crate::<usize as cast::ToPrimitive>::to_i8(p0);
+<usize>::to_i8(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_i16();
+<usize as cast::ToPrimitive>::to_i16(p0);
+crate::<usize as cast::ToPrimitive>::to_i16(p0);
+<usize>::to_i16(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_i32();
+<usize as cast::ToPrimitive>::to_i32(p0);
+crate::<usize as cast::ToPrimitive>::to_i32(p0);
+<usize>::to_i32(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_i64();
+<usize as cast::ToPrimitive>::to_i64(p0);
+crate::<usize as cast::ToPrimitive>::to_i64(p0);
+<usize>::to_i64(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_i128();
+<usize as cast::ToPrimitive>::to_i128(p0);
+crate::<usize as cast::ToPrimitive>::to_i128(p0);
+<usize>::to_i128(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_usize();
+<usize as cast::ToPrimitive>::to_usize(p0);
+crate::<usize as cast::ToPrimitive>::to_usize(p0);
+<usize>::to_usize(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_u8();
+<usize as cast::ToPrimitive>::to_u8(p0);
+crate::<usize as cast::ToPrimitive>::to_u8(p0);
+<usize>::to_u8(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_u16();
+<usize as cast::ToPrimitive>::to_u16(p0);
+crate::<usize as cast::ToPrimitive>::to_u16(p0);
+<usize>::to_u16(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_u32();
+<usize as cast::ToPrimitive>::to_u32(p0);
+crate::<usize as cast::ToPrimitive>::to_u32(p0);
+<usize>::to_u32(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_u64();
+<usize as cast::ToPrimitive>::to_u64(p0);
+crate::<usize as cast::ToPrimitive>::to_u64(p0);
+<usize>::to_u64(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_u128();
+<usize as cast::ToPrimitive>::to_u128(p0);
+crate::<usize as cast::ToPrimitive>::to_u128(p0);
+<usize>::to_u128(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_f32();
+<usize as cast::ToPrimitive>::to_f32(p0);
+crate::<usize as cast::ToPrimitive>::to_f32(p0);
+<usize>::to_f32(p0);
-----------------
src/cast.rs <usize as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_f64();
+<usize as cast::ToPrimitive>::to_f64(p0);
+crate::<usize as cast::ToPrimitive>::to_f64(p0);
+<usize>::to_f64(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_isize();
+<u8 as cast::ToPrimitive>::to_isize(p0);
+crate::<u8 as cast::ToPrimitive>::to_isize(p0);
+<u8>::to_isize(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_i8();
+<u8 as cast::ToPrimitive>::to_i8(p0);
+crate::<u8 as cast::ToPrimitive>::to_i8(p0);
+<u8>::to_i8(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_i16();
+<u8 as cast::ToPrimitive>::to_i16(p0);
+crate::<u8 as cast::ToPrimitive>::to_i16(p0);
+<u8>::to_i16(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_i32();
+<u8 as cast::ToPrimitive>::to_i32(p0);
+crate::<u8 as cast::ToPrimitive>::to_i32(p0);
+<u8>::to_i32(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_i64();
+<u8 as cast::ToPrimitive>::to_i64(p0);
+crate::<u8 as cast::ToPrimitive>::to_i64(p0);
+<u8>::to_i64(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_i128();
+<u8 as cast::ToPrimitive>::to_i128(p0);
+crate::<u8 as cast::ToPrimitive>::to_i128(p0);
+<u8>::to_i128(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_usize();
+<u8 as cast::ToPrimitive>::to_usize(p0);
+crate::<u8 as cast::ToPrimitive>::to_usize(p0);
+<u8>::to_usize(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_u8();
+<u8 as cast::ToPrimitive>::to_u8(p0);
+crate::<u8 as cast::ToPrimitive>::to_u8(p0);
+<u8>::to_u8(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_u16();
+<u8 as cast::ToPrimitive>::to_u16(p0);
+crate::<u8 as cast::ToPrimitive>::to_u16(p0);
+<u8>::to_u16(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_u32();
+<u8 as cast::ToPrimitive>::to_u32(p0);
+crate::<u8 as cast::ToPrimitive>::to_u32(p0);
+<u8>::to_u32(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_u64();
+<u8 as cast::ToPrimitive>::to_u64(p0);
+crate::<u8 as cast::ToPrimitive>::to_u64(p0);
+<u8>::to_u64(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_u128();
+<u8 as cast::ToPrimitive>::to_u128(p0);
+crate::<u8 as cast::ToPrimitive>::to_u128(p0);
+<u8>::to_u128(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_f32();
+<u8 as cast::ToPrimitive>::to_f32(p0);
+crate::<u8 as cast::ToPrimitive>::to_f32(p0);
+<u8>::to_f32(p0);
-----------------
src/cast.rs <u8 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_f64();
+<u8 as cast::ToPrimitive>::to_f64(p0);
+crate::<u8 as cast::ToPrimitive>::to_f64(p0);
+<u8>::to_f64(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_isize();
+<u16 as cast::ToPrimitive>::to_isize(p0);
+crate::<u16 as cast::ToPrimitive>::to_isize(p0);
+<u16>::to_isize(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_i8();
+<u16 as cast::ToPrimitive>::to_i8(p0);
+crate::<u16 as cast::ToPrimitive>::to_i8(p0);
+<u16>::to_i8(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_i16();
+<u16 as cast::ToPrimitive>::to_i16(p0);
+crate::<u16 as cast::ToPrimitive>::to_i16(p0);
+<u16>::to_i16(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_i32();
+<u16 as cast::ToPrimitive>::to_i32(p0);
+crate::<u16 as cast::ToPrimitive>::to_i32(p0);
+<u16>::to_i32(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_i64();
+<u16 as cast::ToPrimitive>::to_i64(p0);
+crate::<u16 as cast::ToPrimitive>::to_i64(p0);
+<u16>::to_i64(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_i128();
+<u16 as cast::ToPrimitive>::to_i128(p0);
+crate::<u16 as cast::ToPrimitive>::to_i128(p0);
+<u16>::to_i128(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_usize();
+<u16 as cast::ToPrimitive>::to_usize(p0);
+crate::<u16 as cast::ToPrimitive>::to_usize(p0);
+<u16>::to_usize(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_u8();
+<u16 as cast::ToPrimitive>::to_u8(p0);
+crate::<u16 as cast::ToPrimitive>::to_u8(p0);
+<u16>::to_u8(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_u16();
+<u16 as cast::ToPrimitive>::to_u16(p0);
+crate::<u16 as cast::ToPrimitive>::to_u16(p0);
+<u16>::to_u16(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_u32();
+<u16 as cast::ToPrimitive>::to_u32(p0);
+crate::<u16 as cast::ToPrimitive>::to_u32(p0);
+<u16>::to_u32(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_u64();
+<u16 as cast::ToPrimitive>::to_u64(p0);
+crate::<u16 as cast::ToPrimitive>::to_u64(p0);
+<u16>::to_u64(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_u128();
+<u16 as cast::ToPrimitive>::to_u128(p0);
+crate::<u16 as cast::ToPrimitive>::to_u128(p0);
+<u16>::to_u128(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_f32();
+<u16 as cast::ToPrimitive>::to_f32(p0);
+crate::<u16 as cast::ToPrimitive>::to_f32(p0);
+<u16>::to_f32(p0);
-----------------
src/cast.rs <u16 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_f64();
+<u16 as cast::ToPrimitive>::to_f64(p0);
+crate::<u16 as cast::ToPrimitive>::to_f64(p0);
+<u16>::to_f64(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_isize();
+<u32 as cast::ToPrimitive>::to_isize(p0);
+crate::<u32 as cast::ToPrimitive>::to_isize(p0);
+<u32>::to_isize(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_i8();
+<u32 as cast::ToPrimitive>::to_i8(p0);
+crate::<u32 as cast::ToPrimitive>::to_i8(p0);
+<u32>::to_i8(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_i16();
+<u32 as cast::ToPrimitive>::to_i16(p0);
+crate::<u32 as cast::ToPrimitive>::to_i16(p0);
+<u32>::to_i16(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_i32();
+<u32 as cast::ToPrimitive>::to_i32(p0);
+crate::<u32 as cast::ToPrimitive>::to_i32(p0);
+<u32>::to_i32(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_i64();
+<u32 as cast::ToPrimitive>::to_i64(p0);
+crate::<u32 as cast::ToPrimitive>::to_i64(p0);
+<u32>::to_i64(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_i128();
+<u32 as cast::ToPrimitive>::to_i128(p0);
+crate::<u32 as cast::ToPrimitive>::to_i128(p0);
+<u32>::to_i128(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_usize();
+<u32 as cast::ToPrimitive>::to_usize(p0);
+crate::<u32 as cast::ToPrimitive>::to_usize(p0);
+<u32>::to_usize(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_u8();
+<u32 as cast::ToPrimitive>::to_u8(p0);
+crate::<u32 as cast::ToPrimitive>::to_u8(p0);
+<u32>::to_u8(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_u16();
+<u32 as cast::ToPrimitive>::to_u16(p0);
+crate::<u32 as cast::ToPrimitive>::to_u16(p0);
+<u32>::to_u16(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_u32();
+<u32 as cast::ToPrimitive>::to_u32(p0);
+crate::<u32 as cast::ToPrimitive>::to_u32(p0);
+<u32>::to_u32(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_u64();
+<u32 as cast::ToPrimitive>::to_u64(p0);
+crate::<u32 as cast::ToPrimitive>::to_u64(p0);
+<u32>::to_u64(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_u128();
+<u32 as cast::ToPrimitive>::to_u128(p0);
+crate::<u32 as cast::ToPrimitive>::to_u128(p0);
+<u32>::to_u128(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_f32();
+<u32 as cast::ToPrimitive>::to_f32(p0);
+crate::<u32 as cast::ToPrimitive>::to_f32(p0);
+<u32>::to_f32(p0);
-----------------
src/cast.rs <u32 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_f64();
+<u32 as cast::ToPrimitive>::to_f64(p0);
+crate::<u32 as cast::ToPrimitive>::to_f64(p0);
+<u32>::to_f64(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_isize();
+<u64 as cast::ToPrimitive>::to_isize(p0);
+crate::<u64 as cast::ToPrimitive>::to_isize(p0);
+<u64>::to_isize(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_i8();
+<u64 as cast::ToPrimitive>::to_i8(p0);
+crate::<u64 as cast::ToPrimitive>::to_i8(p0);
+<u64>::to_i8(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_i16();
+<u64 as cast::ToPrimitive>::to_i16(p0);
+crate::<u64 as cast::ToPrimitive>::to_i16(p0);
+<u64>::to_i16(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_i32();
+<u64 as cast::ToPrimitive>::to_i32(p0);
+crate::<u64 as cast::ToPrimitive>::to_i32(p0);
+<u64>::to_i32(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_i64();
+<u64 as cast::ToPrimitive>::to_i64(p0);
+crate::<u64 as cast::ToPrimitive>::to_i64(p0);
+<u64>::to_i64(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_i128();
+<u64 as cast::ToPrimitive>::to_i128(p0);
+crate::<u64 as cast::ToPrimitive>::to_i128(p0);
+<u64>::to_i128(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_usize();
+<u64 as cast::ToPrimitive>::to_usize(p0);
+crate::<u64 as cast::ToPrimitive>::to_usize(p0);
+<u64>::to_usize(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_u8();
+<u64 as cast::ToPrimitive>::to_u8(p0);
+crate::<u64 as cast::ToPrimitive>::to_u8(p0);
+<u64>::to_u8(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_u16();
+<u64 as cast::ToPrimitive>::to_u16(p0);
+crate::<u64 as cast::ToPrimitive>::to_u16(p0);
+<u64>::to_u16(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_u32();
+<u64 as cast::ToPrimitive>::to_u32(p0);
+crate::<u64 as cast::ToPrimitive>::to_u32(p0);
+<u64>::to_u32(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_u64();
+<u64 as cast::ToPrimitive>::to_u64(p0);
+crate::<u64 as cast::ToPrimitive>::to_u64(p0);
+<u64>::to_u64(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_u128();
+<u64 as cast::ToPrimitive>::to_u128(p0);
+crate::<u64 as cast::ToPrimitive>::to_u128(p0);
+<u64>::to_u128(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_f32();
+<u64 as cast::ToPrimitive>::to_f32(p0);
+crate::<u64 as cast::ToPrimitive>::to_f32(p0);
+<u64>::to_f32(p0);
-----------------
src/cast.rs <u64 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_f64();
+<u64 as cast::ToPrimitive>::to_f64(p0);
+crate::<u64 as cast::ToPrimitive>::to_f64(p0);
+<u64>::to_f64(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_isize();
+<u128 as cast::ToPrimitive>::to_isize(p0);
+crate::<u128 as cast::ToPrimitive>::to_isize(p0);
+<u128>::to_isize(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_i8();
+<u128 as cast::ToPrimitive>::to_i8(p0);
+crate::<u128 as cast::ToPrimitive>::to_i8(p0);
+<u128>::to_i8(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_i16();
+<u128 as cast::ToPrimitive>::to_i16(p0);
+crate::<u128 as cast::ToPrimitive>::to_i16(p0);
+<u128>::to_i16(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_i32();
+<u128 as cast::ToPrimitive>::to_i32(p0);
+crate::<u128 as cast::ToPrimitive>::to_i32(p0);
+<u128>::to_i32(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_i64();
+<u128 as cast::ToPrimitive>::to_i64(p0);
+crate::<u128 as cast::ToPrimitive>::to_i64(p0);
+<u128>::to_i64(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_i128();
+<u128 as cast::ToPrimitive>::to_i128(p0);
+crate::<u128 as cast::ToPrimitive>::to_i128(p0);
+<u128>::to_i128(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_usize();
+<u128 as cast::ToPrimitive>::to_usize(p0);
+crate::<u128 as cast::ToPrimitive>::to_usize(p0);
+<u128>::to_usize(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_u8();
+<u128 as cast::ToPrimitive>::to_u8(p0);
+crate::<u128 as cast::ToPrimitive>::to_u8(p0);
+<u128>::to_u8(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_u16();
+<u128 as cast::ToPrimitive>::to_u16(p0);
+crate::<u128 as cast::ToPrimitive>::to_u16(p0);
+<u128>::to_u16(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_u32();
+<u128 as cast::ToPrimitive>::to_u32(p0);
+crate::<u128 as cast::ToPrimitive>::to_u32(p0);
+<u128>::to_u32(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_u64();
+<u128 as cast::ToPrimitive>::to_u64(p0);
+crate::<u128 as cast::ToPrimitive>::to_u64(p0);
+<u128>::to_u64(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_u128();
+<u128 as cast::ToPrimitive>::to_u128(p0);
+crate::<u128 as cast::ToPrimitive>::to_u128(p0);
+<u128>::to_u128(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_f32();
+<u128 as cast::ToPrimitive>::to_f32(p0);
+crate::<u128 as cast::ToPrimitive>::to_f32(p0);
+<u128>::to_f32(p0);
-----------------
src/cast.rs <u128 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.to_f64();
+<u128 as cast::ToPrimitive>::to_f64(p0);
+crate::<u128 as cast::ToPrimitive>::to_f64(p0);
+<u128>::to_f64(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_isize();
+<f32 as cast::ToPrimitive>::to_isize(p0);
+crate::<f32 as cast::ToPrimitive>::to_isize(p0);
+<f32>::to_isize(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_i8();
+<f32 as cast::ToPrimitive>::to_i8(p0);
+crate::<f32 as cast::ToPrimitive>::to_i8(p0);
+<f32>::to_i8(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_i16();
+<f32 as cast::ToPrimitive>::to_i16(p0);
+crate::<f32 as cast::ToPrimitive>::to_i16(p0);
+<f32>::to_i16(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_i32();
+<f32 as cast::ToPrimitive>::to_i32(p0);
+crate::<f32 as cast::ToPrimitive>::to_i32(p0);
+<f32>::to_i32(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_i64();
+<f32 as cast::ToPrimitive>::to_i64(p0);
+crate::<f32 as cast::ToPrimitive>::to_i64(p0);
+<f32>::to_i64(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_i128();
+<f32 as cast::ToPrimitive>::to_i128(p0);
+crate::<f32 as cast::ToPrimitive>::to_i128(p0);
+<f32>::to_i128(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_usize();
+<f32 as cast::ToPrimitive>::to_usize(p0);
+crate::<f32 as cast::ToPrimitive>::to_usize(p0);
+<f32>::to_usize(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_u8();
+<f32 as cast::ToPrimitive>::to_u8(p0);
+crate::<f32 as cast::ToPrimitive>::to_u8(p0);
+<f32>::to_u8(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_u16();
+<f32 as cast::ToPrimitive>::to_u16(p0);
+crate::<f32 as cast::ToPrimitive>::to_u16(p0);
+<f32>::to_u16(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_u32();
+<f32 as cast::ToPrimitive>::to_u32(p0);
+crate::<f32 as cast::ToPrimitive>::to_u32(p0);
+<f32>::to_u32(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_u64();
+<f32 as cast::ToPrimitive>::to_u64(p0);
+crate::<f32 as cast::ToPrimitive>::to_u64(p0);
+<f32>::to_u64(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_u128();
+<f32 as cast::ToPrimitive>::to_u128(p0);
+crate::<f32 as cast::ToPrimitive>::to_u128(p0);
+<f32>::to_u128(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_f32();
+<f32 as cast::ToPrimitive>::to_f32(p0);
+crate::<f32 as cast::ToPrimitive>::to_f32(p0);
+<f32>::to_f32(p0);
-----------------
src/cast.rs <f32 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.to_f64();
+<f32 as cast::ToPrimitive>::to_f64(p0);
+crate::<f32 as cast::ToPrimitive>::to_f64(p0);
+<f32>::to_f64(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_isize
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_isize();
+<f64 as cast::ToPrimitive>::to_isize(p0);
+crate::<f64 as cast::ToPrimitive>::to_isize(p0);
+<f64>::to_isize(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_i8
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_i8();
+<f64 as cast::ToPrimitive>::to_i8(p0);
+crate::<f64 as cast::ToPrimitive>::to_i8(p0);
+<f64>::to_i8(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_i16
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_i16();
+<f64 as cast::ToPrimitive>::to_i16(p0);
+crate::<f64 as cast::ToPrimitive>::to_i16(p0);
+<f64>::to_i16(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_i32
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_i32();
+<f64 as cast::ToPrimitive>::to_i32(p0);
+crate::<f64 as cast::ToPrimitive>::to_i32(p0);
+<f64>::to_i32(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_i64
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_i64();
+<f64 as cast::ToPrimitive>::to_i64(p0);
+crate::<f64 as cast::ToPrimitive>::to_i64(p0);
+<f64>::to_i64(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_i128
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_i128();
+<f64 as cast::ToPrimitive>::to_i128(p0);
+crate::<f64 as cast::ToPrimitive>::to_i128(p0);
+<f64>::to_i128(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_usize();
+<f64 as cast::ToPrimitive>::to_usize(p0);
+crate::<f64 as cast::ToPrimitive>::to_usize(p0);
+<f64>::to_usize(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_u8
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_u8();
+<f64 as cast::ToPrimitive>::to_u8(p0);
+crate::<f64 as cast::ToPrimitive>::to_u8(p0);
+<f64>::to_u8(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_u16
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_u16();
+<f64 as cast::ToPrimitive>::to_u16(p0);
+crate::<f64 as cast::ToPrimitive>::to_u16(p0);
+<f64>::to_u16(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_u32
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_u32();
+<f64 as cast::ToPrimitive>::to_u32(p0);
+crate::<f64 as cast::ToPrimitive>::to_u32(p0);
+<f64>::to_u32(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_u64
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_u64();
+<f64 as cast::ToPrimitive>::to_u64(p0);
+crate::<f64 as cast::ToPrimitive>::to_u64(p0);
+<f64>::to_u64(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_u128
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_u128();
+<f64 as cast::ToPrimitive>::to_u128(p0);
+crate::<f64 as cast::ToPrimitive>::to_u128(p0);
+<f64>::to_u128(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_f32
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_f32();
+<f64 as cast::ToPrimitive>::to_f32(p0);
+crate::<f64 as cast::ToPrimitive>::to_f32(p0);
+<f64>::to_f32(p0);
-----------------
src/cast.rs <f64 as cast::ToPrimitive>::to_f64
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_f64();
+<f64 as cast::ToPrimitive>::to_f64(p0);
+crate::<f64 as cast::ToPrimitive>::to_f64(p0);
+<f64>::to_f64(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<isize as cast::FromPrimitive>::from_isize(p0);
+crate::<isize as cast::FromPrimitive>::from_isize(p0);
+<isize>::from_isize(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<isize as cast::FromPrimitive>::from_i8(p0);
+crate::<isize as cast::FromPrimitive>::from_i8(p0);
+<isize>::from_i8(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<isize as cast::FromPrimitive>::from_i16(p0);
+crate::<isize as cast::FromPrimitive>::from_i16(p0);
+<isize>::from_i16(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<isize as cast::FromPrimitive>::from_i32(p0);
+crate::<isize as cast::FromPrimitive>::from_i32(p0);
+<isize>::from_i32(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<isize as cast::FromPrimitive>::from_i64(p0);
+crate::<isize as cast::FromPrimitive>::from_i64(p0);
+<isize>::from_i64(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<isize as cast::FromPrimitive>::from_i128(p0);
+crate::<isize as cast::FromPrimitive>::from_i128(p0);
+<isize>::from_i128(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<isize as cast::FromPrimitive>::from_usize(p0);
+crate::<isize as cast::FromPrimitive>::from_usize(p0);
+<isize>::from_usize(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<isize as cast::FromPrimitive>::from_u8(p0);
+crate::<isize as cast::FromPrimitive>::from_u8(p0);
+<isize>::from_u8(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<isize as cast::FromPrimitive>::from_u16(p0);
+crate::<isize as cast::FromPrimitive>::from_u16(p0);
+<isize>::from_u16(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<isize as cast::FromPrimitive>::from_u32(p0);
+crate::<isize as cast::FromPrimitive>::from_u32(p0);
+<isize>::from_u32(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<isize as cast::FromPrimitive>::from_u64(p0);
+crate::<isize as cast::FromPrimitive>::from_u64(p0);
+<isize>::from_u64(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<isize as cast::FromPrimitive>::from_u128(p0);
+crate::<isize as cast::FromPrimitive>::from_u128(p0);
+<isize>::from_u128(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<isize as cast::FromPrimitive>::from_f32(p0);
+crate::<isize as cast::FromPrimitive>::from_f32(p0);
+<isize>::from_f32(p0);
-----------------
src/cast.rs <isize as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<isize as cast::FromPrimitive>::from_f64(p0);
+crate::<isize as cast::FromPrimitive>::from_f64(p0);
+<isize>::from_f64(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<i8 as cast::FromPrimitive>::from_isize(p0);
+crate::<i8 as cast::FromPrimitive>::from_isize(p0);
+<i8>::from_isize(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<i8 as cast::FromPrimitive>::from_i8(p0);
+crate::<i8 as cast::FromPrimitive>::from_i8(p0);
+<i8>::from_i8(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<i8 as cast::FromPrimitive>::from_i16(p0);
+crate::<i8 as cast::FromPrimitive>::from_i16(p0);
+<i8>::from_i16(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<i8 as cast::FromPrimitive>::from_i32(p0);
+crate::<i8 as cast::FromPrimitive>::from_i32(p0);
+<i8>::from_i32(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<i8 as cast::FromPrimitive>::from_i64(p0);
+crate::<i8 as cast::FromPrimitive>::from_i64(p0);
+<i8>::from_i64(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<i8 as cast::FromPrimitive>::from_i128(p0);
+crate::<i8 as cast::FromPrimitive>::from_i128(p0);
+<i8>::from_i128(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<i8 as cast::FromPrimitive>::from_usize(p0);
+crate::<i8 as cast::FromPrimitive>::from_usize(p0);
+<i8>::from_usize(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<i8 as cast::FromPrimitive>::from_u8(p0);
+crate::<i8 as cast::FromPrimitive>::from_u8(p0);
+<i8>::from_u8(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<i8 as cast::FromPrimitive>::from_u16(p0);
+crate::<i8 as cast::FromPrimitive>::from_u16(p0);
+<i8>::from_u16(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<i8 as cast::FromPrimitive>::from_u32(p0);
+crate::<i8 as cast::FromPrimitive>::from_u32(p0);
+<i8>::from_u32(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<i8 as cast::FromPrimitive>::from_u64(p0);
+crate::<i8 as cast::FromPrimitive>::from_u64(p0);
+<i8>::from_u64(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<i8 as cast::FromPrimitive>::from_u128(p0);
+crate::<i8 as cast::FromPrimitive>::from_u128(p0);
+<i8>::from_u128(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<i8 as cast::FromPrimitive>::from_f32(p0);
+crate::<i8 as cast::FromPrimitive>::from_f32(p0);
+<i8>::from_f32(p0);
-----------------
src/cast.rs <i8 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<i8 as cast::FromPrimitive>::from_f64(p0);
+crate::<i8 as cast::FromPrimitive>::from_f64(p0);
+<i8>::from_f64(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<i16 as cast::FromPrimitive>::from_isize(p0);
+crate::<i16 as cast::FromPrimitive>::from_isize(p0);
+<i16>::from_isize(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<i16 as cast::FromPrimitive>::from_i8(p0);
+crate::<i16 as cast::FromPrimitive>::from_i8(p0);
+<i16>::from_i8(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<i16 as cast::FromPrimitive>::from_i16(p0);
+crate::<i16 as cast::FromPrimitive>::from_i16(p0);
+<i16>::from_i16(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<i16 as cast::FromPrimitive>::from_i32(p0);
+crate::<i16 as cast::FromPrimitive>::from_i32(p0);
+<i16>::from_i32(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<i16 as cast::FromPrimitive>::from_i64(p0);
+crate::<i16 as cast::FromPrimitive>::from_i64(p0);
+<i16>::from_i64(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<i16 as cast::FromPrimitive>::from_i128(p0);
+crate::<i16 as cast::FromPrimitive>::from_i128(p0);
+<i16>::from_i128(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<i16 as cast::FromPrimitive>::from_usize(p0);
+crate::<i16 as cast::FromPrimitive>::from_usize(p0);
+<i16>::from_usize(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<i16 as cast::FromPrimitive>::from_u8(p0);
+crate::<i16 as cast::FromPrimitive>::from_u8(p0);
+<i16>::from_u8(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<i16 as cast::FromPrimitive>::from_u16(p0);
+crate::<i16 as cast::FromPrimitive>::from_u16(p0);
+<i16>::from_u16(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<i16 as cast::FromPrimitive>::from_u32(p0);
+crate::<i16 as cast::FromPrimitive>::from_u32(p0);
+<i16>::from_u32(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<i16 as cast::FromPrimitive>::from_u64(p0);
+crate::<i16 as cast::FromPrimitive>::from_u64(p0);
+<i16>::from_u64(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<i16 as cast::FromPrimitive>::from_u128(p0);
+crate::<i16 as cast::FromPrimitive>::from_u128(p0);
+<i16>::from_u128(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<i16 as cast::FromPrimitive>::from_f32(p0);
+crate::<i16 as cast::FromPrimitive>::from_f32(p0);
+<i16>::from_f32(p0);
-----------------
src/cast.rs <i16 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<i16 as cast::FromPrimitive>::from_f64(p0);
+crate::<i16 as cast::FromPrimitive>::from_f64(p0);
+<i16>::from_f64(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<i32 as cast::FromPrimitive>::from_isize(p0);
+crate::<i32 as cast::FromPrimitive>::from_isize(p0);
+<i32>::from_isize(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<i32 as cast::FromPrimitive>::from_i8(p0);
+crate::<i32 as cast::FromPrimitive>::from_i8(p0);
+<i32>::from_i8(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<i32 as cast::FromPrimitive>::from_i16(p0);
+crate::<i32 as cast::FromPrimitive>::from_i16(p0);
+<i32>::from_i16(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<i32 as cast::FromPrimitive>::from_i32(p0);
+crate::<i32 as cast::FromPrimitive>::from_i32(p0);
+<i32>::from_i32(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<i32 as cast::FromPrimitive>::from_i64(p0);
+crate::<i32 as cast::FromPrimitive>::from_i64(p0);
+<i32>::from_i64(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<i32 as cast::FromPrimitive>::from_i128(p0);
+crate::<i32 as cast::FromPrimitive>::from_i128(p0);
+<i32>::from_i128(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<i32 as cast::FromPrimitive>::from_usize(p0);
+crate::<i32 as cast::FromPrimitive>::from_usize(p0);
+<i32>::from_usize(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<i32 as cast::FromPrimitive>::from_u8(p0);
+crate::<i32 as cast::FromPrimitive>::from_u8(p0);
+<i32>::from_u8(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<i32 as cast::FromPrimitive>::from_u16(p0);
+crate::<i32 as cast::FromPrimitive>::from_u16(p0);
+<i32>::from_u16(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<i32 as cast::FromPrimitive>::from_u32(p0);
+crate::<i32 as cast::FromPrimitive>::from_u32(p0);
+<i32>::from_u32(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<i32 as cast::FromPrimitive>::from_u64(p0);
+crate::<i32 as cast::FromPrimitive>::from_u64(p0);
+<i32>::from_u64(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<i32 as cast::FromPrimitive>::from_u128(p0);
+crate::<i32 as cast::FromPrimitive>::from_u128(p0);
+<i32>::from_u128(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<i32 as cast::FromPrimitive>::from_f32(p0);
+crate::<i32 as cast::FromPrimitive>::from_f32(p0);
+<i32>::from_f32(p0);
-----------------
src/cast.rs <i32 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<i32 as cast::FromPrimitive>::from_f64(p0);
+crate::<i32 as cast::FromPrimitive>::from_f64(p0);
+<i32>::from_f64(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<i64 as cast::FromPrimitive>::from_isize(p0);
+crate::<i64 as cast::FromPrimitive>::from_isize(p0);
+<i64>::from_isize(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<i64 as cast::FromPrimitive>::from_i8(p0);
+crate::<i64 as cast::FromPrimitive>::from_i8(p0);
+<i64>::from_i8(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<i64 as cast::FromPrimitive>::from_i16(p0);
+crate::<i64 as cast::FromPrimitive>::from_i16(p0);
+<i64>::from_i16(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<i64 as cast::FromPrimitive>::from_i32(p0);
+crate::<i64 as cast::FromPrimitive>::from_i32(p0);
+<i64>::from_i32(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<i64 as cast::FromPrimitive>::from_i64(p0);
+crate::<i64 as cast::FromPrimitive>::from_i64(p0);
+<i64>::from_i64(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<i64 as cast::FromPrimitive>::from_i128(p0);
+crate::<i64 as cast::FromPrimitive>::from_i128(p0);
+<i64>::from_i128(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<i64 as cast::FromPrimitive>::from_usize(p0);
+crate::<i64 as cast::FromPrimitive>::from_usize(p0);
+<i64>::from_usize(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<i64 as cast::FromPrimitive>::from_u8(p0);
+crate::<i64 as cast::FromPrimitive>::from_u8(p0);
+<i64>::from_u8(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<i64 as cast::FromPrimitive>::from_u16(p0);
+crate::<i64 as cast::FromPrimitive>::from_u16(p0);
+<i64>::from_u16(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<i64 as cast::FromPrimitive>::from_u32(p0);
+crate::<i64 as cast::FromPrimitive>::from_u32(p0);
+<i64>::from_u32(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<i64 as cast::FromPrimitive>::from_u64(p0);
+crate::<i64 as cast::FromPrimitive>::from_u64(p0);
+<i64>::from_u64(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<i64 as cast::FromPrimitive>::from_u128(p0);
+crate::<i64 as cast::FromPrimitive>::from_u128(p0);
+<i64>::from_u128(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<i64 as cast::FromPrimitive>::from_f32(p0);
+crate::<i64 as cast::FromPrimitive>::from_f32(p0);
+<i64>::from_f32(p0);
-----------------
src/cast.rs <i64 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<i64 as cast::FromPrimitive>::from_f64(p0);
+crate::<i64 as cast::FromPrimitive>::from_f64(p0);
+<i64>::from_f64(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<i128 as cast::FromPrimitive>::from_isize(p0);
+crate::<i128 as cast::FromPrimitive>::from_isize(p0);
+<i128>::from_isize(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<i128 as cast::FromPrimitive>::from_i8(p0);
+crate::<i128 as cast::FromPrimitive>::from_i8(p0);
+<i128>::from_i8(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<i128 as cast::FromPrimitive>::from_i16(p0);
+crate::<i128 as cast::FromPrimitive>::from_i16(p0);
+<i128>::from_i16(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<i128 as cast::FromPrimitive>::from_i32(p0);
+crate::<i128 as cast::FromPrimitive>::from_i32(p0);
+<i128>::from_i32(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<i128 as cast::FromPrimitive>::from_i64(p0);
+crate::<i128 as cast::FromPrimitive>::from_i64(p0);
+<i128>::from_i64(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<i128 as cast::FromPrimitive>::from_i128(p0);
+crate::<i128 as cast::FromPrimitive>::from_i128(p0);
+<i128>::from_i128(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<i128 as cast::FromPrimitive>::from_usize(p0);
+crate::<i128 as cast::FromPrimitive>::from_usize(p0);
+<i128>::from_usize(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<i128 as cast::FromPrimitive>::from_u8(p0);
+crate::<i128 as cast::FromPrimitive>::from_u8(p0);
+<i128>::from_u8(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<i128 as cast::FromPrimitive>::from_u16(p0);
+crate::<i128 as cast::FromPrimitive>::from_u16(p0);
+<i128>::from_u16(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<i128 as cast::FromPrimitive>::from_u32(p0);
+crate::<i128 as cast::FromPrimitive>::from_u32(p0);
+<i128>::from_u32(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<i128 as cast::FromPrimitive>::from_u64(p0);
+crate::<i128 as cast::FromPrimitive>::from_u64(p0);
+<i128>::from_u64(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<i128 as cast::FromPrimitive>::from_u128(p0);
+crate::<i128 as cast::FromPrimitive>::from_u128(p0);
+<i128>::from_u128(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<i128 as cast::FromPrimitive>::from_f32(p0);
+crate::<i128 as cast::FromPrimitive>::from_f32(p0);
+<i128>::from_f32(p0);
-----------------
src/cast.rs <i128 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<i128 as cast::FromPrimitive>::from_f64(p0);
+crate::<i128 as cast::FromPrimitive>::from_f64(p0);
+<i128>::from_f64(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<usize as cast::FromPrimitive>::from_isize(p0);
+crate::<usize as cast::FromPrimitive>::from_isize(p0);
+<usize>::from_isize(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<usize as cast::FromPrimitive>::from_i8(p0);
+crate::<usize as cast::FromPrimitive>::from_i8(p0);
+<usize>::from_i8(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<usize as cast::FromPrimitive>::from_i16(p0);
+crate::<usize as cast::FromPrimitive>::from_i16(p0);
+<usize>::from_i16(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<usize as cast::FromPrimitive>::from_i32(p0);
+crate::<usize as cast::FromPrimitive>::from_i32(p0);
+<usize>::from_i32(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<usize as cast::FromPrimitive>::from_i64(p0);
+crate::<usize as cast::FromPrimitive>::from_i64(p0);
+<usize>::from_i64(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<usize as cast::FromPrimitive>::from_i128(p0);
+crate::<usize as cast::FromPrimitive>::from_i128(p0);
+<usize>::from_i128(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<usize as cast::FromPrimitive>::from_usize(p0);
+crate::<usize as cast::FromPrimitive>::from_usize(p0);
+<usize>::from_usize(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<usize as cast::FromPrimitive>::from_u8(p0);
+crate::<usize as cast::FromPrimitive>::from_u8(p0);
+<usize>::from_u8(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<usize as cast::FromPrimitive>::from_u16(p0);
+crate::<usize as cast::FromPrimitive>::from_u16(p0);
+<usize>::from_u16(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<usize as cast::FromPrimitive>::from_u32(p0);
+crate::<usize as cast::FromPrimitive>::from_u32(p0);
+<usize>::from_u32(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<usize as cast::FromPrimitive>::from_u64(p0);
+crate::<usize as cast::FromPrimitive>::from_u64(p0);
+<usize>::from_u64(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<usize as cast::FromPrimitive>::from_u128(p0);
+crate::<usize as cast::FromPrimitive>::from_u128(p0);
+<usize>::from_u128(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<usize as cast::FromPrimitive>::from_f32(p0);
+crate::<usize as cast::FromPrimitive>::from_f32(p0);
+<usize>::from_f32(p0);
-----------------
src/cast.rs <usize as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<usize as cast::FromPrimitive>::from_f64(p0);
+crate::<usize as cast::FromPrimitive>::from_f64(p0);
+<usize>::from_f64(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<u8 as cast::FromPrimitive>::from_isize(p0);
+crate::<u8 as cast::FromPrimitive>::from_isize(p0);
+<u8>::from_isize(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<u8 as cast::FromPrimitive>::from_i8(p0);
+crate::<u8 as cast::FromPrimitive>::from_i8(p0);
+<u8>::from_i8(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<u8 as cast::FromPrimitive>::from_i16(p0);
+crate::<u8 as cast::FromPrimitive>::from_i16(p0);
+<u8>::from_i16(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<u8 as cast::FromPrimitive>::from_i32(p0);
+crate::<u8 as cast::FromPrimitive>::from_i32(p0);
+<u8>::from_i32(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<u8 as cast::FromPrimitive>::from_i64(p0);
+crate::<u8 as cast::FromPrimitive>::from_i64(p0);
+<u8>::from_i64(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<u8 as cast::FromPrimitive>::from_i128(p0);
+crate::<u8 as cast::FromPrimitive>::from_i128(p0);
+<u8>::from_i128(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<u8 as cast::FromPrimitive>::from_usize(p0);
+crate::<u8 as cast::FromPrimitive>::from_usize(p0);
+<u8>::from_usize(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<u8 as cast::FromPrimitive>::from_u8(p0);
+crate::<u8 as cast::FromPrimitive>::from_u8(p0);
+<u8>::from_u8(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<u8 as cast::FromPrimitive>::from_u16(p0);
+crate::<u8 as cast::FromPrimitive>::from_u16(p0);
+<u8>::from_u16(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<u8 as cast::FromPrimitive>::from_u32(p0);
+crate::<u8 as cast::FromPrimitive>::from_u32(p0);
+<u8>::from_u32(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<u8 as cast::FromPrimitive>::from_u64(p0);
+crate::<u8 as cast::FromPrimitive>::from_u64(p0);
+<u8>::from_u64(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<u8 as cast::FromPrimitive>::from_u128(p0);
+crate::<u8 as cast::FromPrimitive>::from_u128(p0);
+<u8>::from_u128(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<u8 as cast::FromPrimitive>::from_f32(p0);
+crate::<u8 as cast::FromPrimitive>::from_f32(p0);
+<u8>::from_f32(p0);
-----------------
src/cast.rs <u8 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<u8 as cast::FromPrimitive>::from_f64(p0);
+crate::<u8 as cast::FromPrimitive>::from_f64(p0);
+<u8>::from_f64(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<u16 as cast::FromPrimitive>::from_isize(p0);
+crate::<u16 as cast::FromPrimitive>::from_isize(p0);
+<u16>::from_isize(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<u16 as cast::FromPrimitive>::from_i8(p0);
+crate::<u16 as cast::FromPrimitive>::from_i8(p0);
+<u16>::from_i8(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<u16 as cast::FromPrimitive>::from_i16(p0);
+crate::<u16 as cast::FromPrimitive>::from_i16(p0);
+<u16>::from_i16(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<u16 as cast::FromPrimitive>::from_i32(p0);
+crate::<u16 as cast::FromPrimitive>::from_i32(p0);
+<u16>::from_i32(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<u16 as cast::FromPrimitive>::from_i64(p0);
+crate::<u16 as cast::FromPrimitive>::from_i64(p0);
+<u16>::from_i64(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<u16 as cast::FromPrimitive>::from_i128(p0);
+crate::<u16 as cast::FromPrimitive>::from_i128(p0);
+<u16>::from_i128(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<u16 as cast::FromPrimitive>::from_usize(p0);
+crate::<u16 as cast::FromPrimitive>::from_usize(p0);
+<u16>::from_usize(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<u16 as cast::FromPrimitive>::from_u8(p0);
+crate::<u16 as cast::FromPrimitive>::from_u8(p0);
+<u16>::from_u8(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<u16 as cast::FromPrimitive>::from_u16(p0);
+crate::<u16 as cast::FromPrimitive>::from_u16(p0);
+<u16>::from_u16(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<u16 as cast::FromPrimitive>::from_u32(p0);
+crate::<u16 as cast::FromPrimitive>::from_u32(p0);
+<u16>::from_u32(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<u16 as cast::FromPrimitive>::from_u64(p0);
+crate::<u16 as cast::FromPrimitive>::from_u64(p0);
+<u16>::from_u64(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<u16 as cast::FromPrimitive>::from_u128(p0);
+crate::<u16 as cast::FromPrimitive>::from_u128(p0);
+<u16>::from_u128(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<u16 as cast::FromPrimitive>::from_f32(p0);
+crate::<u16 as cast::FromPrimitive>::from_f32(p0);
+<u16>::from_f32(p0);
-----------------
src/cast.rs <u16 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<u16 as cast::FromPrimitive>::from_f64(p0);
+crate::<u16 as cast::FromPrimitive>::from_f64(p0);
+<u16>::from_f64(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<u32 as cast::FromPrimitive>::from_isize(p0);
+crate::<u32 as cast::FromPrimitive>::from_isize(p0);
+<u32>::from_isize(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<u32 as cast::FromPrimitive>::from_i8(p0);
+crate::<u32 as cast::FromPrimitive>::from_i8(p0);
+<u32>::from_i8(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<u32 as cast::FromPrimitive>::from_i16(p0);
+crate::<u32 as cast::FromPrimitive>::from_i16(p0);
+<u32>::from_i16(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<u32 as cast::FromPrimitive>::from_i32(p0);
+crate::<u32 as cast::FromPrimitive>::from_i32(p0);
+<u32>::from_i32(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<u32 as cast::FromPrimitive>::from_i64(p0);
+crate::<u32 as cast::FromPrimitive>::from_i64(p0);
+<u32>::from_i64(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<u32 as cast::FromPrimitive>::from_i128(p0);
+crate::<u32 as cast::FromPrimitive>::from_i128(p0);
+<u32>::from_i128(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<u32 as cast::FromPrimitive>::from_usize(p0);
+crate::<u32 as cast::FromPrimitive>::from_usize(p0);
+<u32>::from_usize(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<u32 as cast::FromPrimitive>::from_u8(p0);
+crate::<u32 as cast::FromPrimitive>::from_u8(p0);
+<u32>::from_u8(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<u32 as cast::FromPrimitive>::from_u16(p0);
+crate::<u32 as cast::FromPrimitive>::from_u16(p0);
+<u32>::from_u16(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<u32 as cast::FromPrimitive>::from_u32(p0);
+crate::<u32 as cast::FromPrimitive>::from_u32(p0);
+<u32>::from_u32(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<u32 as cast::FromPrimitive>::from_u64(p0);
+crate::<u32 as cast::FromPrimitive>::from_u64(p0);
+<u32>::from_u64(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<u32 as cast::FromPrimitive>::from_u128(p0);
+crate::<u32 as cast::FromPrimitive>::from_u128(p0);
+<u32>::from_u128(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<u32 as cast::FromPrimitive>::from_f32(p0);
+crate::<u32 as cast::FromPrimitive>::from_f32(p0);
+<u32>::from_f32(p0);
-----------------
src/cast.rs <u32 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<u32 as cast::FromPrimitive>::from_f64(p0);
+crate::<u32 as cast::FromPrimitive>::from_f64(p0);
+<u32>::from_f64(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<u64 as cast::FromPrimitive>::from_isize(p0);
+crate::<u64 as cast::FromPrimitive>::from_isize(p0);
+<u64>::from_isize(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<u64 as cast::FromPrimitive>::from_i8(p0);
+crate::<u64 as cast::FromPrimitive>::from_i8(p0);
+<u64>::from_i8(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<u64 as cast::FromPrimitive>::from_i16(p0);
+crate::<u64 as cast::FromPrimitive>::from_i16(p0);
+<u64>::from_i16(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<u64 as cast::FromPrimitive>::from_i32(p0);
+crate::<u64 as cast::FromPrimitive>::from_i32(p0);
+<u64>::from_i32(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<u64 as cast::FromPrimitive>::from_i64(p0);
+crate::<u64 as cast::FromPrimitive>::from_i64(p0);
+<u64>::from_i64(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<u64 as cast::FromPrimitive>::from_i128(p0);
+crate::<u64 as cast::FromPrimitive>::from_i128(p0);
+<u64>::from_i128(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<u64 as cast::FromPrimitive>::from_usize(p0);
+crate::<u64 as cast::FromPrimitive>::from_usize(p0);
+<u64>::from_usize(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<u64 as cast::FromPrimitive>::from_u8(p0);
+crate::<u64 as cast::FromPrimitive>::from_u8(p0);
+<u64>::from_u8(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<u64 as cast::FromPrimitive>::from_u16(p0);
+crate::<u64 as cast::FromPrimitive>::from_u16(p0);
+<u64>::from_u16(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<u64 as cast::FromPrimitive>::from_u32(p0);
+crate::<u64 as cast::FromPrimitive>::from_u32(p0);
+<u64>::from_u32(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<u64 as cast::FromPrimitive>::from_u64(p0);
+crate::<u64 as cast::FromPrimitive>::from_u64(p0);
+<u64>::from_u64(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<u64 as cast::FromPrimitive>::from_u128(p0);
+crate::<u64 as cast::FromPrimitive>::from_u128(p0);
+<u64>::from_u128(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<u64 as cast::FromPrimitive>::from_f32(p0);
+crate::<u64 as cast::FromPrimitive>::from_f32(p0);
+<u64>::from_f32(p0);
-----------------
src/cast.rs <u64 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<u64 as cast::FromPrimitive>::from_f64(p0);
+crate::<u64 as cast::FromPrimitive>::from_f64(p0);
+<u64>::from_f64(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<u128 as cast::FromPrimitive>::from_isize(p0);
+crate::<u128 as cast::FromPrimitive>::from_isize(p0);
+<u128>::from_isize(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<u128 as cast::FromPrimitive>::from_i8(p0);
+crate::<u128 as cast::FromPrimitive>::from_i8(p0);
+<u128>::from_i8(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<u128 as cast::FromPrimitive>::from_i16(p0);
+crate::<u128 as cast::FromPrimitive>::from_i16(p0);
+<u128>::from_i16(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<u128 as cast::FromPrimitive>::from_i32(p0);
+crate::<u128 as cast::FromPrimitive>::from_i32(p0);
+<u128>::from_i32(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<u128 as cast::FromPrimitive>::from_i64(p0);
+crate::<u128 as cast::FromPrimitive>::from_i64(p0);
+<u128>::from_i64(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<u128 as cast::FromPrimitive>::from_i128(p0);
+crate::<u128 as cast::FromPrimitive>::from_i128(p0);
+<u128>::from_i128(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<u128 as cast::FromPrimitive>::from_usize(p0);
+crate::<u128 as cast::FromPrimitive>::from_usize(p0);
+<u128>::from_usize(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<u128 as cast::FromPrimitive>::from_u8(p0);
+crate::<u128 as cast::FromPrimitive>::from_u8(p0);
+<u128>::from_u8(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<u128 as cast::FromPrimitive>::from_u16(p0);
+crate::<u128 as cast::FromPrimitive>::from_u16(p0);
+<u128>::from_u16(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<u128 as cast::FromPrimitive>::from_u32(p0);
+crate::<u128 as cast::FromPrimitive>::from_u32(p0);
+<u128>::from_u32(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<u128 as cast::FromPrimitive>::from_u64(p0);
+crate::<u128 as cast::FromPrimitive>::from_u64(p0);
+<u128>::from_u64(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<u128 as cast::FromPrimitive>::from_u128(p0);
+crate::<u128 as cast::FromPrimitive>::from_u128(p0);
+<u128>::from_u128(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<u128 as cast::FromPrimitive>::from_f32(p0);
+crate::<u128 as cast::FromPrimitive>::from_f32(p0);
+<u128>::from_f32(p0);
-----------------
src/cast.rs <u128 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<u128 as cast::FromPrimitive>::from_f64(p0);
+crate::<u128 as cast::FromPrimitive>::from_f64(p0);
+<u128>::from_f64(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<f32 as cast::FromPrimitive>::from_isize(p0);
+crate::<f32 as cast::FromPrimitive>::from_isize(p0);
+<f32>::from_isize(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<f32 as cast::FromPrimitive>::from_i8(p0);
+crate::<f32 as cast::FromPrimitive>::from_i8(p0);
+<f32>::from_i8(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<f32 as cast::FromPrimitive>::from_i16(p0);
+crate::<f32 as cast::FromPrimitive>::from_i16(p0);
+<f32>::from_i16(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<f32 as cast::FromPrimitive>::from_i32(p0);
+crate::<f32 as cast::FromPrimitive>::from_i32(p0);
+<f32>::from_i32(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<f32 as cast::FromPrimitive>::from_i64(p0);
+crate::<f32 as cast::FromPrimitive>::from_i64(p0);
+<f32>::from_i64(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<f32 as cast::FromPrimitive>::from_i128(p0);
+crate::<f32 as cast::FromPrimitive>::from_i128(p0);
+<f32>::from_i128(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<f32 as cast::FromPrimitive>::from_usize(p0);
+crate::<f32 as cast::FromPrimitive>::from_usize(p0);
+<f32>::from_usize(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<f32 as cast::FromPrimitive>::from_u8(p0);
+crate::<f32 as cast::FromPrimitive>::from_u8(p0);
+<f32>::from_u8(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<f32 as cast::FromPrimitive>::from_u16(p0);
+crate::<f32 as cast::FromPrimitive>::from_u16(p0);
+<f32>::from_u16(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<f32 as cast::FromPrimitive>::from_u32(p0);
+crate::<f32 as cast::FromPrimitive>::from_u32(p0);
+<f32>::from_u32(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<f32 as cast::FromPrimitive>::from_u64(p0);
+crate::<f32 as cast::FromPrimitive>::from_u64(p0);
+<f32>::from_u64(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<f32 as cast::FromPrimitive>::from_u128(p0);
+crate::<f32 as cast::FromPrimitive>::from_u128(p0);
+<f32>::from_u128(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<f32 as cast::FromPrimitive>::from_f32(p0);
+crate::<f32 as cast::FromPrimitive>::from_f32(p0);
+<f32>::from_f32(p0);
-----------------
src/cast.rs <f32 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<f32 as cast::FromPrimitive>::from_f64(p0);
+crate::<f32 as cast::FromPrimitive>::from_f64(p0);
+<f32>::from_f64(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_isize
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<f64 as cast::FromPrimitive>::from_isize(p0);
+crate::<f64 as cast::FromPrimitive>::from_isize(p0);
+<f64>::from_isize(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_i8
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<f64 as cast::FromPrimitive>::from_i8(p0);
+crate::<f64 as cast::FromPrimitive>::from_i8(p0);
+<f64>::from_i8(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_i16
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<f64 as cast::FromPrimitive>::from_i16(p0);
+crate::<f64 as cast::FromPrimitive>::from_i16(p0);
+<f64>::from_i16(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_i32
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<f64 as cast::FromPrimitive>::from_i32(p0);
+crate::<f64 as cast::FromPrimitive>::from_i32(p0);
+<f64>::from_i32(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_i64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<f64 as cast::FromPrimitive>::from_i64(p0);
+crate::<f64 as cast::FromPrimitive>::from_i64(p0);
+<f64>::from_i64(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<f64 as cast::FromPrimitive>::from_i128(p0);
+crate::<f64 as cast::FromPrimitive>::from_i128(p0);
+<f64>::from_i128(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_usize
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<f64 as cast::FromPrimitive>::from_usize(p0);
+crate::<f64 as cast::FromPrimitive>::from_usize(p0);
+<f64>::from_usize(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_u8
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<f64 as cast::FromPrimitive>::from_u8(p0);
+crate::<f64 as cast::FromPrimitive>::from_u8(p0);
+<f64>::from_u8(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<f64 as cast::FromPrimitive>::from_u16(p0);
+crate::<f64 as cast::FromPrimitive>::from_u16(p0);
+<f64>::from_u16(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_u32
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<f64 as cast::FromPrimitive>::from_u32(p0);
+crate::<f64 as cast::FromPrimitive>::from_u32(p0);
+<f64>::from_u32(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_u64
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<f64 as cast::FromPrimitive>::from_u64(p0);
+crate::<f64 as cast::FromPrimitive>::from_u64(p0);
+<f64>::from_u64(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_u128
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<f64 as cast::FromPrimitive>::from_u128(p0);
+crate::<f64 as cast::FromPrimitive>::from_u128(p0);
+<f64>::from_u128(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+<f64 as cast::FromPrimitive>::from_f32(p0);
+crate::<f64 as cast::FromPrimitive>::from_f32(p0);
+<f64>::from_f32(p0);
-----------------
src/cast.rs <f64 as cast::FromPrimitive>::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<f64 as cast::FromPrimitive>::from_f64(p0);
+crate::<f64 as cast::FromPrimitive>::from_f64(p0);
+<f64>::from_f64(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_isize
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_isize":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["std::marker::Sized","cast::ToPrimitive","ops::wrapping::WrappingSub","sign::Unsigned","ops::wrapping::WrappingMul","bounds::Bounded","ops::wrapping::WrappingShl","identities::One","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","identities::Zero","sign::Signed","Num","cast::NumCast","cast::FromPrimitive","ops::wrapping::WrappingNeg"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_isize":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_isize();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_isize(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_isize(p0);
+<std::num::Wrapping<T>>::to_isize(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_i8
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i8":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::Zero","sign::Signed","Num","std::marker::Sized","ops::wrapping::WrappingAdd","identities::One","cast::NumCast","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","bounds::Bounded","ops::wrapping::WrappingNeg","ops::wrapping::WrappingMul","cast::ToPrimitive","cast::FromPrimitive","sign::Unsigned","ops::wrapping::WrappingSub"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i8":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_i8();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_i8(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_i8(p0);
+<std::num::Wrapping<T>>::to_i8(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_i16
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i16":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::ToPrimitive","sign::Signed","Num","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","bounds::Bounded","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","ops::wrapping::WrappingMul","identities::Zero","identities::One","sign::Unsigned","std::marker::Sized","cast::NumCast","cast::FromPrimitive"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i16":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_i16();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_i16(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_i16(p0);
+<std::num::Wrapping<T>>::to_i16(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_i32
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i32":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::ToPrimitive","cast::NumCast","identities::One","sign::Signed","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","ops::wrapping::WrappingMul","bounds::Bounded","ops::wrapping::WrappingSub","sign::Unsigned","Num","ops::wrapping::WrappingShl","std::marker::Sized","ops::wrapping::WrappingShr","cast::FromPrimitive","identities::Zero"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i32":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_i32();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_i32(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_i32(p0);
+<std::num::Wrapping<T>>::to_i32(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_i64
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i64":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["std::marker::Sized","cast::ToPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","sign::Signed","ops::wrapping::WrappingShl","sign::Unsigned","cast::FromPrimitive","ops::wrapping::WrappingShr","cast::NumCast","identities::One","ops::wrapping::WrappingAdd","identities::Zero","bounds::Bounded","ops::wrapping::WrappingNeg","Num"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i64":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_i64();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_i64(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_i64(p0);
+<std::num::Wrapping<T>>::to_i64(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_i128
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i128":{"T":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","identities::One","std::marker::Sized","ops::wrapping::WrappingAdd","cast::NumCast","identities::Zero","ops::wrapping::WrappingNeg","sign::Unsigned","Num","sign::Signed","cast::FromPrimitive","bounds::Bounded","ops::wrapping::WrappingMul","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","cast::ToPrimitive"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_i128":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_i128();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_i128(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_i128(p0);
+<std::num::Wrapping<T>>::to_i128(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_usize
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_usize":{"T":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["bounds::Bounded","Num","ops::wrapping::WrappingShr","cast::ToPrimitive","ops::wrapping::WrappingNeg","sign::Unsigned","cast::NumCast","ops::wrapping::WrappingSub","ops::wrapping::WrappingAdd","identities::Zero","cast::FromPrimitive","std::marker::Sized","identities::One","ops::wrapping::WrappingShl","ops::wrapping::WrappingMul","sign::Signed"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_usize":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_usize();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_usize(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_usize(p0);
+<std::num::Wrapping<T>>::to_usize(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_u8
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u8":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["bounds::Bounded","ops::wrapping::WrappingAdd","sign::Signed","sign::Unsigned","cast::FromPrimitive","ops::wrapping::WrappingSub","cast::ToPrimitive","ops::wrapping::WrappingNeg","std::marker::Sized","ops::wrapping::WrappingShr","cast::NumCast","identities::Zero","ops::wrapping::WrappingShl","Num","ops::wrapping::WrappingMul","identities::One"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u8":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_u8();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_u8(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_u8(p0);
+<std::num::Wrapping<T>>::to_u8(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_u16
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u16":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["bounds::Bounded","cast::FromPrimitive","ops::wrapping::WrappingShr","std::marker::Sized","ops::wrapping::WrappingShl","ops::wrapping::WrappingNeg","ops::wrapping::WrappingMul","sign::Unsigned","Num","sign::Signed","identities::One","ops::wrapping::WrappingSub","identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingAdd","cast::NumCast"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u16":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_u16();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_u16(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_u16(p0);
+<std::num::Wrapping<T>>::to_u16(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_u32
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u32":{"T":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["sign::Signed","cast::FromPrimitive","sign::Unsigned","cast::ToPrimitive","identities::One","bounds::Bounded","ops::wrapping::WrappingNeg","std::marker::Sized","identities::Zero","ops::wrapping::WrappingShl","cast::NumCast","ops::wrapping::WrappingSub","ops::wrapping::WrappingShr","ops::wrapping::WrappingMul","Num","ops::wrapping::WrappingAdd"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u32":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_u32();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_u32(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_u32(p0);
+<std::num::Wrapping<T>>::to_u32(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_u64
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u64":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["sign::Unsigned","sign::Signed","ops::wrapping::WrappingSub","std::marker::Sized","bounds::Bounded","ops::wrapping::WrappingShl","identities::Zero","cast::ToPrimitive","cast::FromPrimitive","identities::One","ops::wrapping::WrappingAdd","Num","cast::NumCast","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShr","ops::wrapping::WrappingMul"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u64":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_u64();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_u64(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_u64(p0);
+<std::num::Wrapping<T>>::to_u64(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_u128
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u128":{"T":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","cast::ToPrimitive","identities::One","ops::wrapping::WrappingMul","bounds::Bounded","identities::Zero","ops::wrapping::WrappingSub","cast::NumCast","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","sign::Unsigned","sign::Signed","std::marker::Sized","cast::FromPrimitive","Num","ops::wrapping::WrappingShl"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_u128":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_u128();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_u128(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_u128(p0);
+<std::num::Wrapping<T>>::to_u128(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_f32
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_f32":{"T":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["std::marker::Sized","sign::Unsigned","sign::Signed","identities::Zero","cast::NumCast","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","ops::wrapping::WrappingMul","identities::One","cast::FromPrimitive","Num","bounds::Bounded","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShl","cast::ToPrimitive"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_f32":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_f32();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_f32(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_f32(p0);
+<std::num::Wrapping<T>>::to_f32(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::ToPrimitive>::to_f64
deps:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_f64":{"T":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["Num","ops::wrapping::WrappingMul","sign::Signed","identities::One","cast::NumCast","cast::ToPrimitive","sign::Unsigned","std::marker::Sized","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","cast::FromPrimitive","identities::Zero","bounds::Bounded","ops::wrapping::WrappingSub"]}}
candidates:{"<std::num::Wrapping<T> as cast::ToPrimitive>::to_f64":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.to_f64();
+<std::num::Wrapping<T> as cast::ToPrimitive>::to_f64(p0);
+crate::<std::num::Wrapping<T> as cast::ToPrimitive>::to_f64(p0);
+<std::num::Wrapping<T>>::to_f64(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_isize
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_isize":{"T":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","identities::One","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","cast::NumCast","bounds::Bounded","ops::wrapping::WrappingNeg","sign::Signed","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","identities::Zero","sign::Unsigned","cast::ToPrimitive","std::marker::Sized","Num"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_isize":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0isize; // None+isize
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_isize(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_isize(p0);
+<std::num::Wrapping<T>>::from_isize(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_i8
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i8":{"T":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","cast::NumCast","ops::wrapping::WrappingShl","std::marker::Sized","identities::One","sign::Signed","cast::ToPrimitive","sign::Unsigned","bounds::Bounded","ops::wrapping::WrappingMul","identities::Zero","Num","cast::FromPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i8":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i8; // None+i8
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_i8(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_i8(p0);
+<std::num::Wrapping<T>>::from_i8(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_i16
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i16":{"T":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingSub","sign::Signed","Num","identities::One","std::marker::Sized","identities::Zero","ops::wrapping::WrappingAdd","sign::Unsigned","bounds::Bounded","cast::NumCast","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","cast::ToPrimitive","ops::wrapping::WrappingShr","cast::FromPrimitive","ops::wrapping::WrappingShl"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i16":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i16; // None+i16
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_i16(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_i16(p0);
+<std::num::Wrapping<T>>::from_i16(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_i32
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i32":{"T":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","ops::wrapping::WrappingAdd","sign::Unsigned","cast::NumCast","cast::FromPrimitive","ops::wrapping::WrappingShr","identities::One","std::marker::Sized","bounds::Bounded","identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","sign::Signed","Num"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i32":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i32; // None+i32
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_i32(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_i32(p0);
+<std::num::Wrapping<T>>::from_i32(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_i64
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i64":{"T":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["bounds::Bounded","cast::FromPrimitive","cast::NumCast","ops::wrapping::WrappingAdd","sign::Unsigned","ops::wrapping::WrappingMul","sign::Signed","identities::Zero","ops::wrapping::WrappingShr","identities::One","cast::ToPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","std::marker::Sized","Num","ops::wrapping::WrappingNeg"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i64":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i64; // None+i64
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_i64(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_i64(p0);
+<std::num::Wrapping<T>>::from_i64(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_i128
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i128":{"T":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::FromPrimitive","bounds::Bounded","identities::Zero","ops::wrapping::WrappingAdd","sign::Signed","ops::wrapping::WrappingNeg","std::marker::Sized","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","Num","cast::ToPrimitive","ops::wrapping::WrappingMul","cast::NumCast","identities::One","sign::Unsigned","ops::wrapping::WrappingShr"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_i128":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0i128; // None+i128
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_i128(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_i128(p0);
+<std::num::Wrapping<T>>::from_i128(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_usize
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_usize":{"T":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::One","cast::FromPrimitive","std::marker::Sized","Num","bounds::Bounded","ops::wrapping::WrappingAdd","cast::ToPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","identities::Zero","cast::NumCast","ops::wrapping::WrappingSub","ops::wrapping::WrappingShr","sign::Signed","sign::Unsigned"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_usize":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0usize; // None+usize
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_usize(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_usize(p0);
+<std::num::Wrapping<T>>::from_usize(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_u8
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u8":{"T":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","std::marker::Sized","sign::Unsigned","cast::FromPrimitive","cast::NumCast","cast::ToPrimitive","ops::wrapping::WrappingAdd","bounds::Bounded","Num","ops::wrapping::WrappingNeg","sign::Signed","identities::Zero","identities::One","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u8":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u8; // None+u8
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_u8(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_u8(p0);
+<std::num::Wrapping<T>>::from_u8(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_u16
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u16":{"T":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","identities::One","ops::wrapping::WrappingMul","Num","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","sign::Signed","std::marker::Sized","bounds::Bounded","cast::ToPrimitive","cast::NumCast","ops::wrapping::WrappingShr","sign::Unsigned","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingShl"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u16":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u16; // None+u16
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_u16(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_u16(p0);
+<std::num::Wrapping<T>>::from_u16(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_u32
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u32":{"T":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["bounds::Bounded","ops::wrapping::WrappingNeg","identities::One","cast::NumCast","ops::wrapping::WrappingMul","identities::Zero","std::marker::Sized","sign::Signed","cast::ToPrimitive","ops::wrapping::WrappingShl","cast::FromPrimitive","sign::Unsigned","ops::wrapping::WrappingSub","Num","ops::wrapping::WrappingShr","ops::wrapping::WrappingAdd"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u32":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u32; // None+u32
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_u32(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_u32(p0);
+<std::num::Wrapping<T>>::from_u32(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_u64
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u64":{"T":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["cast::NumCast","bounds::Bounded","ops::wrapping::WrappingMul","sign::Unsigned","Num","std::marker::Sized","cast::ToPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","cast::FromPrimitive","sign::Signed","ops::wrapping::WrappingAdd","identities::One","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","identities::Zero"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u64":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u64; // None+u64
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_u64(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_u64(p0);
+<std::num::Wrapping<T>>::from_u64(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_u128
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u128":{"T":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["bounds::Bounded","std::marker::Sized","Num","ops::wrapping::WrappingShl","sign::Signed","identities::Zero","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","ops::wrapping::WrappingAdd","identities::One","ops::wrapping::WrappingShr","cast::NumCast","sign::Unsigned","cast::FromPrimitive","cast::ToPrimitive"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_u128":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0u128; // None+u128
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_u128(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_u128(p0);
+<std::num::Wrapping<T>>::from_u128(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_f32
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_f32":{"T":["std::marker::Sized","cast::FromPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingNeg","ops::wrapping::WrappingAdd","Num","ops::wrapping::WrappingShl","cast::ToPrimitive","ops::wrapping::WrappingSub","identities::One","ops::wrapping::WrappingShr","identities::Zero","cast::FromPrimitive","ops::wrapping::WrappingMul","std::marker::Sized","cast::NumCast","sign::Unsigned","bounds::Bounded","sign::Signed"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_f32":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0f32; // None+f32
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_f32(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_f32(p0);
+<std::num::Wrapping<T>>::from_f32(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::FromPrimitive>::from_f64
deps:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_f64":{"T":["cast::FromPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::One","cast::NumCast","identities::Zero","ops::wrapping::WrappingNeg","bounds::Bounded","cast::ToPrimitive","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","Num","std::marker::Sized","cast::FromPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","sign::Signed","ops::wrapping::WrappingShr","sign::Unsigned"]}}
candidates:{"<std::num::Wrapping<T> as cast::FromPrimitive>::from_f64":{"T":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = 0f64; // None+f64
+<std::num::Wrapping<T> as cast::FromPrimitive>::from_f64(p0);
+crate::<std::num::Wrapping<T> as cast::FromPrimitive>::from_f64(p0);
+<std::num::Wrapping<T>>::from_f64(p0);
-----------------
src/cast.rs <u8 as cast::NumCast>::from
deps:{"<u8 as cast::NumCast>::from":{"N":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["bounds::Bounded","cast::ToPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","sign::Signed","cast::FromPrimitive","identities::Zero","identities::One","ops::wrapping::WrappingNeg","sign::Unsigned","cast::NumCast","Num","std::marker::Sized"]}}
candidates:{"<u8 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<u8 as cast::NumCast>::from(p0);
+crate::<u8 as cast::NumCast>::from(p0);
+<u8>::from(p0);
-----------------
src/cast.rs <u16 as cast::NumCast>::from
deps:{"<u16 as cast::NumCast>::from":{"N":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["std::marker::Sized","ops::wrapping::WrappingShl","identities::One","sign::Unsigned","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","cast::ToPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShr","cast::FromPrimitive","sign::Signed","bounds::Bounded","cast::NumCast","identities::Zero","Num"]}}
candidates:{"<u16 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<u16 as cast::NumCast>::from(p0);
+crate::<u16 as cast::NumCast>::from(p0);
+<u16>::from(p0);
-----------------
src/cast.rs <u32 as cast::NumCast>::from
deps:{"<u32 as cast::NumCast>::from":{"N":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["cast::ToPrimitive","std::marker::Sized","bounds::Bounded","cast::FromPrimitive","Num","identities::Zero","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","cast::NumCast","sign::Signed","ops::wrapping::WrappingMul","identities::One","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","sign::Unsigned"]}}
candidates:{"<u32 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<u32 as cast::NumCast>::from(p0);
+crate::<u32 as cast::NumCast>::from(p0);
+<u32>::from(p0);
-----------------
src/cast.rs <u64 as cast::NumCast>::from
deps:{"<u64 as cast::NumCast>::from":{"N":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["identities::One","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","cast::FromPrimitive","bounds::Bounded","cast::NumCast","identities::Zero","sign::Signed","ops::wrapping::WrappingSub","cast::ToPrimitive","std::marker::Sized","sign::Unsigned","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","Num","ops::wrapping::WrappingShr"]}}
candidates:{"<u64 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<u64 as cast::NumCast>::from(p0);
+crate::<u64 as cast::NumCast>::from(p0);
+<u64>::from(p0);
-----------------
src/cast.rs <u128 as cast::NumCast>::from
deps:{"<u128 as cast::NumCast>::from":{"N":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["Num","bounds::Bounded","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","identities::Zero","ops::wrapping::WrappingNeg","sign::Signed","cast::ToPrimitive","cast::FromPrimitive","ops::wrapping::WrappingShr","sign::Unsigned","std::marker::Sized","ops::wrapping::WrappingAdd","cast::NumCast","identities::One"]}}
candidates:{"<u128 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<u128 as cast::NumCast>::from(p0);
+crate::<u128 as cast::NumCast>::from(p0);
+<u128>::from(p0);
-----------------
src/cast.rs <usize as cast::NumCast>::from
deps:{"<usize as cast::NumCast>::from":{"N":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::Zero","sign::Signed","cast::ToPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingShr","ops::wrapping::WrappingNeg","Num","ops::wrapping::WrappingAdd","std::marker::Sized","ops::wrapping::WrappingShl","bounds::Bounded","cast::NumCast","identities::One","sign::Unsigned","ops::wrapping::WrappingMul","cast::FromPrimitive"]}}
candidates:{"<usize as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<usize as cast::NumCast>::from(p0);
+crate::<usize as cast::NumCast>::from(p0);
+<usize>::from(p0);
-----------------
src/cast.rs <i8 as cast::NumCast>::from
deps:{"<i8 as cast::NumCast>::from":{"N":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["std::marker::Sized","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","sign::Signed","identities::One","cast::ToPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","sign::Unsigned","ops::wrapping::WrappingSub","bounds::Bounded","cast::NumCast","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingAdd","Num"]}}
candidates:{"<i8 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<i8 as cast::NumCast>::from(p0);
+crate::<i8 as cast::NumCast>::from(p0);
+<i8>::from(p0);
-----------------
src/cast.rs <i16 as cast::NumCast>::from
deps:{"<i16 as cast::NumCast>::from":{"N":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["bounds::Bounded","cast::ToPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","sign::Signed","Num","cast::FromPrimitive","std::marker::Sized","identities::Zero","ops::wrapping::WrappingShr","identities::One","sign::Unsigned","ops::wrapping::WrappingMul","cast::NumCast","ops::wrapping::WrappingNeg","ops::wrapping::WrappingAdd"]}}
candidates:{"<i16 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<i16 as cast::NumCast>::from(p0);
+crate::<i16 as cast::NumCast>::from(p0);
+<i16>::from(p0);
-----------------
src/cast.rs <i32 as cast::NumCast>::from
deps:{"<i32 as cast::NumCast>::from":{"N":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","sign::Signed","cast::NumCast","cast::ToPrimitive","ops::wrapping::WrappingAdd","ops::wrapping::WrappingShr","identities::One","bounds::Bounded","std::marker::Sized","ops::wrapping::WrappingMul","sign::Unsigned","Num","identities::Zero","cast::FromPrimitive","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg"]}}
candidates:{"<i32 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<i32 as cast::NumCast>::from(p0);
+crate::<i32 as cast::NumCast>::from(p0);
+<i32>::from(p0);
-----------------
src/cast.rs <i64 as cast::NumCast>::from
deps:{"<i64 as cast::NumCast>::from":{"N":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingAdd","Num","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","cast::NumCast","ops::wrapping::WrappingNeg","identities::One","ops::wrapping::WrappingShl","bounds::Bounded","ops::wrapping::WrappingShr","sign::Unsigned","sign::Signed","std::marker::Sized","cast::FromPrimitive"]}}
candidates:{"<i64 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<i64 as cast::NumCast>::from(p0);
+crate::<i64 as cast::NumCast>::from(p0);
+<i64>::from(p0);
-----------------
src/cast.rs <i128 as cast::NumCast>::from
deps:{"<i128 as cast::NumCast>::from":{"N":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["identities::Zero","ops::wrapping::WrappingShr","std::marker::Sized","cast::FromPrimitive","sign::Signed","bounds::Bounded","Num","ops::wrapping::WrappingMul","cast::ToPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingAdd","cast::NumCast","identities::One","ops::wrapping::WrappingShl","sign::Unsigned","ops::wrapping::WrappingSub"]}}
candidates:{"<i128 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<i128 as cast::NumCast>::from(p0);
+crate::<i128 as cast::NumCast>::from(p0);
+<i128>::from(p0);
-----------------
src/cast.rs <isize as cast::NumCast>::from
deps:{"<isize as cast::NumCast>::from":{"N":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["std::marker::Sized","cast::FromPrimitive","identities::Zero","ops::wrapping::WrappingShr","cast::NumCast","Num","sign::Signed","cast::ToPrimitive","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","sign::Unsigned","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","ops::wrapping::WrappingNeg","bounds::Bounded","identities::One"]}}
candidates:{"<isize as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<isize as cast::NumCast>::from(p0);
+crate::<isize as cast::NumCast>::from(p0);
+<isize>::from(p0);
-----------------
src/cast.rs <f32 as cast::NumCast>::from
deps:{"<f32 as cast::NumCast>::from":{"N":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","identities::One","sign::Unsigned","cast::NumCast","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","Num","ops::wrapping::WrappingNeg","identities::Zero","ops::wrapping::WrappingSub","std::marker::Sized","cast::ToPrimitive","ops::wrapping::WrappingAdd","bounds::Bounded","cast::FromPrimitive","sign::Signed"]}}
candidates:{"<f32 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<f32 as cast::NumCast>::from(p0);
+crate::<f32 as cast::NumCast>::from(p0);
+<f32>::from(p0);
-----------------
src/cast.rs <f64 as cast::NumCast>::from
deps:{"<f64 as cast::NumCast>::from":{"N":["cast::ToPrimitive","std::marker::Sized"]},"std::num::Wrapping":{"T":["std::marker::Sized","cast::ToPrimitive","ops::wrapping::WrappingAdd","identities::One","ops::wrapping::WrappingSub","cast::NumCast","sign::Unsigned","sign::Signed","Num","identities::Zero","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","bounds::Bounded","ops::wrapping::WrappingShr","cast::FromPrimitive"]}}
candidates:{"<f64 as cast::NumCast>::from":{"N":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // N
+<f64 as cast::NumCast>::from(p0);
+crate::<f64 as cast::NumCast>::from(p0);
+<f64>::from(p0);
-----------------
src/cast.rs <std::num::Wrapping<T> as cast::NumCast>::from
deps:{"<std::num::Wrapping<T> as cast::NumCast>::from":{"T":["cast::NumCast","std::marker::Sized"],"U":["std::marker::Sized","cast::ToPrimitive"]},"std::num::Wrapping":{"T":["sign::Signed","std::marker::Sized","ops::wrapping::WrappingMul","cast::FromPrimitive","ops::wrapping::WrappingNeg","cast::ToPrimitive","sign::Unsigned","bounds::Bounded","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","Num","cast::NumCast","ops::wrapping::WrappingShr","identities::One","ops::wrapping::WrappingAdd","identities::Zero"]}}
candidates:{"<std::num::Wrapping<T> as cast::NumCast>::from":{"T":["std::num::Wrapping"],"U":["std::num::Wrapping"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // U
+<std::num::Wrapping<T> as cast::NumCast>::from(p0);
+crate::<std::num::Wrapping<T> as cast::NumCast>::from(p0);
+<std::num::Wrapping<T>>::from(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<char>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<char>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<char>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<f32>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<f64>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<u8>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<u16>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<u32>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<u64>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<u128>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<usize>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<i8>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<i16>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<i32>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<i64>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<i128>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <u8 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_();
+<u8 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<u8 as cast::AsPrimitive<isize>>::as_(p0);
+<u8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<f32>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<f64>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<u8>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<u16>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<u32>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<u64>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<u128>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<usize>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<i8>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<i16>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<i32>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<i64>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<i128>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <i8 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.as_();
+<i8 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<i8 as cast::AsPrimitive<isize>>::as_(p0);
+<i8>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<f32>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<f64>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<u8>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<u16>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<u32>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<u64>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<u128>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<usize>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<i8>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<i16>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<i32>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<i64>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<i128>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <u16 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.as_();
+<u16 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<u16 as cast::AsPrimitive<isize>>::as_(p0);
+<u16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<f32>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<f64>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<u8>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<u16>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<u32>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<u64>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<u128>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<usize>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<i8>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<i16>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<i32>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<i64>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<i128>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <i16 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.as_();
+<i16 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<i16 as cast::AsPrimitive<isize>>::as_(p0);
+<i16>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<f32>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<f64>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<u8>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<u16>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<u32>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<u64>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<u128>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<usize>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<i8>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<i16>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<i32>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<i64>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<i128>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <u32 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.as_();
+<u32 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<u32 as cast::AsPrimitive<isize>>::as_(p0);
+<u32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<f32>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<f64>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<u8>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<u16>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<u32>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<u64>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<u128>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<usize>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<i8>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<i16>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<i32>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<i64>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<i128>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <i32 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.as_();
+<i32 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<i32 as cast::AsPrimitive<isize>>::as_(p0);
+<i32>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<f32>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<f64>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<u8>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<u16>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<u32>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<u64>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<u128>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<usize>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<i8>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<i16>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<i32>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<i64>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<i128>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <u64 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.as_();
+<u64 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<u64 as cast::AsPrimitive<isize>>::as_(p0);
+<u64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<f32>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<f64>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<u8>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<u16>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<u32>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<u64>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<u128>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<usize>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<i8>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<i16>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<i32>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<i64>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<i128>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <i64 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.as_();
+<i64 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<i64 as cast::AsPrimitive<isize>>::as_(p0);
+<i64>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<f32>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<f64>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<u8>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<u16>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<u32>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<u64>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<u128>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<usize>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<i8>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<i16>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<i32>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<i64>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<i128>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <u128 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.as_();
+<u128 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<u128 as cast::AsPrimitive<isize>>::as_(p0);
+<u128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<f32>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<f64>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<u8>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<u16>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<u32>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<u64>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<u128>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<usize>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<i8>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<i16>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<i32>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<i64>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<i128>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <i128 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.as_();
+<i128 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<i128 as cast::AsPrimitive<isize>>::as_(p0);
+<i128>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<f32>>::as_(p0);
+crate::<usize as cast::AsPrimitive<f32>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<f64>>::as_(p0);
+crate::<usize as cast::AsPrimitive<f64>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<u8>>::as_(p0);
+crate::<usize as cast::AsPrimitive<u8>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<u16>>::as_(p0);
+crate::<usize as cast::AsPrimitive<u16>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<u32>>::as_(p0);
+crate::<usize as cast::AsPrimitive<u32>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<u64>>::as_(p0);
+crate::<usize as cast::AsPrimitive<u64>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<u128>>::as_(p0);
+crate::<usize as cast::AsPrimitive<u128>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<usize>>::as_(p0);
+crate::<usize as cast::AsPrimitive<usize>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<i8>>::as_(p0);
+crate::<usize as cast::AsPrimitive<i8>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<i16>>::as_(p0);
+crate::<usize as cast::AsPrimitive<i16>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<i32>>::as_(p0);
+crate::<usize as cast::AsPrimitive<i32>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<i64>>::as_(p0);
+crate::<usize as cast::AsPrimitive<i64>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<i128>>::as_(p0);
+crate::<usize as cast::AsPrimitive<i128>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <usize as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.as_();
+<usize as cast::AsPrimitive<isize>>::as_(p0);
+crate::<usize as cast::AsPrimitive<isize>>::as_(p0);
+<usize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<f32>>::as_(p0);
+crate::<isize as cast::AsPrimitive<f32>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<f64>>::as_(p0);
+crate::<isize as cast::AsPrimitive<f64>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<u8>>::as_(p0);
+crate::<isize as cast::AsPrimitive<u8>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<u16>>::as_(p0);
+crate::<isize as cast::AsPrimitive<u16>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<u32>>::as_(p0);
+crate::<isize as cast::AsPrimitive<u32>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<u64>>::as_(p0);
+crate::<isize as cast::AsPrimitive<u64>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<u128>>::as_(p0);
+crate::<isize as cast::AsPrimitive<u128>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<usize>>::as_(p0);
+crate::<isize as cast::AsPrimitive<usize>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<i8>>::as_(p0);
+crate::<isize as cast::AsPrimitive<i8>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<i16>>::as_(p0);
+crate::<isize as cast::AsPrimitive<i16>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<i32>>::as_(p0);
+crate::<isize as cast::AsPrimitive<i32>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<i64>>::as_(p0);
+crate::<isize as cast::AsPrimitive<i64>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<i128>>::as_(p0);
+crate::<isize as cast::AsPrimitive<i128>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <isize as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.as_();
+<isize as cast::AsPrimitive<isize>>::as_(p0);
+crate::<isize as cast::AsPrimitive<isize>>::as_(p0);
+<isize>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<f32>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<f64>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<u8>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<u16>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<u32>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<u64>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<u128>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<usize>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<i8>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<i16>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<i32>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<i64>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<i128>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f32 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.as_();
+<f32 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<f32 as cast::AsPrimitive<isize>>::as_(p0);
+<f32>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<f32>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<f32>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<f32>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<f64>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<f64>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<f64>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<u8>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<u8>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<u16>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<u16>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<u32>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<u32>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<u64>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<u64>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<u128>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<u128>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<usize>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<usize>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<i8>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<i8>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<i16>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<i16>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<i32>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<i32>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<i64>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<i64>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<i128>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<i128>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <f64 as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.as_();
+<f64 as cast::AsPrimitive<isize>>::as_(p0);
+crate::<f64 as cast::AsPrimitive<isize>>::as_(p0);
+<f64>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<char>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<char>>::as_(p0);
+crate::<char as cast::AsPrimitive<char>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<u8>>::as_(p0);
+crate::<char as cast::AsPrimitive<u8>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<u16>>::as_(p0);
+crate::<char as cast::AsPrimitive<u16>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<u32>>::as_(p0);
+crate::<char as cast::AsPrimitive<u32>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<u64>>::as_(p0);
+crate::<char as cast::AsPrimitive<u64>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<u128>>::as_(p0);
+crate::<char as cast::AsPrimitive<u128>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<usize>>::as_(p0);
+crate::<char as cast::AsPrimitive<usize>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<i8>>::as_(p0);
+crate::<char as cast::AsPrimitive<i8>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<i16>>::as_(p0);
+crate::<char as cast::AsPrimitive<i16>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<i32>>::as_(p0);
+crate::<char as cast::AsPrimitive<i32>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<i64>>::as_(p0);
+crate::<char as cast::AsPrimitive<i64>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<i128>>::as_(p0);
+crate::<char as cast::AsPrimitive<i128>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <char as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_();
+<char as cast::AsPrimitive<isize>>::as_(p0);
+crate::<char as cast::AsPrimitive<isize>>::as_(p0);
+<char>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<u8>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<u8>>::as_(p0);
+crate::<bool as cast::AsPrimitive<u8>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<u16>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<u16>>::as_(p0);
+crate::<bool as cast::AsPrimitive<u16>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<u32>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<u32>>::as_(p0);
+crate::<bool as cast::AsPrimitive<u32>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<u64>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<u64>>::as_(p0);
+crate::<bool as cast::AsPrimitive<u64>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<u128>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<u128>>::as_(p0);
+crate::<bool as cast::AsPrimitive<u128>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<usize>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<usize>>::as_(p0);
+crate::<bool as cast::AsPrimitive<usize>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<i8>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<i8>>::as_(p0);
+crate::<bool as cast::AsPrimitive<i8>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<i16>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<i16>>::as_(p0);
+crate::<bool as cast::AsPrimitive<i16>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<i32>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<i32>>::as_(p0);
+crate::<bool as cast::AsPrimitive<i32>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<i64>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<i64>>::as_(p0);
+crate::<bool as cast::AsPrimitive<i64>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<i128>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<i128>>::as_(p0);
+crate::<bool as cast::AsPrimitive<i128>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/cast.rs <bool as cast::AsPrimitive<isize>>::as_
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+p0.as_();
+<bool as cast::AsPrimitive<isize>>::as_(p0);
+crate::<bool as cast::AsPrimitive<isize>>::as_(p0);
+<bool>::as_(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::infinity
deps:{}
candidates:{}
+<f32 as float::FloatCore>::infinity();
+crate::<f32 as float::FloatCore>::infinity();
+<f32>::infinity();
-----------------
src/macros.rs <f32 as float::FloatCore>::neg_infinity
deps:{}
candidates:{}
+<f32 as float::FloatCore>::neg_infinity();
+crate::<f32 as float::FloatCore>::neg_infinity();
+<f32>::neg_infinity();
-----------------
src/macros.rs <f32 as float::FloatCore>::nan
deps:{}
candidates:{}
+<f32 as float::FloatCore>::nan();
+crate::<f32 as float::FloatCore>::nan();
+<f32>::nan();
-----------------
src/macros.rs <f32 as float::FloatCore>::neg_zero
deps:{}
candidates:{}
+<f32 as float::FloatCore>::neg_zero();
+crate::<f32 as float::FloatCore>::neg_zero();
+<f32>::neg_zero();
-----------------
src/macros.rs <f32 as float::FloatCore>::min_value
deps:{}
candidates:{}
+<f32 as float::FloatCore>::min_value();
+crate::<f32 as float::FloatCore>::min_value();
+<f32>::min_value();
-----------------
src/macros.rs <f32 as float::FloatCore>::min_positive_value
deps:{}
candidates:{}
+<f32 as float::FloatCore>::min_positive_value();
+crate::<f32 as float::FloatCore>::min_positive_value();
+<f32>::min_positive_value();
-----------------
src/macros.rs <f32 as float::FloatCore>::epsilon
deps:{}
candidates:{}
+<f32 as float::FloatCore>::epsilon();
+crate::<f32 as float::FloatCore>::epsilon();
+<f32>::epsilon();
-----------------
src/macros.rs <f32 as float::FloatCore>::max_value
deps:{}
candidates:{}
+<f32 as float::FloatCore>::max_value();
+crate::<f32 as float::FloatCore>::max_value();
+<f32>::max_value();
-----------------
src/float.rs <f32 as float::FloatCore>::integer_decode
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.integer_decode();
+<f32 as float::FloatCore>::integer_decode(p0);
+crate::<f32 as float::FloatCore>::integer_decode(p0);
+<f32>::integer_decode(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::is_nan
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_nan();
+<f32 as float::FloatCore>::is_nan(p0);
+crate::<f32 as float::FloatCore>::is_nan(p0);
+<f32>::is_nan(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::is_infinite
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_infinite();
+<f32 as float::FloatCore>::is_infinite(p0);
+crate::<f32 as float::FloatCore>::is_infinite(p0);
+<f32>::is_infinite(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::is_finite
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_finite();
+<f32 as float::FloatCore>::is_finite(p0);
+crate::<f32 as float::FloatCore>::is_finite(p0);
+<f32>::is_finite(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::is_normal
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_normal();
+<f32 as float::FloatCore>::is_normal(p0);
+crate::<f32 as float::FloatCore>::is_normal(p0);
+<f32>::is_normal(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::classify
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.classify();
+<f32 as float::FloatCore>::classify(p0);
+crate::<f32 as float::FloatCore>::classify(p0);
+<f32>::classify(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::floor
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.floor();
+<f32 as float::FloatCore>::floor(p0);
+crate::<f32 as float::FloatCore>::floor(p0);
+<f32>::floor(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::ceil
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.ceil();
+<f32 as float::FloatCore>::ceil(p0);
+crate::<f32 as float::FloatCore>::ceil(p0);
+<f32>::ceil(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::round
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.round();
+<f32 as float::FloatCore>::round(p0);
+crate::<f32 as float::FloatCore>::round(p0);
+<f32>::round(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::trunc
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.trunc();
+<f32 as float::FloatCore>::trunc(p0);
+crate::<f32 as float::FloatCore>::trunc(p0);
+<f32>::trunc(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::fract
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.fract();
+<f32 as float::FloatCore>::fract(p0);
+crate::<f32 as float::FloatCore>::fract(p0);
+<f32>::fract(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::abs
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.abs();
+<f32 as float::FloatCore>::abs(p0);
+crate::<f32 as float::FloatCore>::abs(p0);
+<f32>::abs(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::signum
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.signum();
+<f32 as float::FloatCore>::signum(p0);
+crate::<f32 as float::FloatCore>::signum(p0);
+<f32>::signum(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::is_sign_positive
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_sign_positive();
+<f32 as float::FloatCore>::is_sign_positive(p0);
+crate::<f32 as float::FloatCore>::is_sign_positive(p0);
+<f32>::is_sign_positive(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::is_sign_negative
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_sign_negative();
+<f32 as float::FloatCore>::is_sign_negative(p0);
+crate::<f32 as float::FloatCore>::is_sign_negative(p0);
+<f32>::is_sign_negative(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::min
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.min(p1);
+<f32 as float::FloatCore>::min(p0, p1);
+crate::<f32 as float::FloatCore>::min(p0, p1);
+<f32>::min(p0, p1);
-----------------
src/macros.rs <f32 as float::FloatCore>::max
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.max(p1);
+<f32 as float::FloatCore>::max(p0, p1);
+crate::<f32 as float::FloatCore>::max(p0, p1);
+<f32>::max(p0, p1);
-----------------
src/macros.rs <f32 as float::FloatCore>::recip
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.recip();
+<f32 as float::FloatCore>::recip(p0);
+crate::<f32 as float::FloatCore>::recip(p0);
+<f32>::recip(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::powi
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0i32; // None+i32
+p0.powi(p1);
+<f32 as float::FloatCore>::powi(p0, p1);
+crate::<f32 as float::FloatCore>::powi(p0, p1);
+<f32>::powi(p0, p1);
-----------------
src/macros.rs <f32 as float::FloatCore>::to_degrees
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.to_degrees();
+<f32 as float::FloatCore>::to_degrees(p0);
+crate::<f32 as float::FloatCore>::to_degrees(p0);
+<f32>::to_degrees(p0);
-----------------
src/macros.rs <f32 as float::FloatCore>::to_radians
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.to_radians();
+<f32 as float::FloatCore>::to_radians(p0);
+crate::<f32 as float::FloatCore>::to_radians(p0);
+<f32>::to_radians(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::infinity
deps:{}
candidates:{}
+<f64 as float::FloatCore>::infinity();
+crate::<f64 as float::FloatCore>::infinity();
+<f64>::infinity();
-----------------
src/macros.rs <f64 as float::FloatCore>::neg_infinity
deps:{}
candidates:{}
+<f64 as float::FloatCore>::neg_infinity();
+crate::<f64 as float::FloatCore>::neg_infinity();
+<f64>::neg_infinity();
-----------------
src/macros.rs <f64 as float::FloatCore>::nan
deps:{}
candidates:{}
+<f64 as float::FloatCore>::nan();
+crate::<f64 as float::FloatCore>::nan();
+<f64>::nan();
-----------------
src/macros.rs <f64 as float::FloatCore>::neg_zero
deps:{}
candidates:{}
+<f64 as float::FloatCore>::neg_zero();
+crate::<f64 as float::FloatCore>::neg_zero();
+<f64>::neg_zero();
-----------------
src/macros.rs <f64 as float::FloatCore>::min_value
deps:{}
candidates:{}
+<f64 as float::FloatCore>::min_value();
+crate::<f64 as float::FloatCore>::min_value();
+<f64>::min_value();
-----------------
src/macros.rs <f64 as float::FloatCore>::min_positive_value
deps:{}
candidates:{}
+<f64 as float::FloatCore>::min_positive_value();
+crate::<f64 as float::FloatCore>::min_positive_value();
+<f64>::min_positive_value();
-----------------
src/macros.rs <f64 as float::FloatCore>::epsilon
deps:{}
candidates:{}
+<f64 as float::FloatCore>::epsilon();
+crate::<f64 as float::FloatCore>::epsilon();
+<f64>::epsilon();
-----------------
src/macros.rs <f64 as float::FloatCore>::max_value
deps:{}
candidates:{}
+<f64 as float::FloatCore>::max_value();
+crate::<f64 as float::FloatCore>::max_value();
+<f64>::max_value();
-----------------
src/float.rs <f64 as float::FloatCore>::integer_decode
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.integer_decode();
+<f64 as float::FloatCore>::integer_decode(p0);
+crate::<f64 as float::FloatCore>::integer_decode(p0);
+<f64>::integer_decode(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::is_nan
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_nan();
+<f64 as float::FloatCore>::is_nan(p0);
+crate::<f64 as float::FloatCore>::is_nan(p0);
+<f64>::is_nan(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::is_infinite
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_infinite();
+<f64 as float::FloatCore>::is_infinite(p0);
+crate::<f64 as float::FloatCore>::is_infinite(p0);
+<f64>::is_infinite(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::is_finite
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_finite();
+<f64 as float::FloatCore>::is_finite(p0);
+crate::<f64 as float::FloatCore>::is_finite(p0);
+<f64>::is_finite(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::is_normal
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_normal();
+<f64 as float::FloatCore>::is_normal(p0);
+crate::<f64 as float::FloatCore>::is_normal(p0);
+<f64>::is_normal(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::classify
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.classify();
+<f64 as float::FloatCore>::classify(p0);
+crate::<f64 as float::FloatCore>::classify(p0);
+<f64>::classify(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::floor
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.floor();
+<f64 as float::FloatCore>::floor(p0);
+crate::<f64 as float::FloatCore>::floor(p0);
+<f64>::floor(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::ceil
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.ceil();
+<f64 as float::FloatCore>::ceil(p0);
+crate::<f64 as float::FloatCore>::ceil(p0);
+<f64>::ceil(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::round
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.round();
+<f64 as float::FloatCore>::round(p0);
+crate::<f64 as float::FloatCore>::round(p0);
+<f64>::round(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::trunc
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.trunc();
+<f64 as float::FloatCore>::trunc(p0);
+crate::<f64 as float::FloatCore>::trunc(p0);
+<f64>::trunc(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::fract
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.fract();
+<f64 as float::FloatCore>::fract(p0);
+crate::<f64 as float::FloatCore>::fract(p0);
+<f64>::fract(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::abs
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.abs();
+<f64 as float::FloatCore>::abs(p0);
+crate::<f64 as float::FloatCore>::abs(p0);
+<f64>::abs(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::signum
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.signum();
+<f64 as float::FloatCore>::signum(p0);
+crate::<f64 as float::FloatCore>::signum(p0);
+<f64>::signum(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::is_sign_positive
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_sign_positive();
+<f64 as float::FloatCore>::is_sign_positive(p0);
+crate::<f64 as float::FloatCore>::is_sign_positive(p0);
+<f64>::is_sign_positive(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::is_sign_negative
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_sign_negative();
+<f64 as float::FloatCore>::is_sign_negative(p0);
+crate::<f64 as float::FloatCore>::is_sign_negative(p0);
+<f64>::is_sign_negative(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::min
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.min(p1);
+<f64 as float::FloatCore>::min(p0, p1);
+crate::<f64 as float::FloatCore>::min(p0, p1);
+<f64>::min(p0, p1);
-----------------
src/macros.rs <f64 as float::FloatCore>::max
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.max(p1);
+<f64 as float::FloatCore>::max(p0, p1);
+crate::<f64 as float::FloatCore>::max(p0, p1);
+<f64>::max(p0, p1);
-----------------
src/macros.rs <f64 as float::FloatCore>::recip
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.recip();
+<f64 as float::FloatCore>::recip(p0);
+crate::<f64 as float::FloatCore>::recip(p0);
+<f64>::recip(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::powi
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0i32; // None+i32
+p0.powi(p1);
+<f64 as float::FloatCore>::powi(p0, p1);
+crate::<f64 as float::FloatCore>::powi(p0, p1);
+<f64>::powi(p0, p1);
-----------------
src/macros.rs <f64 as float::FloatCore>::to_degrees
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.to_degrees();
+<f64 as float::FloatCore>::to_degrees(p0);
+crate::<f64 as float::FloatCore>::to_degrees(p0);
+<f64>::to_degrees(p0);
-----------------
src/macros.rs <f64 as float::FloatCore>::to_radians
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.to_radians();
+<f64 as float::FloatCore>::to_radians(p0);
+crate::<f64 as float::FloatCore>::to_radians(p0);
+<f64>::to_radians(p0);
-----------------
src/macros.rs <f32 as float::Float>::nan
deps:{}
candidates:{}
+<f32 as float::Float>::nan();
+crate::<f32 as float::Float>::nan();
+<f32>::nan();
-----------------
src/macros.rs <f32 as float::Float>::infinity
deps:{}
candidates:{}
+<f32 as float::Float>::infinity();
+crate::<f32 as float::Float>::infinity();
+<f32>::infinity();
-----------------
src/macros.rs <f32 as float::Float>::neg_infinity
deps:{}
candidates:{}
+<f32 as float::Float>::neg_infinity();
+crate::<f32 as float::Float>::neg_infinity();
+<f32>::neg_infinity();
-----------------
src/macros.rs <f32 as float::Float>::neg_zero
deps:{}
candidates:{}
+<f32 as float::Float>::neg_zero();
+crate::<f32 as float::Float>::neg_zero();
+<f32>::neg_zero();
-----------------
src/macros.rs <f32 as float::Float>::min_value
deps:{}
candidates:{}
+<f32 as float::Float>::min_value();
+crate::<f32 as float::Float>::min_value();
+<f32>::min_value();
-----------------
src/macros.rs <f32 as float::Float>::min_positive_value
deps:{}
candidates:{}
+<f32 as float::Float>::min_positive_value();
+crate::<f32 as float::Float>::min_positive_value();
+<f32>::min_positive_value();
-----------------
src/macros.rs <f32 as float::Float>::epsilon
deps:{}
candidates:{}
+<f32 as float::Float>::epsilon();
+crate::<f32 as float::Float>::epsilon();
+<f32>::epsilon();
-----------------
src/macros.rs <f32 as float::Float>::max_value
deps:{}
candidates:{}
+<f32 as float::Float>::max_value();
+crate::<f32 as float::Float>::max_value();
+<f32>::max_value();
-----------------
src/float.rs <f32 as float::Float>::abs_sub
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.abs_sub(p1);
+<f32 as float::Float>::abs_sub(p0, p1);
+crate::<f32 as float::Float>::abs_sub(p0, p1);
+<f32>::abs_sub(p0, p1);
-----------------
src/float.rs <f32 as float::Float>::integer_decode
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.integer_decode();
+<f32 as float::Float>::integer_decode(p0);
+crate::<f32 as float::Float>::integer_decode(p0);
+<f32>::integer_decode(p0);
-----------------
src/macros.rs <f32 as float::Float>::is_nan
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_nan();
+<f32 as float::Float>::is_nan(p0);
+crate::<f32 as float::Float>::is_nan(p0);
+<f32>::is_nan(p0);
-----------------
src/macros.rs <f32 as float::Float>::is_infinite
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_infinite();
+<f32 as float::Float>::is_infinite(p0);
+crate::<f32 as float::Float>::is_infinite(p0);
+<f32>::is_infinite(p0);
-----------------
src/macros.rs <f32 as float::Float>::is_finite
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_finite();
+<f32 as float::Float>::is_finite(p0);
+crate::<f32 as float::Float>::is_finite(p0);
+<f32>::is_finite(p0);
-----------------
src/macros.rs <f32 as float::Float>::is_normal
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_normal();
+<f32 as float::Float>::is_normal(p0);
+crate::<f32 as float::Float>::is_normal(p0);
+<f32>::is_normal(p0);
-----------------
src/macros.rs <f32 as float::Float>::classify
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.classify();
+<f32 as float::Float>::classify(p0);
+crate::<f32 as float::Float>::classify(p0);
+<f32>::classify(p0);
-----------------
src/macros.rs <f32 as float::Float>::floor
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.floor();
+<f32 as float::Float>::floor(p0);
+crate::<f32 as float::Float>::floor(p0);
+<f32>::floor(p0);
-----------------
src/macros.rs <f32 as float::Float>::ceil
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.ceil();
+<f32 as float::Float>::ceil(p0);
+crate::<f32 as float::Float>::ceil(p0);
+<f32>::ceil(p0);
-----------------
src/macros.rs <f32 as float::Float>::round
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.round();
+<f32 as float::Float>::round(p0);
+crate::<f32 as float::Float>::round(p0);
+<f32>::round(p0);
-----------------
src/macros.rs <f32 as float::Float>::trunc
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.trunc();
+<f32 as float::Float>::trunc(p0);
+crate::<f32 as float::Float>::trunc(p0);
+<f32>::trunc(p0);
-----------------
src/macros.rs <f32 as float::Float>::fract
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.fract();
+<f32 as float::Float>::fract(p0);
+crate::<f32 as float::Float>::fract(p0);
+<f32>::fract(p0);
-----------------
src/macros.rs <f32 as float::Float>::abs
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.abs();
+<f32 as float::Float>::abs(p0);
+crate::<f32 as float::Float>::abs(p0);
+<f32>::abs(p0);
-----------------
src/macros.rs <f32 as float::Float>::signum
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.signum();
+<f32 as float::Float>::signum(p0);
+crate::<f32 as float::Float>::signum(p0);
+<f32>::signum(p0);
-----------------
src/macros.rs <f32 as float::Float>::is_sign_positive
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_sign_positive();
+<f32 as float::Float>::is_sign_positive(p0);
+crate::<f32 as float::Float>::is_sign_positive(p0);
+<f32>::is_sign_positive(p0);
-----------------
src/macros.rs <f32 as float::Float>::is_sign_negative
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.is_sign_negative();
+<f32 as float::Float>::is_sign_negative(p0);
+crate::<f32 as float::Float>::is_sign_negative(p0);
+<f32>::is_sign_negative(p0);
-----------------
src/macros.rs <f32 as float::Float>::mul_add
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
let mut p2 = 0f32; // None+f32
+p0.mul_add(p1, p2);
+<f32 as float::Float>::mul_add(p0, p1, p2);
+crate::<f32 as float::Float>::mul_add(p0, p1, p2);
+<f32>::mul_add(p0, p1, p2);
-----------------
src/macros.rs <f32 as float::Float>::recip
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.recip();
+<f32 as float::Float>::recip(p0);
+crate::<f32 as float::Float>::recip(p0);
+<f32>::recip(p0);
-----------------
src/macros.rs <f32 as float::Float>::powi
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0i32; // None+i32
+p0.powi(p1);
+<f32 as float::Float>::powi(p0, p1);
+crate::<f32 as float::Float>::powi(p0, p1);
+<f32>::powi(p0, p1);
-----------------
src/macros.rs <f32 as float::Float>::powf
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.powf(p1);
+<f32 as float::Float>::powf(p0, p1);
+crate::<f32 as float::Float>::powf(p0, p1);
+<f32>::powf(p0, p1);
-----------------
src/macros.rs <f32 as float::Float>::sqrt
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.sqrt();
+<f32 as float::Float>::sqrt(p0);
+crate::<f32 as float::Float>::sqrt(p0);
+<f32>::sqrt(p0);
-----------------
src/macros.rs <f32 as float::Float>::exp
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.exp();
+<f32 as float::Float>::exp(p0);
+crate::<f32 as float::Float>::exp(p0);
+<f32>::exp(p0);
-----------------
src/macros.rs <f32 as float::Float>::exp2
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.exp2();
+<f32 as float::Float>::exp2(p0);
+crate::<f32 as float::Float>::exp2(p0);
+<f32>::exp2(p0);
-----------------
src/macros.rs <f32 as float::Float>::ln
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.ln();
+<f32 as float::Float>::ln(p0);
+crate::<f32 as float::Float>::ln(p0);
+<f32>::ln(p0);
-----------------
src/macros.rs <f32 as float::Float>::log
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.log(p1);
+<f32 as float::Float>::log(p0, p1);
+crate::<f32 as float::Float>::log(p0, p1);
+<f32>::log(p0, p1);
-----------------
src/macros.rs <f32 as float::Float>::log2
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.log2();
+<f32 as float::Float>::log2(p0);
+crate::<f32 as float::Float>::log2(p0);
+<f32>::log2(p0);
-----------------
src/macros.rs <f32 as float::Float>::log10
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.log10();
+<f32 as float::Float>::log10(p0);
+crate::<f32 as float::Float>::log10(p0);
+<f32>::log10(p0);
-----------------
src/macros.rs <f32 as float::Float>::to_degrees
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.to_degrees();
+<f32 as float::Float>::to_degrees(p0);
+crate::<f32 as float::Float>::to_degrees(p0);
+<f32>::to_degrees(p0);
-----------------
src/macros.rs <f32 as float::Float>::to_radians
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.to_radians();
+<f32 as float::Float>::to_radians(p0);
+crate::<f32 as float::Float>::to_radians(p0);
+<f32>::to_radians(p0);
-----------------
src/macros.rs <f32 as float::Float>::max
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.max(p1);
+<f32 as float::Float>::max(p0, p1);
+crate::<f32 as float::Float>::max(p0, p1);
+<f32>::max(p0, p1);
-----------------
src/macros.rs <f32 as float::Float>::min
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.min(p1);
+<f32 as float::Float>::min(p0, p1);
+crate::<f32 as float::Float>::min(p0, p1);
+<f32>::min(p0, p1);
-----------------
src/macros.rs <f32 as float::Float>::cbrt
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.cbrt();
+<f32 as float::Float>::cbrt(p0);
+crate::<f32 as float::Float>::cbrt(p0);
+<f32>::cbrt(p0);
-----------------
src/macros.rs <f32 as float::Float>::hypot
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.hypot(p1);
+<f32 as float::Float>::hypot(p0, p1);
+crate::<f32 as float::Float>::hypot(p0, p1);
+<f32>::hypot(p0, p1);
-----------------
src/macros.rs <f32 as float::Float>::sin
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.sin();
+<f32 as float::Float>::sin(p0);
+crate::<f32 as float::Float>::sin(p0);
+<f32>::sin(p0);
-----------------
src/macros.rs <f32 as float::Float>::cos
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.cos();
+<f32 as float::Float>::cos(p0);
+crate::<f32 as float::Float>::cos(p0);
+<f32>::cos(p0);
-----------------
src/macros.rs <f32 as float::Float>::tan
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.tan();
+<f32 as float::Float>::tan(p0);
+crate::<f32 as float::Float>::tan(p0);
+<f32>::tan(p0);
-----------------
src/macros.rs <f32 as float::Float>::asin
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.asin();
+<f32 as float::Float>::asin(p0);
+crate::<f32 as float::Float>::asin(p0);
+<f32>::asin(p0);
-----------------
src/macros.rs <f32 as float::Float>::acos
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.acos();
+<f32 as float::Float>::acos(p0);
+crate::<f32 as float::Float>::acos(p0);
+<f32>::acos(p0);
-----------------
src/macros.rs <f32 as float::Float>::atan
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.atan();
+<f32 as float::Float>::atan(p0);
+crate::<f32 as float::Float>::atan(p0);
+<f32>::atan(p0);
-----------------
src/macros.rs <f32 as float::Float>::atan2
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.atan2(p1);
+<f32 as float::Float>::atan2(p0, p1);
+crate::<f32 as float::Float>::atan2(p0, p1);
+<f32>::atan2(p0, p1);
-----------------
src/macros.rs <f32 as float::Float>::sin_cos
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.sin_cos();
+<f32 as float::Float>::sin_cos(p0);
+crate::<f32 as float::Float>::sin_cos(p0);
+<f32>::sin_cos(p0);
-----------------
src/macros.rs <f32 as float::Float>::exp_m1
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.exp_m1();
+<f32 as float::Float>::exp_m1(p0);
+crate::<f32 as float::Float>::exp_m1(p0);
+<f32>::exp_m1(p0);
-----------------
src/macros.rs <f32 as float::Float>::ln_1p
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.ln_1p();
+<f32 as float::Float>::ln_1p(p0);
+crate::<f32 as float::Float>::ln_1p(p0);
+<f32>::ln_1p(p0);
-----------------
src/macros.rs <f32 as float::Float>::sinh
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.sinh();
+<f32 as float::Float>::sinh(p0);
+crate::<f32 as float::Float>::sinh(p0);
+<f32>::sinh(p0);
-----------------
src/macros.rs <f32 as float::Float>::cosh
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.cosh();
+<f32 as float::Float>::cosh(p0);
+crate::<f32 as float::Float>::cosh(p0);
+<f32>::cosh(p0);
-----------------
src/macros.rs <f32 as float::Float>::tanh
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.tanh();
+<f32 as float::Float>::tanh(p0);
+crate::<f32 as float::Float>::tanh(p0);
+<f32>::tanh(p0);
-----------------
src/macros.rs <f32 as float::Float>::asinh
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.asinh();
+<f32 as float::Float>::asinh(p0);
+crate::<f32 as float::Float>::asinh(p0);
+<f32>::asinh(p0);
-----------------
src/macros.rs <f32 as float::Float>::acosh
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.acosh();
+<f32 as float::Float>::acosh(p0);
+crate::<f32 as float::Float>::acosh(p0);
+<f32>::acosh(p0);
-----------------
src/macros.rs <f32 as float::Float>::atanh
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.atanh();
+<f32 as float::Float>::atanh(p0);
+crate::<f32 as float::Float>::atanh(p0);
+<f32>::atanh(p0);
-----------------
src/float.rs <f32 as float::Float>::copysign
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.copysign(p1);
+<f32 as float::Float>::copysign(p0, p1);
+crate::<f32 as float::Float>::copysign(p0, p1);
+<f32>::copysign(p0, p1);
-----------------
src/macros.rs <f64 as float::Float>::nan
deps:{}
candidates:{}
+<f64 as float::Float>::nan();
+crate::<f64 as float::Float>::nan();
+<f64>::nan();
-----------------
src/macros.rs <f64 as float::Float>::infinity
deps:{}
candidates:{}
+<f64 as float::Float>::infinity();
+crate::<f64 as float::Float>::infinity();
+<f64>::infinity();
-----------------
src/macros.rs <f64 as float::Float>::neg_infinity
deps:{}
candidates:{}
+<f64 as float::Float>::neg_infinity();
+crate::<f64 as float::Float>::neg_infinity();
+<f64>::neg_infinity();
-----------------
src/macros.rs <f64 as float::Float>::neg_zero
deps:{}
candidates:{}
+<f64 as float::Float>::neg_zero();
+crate::<f64 as float::Float>::neg_zero();
+<f64>::neg_zero();
-----------------
src/macros.rs <f64 as float::Float>::min_value
deps:{}
candidates:{}
+<f64 as float::Float>::min_value();
+crate::<f64 as float::Float>::min_value();
+<f64>::min_value();
-----------------
src/macros.rs <f64 as float::Float>::min_positive_value
deps:{}
candidates:{}
+<f64 as float::Float>::min_positive_value();
+crate::<f64 as float::Float>::min_positive_value();
+<f64>::min_positive_value();
-----------------
src/macros.rs <f64 as float::Float>::epsilon
deps:{}
candidates:{}
+<f64 as float::Float>::epsilon();
+crate::<f64 as float::Float>::epsilon();
+<f64>::epsilon();
-----------------
src/macros.rs <f64 as float::Float>::max_value
deps:{}
candidates:{}
+<f64 as float::Float>::max_value();
+crate::<f64 as float::Float>::max_value();
+<f64>::max_value();
-----------------
src/float.rs <f64 as float::Float>::abs_sub
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.abs_sub(p1);
+<f64 as float::Float>::abs_sub(p0, p1);
+crate::<f64 as float::Float>::abs_sub(p0, p1);
+<f64>::abs_sub(p0, p1);
-----------------
src/float.rs <f64 as float::Float>::integer_decode
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.integer_decode();
+<f64 as float::Float>::integer_decode(p0);
+crate::<f64 as float::Float>::integer_decode(p0);
+<f64>::integer_decode(p0);
-----------------
src/macros.rs <f64 as float::Float>::is_nan
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_nan();
+<f64 as float::Float>::is_nan(p0);
+crate::<f64 as float::Float>::is_nan(p0);
+<f64>::is_nan(p0);
-----------------
src/macros.rs <f64 as float::Float>::is_infinite
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_infinite();
+<f64 as float::Float>::is_infinite(p0);
+crate::<f64 as float::Float>::is_infinite(p0);
+<f64>::is_infinite(p0);
-----------------
src/macros.rs <f64 as float::Float>::is_finite
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_finite();
+<f64 as float::Float>::is_finite(p0);
+crate::<f64 as float::Float>::is_finite(p0);
+<f64>::is_finite(p0);
-----------------
src/macros.rs <f64 as float::Float>::is_normal
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_normal();
+<f64 as float::Float>::is_normal(p0);
+crate::<f64 as float::Float>::is_normal(p0);
+<f64>::is_normal(p0);
-----------------
src/macros.rs <f64 as float::Float>::classify
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.classify();
+<f64 as float::Float>::classify(p0);
+crate::<f64 as float::Float>::classify(p0);
+<f64>::classify(p0);
-----------------
src/macros.rs <f64 as float::Float>::floor
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.floor();
+<f64 as float::Float>::floor(p0);
+crate::<f64 as float::Float>::floor(p0);
+<f64>::floor(p0);
-----------------
src/macros.rs <f64 as float::Float>::ceil
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.ceil();
+<f64 as float::Float>::ceil(p0);
+crate::<f64 as float::Float>::ceil(p0);
+<f64>::ceil(p0);
-----------------
src/macros.rs <f64 as float::Float>::round
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.round();
+<f64 as float::Float>::round(p0);
+crate::<f64 as float::Float>::round(p0);
+<f64>::round(p0);
-----------------
src/macros.rs <f64 as float::Float>::trunc
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.trunc();
+<f64 as float::Float>::trunc(p0);
+crate::<f64 as float::Float>::trunc(p0);
+<f64>::trunc(p0);
-----------------
src/macros.rs <f64 as float::Float>::fract
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.fract();
+<f64 as float::Float>::fract(p0);
+crate::<f64 as float::Float>::fract(p0);
+<f64>::fract(p0);
-----------------
src/macros.rs <f64 as float::Float>::abs
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.abs();
+<f64 as float::Float>::abs(p0);
+crate::<f64 as float::Float>::abs(p0);
+<f64>::abs(p0);
-----------------
src/macros.rs <f64 as float::Float>::signum
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.signum();
+<f64 as float::Float>::signum(p0);
+crate::<f64 as float::Float>::signum(p0);
+<f64>::signum(p0);
-----------------
src/macros.rs <f64 as float::Float>::is_sign_positive
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_sign_positive();
+<f64 as float::Float>::is_sign_positive(p0);
+crate::<f64 as float::Float>::is_sign_positive(p0);
+<f64>::is_sign_positive(p0);
-----------------
src/macros.rs <f64 as float::Float>::is_sign_negative
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.is_sign_negative();
+<f64 as float::Float>::is_sign_negative(p0);
+crate::<f64 as float::Float>::is_sign_negative(p0);
+<f64>::is_sign_negative(p0);
-----------------
src/macros.rs <f64 as float::Float>::mul_add
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
let mut p2 = 0f64; // None+f64
+p0.mul_add(p1, p2);
+<f64 as float::Float>::mul_add(p0, p1, p2);
+crate::<f64 as float::Float>::mul_add(p0, p1, p2);
+<f64>::mul_add(p0, p1, p2);
-----------------
src/macros.rs <f64 as float::Float>::recip
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.recip();
+<f64 as float::Float>::recip(p0);
+crate::<f64 as float::Float>::recip(p0);
+<f64>::recip(p0);
-----------------
src/macros.rs <f64 as float::Float>::powi
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0i32; // None+i32
+p0.powi(p1);
+<f64 as float::Float>::powi(p0, p1);
+crate::<f64 as float::Float>::powi(p0, p1);
+<f64>::powi(p0, p1);
-----------------
src/macros.rs <f64 as float::Float>::powf
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.powf(p1);
+<f64 as float::Float>::powf(p0, p1);
+crate::<f64 as float::Float>::powf(p0, p1);
+<f64>::powf(p0, p1);
-----------------
src/macros.rs <f64 as float::Float>::sqrt
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.sqrt();
+<f64 as float::Float>::sqrt(p0);
+crate::<f64 as float::Float>::sqrt(p0);
+<f64>::sqrt(p0);
-----------------
src/macros.rs <f64 as float::Float>::exp
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.exp();
+<f64 as float::Float>::exp(p0);
+crate::<f64 as float::Float>::exp(p0);
+<f64>::exp(p0);
-----------------
src/macros.rs <f64 as float::Float>::exp2
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.exp2();
+<f64 as float::Float>::exp2(p0);
+crate::<f64 as float::Float>::exp2(p0);
+<f64>::exp2(p0);
-----------------
src/macros.rs <f64 as float::Float>::ln
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.ln();
+<f64 as float::Float>::ln(p0);
+crate::<f64 as float::Float>::ln(p0);
+<f64>::ln(p0);
-----------------
src/macros.rs <f64 as float::Float>::log
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.log(p1);
+<f64 as float::Float>::log(p0, p1);
+crate::<f64 as float::Float>::log(p0, p1);
+<f64>::log(p0, p1);
-----------------
src/macros.rs <f64 as float::Float>::log2
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.log2();
+<f64 as float::Float>::log2(p0);
+crate::<f64 as float::Float>::log2(p0);
+<f64>::log2(p0);
-----------------
src/macros.rs <f64 as float::Float>::log10
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.log10();
+<f64 as float::Float>::log10(p0);
+crate::<f64 as float::Float>::log10(p0);
+<f64>::log10(p0);
-----------------
src/macros.rs <f64 as float::Float>::to_degrees
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.to_degrees();
+<f64 as float::Float>::to_degrees(p0);
+crate::<f64 as float::Float>::to_degrees(p0);
+<f64>::to_degrees(p0);
-----------------
src/macros.rs <f64 as float::Float>::to_radians
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.to_radians();
+<f64 as float::Float>::to_radians(p0);
+crate::<f64 as float::Float>::to_radians(p0);
+<f64>::to_radians(p0);
-----------------
src/macros.rs <f64 as float::Float>::max
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.max(p1);
+<f64 as float::Float>::max(p0, p1);
+crate::<f64 as float::Float>::max(p0, p1);
+<f64>::max(p0, p1);
-----------------
src/macros.rs <f64 as float::Float>::min
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.min(p1);
+<f64 as float::Float>::min(p0, p1);
+crate::<f64 as float::Float>::min(p0, p1);
+<f64>::min(p0, p1);
-----------------
src/macros.rs <f64 as float::Float>::cbrt
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.cbrt();
+<f64 as float::Float>::cbrt(p0);
+crate::<f64 as float::Float>::cbrt(p0);
+<f64>::cbrt(p0);
-----------------
src/macros.rs <f64 as float::Float>::hypot
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.hypot(p1);
+<f64 as float::Float>::hypot(p0, p1);
+crate::<f64 as float::Float>::hypot(p0, p1);
+<f64>::hypot(p0, p1);
-----------------
src/macros.rs <f64 as float::Float>::sin
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.sin();
+<f64 as float::Float>::sin(p0);
+crate::<f64 as float::Float>::sin(p0);
+<f64>::sin(p0);
-----------------
src/macros.rs <f64 as float::Float>::cos
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.cos();
+<f64 as float::Float>::cos(p0);
+crate::<f64 as float::Float>::cos(p0);
+<f64>::cos(p0);
-----------------
src/macros.rs <f64 as float::Float>::tan
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.tan();
+<f64 as float::Float>::tan(p0);
+crate::<f64 as float::Float>::tan(p0);
+<f64>::tan(p0);
-----------------
src/macros.rs <f64 as float::Float>::asin
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.asin();
+<f64 as float::Float>::asin(p0);
+crate::<f64 as float::Float>::asin(p0);
+<f64>::asin(p0);
-----------------
src/macros.rs <f64 as float::Float>::acos
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.acos();
+<f64 as float::Float>::acos(p0);
+crate::<f64 as float::Float>::acos(p0);
+<f64>::acos(p0);
-----------------
src/macros.rs <f64 as float::Float>::atan
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.atan();
+<f64 as float::Float>::atan(p0);
+crate::<f64 as float::Float>::atan(p0);
+<f64>::atan(p0);
-----------------
src/macros.rs <f64 as float::Float>::atan2
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.atan2(p1);
+<f64 as float::Float>::atan2(p0, p1);
+crate::<f64 as float::Float>::atan2(p0, p1);
+<f64>::atan2(p0, p1);
-----------------
src/macros.rs <f64 as float::Float>::sin_cos
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.sin_cos();
+<f64 as float::Float>::sin_cos(p0);
+crate::<f64 as float::Float>::sin_cos(p0);
+<f64>::sin_cos(p0);
-----------------
src/macros.rs <f64 as float::Float>::exp_m1
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.exp_m1();
+<f64 as float::Float>::exp_m1(p0);
+crate::<f64 as float::Float>::exp_m1(p0);
+<f64>::exp_m1(p0);
-----------------
src/macros.rs <f64 as float::Float>::ln_1p
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.ln_1p();
+<f64 as float::Float>::ln_1p(p0);
+crate::<f64 as float::Float>::ln_1p(p0);
+<f64>::ln_1p(p0);
-----------------
src/macros.rs <f64 as float::Float>::sinh
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.sinh();
+<f64 as float::Float>::sinh(p0);
+crate::<f64 as float::Float>::sinh(p0);
+<f64>::sinh(p0);
-----------------
src/macros.rs <f64 as float::Float>::cosh
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.cosh();
+<f64 as float::Float>::cosh(p0);
+crate::<f64 as float::Float>::cosh(p0);
+<f64>::cosh(p0);
-----------------
src/macros.rs <f64 as float::Float>::tanh
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.tanh();
+<f64 as float::Float>::tanh(p0);
+crate::<f64 as float::Float>::tanh(p0);
+<f64>::tanh(p0);
-----------------
src/macros.rs <f64 as float::Float>::asinh
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.asinh();
+<f64 as float::Float>::asinh(p0);
+crate::<f64 as float::Float>::asinh(p0);
+<f64>::asinh(p0);
-----------------
src/macros.rs <f64 as float::Float>::acosh
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.acosh();
+<f64 as float::Float>::acosh(p0);
+crate::<f64 as float::Float>::acosh(p0);
+<f64>::acosh(p0);
-----------------
src/macros.rs <f64 as float::Float>::atanh
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.atanh();
+<f64 as float::Float>::atanh(p0);
+crate::<f64 as float::Float>::atanh(p0);
+<f64>::atanh(p0);
-----------------
src/float.rs <f64 as float::Float>::copysign
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.copysign(p1);
+<f64 as float::Float>::copysign(p0, p1);
+crate::<f64 as float::Float>::copysign(p0, p1);
+<f64>::copysign(p0, p1);
-----------------
src/macros.rs <f32 as float::FloatConst>::E
deps:{}
candidates:{}
+<f32 as float::FloatConst>::E();
+crate::<f32 as float::FloatConst>::E();
+<f32>::E();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_1_PI
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_1_PI();
+crate::<f32 as float::FloatConst>::FRAC_1_PI();
+<f32>::FRAC_1_PI();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_1_SQRT_2
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_1_SQRT_2();
+crate::<f32 as float::FloatConst>::FRAC_1_SQRT_2();
+<f32>::FRAC_1_SQRT_2();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_2_PI
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_2_PI();
+crate::<f32 as float::FloatConst>::FRAC_2_PI();
+<f32>::FRAC_2_PI();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_2_SQRT_PI
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_2_SQRT_PI();
+crate::<f32 as float::FloatConst>::FRAC_2_SQRT_PI();
+<f32>::FRAC_2_SQRT_PI();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_PI_2
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_PI_2();
+crate::<f32 as float::FloatConst>::FRAC_PI_2();
+<f32>::FRAC_PI_2();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_PI_3
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_PI_3();
+crate::<f32 as float::FloatConst>::FRAC_PI_3();
+<f32>::FRAC_PI_3();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_PI_4
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_PI_4();
+crate::<f32 as float::FloatConst>::FRAC_PI_4();
+<f32>::FRAC_PI_4();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_PI_6
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_PI_6();
+crate::<f32 as float::FloatConst>::FRAC_PI_6();
+<f32>::FRAC_PI_6();
-----------------
src/macros.rs <f32 as float::FloatConst>::FRAC_PI_8
deps:{}
candidates:{}
+<f32 as float::FloatConst>::FRAC_PI_8();
+crate::<f32 as float::FloatConst>::FRAC_PI_8();
+<f32>::FRAC_PI_8();
-----------------
src/macros.rs <f32 as float::FloatConst>::LN_10
deps:{}
candidates:{}
+<f32 as float::FloatConst>::LN_10();
+crate::<f32 as float::FloatConst>::LN_10();
+<f32>::LN_10();
-----------------
src/macros.rs <f32 as float::FloatConst>::LN_2
deps:{}
candidates:{}
+<f32 as float::FloatConst>::LN_2();
+crate::<f32 as float::FloatConst>::LN_2();
+<f32>::LN_2();
-----------------
src/macros.rs <f32 as float::FloatConst>::LOG10_E
deps:{}
candidates:{}
+<f32 as float::FloatConst>::LOG10_E();
+crate::<f32 as float::FloatConst>::LOG10_E();
+<f32>::LOG10_E();
-----------------
src/macros.rs <f32 as float::FloatConst>::LOG2_E
deps:{}
candidates:{}
+<f32 as float::FloatConst>::LOG2_E();
+crate::<f32 as float::FloatConst>::LOG2_E();
+<f32>::LOG2_E();
-----------------
src/macros.rs <f32 as float::FloatConst>::PI
deps:{}
candidates:{}
+<f32 as float::FloatConst>::PI();
+crate::<f32 as float::FloatConst>::PI();
+<f32>::PI();
-----------------
src/macros.rs <f32 as float::FloatConst>::SQRT_2
deps:{}
candidates:{}
+<f32 as float::FloatConst>::SQRT_2();
+crate::<f32 as float::FloatConst>::SQRT_2();
+<f32>::SQRT_2();
-----------------
src/macros.rs <f32 as float::FloatConst>::TAU
deps:{}
candidates:{}
+<f32 as float::FloatConst>::TAU();
+crate::<f32 as float::FloatConst>::TAU();
+<f32>::TAU();
-----------------
src/macros.rs <f32 as float::FloatConst>::LOG10_2
deps:{}
candidates:{}
+<f32 as float::FloatConst>::LOG10_2();
+crate::<f32 as float::FloatConst>::LOG10_2();
+<f32>::LOG10_2();
-----------------
src/macros.rs <f32 as float::FloatConst>::LOG2_10
deps:{}
candidates:{}
+<f32 as float::FloatConst>::LOG2_10();
+crate::<f32 as float::FloatConst>::LOG2_10();
+<f32>::LOG2_10();
-----------------
src/macros.rs <f64 as float::FloatConst>::E
deps:{}
candidates:{}
+<f64 as float::FloatConst>::E();
+crate::<f64 as float::FloatConst>::E();
+<f64>::E();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_1_PI
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_1_PI();
+crate::<f64 as float::FloatConst>::FRAC_1_PI();
+<f64>::FRAC_1_PI();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_1_SQRT_2
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_1_SQRT_2();
+crate::<f64 as float::FloatConst>::FRAC_1_SQRT_2();
+<f64>::FRAC_1_SQRT_2();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_2_PI
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_2_PI();
+crate::<f64 as float::FloatConst>::FRAC_2_PI();
+<f64>::FRAC_2_PI();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_2_SQRT_PI
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_2_SQRT_PI();
+crate::<f64 as float::FloatConst>::FRAC_2_SQRT_PI();
+<f64>::FRAC_2_SQRT_PI();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_PI_2
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_PI_2();
+crate::<f64 as float::FloatConst>::FRAC_PI_2();
+<f64>::FRAC_PI_2();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_PI_3
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_PI_3();
+crate::<f64 as float::FloatConst>::FRAC_PI_3();
+<f64>::FRAC_PI_3();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_PI_4
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_PI_4();
+crate::<f64 as float::FloatConst>::FRAC_PI_4();
+<f64>::FRAC_PI_4();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_PI_6
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_PI_6();
+crate::<f64 as float::FloatConst>::FRAC_PI_6();
+<f64>::FRAC_PI_6();
-----------------
src/macros.rs <f64 as float::FloatConst>::FRAC_PI_8
deps:{}
candidates:{}
+<f64 as float::FloatConst>::FRAC_PI_8();
+crate::<f64 as float::FloatConst>::FRAC_PI_8();
+<f64>::FRAC_PI_8();
-----------------
src/macros.rs <f64 as float::FloatConst>::LN_10
deps:{}
candidates:{}
+<f64 as float::FloatConst>::LN_10();
+crate::<f64 as float::FloatConst>::LN_10();
+<f64>::LN_10();
-----------------
src/macros.rs <f64 as float::FloatConst>::LN_2
deps:{}
candidates:{}
+<f64 as float::FloatConst>::LN_2();
+crate::<f64 as float::FloatConst>::LN_2();
+<f64>::LN_2();
-----------------
src/macros.rs <f64 as float::FloatConst>::LOG10_E
deps:{}
candidates:{}
+<f64 as float::FloatConst>::LOG10_E();
+crate::<f64 as float::FloatConst>::LOG10_E();
+<f64>::LOG10_E();
-----------------
src/macros.rs <f64 as float::FloatConst>::LOG2_E
deps:{}
candidates:{}
+<f64 as float::FloatConst>::LOG2_E();
+crate::<f64 as float::FloatConst>::LOG2_E();
+<f64>::LOG2_E();
-----------------
src/macros.rs <f64 as float::FloatConst>::PI
deps:{}
candidates:{}
+<f64 as float::FloatConst>::PI();
+crate::<f64 as float::FloatConst>::PI();
+<f64>::PI();
-----------------
src/macros.rs <f64 as float::FloatConst>::SQRT_2
deps:{}
candidates:{}
+<f64 as float::FloatConst>::SQRT_2();
+crate::<f64 as float::FloatConst>::SQRT_2();
+<f64>::SQRT_2();
-----------------
src/macros.rs <f64 as float::FloatConst>::TAU
deps:{}
candidates:{}
+<f64 as float::FloatConst>::TAU();
+crate::<f64 as float::FloatConst>::TAU();
+<f64>::TAU();
-----------------
src/macros.rs <f64 as float::FloatConst>::LOG10_2
deps:{}
candidates:{}
+<f64 as float::FloatConst>::LOG10_2();
+crate::<f64 as float::FloatConst>::LOG10_2();
+<f64>::LOG10_2();
-----------------
src/macros.rs <f64 as float::FloatConst>::LOG2_10
deps:{}
candidates:{}
+<f64 as float::FloatConst>::LOG2_10();
+crate::<f64 as float::FloatConst>::LOG2_10();
+<f64>::LOG2_10();
-----------------
src/identities.rs <usize as identities::Zero>::zero
deps:{}
candidates:{}
+<usize as identities::Zero>::zero();
+crate::<usize as identities::Zero>::zero();
+<usize>::zero();
-----------------
src/identities.rs <usize as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.is_zero();
+<usize as identities::Zero>::is_zero(p0);
+crate::<usize as identities::Zero>::is_zero(p0);
+<usize>::is_zero(p0);
-----------------
src/identities.rs <u8 as identities::Zero>::zero
deps:{}
candidates:{}
+<u8 as identities::Zero>::zero();
+crate::<u8 as identities::Zero>::zero();
+<u8>::zero();
-----------------
src/identities.rs <u8 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_zero();
+<u8 as identities::Zero>::is_zero(p0);
+crate::<u8 as identities::Zero>::is_zero(p0);
+<u8>::is_zero(p0);
-----------------
src/identities.rs <u16 as identities::Zero>::zero
deps:{}
candidates:{}
+<u16 as identities::Zero>::zero();
+crate::<u16 as identities::Zero>::zero();
+<u16>::zero();
-----------------
src/identities.rs <u16 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.is_zero();
+<u16 as identities::Zero>::is_zero(p0);
+crate::<u16 as identities::Zero>::is_zero(p0);
+<u16>::is_zero(p0);
-----------------
src/identities.rs <u32 as identities::Zero>::zero
deps:{}
candidates:{}
+<u32 as identities::Zero>::zero();
+crate::<u32 as identities::Zero>::zero();
+<u32>::zero();
-----------------
src/identities.rs <u32 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.is_zero();
+<u32 as identities::Zero>::is_zero(p0);
+crate::<u32 as identities::Zero>::is_zero(p0);
+<u32>::is_zero(p0);
-----------------
src/identities.rs <u64 as identities::Zero>::zero
deps:{}
candidates:{}
+<u64 as identities::Zero>::zero();
+crate::<u64 as identities::Zero>::zero();
+<u64>::zero();
-----------------
src/identities.rs <u64 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.is_zero();
+<u64 as identities::Zero>::is_zero(p0);
+crate::<u64 as identities::Zero>::is_zero(p0);
+<u64>::is_zero(p0);
-----------------
src/identities.rs <u128 as identities::Zero>::zero
deps:{}
candidates:{}
+<u128 as identities::Zero>::zero();
+crate::<u128 as identities::Zero>::zero();
+<u128>::zero();
-----------------
src/identities.rs <u128 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.is_zero();
+<u128 as identities::Zero>::is_zero(p0);
+crate::<u128 as identities::Zero>::is_zero(p0);
+<u128>::is_zero(p0);
-----------------
src/identities.rs <isize as identities::Zero>::zero
deps:{}
candidates:{}
+<isize as identities::Zero>::zero();
+crate::<isize as identities::Zero>::zero();
+<isize>::zero();
-----------------
src/identities.rs <isize as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.is_zero();
+<isize as identities::Zero>::is_zero(p0);
+crate::<isize as identities::Zero>::is_zero(p0);
+<isize>::is_zero(p0);
-----------------
src/identities.rs <i8 as identities::Zero>::zero
deps:{}
candidates:{}
+<i8 as identities::Zero>::zero();
+crate::<i8 as identities::Zero>::zero();
+<i8>::zero();
-----------------
src/identities.rs <i8 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.is_zero();
+<i8 as identities::Zero>::is_zero(p0);
+crate::<i8 as identities::Zero>::is_zero(p0);
+<i8>::is_zero(p0);
-----------------
src/identities.rs <i16 as identities::Zero>::zero
deps:{}
candidates:{}
+<i16 as identities::Zero>::zero();
+crate::<i16 as identities::Zero>::zero();
+<i16>::zero();
-----------------
src/identities.rs <i16 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.is_zero();
+<i16 as identities::Zero>::is_zero(p0);
+crate::<i16 as identities::Zero>::is_zero(p0);
+<i16>::is_zero(p0);
-----------------
src/identities.rs <i32 as identities::Zero>::zero
deps:{}
candidates:{}
+<i32 as identities::Zero>::zero();
+crate::<i32 as identities::Zero>::zero();
+<i32>::zero();
-----------------
src/identities.rs <i32 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.is_zero();
+<i32 as identities::Zero>::is_zero(p0);
+crate::<i32 as identities::Zero>::is_zero(p0);
+<i32>::is_zero(p0);
-----------------
src/identities.rs <i64 as identities::Zero>::zero
deps:{}
candidates:{}
+<i64 as identities::Zero>::zero();
+crate::<i64 as identities::Zero>::zero();
+<i64>::zero();
-----------------
src/identities.rs <i64 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.is_zero();
+<i64 as identities::Zero>::is_zero(p0);
+crate::<i64 as identities::Zero>::is_zero(p0);
+<i64>::is_zero(p0);
-----------------
src/identities.rs <i128 as identities::Zero>::zero
deps:{}
candidates:{}
+<i128 as identities::Zero>::zero();
+crate::<i128 as identities::Zero>::zero();
+<i128>::zero();
-----------------
src/identities.rs <i128 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.is_zero();
+<i128 as identities::Zero>::is_zero(p0);
+crate::<i128 as identities::Zero>::is_zero(p0);
+<i128>::is_zero(p0);
-----------------
src/identities.rs <f32 as identities::Zero>::zero
deps:{}
candidates:{}
+<f32 as identities::Zero>::zero();
+crate::<f32 as identities::Zero>::zero();
+<f32>::zero();
-----------------
src/identities.rs <f32 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.is_zero();
+<f32 as identities::Zero>::is_zero(p0);
+crate::<f32 as identities::Zero>::is_zero(p0);
+<f32>::is_zero(p0);
-----------------
src/identities.rs <f64 as identities::Zero>::zero
deps:{}
candidates:{}
+<f64 as identities::Zero>::zero();
+crate::<f64 as identities::Zero>::zero();
+<f64>::zero();
-----------------
src/identities.rs <f64 as identities::Zero>::is_zero
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.is_zero();
+<f64 as identities::Zero>::is_zero(p0);
+crate::<f64 as identities::Zero>::is_zero(p0);
+<f64>::is_zero(p0);
-----------------
src/identities.rs <std::num::Wrapping<T> as identities::Zero>::is_zero
deps:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::Zero>::is_zero":{"T":["identities::Zero","std::marker::Sized"],"std::num::Wrapping<T>":["std::ops::Add"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["ops::wrapping::WrappingSub","cast::FromPrimitive","identities::One","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","sign::Signed","std::marker::Sized","identities::Zero","cast::NumCast","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","sign::Unsigned","Num","cast::ToPrimitive","bounds::Bounded","ops::wrapping::WrappingNeg"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::Zero>::is_zero":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::simd::Simd<i8, N>","std::simd::Simd<isize, N>","<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>","std::simd::Simd<f32, N>","std::simd::Simd<u64, N>","std::simd::Simd<i64, N>","std::string::String","std::simd::Simd<i16, N>","std::simd::Simd<i32, N>","std::time::Instant","std::simd::Simd<u32, N>","std::simd::Simd<f64, N>","std::simd::Simd<usize, N>","std::mem::Assume","std::time::SystemTime","std::simd::Simd<u8, N>","std::simd::Simd<u16, N>","std::time::Duration","std::simd::Simd<T, LANES>"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.is_zero();
+<std::num::Wrapping<T> as identities::Zero>::is_zero(p0);
+crate::<std::num::Wrapping<T> as identities::Zero>::is_zero(p0);
+<std::num::Wrapping<T>>::is_zero(p0);
-----------------
src/identities.rs <std::num::Wrapping<T> as identities::Zero>::set_zero
deps:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::Zero>::set_zero":{"T":["identities::Zero","std::marker::Sized"],"std::num::Wrapping<T>":["std::ops::Add"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["sign::Unsigned","cast::NumCast","ops::wrapping::WrappingAdd","identities::Zero","ops::wrapping::WrappingMul","ops::wrapping::WrappingSub","identities::One","cast::FromPrimitive","bounds::Bounded","cast::ToPrimitive","Num","ops::wrapping::WrappingShr","sign::Signed","ops::wrapping::WrappingNeg","std::marker::Sized","ops::wrapping::WrappingShl"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::Zero>::set_zero":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::simd::Simd<u64, N>","std::time::SystemTime","std::simd::Simd<u8, N>","std::simd::Simd<usize, N>","std::simd::Simd<i16, N>","std::simd::Simd<u16, N>","std::simd::Simd<f64, N>","std::simd::Simd<isize, N>","std::simd::Simd<T, LANES>","std::simd::Simd<u32, N>","std::simd::Simd<f32, N>","std::mem::Assume","std::time::Instant","<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>","std::simd::Simd<i64, N>","std::simd::Simd<i8, N>","std::simd::Simd<i32, N>","std::string::String","std::time::Duration"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.set_zero();
+<std::num::Wrapping<T> as identities::Zero>::set_zero(p0);
+crate::<std::num::Wrapping<T> as identities::Zero>::set_zero(p0);
+<std::num::Wrapping<T>>::set_zero(p0);
-----------------
src/identities.rs <std::num::Wrapping<T> as identities::Zero>::zero
deps:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::Zero>::zero":{"T":["std::marker::Sized","identities::Zero"],"std::num::Wrapping<T>":["std::ops::Add"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShl","cast::ToPrimitive","bounds::Bounded","cast::NumCast","cast::FromPrimitive","ops::wrapping::WrappingAdd","identities::One","Num","ops::wrapping::WrappingSub","ops::wrapping::WrappingMul","sign::Unsigned","identities::Zero","ops::wrapping::WrappingShr","sign::Signed","ops::wrapping::WrappingNeg","std::marker::Sized"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::Zero>::zero":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::simd::Simd<i32, N>","std::simd::Simd<u32, N>","std::simd::Simd<usize, N>","std::time::Instant","std::string::String","std::simd::Simd<u8, N>","std::simd::Simd<i8, N>","<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>","std::time::SystemTime","std::simd::Simd<i64, N>","std::simd::Simd<i16, N>","std::simd::Simd<f32, N>","std::simd::Simd<T, LANES>","std::time::Duration","std::mem::Assume","std::simd::Simd<u16, N>","std::simd::Simd<isize, N>","std::simd::Simd<u64, N>","std::simd::Simd<f64, N>"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<std::num::Wrapping<T> as identities::Zero>::zero();
+crate::<std::num::Wrapping<T> as identities::Zero>::zero();
+<std::num::Wrapping<T>>::zero();
-----------------
src/identities.rs <usize as identities::One>::one
deps:{}
candidates:{}
+<usize as identities::One>::one();
+crate::<usize as identities::One>::one();
+<usize>::one();
-----------------
src/identities.rs <usize as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.is_one();
+<usize as identities::One>::is_one(p0);
+crate::<usize as identities::One>::is_one(p0);
+<usize>::is_one(p0);
-----------------
src/identities.rs <u8 as identities::One>::one
deps:{}
candidates:{}
+<u8 as identities::One>::one();
+crate::<u8 as identities::One>::one();
+<u8>::one();
-----------------
src/identities.rs <u8 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_one();
+<u8 as identities::One>::is_one(p0);
+crate::<u8 as identities::One>::is_one(p0);
+<u8>::is_one(p0);
-----------------
src/identities.rs <u16 as identities::One>::one
deps:{}
candidates:{}
+<u16 as identities::One>::one();
+crate::<u16 as identities::One>::one();
+<u16>::one();
-----------------
src/identities.rs <u16 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.is_one();
+<u16 as identities::One>::is_one(p0);
+crate::<u16 as identities::One>::is_one(p0);
+<u16>::is_one(p0);
-----------------
src/identities.rs <u32 as identities::One>::one
deps:{}
candidates:{}
+<u32 as identities::One>::one();
+crate::<u32 as identities::One>::one();
+<u32>::one();
-----------------
src/identities.rs <u32 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.is_one();
+<u32 as identities::One>::is_one(p0);
+crate::<u32 as identities::One>::is_one(p0);
+<u32>::is_one(p0);
-----------------
src/identities.rs <u64 as identities::One>::one
deps:{}
candidates:{}
+<u64 as identities::One>::one();
+crate::<u64 as identities::One>::one();
+<u64>::one();
-----------------
src/identities.rs <u64 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.is_one();
+<u64 as identities::One>::is_one(p0);
+crate::<u64 as identities::One>::is_one(p0);
+<u64>::is_one(p0);
-----------------
src/identities.rs <u128 as identities::One>::one
deps:{}
candidates:{}
+<u128 as identities::One>::one();
+crate::<u128 as identities::One>::one();
+<u128>::one();
-----------------
src/identities.rs <u128 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.is_one();
+<u128 as identities::One>::is_one(p0);
+crate::<u128 as identities::One>::is_one(p0);
+<u128>::is_one(p0);
-----------------
src/identities.rs <isize as identities::One>::one
deps:{}
candidates:{}
+<isize as identities::One>::one();
+crate::<isize as identities::One>::one();
+<isize>::one();
-----------------
src/identities.rs <isize as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.is_one();
+<isize as identities::One>::is_one(p0);
+crate::<isize as identities::One>::is_one(p0);
+<isize>::is_one(p0);
-----------------
src/identities.rs <i8 as identities::One>::one
deps:{}
candidates:{}
+<i8 as identities::One>::one();
+crate::<i8 as identities::One>::one();
+<i8>::one();
-----------------
src/identities.rs <i8 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.is_one();
+<i8 as identities::One>::is_one(p0);
+crate::<i8 as identities::One>::is_one(p0);
+<i8>::is_one(p0);
-----------------
src/identities.rs <i16 as identities::One>::one
deps:{}
candidates:{}
+<i16 as identities::One>::one();
+crate::<i16 as identities::One>::one();
+<i16>::one();
-----------------
src/identities.rs <i16 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.is_one();
+<i16 as identities::One>::is_one(p0);
+crate::<i16 as identities::One>::is_one(p0);
+<i16>::is_one(p0);
-----------------
src/identities.rs <i32 as identities::One>::one
deps:{}
candidates:{}
+<i32 as identities::One>::one();
+crate::<i32 as identities::One>::one();
+<i32>::one();
-----------------
src/identities.rs <i32 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.is_one();
+<i32 as identities::One>::is_one(p0);
+crate::<i32 as identities::One>::is_one(p0);
+<i32>::is_one(p0);
-----------------
src/identities.rs <i64 as identities::One>::one
deps:{}
candidates:{}
+<i64 as identities::One>::one();
+crate::<i64 as identities::One>::one();
+<i64>::one();
-----------------
src/identities.rs <i64 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.is_one();
+<i64 as identities::One>::is_one(p0);
+crate::<i64 as identities::One>::is_one(p0);
+<i64>::is_one(p0);
-----------------
src/identities.rs <i128 as identities::One>::one
deps:{}
candidates:{}
+<i128 as identities::One>::one();
+crate::<i128 as identities::One>::one();
+<i128>::one();
-----------------
src/identities.rs <i128 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.is_one();
+<i128 as identities::One>::is_one(p0);
+crate::<i128 as identities::One>::is_one(p0);
+<i128>::is_one(p0);
-----------------
src/identities.rs <f32 as identities::One>::one
deps:{}
candidates:{}
+<f32 as identities::One>::one();
+crate::<f32 as identities::One>::one();
+<f32>::one();
-----------------
src/identities.rs <f32 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.is_one();
+<f32 as identities::One>::is_one(p0);
+crate::<f32 as identities::One>::is_one(p0);
+<f32>::is_one(p0);
-----------------
src/identities.rs <f64 as identities::One>::one
deps:{}
candidates:{}
+<f64 as identities::One>::one();
+crate::<f64 as identities::One>::one();
+<f64>::one();
-----------------
src/identities.rs <f64 as identities::One>::is_one
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.is_one();
+<f64 as identities::One>::is_one(p0);
+crate::<f64 as identities::One>::is_one(p0);
+<f64>::is_one(p0);
-----------------
src/identities.rs <std::num::Wrapping<T> as identities::One>::set_one
deps:{"<&'a std::num::Saturating<i128> as std::ops::Mul<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Mul<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Mul<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Mul<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Mul<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Mul<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Mul<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Mul<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Mul<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Mul<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Mul<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Mul<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Mul<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Mul<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Mul<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Mul<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Mul<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Mul<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Mul<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Mul<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Mul<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Mul<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Mul<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Mul<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Mul<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Mul<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Mul<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Mul<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Mul<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Mul<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Mul<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Mul<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Mul<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Mul<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Mul<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Mul<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Mul<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Mul<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Mul<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Mul<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Mul<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Mul<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Mul<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Mul<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Mul<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Mul<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Mul<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Mul<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::One>::set_one":{"T":["identities::One","std::marker::Sized"],"std::num::Wrapping<T>":["std::ops::Mul"]},"core::core_simd::ops::deref::<impl std::ops::Mul<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Mul<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["identities::One","ops::wrapping::WrappingNeg","ops::wrapping::WrappingMul","ops::wrapping::WrappingAdd","identities::Zero","bounds::Bounded","sign::Signed","std::marker::Sized","cast::NumCast","ops::wrapping::WrappingShr","sign::Unsigned","Num","cast::ToPrimitive","ops::wrapping::WrappingShl","cast::FromPrimitive","ops::wrapping::WrappingSub"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Mul<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Mul<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Mul<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Mul<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Mul<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Mul<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Mul<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Mul<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Mul<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Mul<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Mul<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Mul<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Mul<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Mul<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Mul<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Mul<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Mul<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Mul<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Mul<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Mul<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Mul<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Mul<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Mul<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Mul<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Mul<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Mul<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Mul<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Mul<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Mul<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Mul<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Mul<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Mul<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Mul<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Mul<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Mul<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Mul<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Mul<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Mul<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Mul<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Mul<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Mul<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Mul<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Mul<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Mul<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Mul<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Mul<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Mul<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Mul<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::One>::set_one":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::simd::Simd<i8, N>","std::simd::Simd<i16, N>","std::simd::Simd<f64, N>","std::simd::Simd<usize, N>","std::simd::Simd<u64, N>","std::simd::Simd<i64, N>","std::simd::Simd<u16, N>","std::simd::Simd<T, LANES>","std::simd::Simd<isize, N>","std::simd::Simd<u32, N>","std::time::Duration","std::simd::Simd<f32, N>","std::simd::Simd<u8, N>","<&'a std::num::Saturating<i16> as std::ops::Mul<std::num::Saturating<i16>>>","std::simd::Simd<i32, N>"]},"core::core_simd::ops::deref::<impl std::ops::Mul<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Mul<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.set_one();
+<std::num::Wrapping<T> as identities::One>::set_one(p0);
+crate::<std::num::Wrapping<T> as identities::One>::set_one(p0);
+<std::num::Wrapping<T>>::set_one(p0);
-----------------
src/identities.rs <std::num::Wrapping<T> as identities::One>::one
deps:{"<&'a std::num::Saturating<i128> as std::ops::Mul<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Mul<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Mul<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Mul<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Mul<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Mul<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Mul<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Mul<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Mul<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Mul<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Mul<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Mul<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Mul<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Mul<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Mul<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Mul<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Mul<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Mul<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Mul<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Mul<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Mul<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Mul<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Mul<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Mul<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Mul<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Mul<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Mul<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Mul<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Mul<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Mul<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Mul<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Mul<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Mul<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Mul<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Mul<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Mul<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Mul<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Mul<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Mul<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Mul<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Mul<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Mul<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Mul<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Mul<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Mul<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Mul<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Mul<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Mul<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::One>::one":{"T":["identities::One","std::marker::Sized"],"std::num::Wrapping<T>":["std::ops::Mul"]},"core::core_simd::ops::deref::<impl std::ops::Mul<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Mul<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["Num","ops::wrapping::WrappingSub","std::marker::Sized","sign::Unsigned","ops::wrapping::WrappingShl","cast::NumCast","ops::wrapping::WrappingNeg","ops::wrapping::WrappingAdd","cast::ToPrimitive","identities::One","bounds::Bounded","sign::Signed","identities::Zero","ops::wrapping::WrappingMul","cast::FromPrimitive","ops::wrapping::WrappingShr"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Mul<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Mul<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Mul<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Mul<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Mul<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Mul<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Mul<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Mul<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Mul<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Mul<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Mul<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Mul<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Mul<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Mul<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Mul<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Mul<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Mul<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Mul<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Mul<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Mul<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Mul<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Mul<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Mul<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Mul<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Mul<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Mul<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Mul<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Mul<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Mul<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Mul<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Mul<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Mul<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Mul<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Mul<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Mul<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Mul<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Mul<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Mul<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Mul<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Mul<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Mul<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Mul<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Mul<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Mul<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Mul<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Mul<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Mul<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Mul<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as identities::One>::one":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::simd::Simd<i32, N>","std::simd::Simd<u8, N>","std::simd::Simd<i8, N>","std::simd::Simd<T, LANES>","std::simd::Simd<f64, N>","std::time::Duration","std::simd::Simd<f32, N>","std::simd::Simd<isize, N>","std::simd::Simd<i64, N>","<&std::num::Saturating<u16> as std::ops::Mul<&std::num::Saturating<u16>>>","std::simd::Simd<i16, N>","std::simd::Simd<u16, N>","std::simd::Simd<u64, N>","std::simd::Simd<usize, N>","std::simd::Simd<u32, N>"]},"core::core_simd::ops::deref::<impl std::ops::Mul<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Mul<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
+<std::num::Wrapping<T> as identities::One>::one();
+crate::<std::num::Wrapping<T> as identities::One>::one();
+<std::num::Wrapping<T>>::one();
-----------------
src/int.rs <u8 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.count_ones();
+<u8 as int::PrimInt>::count_ones(p0);
+crate::<u8 as int::PrimInt>::count_ones(p0);
+<u8>::count_ones(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.count_zeros();
+<u8 as int::PrimInt>::count_zeros(p0);
+crate::<u8 as int::PrimInt>::count_zeros(p0);
+<u8>::count_zeros(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.leading_ones();
+<u8 as int::PrimInt>::leading_ones(p0);
+crate::<u8 as int::PrimInt>::leading_ones(p0);
+<u8>::leading_ones(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.leading_zeros();
+<u8 as int::PrimInt>::leading_zeros(p0);
+crate::<u8 as int::PrimInt>::leading_zeros(p0);
+<u8>::leading_zeros(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.trailing_ones();
+<u8 as int::PrimInt>::trailing_ones(p0);
+crate::<u8 as int::PrimInt>::trailing_ones(p0);
+<u8>::trailing_ones(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.trailing_zeros();
+<u8 as int::PrimInt>::trailing_zeros(p0);
+crate::<u8 as int::PrimInt>::trailing_zeros(p0);
+<u8>::trailing_zeros(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<u8 as int::PrimInt>::rotate_left(p0, p1);
+crate::<u8 as int::PrimInt>::rotate_left(p0, p1);
+<u8>::rotate_left(p0, p1);
-----------------
src/int.rs <u8 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<u8 as int::PrimInt>::rotate_right(p0, p1);
+crate::<u8 as int::PrimInt>::rotate_right(p0, p1);
+<u8>::rotate_right(p0, p1);
-----------------
src/int.rs <u8 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<u8 as int::PrimInt>::signed_shl(p0, p1);
+crate::<u8 as int::PrimInt>::signed_shl(p0, p1);
+<u8>::signed_shl(p0, p1);
-----------------
src/int.rs <u8 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<u8 as int::PrimInt>::signed_shr(p0, p1);
+crate::<u8 as int::PrimInt>::signed_shr(p0, p1);
+<u8>::signed_shr(p0, p1);
-----------------
src/int.rs <u8 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<u8 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<u8 as int::PrimInt>::unsigned_shl(p0, p1);
+<u8>::unsigned_shl(p0, p1);
-----------------
src/int.rs <u8 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<u8 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<u8 as int::PrimInt>::unsigned_shr(p0, p1);
+<u8>::unsigned_shr(p0, p1);
-----------------
src/int.rs <u8 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.swap_bytes();
+<u8 as int::PrimInt>::swap_bytes(p0);
+crate::<u8 as int::PrimInt>::swap_bytes(p0);
+<u8>::swap_bytes(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.reverse_bits();
+<u8 as int::PrimInt>::reverse_bits(p0);
+crate::<u8 as int::PrimInt>::reverse_bits(p0);
+<u8>::reverse_bits(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<u8 as int::PrimInt>::from_be(p0);
+crate::<u8 as int::PrimInt>::from_be(p0);
+<u8>::from_be(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<u8 as int::PrimInt>::from_le(p0);
+crate::<u8 as int::PrimInt>::from_le(p0);
+<u8>::from_le(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.to_be();
+<u8 as int::PrimInt>::to_be(p0);
+crate::<u8 as int::PrimInt>::to_be(p0);
+<u8>::to_be(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.to_le();
+<u8 as int::PrimInt>::to_le(p0);
+crate::<u8 as int::PrimInt>::to_le(p0);
+<u8>::to_le(p0);
-----------------
src/int.rs <u8 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u8 as int::PrimInt>::pow(p0, p1);
+crate::<u8 as int::PrimInt>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/int.rs <u16 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.count_ones();
+<u16 as int::PrimInt>::count_ones(p0);
+crate::<u16 as int::PrimInt>::count_ones(p0);
+<u16>::count_ones(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.count_zeros();
+<u16 as int::PrimInt>::count_zeros(p0);
+crate::<u16 as int::PrimInt>::count_zeros(p0);
+<u16>::count_zeros(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.leading_ones();
+<u16 as int::PrimInt>::leading_ones(p0);
+crate::<u16 as int::PrimInt>::leading_ones(p0);
+<u16>::leading_ones(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.leading_zeros();
+<u16 as int::PrimInt>::leading_zeros(p0);
+crate::<u16 as int::PrimInt>::leading_zeros(p0);
+<u16>::leading_zeros(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.trailing_ones();
+<u16 as int::PrimInt>::trailing_ones(p0);
+crate::<u16 as int::PrimInt>::trailing_ones(p0);
+<u16>::trailing_ones(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.trailing_zeros();
+<u16 as int::PrimInt>::trailing_zeros(p0);
+crate::<u16 as int::PrimInt>::trailing_zeros(p0);
+<u16>::trailing_zeros(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<u16 as int::PrimInt>::rotate_left(p0, p1);
+crate::<u16 as int::PrimInt>::rotate_left(p0, p1);
+<u16>::rotate_left(p0, p1);
-----------------
src/int.rs <u16 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<u16 as int::PrimInt>::rotate_right(p0, p1);
+crate::<u16 as int::PrimInt>::rotate_right(p0, p1);
+<u16>::rotate_right(p0, p1);
-----------------
src/int.rs <u16 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<u16 as int::PrimInt>::signed_shl(p0, p1);
+crate::<u16 as int::PrimInt>::signed_shl(p0, p1);
+<u16>::signed_shl(p0, p1);
-----------------
src/int.rs <u16 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<u16 as int::PrimInt>::signed_shr(p0, p1);
+crate::<u16 as int::PrimInt>::signed_shr(p0, p1);
+<u16>::signed_shr(p0, p1);
-----------------
src/int.rs <u16 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<u16 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<u16 as int::PrimInt>::unsigned_shl(p0, p1);
+<u16>::unsigned_shl(p0, p1);
-----------------
src/int.rs <u16 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<u16 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<u16 as int::PrimInt>::unsigned_shr(p0, p1);
+<u16>::unsigned_shr(p0, p1);
-----------------
src/int.rs <u16 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.swap_bytes();
+<u16 as int::PrimInt>::swap_bytes(p0);
+crate::<u16 as int::PrimInt>::swap_bytes(p0);
+<u16>::swap_bytes(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.reverse_bits();
+<u16 as int::PrimInt>::reverse_bits(p0);
+crate::<u16 as int::PrimInt>::reverse_bits(p0);
+<u16>::reverse_bits(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<u16 as int::PrimInt>::from_be(p0);
+crate::<u16 as int::PrimInt>::from_be(p0);
+<u16>::from_be(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<u16 as int::PrimInt>::from_le(p0);
+crate::<u16 as int::PrimInt>::from_le(p0);
+<u16>::from_le(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.to_be();
+<u16 as int::PrimInt>::to_be(p0);
+crate::<u16 as int::PrimInt>::to_be(p0);
+<u16>::to_be(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+p0.to_le();
+<u16 as int::PrimInt>::to_le(p0);
+crate::<u16 as int::PrimInt>::to_le(p0);
+<u16>::to_le(p0);
-----------------
src/int.rs <u16 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u16 as int::PrimInt>::pow(p0, p1);
+crate::<u16 as int::PrimInt>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/int.rs <u32 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.count_ones();
+<u32 as int::PrimInt>::count_ones(p0);
+crate::<u32 as int::PrimInt>::count_ones(p0);
+<u32>::count_ones(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.count_zeros();
+<u32 as int::PrimInt>::count_zeros(p0);
+crate::<u32 as int::PrimInt>::count_zeros(p0);
+<u32>::count_zeros(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.leading_ones();
+<u32 as int::PrimInt>::leading_ones(p0);
+crate::<u32 as int::PrimInt>::leading_ones(p0);
+<u32>::leading_ones(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.leading_zeros();
+<u32 as int::PrimInt>::leading_zeros(p0);
+crate::<u32 as int::PrimInt>::leading_zeros(p0);
+<u32>::leading_zeros(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.trailing_ones();
+<u32 as int::PrimInt>::trailing_ones(p0);
+crate::<u32 as int::PrimInt>::trailing_ones(p0);
+<u32>::trailing_ones(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.trailing_zeros();
+<u32 as int::PrimInt>::trailing_zeros(p0);
+crate::<u32 as int::PrimInt>::trailing_zeros(p0);
+<u32>::trailing_zeros(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<u32 as int::PrimInt>::rotate_left(p0, p1);
+crate::<u32 as int::PrimInt>::rotate_left(p0, p1);
+<u32>::rotate_left(p0, p1);
-----------------
src/int.rs <u32 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<u32 as int::PrimInt>::rotate_right(p0, p1);
+crate::<u32 as int::PrimInt>::rotate_right(p0, p1);
+<u32>::rotate_right(p0, p1);
-----------------
src/int.rs <u32 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<u32 as int::PrimInt>::signed_shl(p0, p1);
+crate::<u32 as int::PrimInt>::signed_shl(p0, p1);
+<u32>::signed_shl(p0, p1);
-----------------
src/int.rs <u32 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<u32 as int::PrimInt>::signed_shr(p0, p1);
+crate::<u32 as int::PrimInt>::signed_shr(p0, p1);
+<u32>::signed_shr(p0, p1);
-----------------
src/int.rs <u32 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<u32 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<u32 as int::PrimInt>::unsigned_shl(p0, p1);
+<u32>::unsigned_shl(p0, p1);
-----------------
src/int.rs <u32 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<u32 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<u32 as int::PrimInt>::unsigned_shr(p0, p1);
+<u32>::unsigned_shr(p0, p1);
-----------------
src/int.rs <u32 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.swap_bytes();
+<u32 as int::PrimInt>::swap_bytes(p0);
+crate::<u32 as int::PrimInt>::swap_bytes(p0);
+<u32>::swap_bytes(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.reverse_bits();
+<u32 as int::PrimInt>::reverse_bits(p0);
+crate::<u32 as int::PrimInt>::reverse_bits(p0);
+<u32>::reverse_bits(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<u32 as int::PrimInt>::from_be(p0);
+crate::<u32 as int::PrimInt>::from_be(p0);
+<u32>::from_be(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<u32 as int::PrimInt>::from_le(p0);
+crate::<u32 as int::PrimInt>::from_le(p0);
+<u32>::from_le(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.to_be();
+<u32 as int::PrimInt>::to_be(p0);
+crate::<u32 as int::PrimInt>::to_be(p0);
+<u32>::to_be(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+p0.to_le();
+<u32 as int::PrimInt>::to_le(p0);
+crate::<u32 as int::PrimInt>::to_le(p0);
+<u32>::to_le(p0);
-----------------
src/int.rs <u32 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u32 as int::PrimInt>::pow(p0, p1);
+crate::<u32 as int::PrimInt>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/int.rs <u64 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.count_ones();
+<u64 as int::PrimInt>::count_ones(p0);
+crate::<u64 as int::PrimInt>::count_ones(p0);
+<u64>::count_ones(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.count_zeros();
+<u64 as int::PrimInt>::count_zeros(p0);
+crate::<u64 as int::PrimInt>::count_zeros(p0);
+<u64>::count_zeros(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.leading_ones();
+<u64 as int::PrimInt>::leading_ones(p0);
+crate::<u64 as int::PrimInt>::leading_ones(p0);
+<u64>::leading_ones(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.leading_zeros();
+<u64 as int::PrimInt>::leading_zeros(p0);
+crate::<u64 as int::PrimInt>::leading_zeros(p0);
+<u64>::leading_zeros(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.trailing_ones();
+<u64 as int::PrimInt>::trailing_ones(p0);
+crate::<u64 as int::PrimInt>::trailing_ones(p0);
+<u64>::trailing_ones(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.trailing_zeros();
+<u64 as int::PrimInt>::trailing_zeros(p0);
+crate::<u64 as int::PrimInt>::trailing_zeros(p0);
+<u64>::trailing_zeros(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<u64 as int::PrimInt>::rotate_left(p0, p1);
+crate::<u64 as int::PrimInt>::rotate_left(p0, p1);
+<u64>::rotate_left(p0, p1);
-----------------
src/int.rs <u64 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<u64 as int::PrimInt>::rotate_right(p0, p1);
+crate::<u64 as int::PrimInt>::rotate_right(p0, p1);
+<u64>::rotate_right(p0, p1);
-----------------
src/int.rs <u64 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<u64 as int::PrimInt>::signed_shl(p0, p1);
+crate::<u64 as int::PrimInt>::signed_shl(p0, p1);
+<u64>::signed_shl(p0, p1);
-----------------
src/int.rs <u64 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<u64 as int::PrimInt>::signed_shr(p0, p1);
+crate::<u64 as int::PrimInt>::signed_shr(p0, p1);
+<u64>::signed_shr(p0, p1);
-----------------
src/int.rs <u64 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<u64 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<u64 as int::PrimInt>::unsigned_shl(p0, p1);
+<u64>::unsigned_shl(p0, p1);
-----------------
src/int.rs <u64 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<u64 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<u64 as int::PrimInt>::unsigned_shr(p0, p1);
+<u64>::unsigned_shr(p0, p1);
-----------------
src/int.rs <u64 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.swap_bytes();
+<u64 as int::PrimInt>::swap_bytes(p0);
+crate::<u64 as int::PrimInt>::swap_bytes(p0);
+<u64>::swap_bytes(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.reverse_bits();
+<u64 as int::PrimInt>::reverse_bits(p0);
+crate::<u64 as int::PrimInt>::reverse_bits(p0);
+<u64>::reverse_bits(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<u64 as int::PrimInt>::from_be(p0);
+crate::<u64 as int::PrimInt>::from_be(p0);
+<u64>::from_be(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<u64 as int::PrimInt>::from_le(p0);
+crate::<u64 as int::PrimInt>::from_le(p0);
+<u64>::from_le(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.to_be();
+<u64 as int::PrimInt>::to_be(p0);
+crate::<u64 as int::PrimInt>::to_be(p0);
+<u64>::to_be(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.to_le();
+<u64 as int::PrimInt>::to_le(p0);
+crate::<u64 as int::PrimInt>::to_le(p0);
+<u64>::to_le(p0);
-----------------
src/int.rs <u64 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u64 as int::PrimInt>::pow(p0, p1);
+crate::<u64 as int::PrimInt>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/int.rs <u128 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.count_ones();
+<u128 as int::PrimInt>::count_ones(p0);
+crate::<u128 as int::PrimInt>::count_ones(p0);
+<u128>::count_ones(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.count_zeros();
+<u128 as int::PrimInt>::count_zeros(p0);
+crate::<u128 as int::PrimInt>::count_zeros(p0);
+<u128>::count_zeros(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.leading_ones();
+<u128 as int::PrimInt>::leading_ones(p0);
+crate::<u128 as int::PrimInt>::leading_ones(p0);
+<u128>::leading_ones(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.leading_zeros();
+<u128 as int::PrimInt>::leading_zeros(p0);
+crate::<u128 as int::PrimInt>::leading_zeros(p0);
+<u128>::leading_zeros(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.trailing_ones();
+<u128 as int::PrimInt>::trailing_ones(p0);
+crate::<u128 as int::PrimInt>::trailing_ones(p0);
+<u128>::trailing_ones(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.trailing_zeros();
+<u128 as int::PrimInt>::trailing_zeros(p0);
+crate::<u128 as int::PrimInt>::trailing_zeros(p0);
+<u128>::trailing_zeros(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<u128 as int::PrimInt>::rotate_left(p0, p1);
+crate::<u128 as int::PrimInt>::rotate_left(p0, p1);
+<u128>::rotate_left(p0, p1);
-----------------
src/int.rs <u128 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<u128 as int::PrimInt>::rotate_right(p0, p1);
+crate::<u128 as int::PrimInt>::rotate_right(p0, p1);
+<u128>::rotate_right(p0, p1);
-----------------
src/int.rs <u128 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<u128 as int::PrimInt>::signed_shl(p0, p1);
+crate::<u128 as int::PrimInt>::signed_shl(p0, p1);
+<u128>::signed_shl(p0, p1);
-----------------
src/int.rs <u128 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<u128 as int::PrimInt>::signed_shr(p0, p1);
+crate::<u128 as int::PrimInt>::signed_shr(p0, p1);
+<u128>::signed_shr(p0, p1);
-----------------
src/int.rs <u128 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<u128 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<u128 as int::PrimInt>::unsigned_shl(p0, p1);
+<u128>::unsigned_shl(p0, p1);
-----------------
src/int.rs <u128 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<u128 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<u128 as int::PrimInt>::unsigned_shr(p0, p1);
+<u128>::unsigned_shr(p0, p1);
-----------------
src/int.rs <u128 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.swap_bytes();
+<u128 as int::PrimInt>::swap_bytes(p0);
+crate::<u128 as int::PrimInt>::swap_bytes(p0);
+<u128>::swap_bytes(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.reverse_bits();
+<u128 as int::PrimInt>::reverse_bits(p0);
+crate::<u128 as int::PrimInt>::reverse_bits(p0);
+<u128>::reverse_bits(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<u128 as int::PrimInt>::from_be(p0);
+crate::<u128 as int::PrimInt>::from_be(p0);
+<u128>::from_be(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+<u128 as int::PrimInt>::from_le(p0);
+crate::<u128 as int::PrimInt>::from_le(p0);
+<u128>::from_le(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.to_be();
+<u128 as int::PrimInt>::to_be(p0);
+crate::<u128 as int::PrimInt>::to_be(p0);
+<u128>::to_be(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
+p0.to_le();
+<u128 as int::PrimInt>::to_le(p0);
+crate::<u128 as int::PrimInt>::to_le(p0);
+<u128>::to_le(p0);
-----------------
src/int.rs <u128 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u128 as int::PrimInt>::pow(p0, p1);
+crate::<u128 as int::PrimInt>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/int.rs <usize as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.count_ones();
+<usize as int::PrimInt>::count_ones(p0);
+crate::<usize as int::PrimInt>::count_ones(p0);
+<usize>::count_ones(p0);
-----------------
src/int.rs <usize as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.count_zeros();
+<usize as int::PrimInt>::count_zeros(p0);
+crate::<usize as int::PrimInt>::count_zeros(p0);
+<usize>::count_zeros(p0);
-----------------
src/int.rs <usize as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.leading_ones();
+<usize as int::PrimInt>::leading_ones(p0);
+crate::<usize as int::PrimInt>::leading_ones(p0);
+<usize>::leading_ones(p0);
-----------------
src/int.rs <usize as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.leading_zeros();
+<usize as int::PrimInt>::leading_zeros(p0);
+crate::<usize as int::PrimInt>::leading_zeros(p0);
+<usize>::leading_zeros(p0);
-----------------
src/int.rs <usize as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.trailing_ones();
+<usize as int::PrimInt>::trailing_ones(p0);
+crate::<usize as int::PrimInt>::trailing_ones(p0);
+<usize>::trailing_ones(p0);
-----------------
src/int.rs <usize as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.trailing_zeros();
+<usize as int::PrimInt>::trailing_zeros(p0);
+crate::<usize as int::PrimInt>::trailing_zeros(p0);
+<usize>::trailing_zeros(p0);
-----------------
src/int.rs <usize as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<usize as int::PrimInt>::rotate_left(p0, p1);
+crate::<usize as int::PrimInt>::rotate_left(p0, p1);
+<usize>::rotate_left(p0, p1);
-----------------
src/int.rs <usize as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<usize as int::PrimInt>::rotate_right(p0, p1);
+crate::<usize as int::PrimInt>::rotate_right(p0, p1);
+<usize>::rotate_right(p0, p1);
-----------------
src/int.rs <usize as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<usize as int::PrimInt>::signed_shl(p0, p1);
+crate::<usize as int::PrimInt>::signed_shl(p0, p1);
+<usize>::signed_shl(p0, p1);
-----------------
src/int.rs <usize as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<usize as int::PrimInt>::signed_shr(p0, p1);
+crate::<usize as int::PrimInt>::signed_shr(p0, p1);
+<usize>::signed_shr(p0, p1);
-----------------
src/int.rs <usize as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<usize as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<usize as int::PrimInt>::unsigned_shl(p0, p1);
+<usize>::unsigned_shl(p0, p1);
-----------------
src/int.rs <usize as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<usize as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<usize as int::PrimInt>::unsigned_shr(p0, p1);
+<usize>::unsigned_shr(p0, p1);
-----------------
src/int.rs <usize as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.swap_bytes();
+<usize as int::PrimInt>::swap_bytes(p0);
+crate::<usize as int::PrimInt>::swap_bytes(p0);
+<usize>::swap_bytes(p0);
-----------------
src/int.rs <usize as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.reverse_bits();
+<usize as int::PrimInt>::reverse_bits(p0);
+crate::<usize as int::PrimInt>::reverse_bits(p0);
+<usize>::reverse_bits(p0);
-----------------
src/int.rs <usize as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<usize as int::PrimInt>::from_be(p0);
+crate::<usize as int::PrimInt>::from_be(p0);
+<usize>::from_be(p0);
-----------------
src/int.rs <usize as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<usize as int::PrimInt>::from_le(p0);
+crate::<usize as int::PrimInt>::from_le(p0);
+<usize>::from_le(p0);
-----------------
src/int.rs <usize as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.to_be();
+<usize as int::PrimInt>::to_be(p0);
+crate::<usize as int::PrimInt>::to_be(p0);
+<usize>::to_be(p0);
-----------------
src/int.rs <usize as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+p0.to_le();
+<usize as int::PrimInt>::to_le(p0);
+crate::<usize as int::PrimInt>::to_le(p0);
+<usize>::to_le(p0);
-----------------
src/int.rs <usize as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<usize as int::PrimInt>::pow(p0, p1);
+crate::<usize as int::PrimInt>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/int.rs <i8 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.count_ones();
+<i8 as int::PrimInt>::count_ones(p0);
+crate::<i8 as int::PrimInt>::count_ones(p0);
+<i8>::count_ones(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.count_zeros();
+<i8 as int::PrimInt>::count_zeros(p0);
+crate::<i8 as int::PrimInt>::count_zeros(p0);
+<i8>::count_zeros(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.leading_ones();
+<i8 as int::PrimInt>::leading_ones(p0);
+crate::<i8 as int::PrimInt>::leading_ones(p0);
+<i8>::leading_ones(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.leading_zeros();
+<i8 as int::PrimInt>::leading_zeros(p0);
+crate::<i8 as int::PrimInt>::leading_zeros(p0);
+<i8>::leading_zeros(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.trailing_ones();
+<i8 as int::PrimInt>::trailing_ones(p0);
+crate::<i8 as int::PrimInt>::trailing_ones(p0);
+<i8>::trailing_ones(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.trailing_zeros();
+<i8 as int::PrimInt>::trailing_zeros(p0);
+crate::<i8 as int::PrimInt>::trailing_zeros(p0);
+<i8>::trailing_zeros(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<i8 as int::PrimInt>::rotate_left(p0, p1);
+crate::<i8 as int::PrimInt>::rotate_left(p0, p1);
+<i8>::rotate_left(p0, p1);
-----------------
src/int.rs <i8 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<i8 as int::PrimInt>::rotate_right(p0, p1);
+crate::<i8 as int::PrimInt>::rotate_right(p0, p1);
+<i8>::rotate_right(p0, p1);
-----------------
src/int.rs <i8 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<i8 as int::PrimInt>::signed_shl(p0, p1);
+crate::<i8 as int::PrimInt>::signed_shl(p0, p1);
+<i8>::signed_shl(p0, p1);
-----------------
src/int.rs <i8 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<i8 as int::PrimInt>::signed_shr(p0, p1);
+crate::<i8 as int::PrimInt>::signed_shr(p0, p1);
+<i8>::signed_shr(p0, p1);
-----------------
src/int.rs <i8 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<i8 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<i8 as int::PrimInt>::unsigned_shl(p0, p1);
+<i8>::unsigned_shl(p0, p1);
-----------------
src/int.rs <i8 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<i8 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<i8 as int::PrimInt>::unsigned_shr(p0, p1);
+<i8>::unsigned_shr(p0, p1);
-----------------
src/int.rs <i8 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.swap_bytes();
+<i8 as int::PrimInt>::swap_bytes(p0);
+crate::<i8 as int::PrimInt>::swap_bytes(p0);
+<i8>::swap_bytes(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.reverse_bits();
+<i8 as int::PrimInt>::reverse_bits(p0);
+crate::<i8 as int::PrimInt>::reverse_bits(p0);
+<i8>::reverse_bits(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<i8 as int::PrimInt>::from_be(p0);
+crate::<i8 as int::PrimInt>::from_be(p0);
+<i8>::from_be(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<i8 as int::PrimInt>::from_le(p0);
+crate::<i8 as int::PrimInt>::from_le(p0);
+<i8>::from_le(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.to_be();
+<i8 as int::PrimInt>::to_be(p0);
+crate::<i8 as int::PrimInt>::to_be(p0);
+<i8>::to_be(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+p0.to_le();
+<i8 as int::PrimInt>::to_le(p0);
+crate::<i8 as int::PrimInt>::to_le(p0);
+<i8>::to_le(p0);
-----------------
src/int.rs <i8 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i8 as int::PrimInt>::pow(p0, p1);
+crate::<i8 as int::PrimInt>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/int.rs <i16 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.count_ones();
+<i16 as int::PrimInt>::count_ones(p0);
+crate::<i16 as int::PrimInt>::count_ones(p0);
+<i16>::count_ones(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.count_zeros();
+<i16 as int::PrimInt>::count_zeros(p0);
+crate::<i16 as int::PrimInt>::count_zeros(p0);
+<i16>::count_zeros(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.leading_ones();
+<i16 as int::PrimInt>::leading_ones(p0);
+crate::<i16 as int::PrimInt>::leading_ones(p0);
+<i16>::leading_ones(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.leading_zeros();
+<i16 as int::PrimInt>::leading_zeros(p0);
+crate::<i16 as int::PrimInt>::leading_zeros(p0);
+<i16>::leading_zeros(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.trailing_ones();
+<i16 as int::PrimInt>::trailing_ones(p0);
+crate::<i16 as int::PrimInt>::trailing_ones(p0);
+<i16>::trailing_ones(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.trailing_zeros();
+<i16 as int::PrimInt>::trailing_zeros(p0);
+crate::<i16 as int::PrimInt>::trailing_zeros(p0);
+<i16>::trailing_zeros(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<i16 as int::PrimInt>::rotate_left(p0, p1);
+crate::<i16 as int::PrimInt>::rotate_left(p0, p1);
+<i16>::rotate_left(p0, p1);
-----------------
src/int.rs <i16 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<i16 as int::PrimInt>::rotate_right(p0, p1);
+crate::<i16 as int::PrimInt>::rotate_right(p0, p1);
+<i16>::rotate_right(p0, p1);
-----------------
src/int.rs <i16 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<i16 as int::PrimInt>::signed_shl(p0, p1);
+crate::<i16 as int::PrimInt>::signed_shl(p0, p1);
+<i16>::signed_shl(p0, p1);
-----------------
src/int.rs <i16 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<i16 as int::PrimInt>::signed_shr(p0, p1);
+crate::<i16 as int::PrimInt>::signed_shr(p0, p1);
+<i16>::signed_shr(p0, p1);
-----------------
src/int.rs <i16 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<i16 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<i16 as int::PrimInt>::unsigned_shl(p0, p1);
+<i16>::unsigned_shl(p0, p1);
-----------------
src/int.rs <i16 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<i16 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<i16 as int::PrimInt>::unsigned_shr(p0, p1);
+<i16>::unsigned_shr(p0, p1);
-----------------
src/int.rs <i16 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.swap_bytes();
+<i16 as int::PrimInt>::swap_bytes(p0);
+crate::<i16 as int::PrimInt>::swap_bytes(p0);
+<i16>::swap_bytes(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.reverse_bits();
+<i16 as int::PrimInt>::reverse_bits(p0);
+crate::<i16 as int::PrimInt>::reverse_bits(p0);
+<i16>::reverse_bits(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<i16 as int::PrimInt>::from_be(p0);
+crate::<i16 as int::PrimInt>::from_be(p0);
+<i16>::from_be(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<i16 as int::PrimInt>::from_le(p0);
+crate::<i16 as int::PrimInt>::from_le(p0);
+<i16>::from_le(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.to_be();
+<i16 as int::PrimInt>::to_be(p0);
+crate::<i16 as int::PrimInt>::to_be(p0);
+<i16>::to_be(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+p0.to_le();
+<i16 as int::PrimInt>::to_le(p0);
+crate::<i16 as int::PrimInt>::to_le(p0);
+<i16>::to_le(p0);
-----------------
src/int.rs <i16 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i16 as int::PrimInt>::pow(p0, p1);
+crate::<i16 as int::PrimInt>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/int.rs <i32 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.count_ones();
+<i32 as int::PrimInt>::count_ones(p0);
+crate::<i32 as int::PrimInt>::count_ones(p0);
+<i32>::count_ones(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.count_zeros();
+<i32 as int::PrimInt>::count_zeros(p0);
+crate::<i32 as int::PrimInt>::count_zeros(p0);
+<i32>::count_zeros(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.leading_ones();
+<i32 as int::PrimInt>::leading_ones(p0);
+crate::<i32 as int::PrimInt>::leading_ones(p0);
+<i32>::leading_ones(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.leading_zeros();
+<i32 as int::PrimInt>::leading_zeros(p0);
+crate::<i32 as int::PrimInt>::leading_zeros(p0);
+<i32>::leading_zeros(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.trailing_ones();
+<i32 as int::PrimInt>::trailing_ones(p0);
+crate::<i32 as int::PrimInt>::trailing_ones(p0);
+<i32>::trailing_ones(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.trailing_zeros();
+<i32 as int::PrimInt>::trailing_zeros(p0);
+crate::<i32 as int::PrimInt>::trailing_zeros(p0);
+<i32>::trailing_zeros(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<i32 as int::PrimInt>::rotate_left(p0, p1);
+crate::<i32 as int::PrimInt>::rotate_left(p0, p1);
+<i32>::rotate_left(p0, p1);
-----------------
src/int.rs <i32 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<i32 as int::PrimInt>::rotate_right(p0, p1);
+crate::<i32 as int::PrimInt>::rotate_right(p0, p1);
+<i32>::rotate_right(p0, p1);
-----------------
src/int.rs <i32 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<i32 as int::PrimInt>::signed_shl(p0, p1);
+crate::<i32 as int::PrimInt>::signed_shl(p0, p1);
+<i32>::signed_shl(p0, p1);
-----------------
src/int.rs <i32 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<i32 as int::PrimInt>::signed_shr(p0, p1);
+crate::<i32 as int::PrimInt>::signed_shr(p0, p1);
+<i32>::signed_shr(p0, p1);
-----------------
src/int.rs <i32 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<i32 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<i32 as int::PrimInt>::unsigned_shl(p0, p1);
+<i32>::unsigned_shl(p0, p1);
-----------------
src/int.rs <i32 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<i32 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<i32 as int::PrimInt>::unsigned_shr(p0, p1);
+<i32>::unsigned_shr(p0, p1);
-----------------
src/int.rs <i32 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.swap_bytes();
+<i32 as int::PrimInt>::swap_bytes(p0);
+crate::<i32 as int::PrimInt>::swap_bytes(p0);
+<i32>::swap_bytes(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.reverse_bits();
+<i32 as int::PrimInt>::reverse_bits(p0);
+crate::<i32 as int::PrimInt>::reverse_bits(p0);
+<i32>::reverse_bits(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<i32 as int::PrimInt>::from_be(p0);
+crate::<i32 as int::PrimInt>::from_be(p0);
+<i32>::from_be(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<i32 as int::PrimInt>::from_le(p0);
+crate::<i32 as int::PrimInt>::from_le(p0);
+<i32>::from_le(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.to_be();
+<i32 as int::PrimInt>::to_be(p0);
+crate::<i32 as int::PrimInt>::to_be(p0);
+<i32>::to_be(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+p0.to_le();
+<i32 as int::PrimInt>::to_le(p0);
+crate::<i32 as int::PrimInt>::to_le(p0);
+<i32>::to_le(p0);
-----------------
src/int.rs <i32 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i32 as int::PrimInt>::pow(p0, p1);
+crate::<i32 as int::PrimInt>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/int.rs <i64 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.count_ones();
+<i64 as int::PrimInt>::count_ones(p0);
+crate::<i64 as int::PrimInt>::count_ones(p0);
+<i64>::count_ones(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.count_zeros();
+<i64 as int::PrimInt>::count_zeros(p0);
+crate::<i64 as int::PrimInt>::count_zeros(p0);
+<i64>::count_zeros(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.leading_ones();
+<i64 as int::PrimInt>::leading_ones(p0);
+crate::<i64 as int::PrimInt>::leading_ones(p0);
+<i64>::leading_ones(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.leading_zeros();
+<i64 as int::PrimInt>::leading_zeros(p0);
+crate::<i64 as int::PrimInt>::leading_zeros(p0);
+<i64>::leading_zeros(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.trailing_ones();
+<i64 as int::PrimInt>::trailing_ones(p0);
+crate::<i64 as int::PrimInt>::trailing_ones(p0);
+<i64>::trailing_ones(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.trailing_zeros();
+<i64 as int::PrimInt>::trailing_zeros(p0);
+crate::<i64 as int::PrimInt>::trailing_zeros(p0);
+<i64>::trailing_zeros(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<i64 as int::PrimInt>::rotate_left(p0, p1);
+crate::<i64 as int::PrimInt>::rotate_left(p0, p1);
+<i64>::rotate_left(p0, p1);
-----------------
src/int.rs <i64 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<i64 as int::PrimInt>::rotate_right(p0, p1);
+crate::<i64 as int::PrimInt>::rotate_right(p0, p1);
+<i64>::rotate_right(p0, p1);
-----------------
src/int.rs <i64 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<i64 as int::PrimInt>::signed_shl(p0, p1);
+crate::<i64 as int::PrimInt>::signed_shl(p0, p1);
+<i64>::signed_shl(p0, p1);
-----------------
src/int.rs <i64 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<i64 as int::PrimInt>::signed_shr(p0, p1);
+crate::<i64 as int::PrimInt>::signed_shr(p0, p1);
+<i64>::signed_shr(p0, p1);
-----------------
src/int.rs <i64 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<i64 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<i64 as int::PrimInt>::unsigned_shl(p0, p1);
+<i64>::unsigned_shl(p0, p1);
-----------------
src/int.rs <i64 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<i64 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<i64 as int::PrimInt>::unsigned_shr(p0, p1);
+<i64>::unsigned_shr(p0, p1);
-----------------
src/int.rs <i64 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.swap_bytes();
+<i64 as int::PrimInt>::swap_bytes(p0);
+crate::<i64 as int::PrimInt>::swap_bytes(p0);
+<i64>::swap_bytes(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.reverse_bits();
+<i64 as int::PrimInt>::reverse_bits(p0);
+crate::<i64 as int::PrimInt>::reverse_bits(p0);
+<i64>::reverse_bits(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<i64 as int::PrimInt>::from_be(p0);
+crate::<i64 as int::PrimInt>::from_be(p0);
+<i64>::from_be(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<i64 as int::PrimInt>::from_le(p0);
+crate::<i64 as int::PrimInt>::from_le(p0);
+<i64>::from_le(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.to_be();
+<i64 as int::PrimInt>::to_be(p0);
+crate::<i64 as int::PrimInt>::to_be(p0);
+<i64>::to_be(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.to_le();
+<i64 as int::PrimInt>::to_le(p0);
+crate::<i64 as int::PrimInt>::to_le(p0);
+<i64>::to_le(p0);
-----------------
src/int.rs <i64 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i64 as int::PrimInt>::pow(p0, p1);
+crate::<i64 as int::PrimInt>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/int.rs <i128 as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.count_ones();
+<i128 as int::PrimInt>::count_ones(p0);
+crate::<i128 as int::PrimInt>::count_ones(p0);
+<i128>::count_ones(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.count_zeros();
+<i128 as int::PrimInt>::count_zeros(p0);
+crate::<i128 as int::PrimInt>::count_zeros(p0);
+<i128>::count_zeros(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.leading_ones();
+<i128 as int::PrimInt>::leading_ones(p0);
+crate::<i128 as int::PrimInt>::leading_ones(p0);
+<i128>::leading_ones(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.leading_zeros();
+<i128 as int::PrimInt>::leading_zeros(p0);
+crate::<i128 as int::PrimInt>::leading_zeros(p0);
+<i128>::leading_zeros(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.trailing_ones();
+<i128 as int::PrimInt>::trailing_ones(p0);
+crate::<i128 as int::PrimInt>::trailing_ones(p0);
+<i128>::trailing_ones(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.trailing_zeros();
+<i128 as int::PrimInt>::trailing_zeros(p0);
+crate::<i128 as int::PrimInt>::trailing_zeros(p0);
+<i128>::trailing_zeros(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<i128 as int::PrimInt>::rotate_left(p0, p1);
+crate::<i128 as int::PrimInt>::rotate_left(p0, p1);
+<i128>::rotate_left(p0, p1);
-----------------
src/int.rs <i128 as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<i128 as int::PrimInt>::rotate_right(p0, p1);
+crate::<i128 as int::PrimInt>::rotate_right(p0, p1);
+<i128>::rotate_right(p0, p1);
-----------------
src/int.rs <i128 as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<i128 as int::PrimInt>::signed_shl(p0, p1);
+crate::<i128 as int::PrimInt>::signed_shl(p0, p1);
+<i128>::signed_shl(p0, p1);
-----------------
src/int.rs <i128 as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<i128 as int::PrimInt>::signed_shr(p0, p1);
+crate::<i128 as int::PrimInt>::signed_shr(p0, p1);
+<i128>::signed_shr(p0, p1);
-----------------
src/int.rs <i128 as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<i128 as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<i128 as int::PrimInt>::unsigned_shl(p0, p1);
+<i128>::unsigned_shl(p0, p1);
-----------------
src/int.rs <i128 as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<i128 as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<i128 as int::PrimInt>::unsigned_shr(p0, p1);
+<i128>::unsigned_shr(p0, p1);
-----------------
src/int.rs <i128 as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.swap_bytes();
+<i128 as int::PrimInt>::swap_bytes(p0);
+crate::<i128 as int::PrimInt>::swap_bytes(p0);
+<i128>::swap_bytes(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.reverse_bits();
+<i128 as int::PrimInt>::reverse_bits(p0);
+crate::<i128 as int::PrimInt>::reverse_bits(p0);
+<i128>::reverse_bits(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<i128 as int::PrimInt>::from_be(p0);
+crate::<i128 as int::PrimInt>::from_be(p0);
+<i128>::from_be(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+<i128 as int::PrimInt>::from_le(p0);
+crate::<i128 as int::PrimInt>::from_le(p0);
+<i128>::from_le(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.to_be();
+<i128 as int::PrimInt>::to_be(p0);
+crate::<i128 as int::PrimInt>::to_be(p0);
+<i128>::to_be(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+p0.to_le();
+<i128 as int::PrimInt>::to_le(p0);
+crate::<i128 as int::PrimInt>::to_le(p0);
+<i128>::to_le(p0);
-----------------
src/int.rs <i128 as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i128 as int::PrimInt>::pow(p0, p1);
+crate::<i128 as int::PrimInt>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/int.rs <isize as int::PrimInt>::count_ones
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.count_ones();
+<isize as int::PrimInt>::count_ones(p0);
+crate::<isize as int::PrimInt>::count_ones(p0);
+<isize>::count_ones(p0);
-----------------
src/int.rs <isize as int::PrimInt>::count_zeros
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.count_zeros();
+<isize as int::PrimInt>::count_zeros(p0);
+crate::<isize as int::PrimInt>::count_zeros(p0);
+<isize>::count_zeros(p0);
-----------------
src/int.rs <isize as int::PrimInt>::leading_ones
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.leading_ones();
+<isize as int::PrimInt>::leading_ones(p0);
+crate::<isize as int::PrimInt>::leading_ones(p0);
+<isize>::leading_ones(p0);
-----------------
src/int.rs <isize as int::PrimInt>::leading_zeros
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.leading_zeros();
+<isize as int::PrimInt>::leading_zeros(p0);
+crate::<isize as int::PrimInt>::leading_zeros(p0);
+<isize>::leading_zeros(p0);
-----------------
src/int.rs <isize as int::PrimInt>::trailing_ones
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.trailing_ones();
+<isize as int::PrimInt>::trailing_ones(p0);
+crate::<isize as int::PrimInt>::trailing_ones(p0);
+<isize>::trailing_ones(p0);
-----------------
src/int.rs <isize as int::PrimInt>::trailing_zeros
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.trailing_zeros();
+<isize as int::PrimInt>::trailing_zeros(p0);
+crate::<isize as int::PrimInt>::trailing_zeros(p0);
+<isize>::trailing_zeros(p0);
-----------------
src/int.rs <isize as int::PrimInt>::rotate_left
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.rotate_left(p1);
+<isize as int::PrimInt>::rotate_left(p0, p1);
+crate::<isize as int::PrimInt>::rotate_left(p0, p1);
+<isize>::rotate_left(p0, p1);
-----------------
src/int.rs <isize as int::PrimInt>::rotate_right
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.rotate_right(p1);
+<isize as int::PrimInt>::rotate_right(p0, p1);
+crate::<isize as int::PrimInt>::rotate_right(p0, p1);
+<isize>::rotate_right(p0, p1);
-----------------
src/int.rs <isize as int::PrimInt>::signed_shl
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.signed_shl(p1);
+<isize as int::PrimInt>::signed_shl(p0, p1);
+crate::<isize as int::PrimInt>::signed_shl(p0, p1);
+<isize>::signed_shl(p0, p1);
-----------------
src/int.rs <isize as int::PrimInt>::signed_shr
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.signed_shr(p1);
+<isize as int::PrimInt>::signed_shr(p0, p1);
+crate::<isize as int::PrimInt>::signed_shr(p0, p1);
+<isize>::signed_shr(p0, p1);
-----------------
src/int.rs <isize as int::PrimInt>::unsigned_shl
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.unsigned_shl(p1);
+<isize as int::PrimInt>::unsigned_shl(p0, p1);
+crate::<isize as int::PrimInt>::unsigned_shl(p0, p1);
+<isize>::unsigned_shl(p0, p1);
-----------------
src/int.rs <isize as int::PrimInt>::unsigned_shr
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.unsigned_shr(p1);
+<isize as int::PrimInt>::unsigned_shr(p0, p1);
+crate::<isize as int::PrimInt>::unsigned_shr(p0, p1);
+<isize>::unsigned_shr(p0, p1);
-----------------
src/int.rs <isize as int::PrimInt>::swap_bytes
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.swap_bytes();
+<isize as int::PrimInt>::swap_bytes(p0);
+crate::<isize as int::PrimInt>::swap_bytes(p0);
+<isize>::swap_bytes(p0);
-----------------
src/int.rs <isize as int::PrimInt>::reverse_bits
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.reverse_bits();
+<isize as int::PrimInt>::reverse_bits(p0);
+crate::<isize as int::PrimInt>::reverse_bits(p0);
+<isize>::reverse_bits(p0);
-----------------
src/int.rs <isize as int::PrimInt>::from_be
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<isize as int::PrimInt>::from_be(p0);
+crate::<isize as int::PrimInt>::from_be(p0);
+<isize>::from_be(p0);
-----------------
src/int.rs <isize as int::PrimInt>::from_le
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<isize as int::PrimInt>::from_le(p0);
+crate::<isize as int::PrimInt>::from_le(p0);
+<isize>::from_le(p0);
-----------------
src/int.rs <isize as int::PrimInt>::to_be
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.to_be();
+<isize as int::PrimInt>::to_be(p0);
+crate::<isize as int::PrimInt>::to_be(p0);
+<isize>::to_be(p0);
-----------------
src/int.rs <isize as int::PrimInt>::to_le
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+p0.to_le();
+<isize as int::PrimInt>::to_le(p0);
+crate::<isize as int::PrimInt>::to_le(p0);
+<isize>::to_le(p0);
-----------------
src/int.rs <isize as int::PrimInt>::pow
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<isize as int::PrimInt>::pow(p0, p1);
+crate::<isize as int::PrimInt>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/ops/checked.rs <u8 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.checked_add(p1);
+<u8 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<u8 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<u8>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <u16 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.checked_add(p1);
+<u16 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<u16 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<u16>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <u32 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.checked_add(p1);
+<u32 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<u32 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<u32>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <u64 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.checked_add(p1);
+<u64 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<u64 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<u64>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <usize as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.checked_add(p1);
+<usize as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<usize as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<usize>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <u128 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.checked_add(p1);
+<u128 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<u128 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<u128>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <i8 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.checked_add(p1);
+<i8 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<i8 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<i8>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <i16 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.checked_add(p1);
+<i16 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<i16 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<i16>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <i32 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.checked_add(p1);
+<i32 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<i32 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<i32>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <i64 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.checked_add(p1);
+<i64 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<i64 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<i64>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <isize as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.checked_add(p1);
+<isize as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<isize as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<isize>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <i128 as ops::checked::CheckedAdd>::checked_add
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.checked_add(p1);
+<i128 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+crate::<i128 as ops::checked::CheckedAdd>::checked_add(p0, p1);
+<i128>::checked_add(p0, p1);
-----------------
src/ops/checked.rs <u8 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.checked_sub(p1);
+<u8 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<u8 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<u8>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <u16 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.checked_sub(p1);
+<u16 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<u16 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<u16>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <u32 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.checked_sub(p1);
+<u32 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<u32 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<u32>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <u64 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.checked_sub(p1);
+<u64 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<u64 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<u64>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <usize as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.checked_sub(p1);
+<usize as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<usize as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<usize>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <u128 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.checked_sub(p1);
+<u128 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<u128 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<u128>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <i8 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.checked_sub(p1);
+<i8 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<i8 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<i8>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <i16 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.checked_sub(p1);
+<i16 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<i16 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<i16>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <i32 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.checked_sub(p1);
+<i32 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<i32 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<i32>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <i64 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.checked_sub(p1);
+<i64 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<i64 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<i64>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <isize as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.checked_sub(p1);
+<isize as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<isize as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<isize>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <i128 as ops::checked::CheckedSub>::checked_sub
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.checked_sub(p1);
+<i128 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+crate::<i128 as ops::checked::CheckedSub>::checked_sub(p0, p1);
+<i128>::checked_sub(p0, p1);
-----------------
src/ops/checked.rs <u8 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.checked_mul(p1);
+<u8 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<u8 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<u8>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <u16 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.checked_mul(p1);
+<u16 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<u16 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<u16>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <u32 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.checked_mul(p1);
+<u32 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<u32 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<u32>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <u64 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.checked_mul(p1);
+<u64 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<u64 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<u64>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <usize as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.checked_mul(p1);
+<usize as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<usize as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<usize>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <u128 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.checked_mul(p1);
+<u128 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<u128 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<u128>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <i8 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.checked_mul(p1);
+<i8 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<i8 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<i8>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <i16 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.checked_mul(p1);
+<i16 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<i16 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<i16>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <i32 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.checked_mul(p1);
+<i32 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<i32 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<i32>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <i64 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.checked_mul(p1);
+<i64 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<i64 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<i64>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <isize as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.checked_mul(p1);
+<isize as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<isize as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<isize>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <i128 as ops::checked::CheckedMul>::checked_mul
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.checked_mul(p1);
+<i128 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+crate::<i128 as ops::checked::CheckedMul>::checked_mul(p0, p1);
+<i128>::checked_mul(p0, p1);
-----------------
src/ops/checked.rs <u8 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.checked_div(p1);
+<u8 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<u8 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<u8>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <u16 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.checked_div(p1);
+<u16 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<u16 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<u16>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <u32 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.checked_div(p1);
+<u32 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<u32 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<u32>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <u64 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.checked_div(p1);
+<u64 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<u64 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<u64>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <usize as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.checked_div(p1);
+<usize as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<usize as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<usize>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <u128 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.checked_div(p1);
+<u128 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<u128 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<u128>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <i8 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.checked_div(p1);
+<i8 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<i8 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<i8>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <i16 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.checked_div(p1);
+<i16 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<i16 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<i16>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <i32 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.checked_div(p1);
+<i32 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<i32 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<i32>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <i64 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.checked_div(p1);
+<i64 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<i64 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<i64>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <isize as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.checked_div(p1);
+<isize as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<isize as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<isize>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <i128 as ops::checked::CheckedDiv>::checked_div
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.checked_div(p1);
+<i128 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+crate::<i128 as ops::checked::CheckedDiv>::checked_div(p0, p1);
+<i128>::checked_div(p0, p1);
-----------------
src/ops/checked.rs <u8 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.checked_rem(p1);
+<u8 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<u8 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<u8>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <u16 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.checked_rem(p1);
+<u16 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<u16 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<u16>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <u32 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.checked_rem(p1);
+<u32 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<u32 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<u32>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <u64 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.checked_rem(p1);
+<u64 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<u64 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<u64>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <usize as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.checked_rem(p1);
+<usize as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<usize as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<usize>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <u128 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.checked_rem(p1);
+<u128 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<u128 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<u128>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <i8 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.checked_rem(p1);
+<i8 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<i8 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<i8>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <i16 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.checked_rem(p1);
+<i16 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<i16 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<i16>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <i32 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.checked_rem(p1);
+<i32 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<i32 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<i32>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <i64 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.checked_rem(p1);
+<i64 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<i64 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<i64>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <isize as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.checked_rem(p1);
+<isize as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<isize as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<isize>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <i128 as ops::checked::CheckedRem>::checked_rem
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.checked_rem(p1);
+<i128 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+crate::<i128 as ops::checked::CheckedRem>::checked_rem(p0, p1);
+<i128>::checked_rem(p0, p1);
-----------------
src/ops/checked.rs <u8 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.checked_neg();
+<u8 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<u8 as ops::checked::CheckedNeg>::checked_neg(p0);
+<u8>::checked_neg(p0);
-----------------
src/ops/checked.rs <u16 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.checked_neg();
+<u16 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<u16 as ops::checked::CheckedNeg>::checked_neg(p0);
+<u16>::checked_neg(p0);
-----------------
src/ops/checked.rs <u32 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.checked_neg();
+<u32 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<u32 as ops::checked::CheckedNeg>::checked_neg(p0);
+<u32>::checked_neg(p0);
-----------------
src/ops/checked.rs <u64 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.checked_neg();
+<u64 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<u64 as ops::checked::CheckedNeg>::checked_neg(p0);
+<u64>::checked_neg(p0);
-----------------
src/ops/checked.rs <usize as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.checked_neg();
+<usize as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<usize as ops::checked::CheckedNeg>::checked_neg(p0);
+<usize>::checked_neg(p0);
-----------------
src/ops/checked.rs <u128 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.checked_neg();
+<u128 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<u128 as ops::checked::CheckedNeg>::checked_neg(p0);
+<u128>::checked_neg(p0);
-----------------
src/ops/checked.rs <i8 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.checked_neg();
+<i8 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<i8 as ops::checked::CheckedNeg>::checked_neg(p0);
+<i8>::checked_neg(p0);
-----------------
src/ops/checked.rs <i16 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.checked_neg();
+<i16 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<i16 as ops::checked::CheckedNeg>::checked_neg(p0);
+<i16>::checked_neg(p0);
-----------------
src/ops/checked.rs <i32 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.checked_neg();
+<i32 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<i32 as ops::checked::CheckedNeg>::checked_neg(p0);
+<i32>::checked_neg(p0);
-----------------
src/ops/checked.rs <i64 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.checked_neg();
+<i64 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<i64 as ops::checked::CheckedNeg>::checked_neg(p0);
+<i64>::checked_neg(p0);
-----------------
src/ops/checked.rs <isize as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.checked_neg();
+<isize as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<isize as ops::checked::CheckedNeg>::checked_neg(p0);
+<isize>::checked_neg(p0);
-----------------
src/ops/checked.rs <i128 as ops::checked::CheckedNeg>::checked_neg
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.checked_neg();
+<i128 as ops::checked::CheckedNeg>::checked_neg(p0);
+crate::<i128 as ops::checked::CheckedNeg>::checked_neg(p0);
+<i128>::checked_neg(p0);
-----------------
src/ops/checked.rs <u8 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<u8 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<u8 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<u8>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <u16 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<u16 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<u16 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<u16>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <u32 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<u32 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<u32 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<u32>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <u64 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<u64 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<u64 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<u64>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <usize as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<usize as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<usize as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<usize>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <u128 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<u128 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<u128 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<u128>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <i8 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<i8 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<i8 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<i8>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <i16 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<i16 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<i16 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<i16>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <i32 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<i32 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<i32 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<i32>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <i64 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<i64 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<i64 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<i64>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <isize as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<isize as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<isize as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<isize>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <i128 as ops::checked::CheckedShl>::checked_shl
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.checked_shl(p1);
+<i128 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+crate::<i128 as ops::checked::CheckedShl>::checked_shl(p0, p1);
+<i128>::checked_shl(p0, p1);
-----------------
src/ops/checked.rs <u8 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<u8 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<u8 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<u8>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <u16 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<u16 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<u16 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<u16>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <u32 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<u32 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<u32 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<u32>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <u64 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<u64 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<u64 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<u64>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <usize as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<usize as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<usize as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<usize>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <u128 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<u128 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<u128 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<u128>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <i8 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<i8 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<i8 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<i8>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <i16 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<i16 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<i16 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<i16>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <i32 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<i32 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<i32 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<i32>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <i64 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<i64 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<i64 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<i64>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <isize as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<isize as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<isize as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<isize>::checked_shr(p0, p1);
-----------------
src/ops/checked.rs <i128 as ops::checked::CheckedShr>::checked_shr
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.checked_shr(p1);
+<i128 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+crate::<i128 as ops::checked::CheckedShr>::checked_shr(p0, p1);
+<i128>::checked_shr(p0, p1);
-----------------
src/ops/euclid.rs <isize as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.div_euclid(p1);
+<isize as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<isize as ops::euclid::Euclid>::div_euclid(p0, p1);
+<isize>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <isize as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.rem_euclid(p1);
+<isize as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<isize as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<isize>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i8 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.div_euclid(p1);
+<i8 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<i8 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<i8>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i8 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.rem_euclid(p1);
+<i8 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<i8 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<i8>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i16 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.div_euclid(p1);
+<i16 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<i16 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<i16>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i16 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.rem_euclid(p1);
+<i16 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<i16 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<i16>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i32 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.div_euclid(p1);
+<i32 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<i32 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<i32>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i32 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.rem_euclid(p1);
+<i32 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<i32 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<i32>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i64 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.div_euclid(p1);
+<i64 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<i64 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<i64>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i64 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.rem_euclid(p1);
+<i64 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<i64 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<i64>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i128 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.div_euclid(p1);
+<i128 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<i128 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<i128>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i128 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.rem_euclid(p1);
+<i128 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<i128 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<i128>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <usize as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.div_euclid(p1);
+<usize as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<usize as ops::euclid::Euclid>::div_euclid(p0, p1);
+<usize>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <usize as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.rem_euclid(p1);
+<usize as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<usize as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<usize>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u8 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.div_euclid(p1);
+<u8 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<u8 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<u8>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u8 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.rem_euclid(p1);
+<u8 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<u8 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<u8>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u16 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.div_euclid(p1);
+<u16 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<u16 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<u16>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u16 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.rem_euclid(p1);
+<u16 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<u16 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<u16>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u32 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.div_euclid(p1);
+<u32 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<u32 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<u32>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u32 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.rem_euclid(p1);
+<u32 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<u32 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<u32>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u64 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.div_euclid(p1);
+<u64 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<u64 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<u64>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u64 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.rem_euclid(p1);
+<u64 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<u64 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<u64>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u128 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.div_euclid(p1);
+<u128 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<u128 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<u128>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u128 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.rem_euclid(p1);
+<u128 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<u128 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<u128>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <f32 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0f32; // None+f32
+p0.div_euclid(p1);
+<f32 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<f32 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<f32>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <f32 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0f32; // None+f32
+p0.rem_euclid(p1);
+<f32 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<f32 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<f32>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <f64 as ops::euclid::Euclid>::div_euclid
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0f64; // None+f64
+p0.div_euclid(p1);
+<f64 as ops::euclid::Euclid>::div_euclid(p0, p1);
+crate::<f64 as ops::euclid::Euclid>::div_euclid(p0, p1);
+<f64>::div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <f64 as ops::euclid::Euclid>::rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0f64; // None+f64
+p0.rem_euclid(p1);
+<f64 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+crate::<f64 as ops::euclid::Euclid>::rem_euclid(p0, p1);
+<f64>::rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <isize as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.checked_div_euclid(p1);
+<isize as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<isize as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<isize>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <isize as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.checked_rem_euclid(p1);
+<isize as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<isize as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<isize>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i8 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.checked_div_euclid(p1);
+<i8 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<i8 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<i8>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i8 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.checked_rem_euclid(p1);
+<i8 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<i8 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<i8>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i16 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.checked_div_euclid(p1);
+<i16 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<i16 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<i16>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i16 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.checked_rem_euclid(p1);
+<i16 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<i16 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<i16>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i32 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.checked_div_euclid(p1);
+<i32 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<i32 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<i32>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i32 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.checked_rem_euclid(p1);
+<i32 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<i32 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<i32>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i64 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.checked_div_euclid(p1);
+<i64 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<i64 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<i64>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i64 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.checked_rem_euclid(p1);
+<i64 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<i64 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<i64>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i128 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.checked_div_euclid(p1);
+<i128 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<i128 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<i128>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <i128 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.checked_rem_euclid(p1);
+<i128 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<i128 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<i128>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <usize as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.checked_div_euclid(p1);
+<usize as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<usize as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<usize>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <usize as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.checked_rem_euclid(p1);
+<usize as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<usize as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<usize>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u8 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.checked_div_euclid(p1);
+<u8 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<u8 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<u8>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u8 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.checked_rem_euclid(p1);
+<u8 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<u8 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<u8>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u16 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.checked_div_euclid(p1);
+<u16 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<u16 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<u16>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u16 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.checked_rem_euclid(p1);
+<u16 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<u16 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<u16>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u32 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.checked_div_euclid(p1);
+<u32 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<u32 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<u32>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u32 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.checked_rem_euclid(p1);
+<u32 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<u32 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<u32>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u64 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.checked_div_euclid(p1);
+<u64 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<u64 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<u64>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u64 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.checked_rem_euclid(p1);
+<u64 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<u64 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<u64>::checked_rem_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u128 as ops::euclid::CheckedEuclid>::checked_div_euclid
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.checked_div_euclid(p1);
+<u128 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+crate::<u128 as ops::euclid::CheckedEuclid>::checked_div_euclid(p0, p1);
+<u128>::checked_div_euclid(p0, p1);
-----------------
src/ops/euclid.rs <u128 as ops::euclid::CheckedEuclid>::checked_rem_euclid
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.checked_rem_euclid(p1);
+<u128 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+crate::<u128 as ops::euclid::CheckedEuclid>::checked_rem_euclid(p0, p1);
+<u128>::checked_rem_euclid(p0, p1);
-----------------
src/ops/inv.rs <f32 as ops::inv::Inv>::inv
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+p0.inv();
+<f32 as ops::inv::Inv>::inv(p0);
+crate::<f32 as ops::inv::Inv>::inv(p0);
+<f32>::inv(p0);
-----------------
src/ops/inv.rs <f64 as ops::inv::Inv>::inv
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.inv();
+<f64 as ops::inv::Inv>::inv(p0);
+crate::<f64 as ops::inv::Inv>::inv(p0);
+<f64>::inv(p0);
-----------------
src/ops/inv.rs <&'a f32 as ops::inv::Inv>::inv
'a
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.inv();
+<&'a f32 as ops::inv::Inv>::inv(p0);
+crate::<&'a f32 as ops::inv::Inv>::inv(p0);
+<&'a f32>::inv(p0);
-----------------
src/ops/inv.rs <&'a f64 as ops::inv::Inv>::inv
'a
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.inv();
+<&'a f64 as ops::inv::Inv>::inv(p0);
+crate::<&'a f64 as ops::inv::Inv>::inv(p0);
+<&'a f64>::inv(p0);
-----------------
src/ops/mul_add.rs <f32 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
let mut p2 = 0f32; // None+f32
+p0.mul_add(p1, p2);
+<f32 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<f32 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<f32>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <f64 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
let mut p2 = 0f64; // None+f64
+p0.mul_add(p1, p2);
+<f64 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<f64 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<f64>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <isize as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0isize; // None+isize
let mut p2 = 0isize; // None+isize
+p0.mul_add(p1, p2);
+<isize as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<isize as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<isize>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i8 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0i8; // None+i8
let mut p2 = 0i8; // None+i8
+p0.mul_add(p1, p2);
+<i8 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<i8 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<i8>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i16 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0i16; // None+i16
let mut p2 = 0i16; // None+i16
+p0.mul_add(p1, p2);
+<i16 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<i16 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<i16>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i32 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0i32; // None+i32
let mut p2 = 0i32; // None+i32
+p0.mul_add(p1, p2);
+<i32 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<i32 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<i32>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i64 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0i64; // None+i64
let mut p2 = 0i64; // None+i64
+p0.mul_add(p1, p2);
+<i64 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<i64 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<i64>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i128 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0i128; // None+i128
let mut p2 = 0i128; // None+i128
+p0.mul_add(p1, p2);
+<i128 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<i128 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<i128>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <usize as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.mul_add(p1, p2);
+<usize as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<usize as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<usize>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u8 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
+p0.mul_add(p1, p2);
+<u8 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<u8 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<u8>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u16 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u16; // None+u16
let mut p2 = 0u16; // None+u16
+p0.mul_add(p1, p2);
+<u16 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<u16 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<u16>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u32 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+p0.mul_add(p1, p2);
+<u32 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<u32 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<u32>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u64 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u64; // None+u64
let mut p2 = 0u64; // None+u64
+p0.mul_add(p1, p2);
+<u64 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<u64 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<u64>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u128 as ops::mul_add::MulAdd>::mul_add
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u128; // None+u128
let mut p2 = 0u128; // None+u128
+p0.mul_add(p1, p2);
+<u128 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+crate::<u128 as ops::mul_add::MulAdd>::mul_add(p0, p1, p2);
+<u128>::mul_add(p0, p1, p2);
-----------------
src/ops/mul_add.rs <f32 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0f32; // None+f32
let mut p1 = 0f32; // None+f32
let mut p2 = 0f32; // None+f32
+p0.mul_add_assign(p1, p2);
+<f32 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<f32 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<f32>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <f64 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0f64; // None+f64
let mut p1 = 0f64; // None+f64
let mut p2 = 0f64; // None+f64
+p0.mul_add_assign(p1, p2);
+<f64 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<f64 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<f64>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <isize as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0isize; // None+isize
let mut p1 = 0isize; // None+isize
let mut p2 = 0isize; // None+isize
+p0.mul_add_assign(p1, p2);
+<isize as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<isize as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<isize>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i8 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0i8; // None+i8
let mut p1 = 0i8; // None+i8
let mut p2 = 0i8; // None+i8
+p0.mul_add_assign(p1, p2);
+<i8 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<i8 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<i8>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i16 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0i16; // None+i16
let mut p1 = 0i16; // None+i16
let mut p2 = 0i16; // None+i16
+p0.mul_add_assign(p1, p2);
+<i16 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<i16 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<i16>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i32 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0i32; // None+i32
let mut p1 = 0i32; // None+i32
let mut p2 = 0i32; // None+i32
+p0.mul_add_assign(p1, p2);
+<i32 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<i32 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<i32>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i64 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0i64; // None+i64
let mut p1 = 0i64; // None+i64
let mut p2 = 0i64; // None+i64
+p0.mul_add_assign(p1, p2);
+<i64 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<i64 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<i64>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <i128 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0i128; // None+i128
let mut p1 = 0i128; // None+i128
let mut p2 = 0i128; // None+i128
+p0.mul_add_assign(p1, p2);
+<i128 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<i128 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<i128>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <usize as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.mul_add_assign(p1, p2);
+<usize as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<usize as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<usize>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u8 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0u8; // None+u8
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
+p0.mul_add_assign(p1, p2);
+<u8 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<u8 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<u8>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u16 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0u16; // None+u16
let mut p1 = 0u16; // None+u16
let mut p2 = 0u16; // None+u16
+p0.mul_add_assign(p1, p2);
+<u16 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<u16 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<u16>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u32 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+p0.mul_add_assign(p1, p2);
+<u32 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<u32 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<u32>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u64 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0u64; // None+u64
let mut p1 = 0u64; // None+u64
let mut p2 = 0u64; // None+u64
+p0.mul_add_assign(p1, p2);
+<u64 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<u64 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<u64>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/mul_add.rs <u128 as ops::mul_add::MulAddAssign>::mul_add_assign
deps:{}
candidates:{}
let mut p0 = &mut 0u128; // None+u128
let mut p1 = 0u128; // None+u128
let mut p2 = 0u128; // None+u128
+p0.mul_add_assign(p1, p2);
+<u128 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+crate::<u128 as ops::mul_add::MulAddAssign>::mul_add_assign(p0, p1, p2);
+<u128>::mul_add_assign(p0, p1, p2);
-----------------
src/ops/overflowing.rs <u8 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.overflowing_add(p1);
+<u8 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<u8 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<u8>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <u16 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.overflowing_add(p1);
+<u16 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<u16 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<u16>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <u32 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.overflowing_add(p1);
+<u32 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<u32 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<u32>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <u64 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.overflowing_add(p1);
+<u64 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<u64 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<u64>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <usize as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.overflowing_add(p1);
+<usize as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<usize as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<usize>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <u128 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.overflowing_add(p1);
+<u128 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<u128 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<u128>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <i8 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.overflowing_add(p1);
+<i8 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<i8 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<i8>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <i16 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.overflowing_add(p1);
+<i16 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<i16 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<i16>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <i32 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.overflowing_add(p1);
+<i32 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<i32 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<i32>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <i64 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.overflowing_add(p1);
+<i64 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<i64 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<i64>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <isize as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.overflowing_add(p1);
+<isize as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<isize as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<isize>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <i128 as ops::overflowing::OverflowingAdd>::overflowing_add
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.overflowing_add(p1);
+<i128 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+crate::<i128 as ops::overflowing::OverflowingAdd>::overflowing_add(p0, p1);
+<i128>::overflowing_add(p0, p1);
-----------------
src/ops/overflowing.rs <u8 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.overflowing_sub(p1);
+<u8 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<u8 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<u8>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <u16 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.overflowing_sub(p1);
+<u16 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<u16 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<u16>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <u32 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.overflowing_sub(p1);
+<u32 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<u32 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<u32>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <u64 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.overflowing_sub(p1);
+<u64 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<u64 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<u64>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <usize as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.overflowing_sub(p1);
+<usize as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<usize as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<usize>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <u128 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.overflowing_sub(p1);
+<u128 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<u128 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<u128>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <i8 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.overflowing_sub(p1);
+<i8 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<i8 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<i8>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <i16 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.overflowing_sub(p1);
+<i16 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<i16 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<i16>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <i32 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.overflowing_sub(p1);
+<i32 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<i32 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<i32>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <i64 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.overflowing_sub(p1);
+<i64 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<i64 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<i64>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <isize as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.overflowing_sub(p1);
+<isize as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<isize as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<isize>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <i128 as ops::overflowing::OverflowingSub>::overflowing_sub
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.overflowing_sub(p1);
+<i128 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+crate::<i128 as ops::overflowing::OverflowingSub>::overflowing_sub(p0, p1);
+<i128>::overflowing_sub(p0, p1);
-----------------
src/ops/overflowing.rs <u8 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.overflowing_mul(p1);
+<u8 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<u8 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<u8>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <u16 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.overflowing_mul(p1);
+<u16 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<u16 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<u16>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <u32 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.overflowing_mul(p1);
+<u32 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<u32 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<u32>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <u64 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.overflowing_mul(p1);
+<u64 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<u64 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<u64>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <usize as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.overflowing_mul(p1);
+<usize as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<usize as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<usize>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <u128 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.overflowing_mul(p1);
+<u128 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<u128 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<u128>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <i8 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.overflowing_mul(p1);
+<i8 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<i8 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<i8>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <i16 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.overflowing_mul(p1);
+<i16 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<i16 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<i16>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <i32 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.overflowing_mul(p1);
+<i32 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<i32 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<i32>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <i64 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.overflowing_mul(p1);
+<i64 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<i64 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<i64>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <isize as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.overflowing_mul(p1);
+<isize as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<isize as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<isize>::overflowing_mul(p0, p1);
-----------------
src/ops/overflowing.rs <i128 as ops::overflowing::OverflowingMul>::overflowing_mul
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.overflowing_mul(p1);
+<i128 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+crate::<i128 as ops::overflowing::OverflowingMul>::overflowing_mul(p0, p1);
+<i128>::overflowing_mul(p0, p1);
-----------------
src/ops/saturating.rs <isize as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0isize; // None+isize
+p0.saturating_add(p1);
+<isize as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<isize as ops::saturating::Saturating>::saturating_add(p0, p1);
+<isize>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <isize as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0isize; // None+isize
+p0.saturating_sub(p1);
+<isize as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<isize as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<isize>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i8 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0i8; // None+i8
+p0.saturating_add(p1);
+<i8 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<i8 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<i8>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i8 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0i8; // None+i8
+p0.saturating_sub(p1);
+<i8 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<i8 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<i8>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i16 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0i16; // None+i16
+p0.saturating_add(p1);
+<i16 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<i16 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<i16>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i16 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0i16; // None+i16
+p0.saturating_sub(p1);
+<i16 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<i16 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<i16>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i32 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0i32; // None+i32
+p0.saturating_add(p1);
+<i32 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<i32 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<i32>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i32 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0i32; // None+i32
+p0.saturating_sub(p1);
+<i32 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<i32 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<i32>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i64 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0i64; // None+i64
+p0.saturating_add(p1);
+<i64 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<i64 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<i64>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i64 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0i64; // None+i64
+p0.saturating_sub(p1);
+<i64 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<i64 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<i64>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i128 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0i128; // None+i128
+p0.saturating_add(p1);
+<i128 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<i128 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<i128>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i128 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0i128; // None+i128
+p0.saturating_sub(p1);
+<i128 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<i128 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<i128>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <usize as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+p0.saturating_add(p1);
+<usize as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<usize as ops::saturating::Saturating>::saturating_add(p0, p1);
+<usize>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <usize as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+p0.saturating_sub(p1);
+<usize as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<usize as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<usize>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u8 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+p0.saturating_add(p1);
+<u8 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<u8 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<u8>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u8 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+p0.saturating_sub(p1);
+<u8 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<u8 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<u8>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u16 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u16; // None+u16
+p0.saturating_add(p1);
+<u16 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<u16 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<u16>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u16 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u16; // None+u16
+p0.saturating_sub(p1);
+<u16 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<u16 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<u16>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u32 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.saturating_add(p1);
+<u32 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<u32 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<u32>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u32 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.saturating_sub(p1);
+<u32 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<u32 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<u32>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u64 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u64; // None+u64
+p0.saturating_add(p1);
+<u64 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<u64 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<u64>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u64 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u64; // None+u64
+p0.saturating_sub(p1);
+<u64 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<u64 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<u64>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u128 as ops::saturating::Saturating>::saturating_add
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u128; // None+u128
+p0.saturating_add(p1);
+<u128 as ops::saturating::Saturating>::saturating_add(p0, p1);
+crate::<u128 as ops::saturating::Saturating>::saturating_add(p0, p1);
+<u128>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u128 as ops::saturating::Saturating>::saturating_sub
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u128; // None+u128
+p0.saturating_sub(p1);
+<u128 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+crate::<u128 as ops::saturating::Saturating>::saturating_sub(p0, p1);
+<u128>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u8 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.saturating_add(p1);
+<u8 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<u8 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<u8>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u16 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.saturating_add(p1);
+<u16 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<u16 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<u16>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u32 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.saturating_add(p1);
+<u32 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<u32 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<u32>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u64 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.saturating_add(p1);
+<u64 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<u64 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<u64>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <usize as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.saturating_add(p1);
+<usize as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<usize as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<usize>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u128 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.saturating_add(p1);
+<u128 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<u128 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<u128>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i8 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.saturating_add(p1);
+<i8 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<i8 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<i8>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i16 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.saturating_add(p1);
+<i16 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<i16 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<i16>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i32 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.saturating_add(p1);
+<i32 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<i32 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<i32>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i64 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.saturating_add(p1);
+<i64 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<i64 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<i64>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <isize as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.saturating_add(p1);
+<isize as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<isize as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<isize>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <i128 as ops::saturating::SaturatingAdd>::saturating_add
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.saturating_add(p1);
+<i128 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+crate::<i128 as ops::saturating::SaturatingAdd>::saturating_add(p0, p1);
+<i128>::saturating_add(p0, p1);
-----------------
src/ops/saturating.rs <u8 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.saturating_sub(p1);
+<u8 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<u8 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<u8>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u16 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.saturating_sub(p1);
+<u16 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<u16 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<u16>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u32 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.saturating_sub(p1);
+<u32 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<u32 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<u32>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u64 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.saturating_sub(p1);
+<u64 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<u64 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<u64>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <usize as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.saturating_sub(p1);
+<usize as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<usize as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<usize>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u128 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.saturating_sub(p1);
+<u128 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<u128 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<u128>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i8 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.saturating_sub(p1);
+<i8 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<i8 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<i8>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i16 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.saturating_sub(p1);
+<i16 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<i16 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<i16>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i32 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.saturating_sub(p1);
+<i32 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<i32 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<i32>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i64 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.saturating_sub(p1);
+<i64 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<i64 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<i64>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <isize as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.saturating_sub(p1);
+<isize as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<isize as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<isize>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <i128 as ops::saturating::SaturatingSub>::saturating_sub
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.saturating_sub(p1);
+<i128 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+crate::<i128 as ops::saturating::SaturatingSub>::saturating_sub(p0, p1);
+<i128>::saturating_sub(p0, p1);
-----------------
src/ops/saturating.rs <u8 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.saturating_mul(p1);
+<u8 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<u8 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<u8>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <u16 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.saturating_mul(p1);
+<u16 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<u16 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<u16>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <u32 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.saturating_mul(p1);
+<u32 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<u32 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<u32>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <u64 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.saturating_mul(p1);
+<u64 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<u64 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<u64>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <usize as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.saturating_mul(p1);
+<usize as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<usize as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<usize>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <u128 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.saturating_mul(p1);
+<u128 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<u128 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<u128>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <i8 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.saturating_mul(p1);
+<i8 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<i8 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<i8>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <i16 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.saturating_mul(p1);
+<i16 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<i16 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<i16>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <i32 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.saturating_mul(p1);
+<i32 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<i32 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<i32>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <i64 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.saturating_mul(p1);
+<i64 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<i64 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<i64>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <isize as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.saturating_mul(p1);
+<isize as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<isize as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<isize>::saturating_mul(p0, p1);
-----------------
src/ops/saturating.rs <i128 as ops::saturating::SaturatingMul>::saturating_mul
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.saturating_mul(p1);
+<i128 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+crate::<i128 as ops::saturating::SaturatingMul>::saturating_mul(p0, p1);
+<i128>::saturating_mul(p0, p1);
-----------------
src/ops/wrapping.rs <u8 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.wrapping_add(p1);
+<u8 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<u8 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<u8>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <u16 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.wrapping_add(p1);
+<u16 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<u16 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<u16>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <u32 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.wrapping_add(p1);
+<u32 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<u32 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<u32>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <u64 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.wrapping_add(p1);
+<u64 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<u64 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<u64>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <usize as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.wrapping_add(p1);
+<usize as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<usize as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<usize>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <u128 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.wrapping_add(p1);
+<u128 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<u128 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<u128>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <i8 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.wrapping_add(p1);
+<i8 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<i8 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<i8>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <i16 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.wrapping_add(p1);
+<i16 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<i16 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<i16>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <i32 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.wrapping_add(p1);
+<i32 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<i32 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<i32>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <i64 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.wrapping_add(p1);
+<i64 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<i64 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<i64>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <isize as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.wrapping_add(p1);
+<isize as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<isize as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<isize>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <i128 as ops::wrapping::WrappingAdd>::wrapping_add
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.wrapping_add(p1);
+<i128 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<i128 as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<i128>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <u8 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.wrapping_sub(p1);
+<u8 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<u8 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<u8>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <u16 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.wrapping_sub(p1);
+<u16 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<u16 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<u16>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <u32 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.wrapping_sub(p1);
+<u32 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<u32 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<u32>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <u64 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.wrapping_sub(p1);
+<u64 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<u64 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<u64>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <usize as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.wrapping_sub(p1);
+<usize as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<usize as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<usize>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <u128 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.wrapping_sub(p1);
+<u128 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<u128 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<u128>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <i8 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.wrapping_sub(p1);
+<i8 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<i8 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<i8>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <i16 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.wrapping_sub(p1);
+<i16 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<i16 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<i16>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <i32 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.wrapping_sub(p1);
+<i32 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<i32 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<i32>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <i64 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.wrapping_sub(p1);
+<i64 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<i64 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<i64>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <isize as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.wrapping_sub(p1);
+<isize as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<isize as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<isize>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <i128 as ops::wrapping::WrappingSub>::wrapping_sub
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.wrapping_sub(p1);
+<i128 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<i128 as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<i128>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <u8 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.wrapping_mul(p1);
+<u8 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<u8 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<u8>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <u16 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.wrapping_mul(p1);
+<u16 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<u16 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<u16>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <u32 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.wrapping_mul(p1);
+<u32 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<u32 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<u32>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <u64 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u64; // None+u64
+p0.wrapping_mul(p1);
+<u64 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<u64 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<u64>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <usize as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.wrapping_mul(p1);
+<usize as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<usize as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<usize>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <u128 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u128; // None+u128
+p0.wrapping_mul(p1);
+<u128 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<u128 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<u128>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <i8 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.wrapping_mul(p1);
+<i8 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<i8 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<i8>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <i16 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.wrapping_mul(p1);
+<i16 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<i16 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<i16>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <i32 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.wrapping_mul(p1);
+<i32 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<i32 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<i32>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <i64 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.wrapping_mul(p1);
+<i64 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<i64 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<i64>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <isize as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.wrapping_mul(p1);
+<isize as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<isize as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<isize>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <i128 as ops::wrapping::WrappingMul>::wrapping_mul
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.wrapping_mul(p1);
+<i128 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<i128 as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<i128>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <u8 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.wrapping_neg();
+<u8 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<u8 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<u8>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <u16 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.wrapping_neg();
+<u16 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<u16 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<u16>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <u32 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.wrapping_neg();
+<u32 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<u32 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<u32>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <u64 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.wrapping_neg();
+<u64 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<u64 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<u64>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <usize as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.wrapping_neg();
+<usize as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<usize as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<usize>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <u128 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
+p0.wrapping_neg();
+<u128 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<u128 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<u128>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <i8 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.wrapping_neg();
+<i8 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<i8 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<i8>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <i16 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.wrapping_neg();
+<i16 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<i16 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<i16>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <i32 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.wrapping_neg();
+<i32 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<i32 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<i32>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <i64 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.wrapping_neg();
+<i64 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<i64 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<i64>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <isize as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.wrapping_neg();
+<isize as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<isize as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<isize>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <i128 as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.wrapping_neg();
+<i128 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<i128 as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<i128>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <u8 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<u8 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<u8 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<u8>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <u16 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<u16 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<u16 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<u16>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <u32 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<u32 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<u32 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<u32>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <u64 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<u64 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<u64 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<u64>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <usize as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<usize as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<usize as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<usize>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <u128 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<u128 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<u128 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<u128>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <i8 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<i8 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<i8 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<i8>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <i16 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<i16 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<i16 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<i16>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <i32 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<i32 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<i32 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<i32>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <i64 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<i64 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<i64 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<i64>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <isize as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<isize as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<isize as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<isize>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <i128 as ops::wrapping::WrappingShl>::wrapping_shl
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<i128 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<i128 as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<i128>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <u8 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<u8 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<u8 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<u8>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <u16 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<u16 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<u16 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<u16>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <u32 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<u32 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<u32 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<u32>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <u64 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<u64 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<u64 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<u64>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <usize as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<usize as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<usize as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<usize>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <u128 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<u128 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<u128 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<u128>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <i8 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<i8 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<i8 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<i8>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <i16 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<i16 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<i16 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<i16>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <i32 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<i32 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<i32 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<i32>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <i64 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<i64 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<i64 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<i64>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <isize as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<isize as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<isize as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<isize>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <i128 as ops::wrapping::WrappingShr>::wrapping_shr
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<i128 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<i128 as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<i128>::wrapping_shr(p0, p1);
-----------------
src/ops/wrapping.rs <std::num::Wrapping<T> as ops::wrapping::WrappingAdd>::wrapping_add
deps:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingAdd>::wrapping_add":{"T":["ops::wrapping::WrappingAdd","std::marker::Sized"],"std::num::Wrapping<T>":["std::ops::Add"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["ops::wrapping::WrappingMul","cast::FromPrimitive","cast::NumCast","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","sign::Unsigned","std::marker::Sized","bounds::Bounded","cast::ToPrimitive","ops::wrapping::WrappingShr","Num","sign::Signed","ops::wrapping::WrappingAdd","identities::Zero","identities::One","ops::wrapping::WrappingSub"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingAdd>::wrapping_add":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::mem::Assume","std::simd::Simd<i64, N>","std::time::Duration","std::time::Instant","std::simd::Simd<i8, N>","std::string::String","std::simd::Simd<f32, N>","std::simd::Simd<i16, N>","std::simd::Simd<usize, N>","std::simd::Simd<i32, N>","std::simd::Simd<u16, N>","<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>","std::time::SystemTime","std::simd::Simd<f64, N>","std::simd::Simd<isize, N>","std::simd::Simd<T, LANES>","std::simd::Simd<u64, N>","std::simd::Simd<u8, N>","std::simd::Simd<u32, N>"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.wrapping_add(p1);
+<std::num::Wrapping<T> as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+crate::<std::num::Wrapping<T> as ops::wrapping::WrappingAdd>::wrapping_add(p0, p1);
+<std::num::Wrapping<T>>::wrapping_add(p0, p1);
-----------------
src/ops/wrapping.rs <std::num::Wrapping<T> as ops::wrapping::WrappingSub>::wrapping_sub
deps:{"<&'a std::num::Saturating<i128> as std::ops::Sub<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Sub<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Sub<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Sub<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Sub<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Sub<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Sub<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Sub<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Sub<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Sub<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Sub<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Sub<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Sub<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Sub<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Sub<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Sub<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Sub<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Sub<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Sub<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Sub<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Sub<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Sub<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Sub<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Sub<std::num::Wrapping<usize>>>":{},"<&hashbrown::set::HashSet<T, S> as std::ops::Sub<&hashbrown::set::HashSet<T, S>>>":{},"<&std::collections::BTreeSet<T, A> as std::ops::Sub<&std::collections::BTreeSet<T, A>>>":{},"<&std::collections::HashSet<T, S> as std::ops::Sub<&std::collections::HashSet<T, S>>>":{},"<&std::num::Saturating<i128> as std::ops::Sub<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Sub<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Sub<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Sub<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Sub<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Sub<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Sub<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Sub<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Sub<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Sub<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Sub<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Sub<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Sub<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Sub<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Sub<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Sub<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Sub<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Sub<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Sub<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Sub<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Sub<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Sub<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Sub<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Sub<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingSub>::wrapping_sub":{"T":["std::marker::Sized","ops::wrapping::WrappingSub"],"std::num::Wrapping<T>":["std::ops::Sub"]},"core::core_simd::ops::deref::<impl std::ops::Sub<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Sub<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["sign::Unsigned","ops::wrapping::WrappingAdd","bounds::Bounded","cast::FromPrimitive","Num","ops::wrapping::WrappingMul","identities::One","sign::Signed","std::marker::Sized","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","cast::ToPrimitive","identities::Zero","ops::wrapping::WrappingNeg","cast::NumCast"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Sub<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Sub<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Sub<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Sub<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Sub<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Sub<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Sub<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Sub<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Sub<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Sub<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Sub<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Sub<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Sub<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Sub<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Sub<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Sub<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Sub<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Sub<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Sub<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Sub<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Sub<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Sub<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Sub<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Sub<std::num::Wrapping<usize>>>":{},"<&hashbrown::set::HashSet<T, S> as std::ops::Sub<&hashbrown::set::HashSet<T, S>>>":{},"<&std::collections::BTreeSet<T, A> as std::ops::Sub<&std::collections::BTreeSet<T, A>>>":{},"<&std::collections::HashSet<T, S> as std::ops::Sub<&std::collections::HashSet<T, S>>>":{},"<&std::num::Saturating<i128> as std::ops::Sub<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Sub<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Sub<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Sub<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Sub<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Sub<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Sub<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Sub<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Sub<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Sub<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Sub<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Sub<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Sub<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Sub<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Sub<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Sub<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Sub<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Sub<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Sub<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Sub<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Sub<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Sub<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Sub<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Sub<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingSub>::wrapping_sub":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::simd::Simd<i64, N>","std::simd::Simd<u32, N>","std::time::Duration","std::mem::Assume","std::simd::Simd<u64, N>","std::simd::Simd<u8, N>","std::time::SystemTime","std::simd::Simd<f32, N>","std::simd::Simd<isize, N>","std::simd::Simd<i32, N>","<&std::num::Saturating<i16> as std::ops::Sub<&std::num::Saturating<i16>>>","std::simd::Simd<i8, N>","std::simd::Simd<T, LANES>","std::simd::Simd<f64, N>","std::simd::Simd<i16, N>","std::simd::Simd<usize, N>","std::simd::Simd<u16, N>"]},"core::core_simd::ops::deref::<impl std::ops::Sub<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Sub<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.wrapping_sub(p1);
+<std::num::Wrapping<T> as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+crate::<std::num::Wrapping<T> as ops::wrapping::WrappingSub>::wrapping_sub(p0, p1);
+<std::num::Wrapping<T>>::wrapping_sub(p0, p1);
-----------------
src/ops/wrapping.rs <std::num::Wrapping<T> as ops::wrapping::WrappingMul>::wrapping_mul
deps:{"<&'a std::num::Saturating<i128> as std::ops::Mul<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Mul<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Mul<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Mul<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Mul<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Mul<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Mul<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Mul<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Mul<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Mul<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Mul<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Mul<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Mul<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Mul<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Mul<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Mul<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Mul<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Mul<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Mul<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Mul<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Mul<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Mul<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Mul<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Mul<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Mul<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Mul<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Mul<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Mul<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Mul<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Mul<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Mul<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Mul<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Mul<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Mul<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Mul<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Mul<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Mul<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Mul<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Mul<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Mul<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Mul<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Mul<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Mul<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Mul<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Mul<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Mul<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Mul<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Mul<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingMul>::wrapping_mul":{"T":["ops::wrapping::WrappingMul","std::marker::Sized"],"std::num::Wrapping<T>":["std::ops::Mul"]},"core::core_simd::ops::deref::<impl std::ops::Mul<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Mul<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["sign::Signed","bounds::Bounded","identities::One","cast::NumCast","identities::Zero","ops::wrapping::WrappingNeg","cast::ToPrimitive","ops::wrapping::WrappingMul","ops::wrapping::WrappingSub","ops::wrapping::WrappingAdd","sign::Unsigned","cast::FromPrimitive","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","Num","std::marker::Sized"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Mul<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Mul<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Mul<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Mul<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Mul<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Mul<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Mul<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Mul<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Mul<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Mul<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Mul<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Mul<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Mul<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Mul<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Mul<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Mul<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Mul<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Mul<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Mul<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Mul<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Mul<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Mul<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Mul<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Mul<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Mul<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Mul<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Mul<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Mul<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Mul<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Mul<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Mul<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Mul<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Mul<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Mul<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Mul<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Mul<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Mul<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Mul<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Mul<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Mul<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Mul<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Mul<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Mul<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Mul<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Mul<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Mul<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Mul<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Mul<&std::num::Wrapping<usize>>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingMul>::wrapping_mul":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::simd::Simd<i16, N>","std::simd::Simd<T, LANES>","std::simd::Simd<u8, N>","<&'a std::num::Wrapping<i16> as std::ops::Mul<std::num::Wrapping<i16>>>","std::simd::Simd<u16, N>","std::simd::Simd<u32, N>","std::simd::Simd<i32, N>","std::simd::Simd<i8, N>","std::simd::Simd<i64, N>","std::simd::Simd<f64, N>","std::simd::Simd<isize, N>","std::simd::Simd<f32, N>","std::simd::Simd<u64, N>","std::simd::Simd<usize, N>","std::time::Duration"]},"core::core_simd::ops::deref::<impl std::ops::Mul<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Mul<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.wrapping_mul(p1);
+<std::num::Wrapping<T> as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+crate::<std::num::Wrapping<T> as ops::wrapping::WrappingMul>::wrapping_mul(p0, p1);
+<std::num::Wrapping<T>>::wrapping_mul(p0, p1);
-----------------
src/ops/wrapping.rs <std::num::Wrapping<T> as ops::wrapping::WrappingNeg>::wrapping_neg
deps:{"<&std::num::Saturating<i128> as std::ops::Neg>":{},"<&std::num::Saturating<i16> as std::ops::Neg>":{},"<&std::num::Saturating<i32> as std::ops::Neg>":{},"<&std::num::Saturating<i64> as std::ops::Neg>":{},"<&std::num::Saturating<i8> as std::ops::Neg>":{},"<&std::num::Saturating<isize> as std::ops::Neg>":{},"<&std::num::Wrapping<i128> as std::ops::Neg>":{},"<&std::num::Wrapping<i16> as std::ops::Neg>":{},"<&std::num::Wrapping<i32> as std::ops::Neg>":{},"<&std::num::Wrapping<i64> as std::ops::Neg>":{},"<&std::num::Wrapping<i8> as std::ops::Neg>":{},"<&std::num::Wrapping<isize> as std::ops::Neg>":{},"<&std::num::Wrapping<u128> as std::ops::Neg>":{},"<&std::num::Wrapping<u16> as std::ops::Neg>":{},"<&std::num::Wrapping<u32> as std::ops::Neg>":{},"<&std::num::Wrapping<u64> as std::ops::Neg>":{},"<&std::num::Wrapping<u8> as std::ops::Neg>":{},"<&std::num::Wrapping<usize> as std::ops::Neg>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingNeg>::wrapping_neg":{"T":["std::marker::Sized","ops::wrapping::WrappingNeg"],"std::num::Wrapping<T>":["std::ops::Neg"]},"std::num::Wrapping":{"T":["identities::Zero","ops::wrapping::WrappingNeg","std::marker::Sized","identities::One","sign::Unsigned","sign::Signed","ops::wrapping::WrappingShl","cast::FromPrimitive","ops::wrapping::WrappingShr","bounds::Bounded","cast::NumCast","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","Num","cast::ToPrimitive","ops::wrapping::WrappingSub"]}}
candidates:{"<&std::num::Saturating<i128> as std::ops::Neg>":{},"<&std::num::Saturating<i16> as std::ops::Neg>":{},"<&std::num::Saturating<i32> as std::ops::Neg>":{},"<&std::num::Saturating<i64> as std::ops::Neg>":{},"<&std::num::Saturating<i8> as std::ops::Neg>":{},"<&std::num::Saturating<isize> as std::ops::Neg>":{},"<&std::num::Wrapping<i128> as std::ops::Neg>":{},"<&std::num::Wrapping<i16> as std::ops::Neg>":{},"<&std::num::Wrapping<i32> as std::ops::Neg>":{},"<&std::num::Wrapping<i64> as std::ops::Neg>":{},"<&std::num::Wrapping<i8> as std::ops::Neg>":{},"<&std::num::Wrapping<isize> as std::ops::Neg>":{},"<&std::num::Wrapping<u128> as std::ops::Neg>":{},"<&std::num::Wrapping<u16> as std::ops::Neg>":{},"<&std::num::Wrapping<u32> as std::ops::Neg>":{},"<&std::num::Wrapping<u64> as std::ops::Neg>":{},"<&std::num::Wrapping<u8> as std::ops::Neg>":{},"<&std::num::Wrapping<usize> as std::ops::Neg>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingNeg>::wrapping_neg":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["i64","i32","i8","<&std::num::Wrapping<i8> as std::ops::Neg>","i16"]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.wrapping_neg();
+<std::num::Wrapping<T> as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+crate::<std::num::Wrapping<T> as ops::wrapping::WrappingNeg>::wrapping_neg(p0);
+<std::num::Wrapping<T>>::wrapping_neg(p0);
-----------------
src/ops/wrapping.rs <std::num::Wrapping<T> as ops::wrapping::WrappingShl>::wrapping_shl
deps:{"<&'a std::num::Saturating<i128> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<i16> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<i32> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<i64> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<i8> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<isize> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u128> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u16> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u32> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u64> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u8> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<usize> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Shl<usize>>":{},"<&std::num::Saturating<i128> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<i16> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<i32> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<i64> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<i8> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<isize> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u128> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u16> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u32> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u64> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u8> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<usize> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i128> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i16> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i32> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i64> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i8> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<isize> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u128> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u16> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u32> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u64> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u8> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<usize> as std::ops::Shl<&usize>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingShl>::wrapping_shl":{"T":["ops::wrapping::WrappingShl","std::marker::Sized"],"std::num::Wrapping<T>":["std::ops::Shl"]},"core::core_simd::ops::deref::<impl std::ops::Shl<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Shl<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["ops::wrapping::WrappingShr","ops::wrapping::WrappingNeg","sign::Unsigned","cast::NumCast","ops::wrapping::WrappingAdd","ops::wrapping::WrappingSub","cast::FromPrimitive","identities::Zero","cast::ToPrimitive","identities::One","std::marker::Sized","ops::wrapping::WrappingMul","bounds::Bounded","ops::wrapping::WrappingShl","Num","sign::Signed"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<i16> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<i32> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<i64> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<i8> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<isize> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u128> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u16> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u32> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u64> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<u8> as std::ops::Shl<usize>>":{},"<&'a std::num::Saturating<usize> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Shl<usize>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Shl<usize>>":{},"<&std::num::Saturating<i128> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<i16> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<i32> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<i64> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<i8> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<isize> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u128> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u16> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u32> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u64> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<u8> as std::ops::Shl<&usize>>":{},"<&std::num::Saturating<usize> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i128> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i16> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i32> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i64> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<i8> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<isize> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u128> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u16> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u32> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u64> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<u8> as std::ops::Shl<&usize>>":{},"<&std::num::Wrapping<usize> as std::ops::Shl<&usize>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingShl>::wrapping_shl":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["<&'a std::num::Wrapping<i32> as std::ops::Shl<usize>>","std::simd::Simd<u64, N>","std::simd::Simd<i32, N>","std::simd::Simd<usize, N>","std::simd::Simd<i8, N>","std::simd::Simd<u16, N>","std::simd::Simd<i16, N>","std::simd::Simd<i64, N>","std::simd::Simd<u8, N>","std::simd::Simd<u32, N>","std::simd::Simd<isize, N>","std::simd::Simd<T, LANES>"]},"core::core_simd::ops::deref::<impl std::ops::Shl<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Shl<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
let mut p1 = 0u32; // None+u32
+p0.wrapping_shl(p1);
+<std::num::Wrapping<T> as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+crate::<std::num::Wrapping<T> as ops::wrapping::WrappingShl>::wrapping_shl(p0, p1);
+<std::num::Wrapping<T>>::wrapping_shl(p0, p1);
-----------------
src/ops/wrapping.rs <std::num::Wrapping<T> as ops::wrapping::WrappingShr>::wrapping_shr
deps:{"<&'a std::num::Saturating<i128> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<i16> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<i32> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<i64> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<i8> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<isize> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u128> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u16> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u32> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u64> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u8> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<usize> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Shr<usize>>":{},"<&std::num::Saturating<i128> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<i16> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<i32> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<i64> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<i8> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<isize> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u128> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u16> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u32> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u64> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u8> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<usize> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i128> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i16> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i32> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i64> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i8> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<isize> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u128> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u16> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u32> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u64> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u8> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<usize> as std::ops::Shr<&usize>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingShr>::wrapping_shr":{"T":["ops::wrapping::WrappingShr","std::marker::Sized"],"std::num::Wrapping<T>":["std::ops::Shr"]},"core::core_simd::ops::deref::<impl std::ops::Shr<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Shr<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::marker::Sized","Num","identities::Zero","bounds::Bounded","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","sign::Signed","cast::NumCast","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","cast::ToPrimitive","sign::Unsigned","identities::One","ops::wrapping::WrappingSub","cast::FromPrimitive","ops::wrapping::WrappingNeg"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<i16> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<i32> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<i64> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<i8> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<isize> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u128> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u16> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u32> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u64> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<u8> as std::ops::Shr<usize>>":{},"<&'a std::num::Saturating<usize> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Shr<usize>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Shr<usize>>":{},"<&std::num::Saturating<i128> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<i16> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<i32> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<i64> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<i8> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<isize> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u128> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u16> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u32> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u64> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<u8> as std::ops::Shr<&usize>>":{},"<&std::num::Saturating<usize> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i128> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i16> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i32> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i64> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<i8> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<isize> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u128> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u16> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u32> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u64> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<u8> as std::ops::Shr<&usize>>":{},"<&std::num::Wrapping<usize> as std::ops::Shr<&usize>>":{},"<std::num::Wrapping<T> as ops::wrapping::WrappingShr>::wrapping_shr":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["std::simd::Simd<T, LANES>","std::simd::Simd<i32, N>","std::simd::Simd<i64, N>","<&std::num::Saturating<i32> as std::ops::Shr<&usize>>","std::simd::Simd<isize, N>","std::simd::Simd<usize, N>","std::simd::Simd<i16, N>","std::simd::Simd<i8, N>","std::simd::Simd<u8, N>","std::simd::Simd<u32, N>","std::simd::Simd<u64, N>","std::simd::Simd<u16, N>"]},"core::core_simd::ops::deref::<impl std::ops::Shr<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Shr<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
let mut p1 = 0u32; // None+u32
+p0.wrapping_shr(p1);
+<std::num::Wrapping<T> as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+crate::<std::num::Wrapping<T> as ops::wrapping::WrappingShr>::wrapping_shr(p0, p1);
+<std::num::Wrapping<T>>::wrapping_shr(p0, p1);
-----------------
src/pow.rs <u8 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<u8 as pow::Pow<u8>>::pow(p0, p1);
+crate::<u8 as pow::Pow<u8>>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/pow.rs <u8 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<u8 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<u8 as pow::Pow<&'a u8>>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/pow.rs <&'a u8 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a u8 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a u8 as pow::Pow<u8>>::pow(p0, p1);
+<&'a u8>::pow(p0, p1);
-----------------
src/pow.rs <&'b u8 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b u8 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b u8 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b u8>::pow(p0, p1);
-----------------
src/pow.rs <u8 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<u8 as pow::Pow<u16>>::pow(p0, p1);
+crate::<u8 as pow::Pow<u16>>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/pow.rs <u8 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<u8 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<u8 as pow::Pow<&'a u16>>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/pow.rs <&'a u8 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a u8 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a u8 as pow::Pow<u16>>::pow(p0, p1);
+<&'a u8>::pow(p0, p1);
-----------------
src/pow.rs <&'b u8 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b u8 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b u8 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b u8>::pow(p0, p1);
-----------------
src/pow.rs <u8 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u8 as pow::Pow<u32>>::pow(p0, p1);
+crate::<u8 as pow::Pow<u32>>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/pow.rs <u8 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<u8 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<u8 as pow::Pow<&'a u32>>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/pow.rs <&'a u8 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a u8 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a u8 as pow::Pow<u32>>::pow(p0, p1);
+<&'a u8>::pow(p0, p1);
-----------------
src/pow.rs <&'b u8 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b u8 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b u8 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b u8>::pow(p0, p1);
-----------------
src/pow.rs <u8 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<u8 as pow::Pow<usize>>::pow(p0, p1);
+crate::<u8 as pow::Pow<usize>>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/pow.rs <u8 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<u8 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<u8 as pow::Pow<&'a usize>>::pow(p0, p1);
+<u8>::pow(p0, p1);
-----------------
src/pow.rs <&'a u8 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a u8 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a u8 as pow::Pow<usize>>::pow(p0, p1);
+<&'a u8>::pow(p0, p1);
-----------------
src/pow.rs <&'b u8 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b u8 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b u8 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b u8>::pow(p0, p1);
-----------------
src/pow.rs <i8 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<i8 as pow::Pow<u8>>::pow(p0, p1);
+crate::<i8 as pow::Pow<u8>>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/pow.rs <i8 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<i8 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<i8 as pow::Pow<&'a u8>>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/pow.rs <&'a i8 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a i8 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a i8 as pow::Pow<u8>>::pow(p0, p1);
+<&'a i8>::pow(p0, p1);
-----------------
src/pow.rs <&'b i8 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b i8 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b i8 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b i8>::pow(p0, p1);
-----------------
src/pow.rs <i8 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<i8 as pow::Pow<u16>>::pow(p0, p1);
+crate::<i8 as pow::Pow<u16>>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/pow.rs <i8 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<i8 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<i8 as pow::Pow<&'a u16>>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/pow.rs <&'a i8 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a i8 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a i8 as pow::Pow<u16>>::pow(p0, p1);
+<&'a i8>::pow(p0, p1);
-----------------
src/pow.rs <&'b i8 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b i8 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b i8 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b i8>::pow(p0, p1);
-----------------
src/pow.rs <i8 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i8 as pow::Pow<u32>>::pow(p0, p1);
+crate::<i8 as pow::Pow<u32>>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/pow.rs <i8 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<i8 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<i8 as pow::Pow<&'a u32>>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/pow.rs <&'a i8 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a i8 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a i8 as pow::Pow<u32>>::pow(p0, p1);
+<&'a i8>::pow(p0, p1);
-----------------
src/pow.rs <&'b i8 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b i8 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b i8 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b i8>::pow(p0, p1);
-----------------
src/pow.rs <i8 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<i8 as pow::Pow<usize>>::pow(p0, p1);
+crate::<i8 as pow::Pow<usize>>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/pow.rs <i8 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<i8 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<i8 as pow::Pow<&'a usize>>::pow(p0, p1);
+<i8>::pow(p0, p1);
-----------------
src/pow.rs <&'a i8 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a i8 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a i8 as pow::Pow<usize>>::pow(p0, p1);
+<&'a i8>::pow(p0, p1);
-----------------
src/pow.rs <&'b i8 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b i8 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b i8 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b i8>::pow(p0, p1);
-----------------
src/pow.rs <u16 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<u16 as pow::Pow<u8>>::pow(p0, p1);
+crate::<u16 as pow::Pow<u8>>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/pow.rs <u16 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<u16 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<u16 as pow::Pow<&'a u8>>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/pow.rs <&'a u16 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a u16 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a u16 as pow::Pow<u8>>::pow(p0, p1);
+<&'a u16>::pow(p0, p1);
-----------------
src/pow.rs <&'b u16 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b u16 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b u16 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b u16>::pow(p0, p1);
-----------------
src/pow.rs <u16 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<u16 as pow::Pow<u16>>::pow(p0, p1);
+crate::<u16 as pow::Pow<u16>>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/pow.rs <u16 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<u16 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<u16 as pow::Pow<&'a u16>>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/pow.rs <&'a u16 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a u16 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a u16 as pow::Pow<u16>>::pow(p0, p1);
+<&'a u16>::pow(p0, p1);
-----------------
src/pow.rs <&'b u16 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b u16 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b u16 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b u16>::pow(p0, p1);
-----------------
src/pow.rs <u16 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u16 as pow::Pow<u32>>::pow(p0, p1);
+crate::<u16 as pow::Pow<u32>>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/pow.rs <u16 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<u16 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<u16 as pow::Pow<&'a u32>>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/pow.rs <&'a u16 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a u16 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a u16 as pow::Pow<u32>>::pow(p0, p1);
+<&'a u16>::pow(p0, p1);
-----------------
src/pow.rs <&'b u16 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b u16 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b u16 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b u16>::pow(p0, p1);
-----------------
src/pow.rs <u16 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<u16 as pow::Pow<usize>>::pow(p0, p1);
+crate::<u16 as pow::Pow<usize>>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/pow.rs <u16 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<u16 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<u16 as pow::Pow<&'a usize>>::pow(p0, p1);
+<u16>::pow(p0, p1);
-----------------
src/pow.rs <&'a u16 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a u16 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a u16 as pow::Pow<usize>>::pow(p0, p1);
+<&'a u16>::pow(p0, p1);
-----------------
src/pow.rs <&'b u16 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b u16 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b u16 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b u16>::pow(p0, p1);
-----------------
src/pow.rs <i16 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<i16 as pow::Pow<u8>>::pow(p0, p1);
+crate::<i16 as pow::Pow<u8>>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/pow.rs <i16 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<i16 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<i16 as pow::Pow<&'a u8>>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/pow.rs <&'a i16 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a i16 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a i16 as pow::Pow<u8>>::pow(p0, p1);
+<&'a i16>::pow(p0, p1);
-----------------
src/pow.rs <&'b i16 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b i16 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b i16 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b i16>::pow(p0, p1);
-----------------
src/pow.rs <i16 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<i16 as pow::Pow<u16>>::pow(p0, p1);
+crate::<i16 as pow::Pow<u16>>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/pow.rs <i16 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<i16 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<i16 as pow::Pow<&'a u16>>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/pow.rs <&'a i16 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a i16 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a i16 as pow::Pow<u16>>::pow(p0, p1);
+<&'a i16>::pow(p0, p1);
-----------------
src/pow.rs <&'b i16 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b i16 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b i16 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b i16>::pow(p0, p1);
-----------------
src/pow.rs <i16 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i16 as pow::Pow<u32>>::pow(p0, p1);
+crate::<i16 as pow::Pow<u32>>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/pow.rs <i16 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<i16 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<i16 as pow::Pow<&'a u32>>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/pow.rs <&'a i16 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a i16 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a i16 as pow::Pow<u32>>::pow(p0, p1);
+<&'a i16>::pow(p0, p1);
-----------------
src/pow.rs <&'b i16 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b i16 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b i16 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b i16>::pow(p0, p1);
-----------------
src/pow.rs <i16 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<i16 as pow::Pow<usize>>::pow(p0, p1);
+crate::<i16 as pow::Pow<usize>>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/pow.rs <i16 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<i16 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<i16 as pow::Pow<&'a usize>>::pow(p0, p1);
+<i16>::pow(p0, p1);
-----------------
src/pow.rs <&'a i16 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a i16 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a i16 as pow::Pow<usize>>::pow(p0, p1);
+<&'a i16>::pow(p0, p1);
-----------------
src/pow.rs <&'b i16 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b i16 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b i16 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b i16>::pow(p0, p1);
-----------------
src/pow.rs <u32 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<u32 as pow::Pow<u8>>::pow(p0, p1);
+crate::<u32 as pow::Pow<u8>>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/pow.rs <u32 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<u32 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<u32 as pow::Pow<&'a u8>>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/pow.rs <&'a u32 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a u32 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a u32 as pow::Pow<u8>>::pow(p0, p1);
+<&'a u32>::pow(p0, p1);
-----------------
src/pow.rs <&'b u32 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b u32 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b u32 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b u32>::pow(p0, p1);
-----------------
src/pow.rs <u32 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<u32 as pow::Pow<u16>>::pow(p0, p1);
+crate::<u32 as pow::Pow<u16>>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/pow.rs <u32 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<u32 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<u32 as pow::Pow<&'a u16>>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/pow.rs <&'a u32 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a u32 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a u32 as pow::Pow<u16>>::pow(p0, p1);
+<&'a u32>::pow(p0, p1);
-----------------
src/pow.rs <&'b u32 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b u32 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b u32 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b u32>::pow(p0, p1);
-----------------
src/pow.rs <u32 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u32 as pow::Pow<u32>>::pow(p0, p1);
+crate::<u32 as pow::Pow<u32>>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/pow.rs <u32 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<u32 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<u32 as pow::Pow<&'a u32>>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/pow.rs <&'a u32 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a u32 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a u32 as pow::Pow<u32>>::pow(p0, p1);
+<&'a u32>::pow(p0, p1);
-----------------
src/pow.rs <&'b u32 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b u32 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b u32 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b u32>::pow(p0, p1);
-----------------
src/pow.rs <u32 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<u32 as pow::Pow<usize>>::pow(p0, p1);
+crate::<u32 as pow::Pow<usize>>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/pow.rs <u32 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<u32 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<u32 as pow::Pow<&'a usize>>::pow(p0, p1);
+<u32>::pow(p0, p1);
-----------------
src/pow.rs <&'a u32 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a u32 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a u32 as pow::Pow<usize>>::pow(p0, p1);
+<&'a u32>::pow(p0, p1);
-----------------
src/pow.rs <&'b u32 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b u32 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b u32 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b u32>::pow(p0, p1);
-----------------
src/pow.rs <i32 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<i32 as pow::Pow<u8>>::pow(p0, p1);
+crate::<i32 as pow::Pow<u8>>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/pow.rs <i32 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<i32 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<i32 as pow::Pow<&'a u8>>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/pow.rs <&'a i32 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a i32 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a i32 as pow::Pow<u8>>::pow(p0, p1);
+<&'a i32>::pow(p0, p1);
-----------------
src/pow.rs <&'b i32 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b i32 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b i32 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b i32>::pow(p0, p1);
-----------------
src/pow.rs <i32 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<i32 as pow::Pow<u16>>::pow(p0, p1);
+crate::<i32 as pow::Pow<u16>>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/pow.rs <i32 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<i32 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<i32 as pow::Pow<&'a u16>>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/pow.rs <&'a i32 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a i32 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a i32 as pow::Pow<u16>>::pow(p0, p1);
+<&'a i32>::pow(p0, p1);
-----------------
src/pow.rs <&'b i32 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b i32 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b i32 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b i32>::pow(p0, p1);
-----------------
src/pow.rs <i32 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i32 as pow::Pow<u32>>::pow(p0, p1);
+crate::<i32 as pow::Pow<u32>>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/pow.rs <i32 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<i32 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<i32 as pow::Pow<&'a u32>>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/pow.rs <&'a i32 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a i32 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a i32 as pow::Pow<u32>>::pow(p0, p1);
+<&'a i32>::pow(p0, p1);
-----------------
src/pow.rs <&'b i32 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b i32 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b i32 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b i32>::pow(p0, p1);
-----------------
src/pow.rs <i32 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<i32 as pow::Pow<usize>>::pow(p0, p1);
+crate::<i32 as pow::Pow<usize>>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/pow.rs <i32 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<i32 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<i32 as pow::Pow<&'a usize>>::pow(p0, p1);
+<i32>::pow(p0, p1);
-----------------
src/pow.rs <&'a i32 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a i32 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a i32 as pow::Pow<usize>>::pow(p0, p1);
+<&'a i32>::pow(p0, p1);
-----------------
src/pow.rs <&'b i32 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b i32 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b i32 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b i32>::pow(p0, p1);
-----------------
src/pow.rs <u64 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<u64 as pow::Pow<u8>>::pow(p0, p1);
+crate::<u64 as pow::Pow<u8>>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/pow.rs <u64 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<u64 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<u64 as pow::Pow<&'a u8>>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/pow.rs <&'a u64 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a u64 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a u64 as pow::Pow<u8>>::pow(p0, p1);
+<&'a u64>::pow(p0, p1);
-----------------
src/pow.rs <&'b u64 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b u64 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b u64 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b u64>::pow(p0, p1);
-----------------
src/pow.rs <u64 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<u64 as pow::Pow<u16>>::pow(p0, p1);
+crate::<u64 as pow::Pow<u16>>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/pow.rs <u64 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<u64 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<u64 as pow::Pow<&'a u16>>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/pow.rs <&'a u64 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a u64 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a u64 as pow::Pow<u16>>::pow(p0, p1);
+<&'a u64>::pow(p0, p1);
-----------------
src/pow.rs <&'b u64 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b u64 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b u64 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b u64>::pow(p0, p1);
-----------------
src/pow.rs <u64 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u64 as pow::Pow<u32>>::pow(p0, p1);
+crate::<u64 as pow::Pow<u32>>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/pow.rs <u64 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<u64 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<u64 as pow::Pow<&'a u32>>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/pow.rs <&'a u64 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a u64 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a u64 as pow::Pow<u32>>::pow(p0, p1);
+<&'a u64>::pow(p0, p1);
-----------------
src/pow.rs <&'b u64 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b u64 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b u64 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b u64>::pow(p0, p1);
-----------------
src/pow.rs <u64 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<u64 as pow::Pow<usize>>::pow(p0, p1);
+crate::<u64 as pow::Pow<usize>>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/pow.rs <u64 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<u64 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<u64 as pow::Pow<&'a usize>>::pow(p0, p1);
+<u64>::pow(p0, p1);
-----------------
src/pow.rs <&'a u64 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a u64 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a u64 as pow::Pow<usize>>::pow(p0, p1);
+<&'a u64>::pow(p0, p1);
-----------------
src/pow.rs <&'b u64 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b u64 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b u64 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b u64>::pow(p0, p1);
-----------------
src/pow.rs <i64 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<i64 as pow::Pow<u8>>::pow(p0, p1);
+crate::<i64 as pow::Pow<u8>>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/pow.rs <i64 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<i64 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<i64 as pow::Pow<&'a u8>>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/pow.rs <&'a i64 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a i64 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a i64 as pow::Pow<u8>>::pow(p0, p1);
+<&'a i64>::pow(p0, p1);
-----------------
src/pow.rs <&'b i64 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b i64 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b i64 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b i64>::pow(p0, p1);
-----------------
src/pow.rs <i64 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<i64 as pow::Pow<u16>>::pow(p0, p1);
+crate::<i64 as pow::Pow<u16>>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/pow.rs <i64 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<i64 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<i64 as pow::Pow<&'a u16>>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/pow.rs <&'a i64 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a i64 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a i64 as pow::Pow<u16>>::pow(p0, p1);
+<&'a i64>::pow(p0, p1);
-----------------
src/pow.rs <&'b i64 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b i64 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b i64 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b i64>::pow(p0, p1);
-----------------
src/pow.rs <i64 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i64 as pow::Pow<u32>>::pow(p0, p1);
+crate::<i64 as pow::Pow<u32>>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/pow.rs <i64 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<i64 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<i64 as pow::Pow<&'a u32>>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/pow.rs <&'a i64 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a i64 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a i64 as pow::Pow<u32>>::pow(p0, p1);
+<&'a i64>::pow(p0, p1);
-----------------
src/pow.rs <&'b i64 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b i64 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b i64 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b i64>::pow(p0, p1);
-----------------
src/pow.rs <i64 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<i64 as pow::Pow<usize>>::pow(p0, p1);
+crate::<i64 as pow::Pow<usize>>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/pow.rs <i64 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<i64 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<i64 as pow::Pow<&'a usize>>::pow(p0, p1);
+<i64>::pow(p0, p1);
-----------------
src/pow.rs <&'a i64 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a i64 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a i64 as pow::Pow<usize>>::pow(p0, p1);
+<&'a i64>::pow(p0, p1);
-----------------
src/pow.rs <&'b i64 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b i64 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b i64 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b i64>::pow(p0, p1);
-----------------
src/pow.rs <u128 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<u128 as pow::Pow<u8>>::pow(p0, p1);
+crate::<u128 as pow::Pow<u8>>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/pow.rs <u128 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<u128 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<u128 as pow::Pow<&'a u8>>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/pow.rs <&'a u128 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a u128 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a u128 as pow::Pow<u8>>::pow(p0, p1);
+<&'a u128>::pow(p0, p1);
-----------------
src/pow.rs <&'b u128 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b u128 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b u128 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b u128>::pow(p0, p1);
-----------------
src/pow.rs <u128 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<u128 as pow::Pow<u16>>::pow(p0, p1);
+crate::<u128 as pow::Pow<u16>>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/pow.rs <u128 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<u128 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<u128 as pow::Pow<&'a u16>>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/pow.rs <&'a u128 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a u128 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a u128 as pow::Pow<u16>>::pow(p0, p1);
+<&'a u128>::pow(p0, p1);
-----------------
src/pow.rs <&'b u128 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b u128 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b u128 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b u128>::pow(p0, p1);
-----------------
src/pow.rs <u128 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<u128 as pow::Pow<u32>>::pow(p0, p1);
+crate::<u128 as pow::Pow<u32>>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/pow.rs <u128 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<u128 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<u128 as pow::Pow<&'a u32>>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/pow.rs <&'a u128 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a u128 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a u128 as pow::Pow<u32>>::pow(p0, p1);
+<&'a u128>::pow(p0, p1);
-----------------
src/pow.rs <&'b u128 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b u128 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b u128 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b u128>::pow(p0, p1);
-----------------
src/pow.rs <u128 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<u128 as pow::Pow<usize>>::pow(p0, p1);
+crate::<u128 as pow::Pow<usize>>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/pow.rs <u128 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<u128 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<u128 as pow::Pow<&'a usize>>::pow(p0, p1);
+<u128>::pow(p0, p1);
-----------------
src/pow.rs <&'a u128 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a u128 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a u128 as pow::Pow<usize>>::pow(p0, p1);
+<&'a u128>::pow(p0, p1);
-----------------
src/pow.rs <&'b u128 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0u128; // None+u128
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b u128 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b u128 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b u128>::pow(p0, p1);
-----------------
src/pow.rs <i128 as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<i128 as pow::Pow<u8>>::pow(p0, p1);
+crate::<i128 as pow::Pow<u8>>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/pow.rs <i128 as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<i128 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<i128 as pow::Pow<&'a u8>>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/pow.rs <&'a i128 as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a i128 as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a i128 as pow::Pow<u8>>::pow(p0, p1);
+<&'a i128>::pow(p0, p1);
-----------------
src/pow.rs <&'b i128 as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b i128 as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b i128 as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b i128>::pow(p0, p1);
-----------------
src/pow.rs <i128 as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<i128 as pow::Pow<u16>>::pow(p0, p1);
+crate::<i128 as pow::Pow<u16>>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/pow.rs <i128 as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<i128 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<i128 as pow::Pow<&'a u16>>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/pow.rs <&'a i128 as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a i128 as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a i128 as pow::Pow<u16>>::pow(p0, p1);
+<&'a i128>::pow(p0, p1);
-----------------
src/pow.rs <&'b i128 as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b i128 as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b i128 as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b i128>::pow(p0, p1);
-----------------
src/pow.rs <i128 as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<i128 as pow::Pow<u32>>::pow(p0, p1);
+crate::<i128 as pow::Pow<u32>>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/pow.rs <i128 as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<i128 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<i128 as pow::Pow<&'a u32>>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/pow.rs <&'a i128 as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a i128 as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a i128 as pow::Pow<u32>>::pow(p0, p1);
+<&'a i128>::pow(p0, p1);
-----------------
src/pow.rs <&'b i128 as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b i128 as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b i128 as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b i128>::pow(p0, p1);
-----------------
src/pow.rs <i128 as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<i128 as pow::Pow<usize>>::pow(p0, p1);
+crate::<i128 as pow::Pow<usize>>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/pow.rs <i128 as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<i128 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<i128 as pow::Pow<&'a usize>>::pow(p0, p1);
+<i128>::pow(p0, p1);
-----------------
src/pow.rs <&'a i128 as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a i128 as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a i128 as pow::Pow<usize>>::pow(p0, p1);
+<&'a i128>::pow(p0, p1);
-----------------
src/pow.rs <&'b i128 as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b i128 as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b i128 as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b i128>::pow(p0, p1);
-----------------
src/pow.rs <usize as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<usize as pow::Pow<u8>>::pow(p0, p1);
+crate::<usize as pow::Pow<u8>>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/pow.rs <usize as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<usize as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<usize as pow::Pow<&'a u8>>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/pow.rs <&'a usize as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a usize as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a usize as pow::Pow<u8>>::pow(p0, p1);
+<&'a usize>::pow(p0, p1);
-----------------
src/pow.rs <&'b usize as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b usize as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b usize as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b usize>::pow(p0, p1);
-----------------
src/pow.rs <usize as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<usize as pow::Pow<u16>>::pow(p0, p1);
+crate::<usize as pow::Pow<u16>>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/pow.rs <usize as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<usize as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<usize as pow::Pow<&'a u16>>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/pow.rs <&'a usize as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a usize as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a usize as pow::Pow<u16>>::pow(p0, p1);
+<&'a usize>::pow(p0, p1);
-----------------
src/pow.rs <&'b usize as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b usize as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b usize as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b usize>::pow(p0, p1);
-----------------
src/pow.rs <usize as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<usize as pow::Pow<u32>>::pow(p0, p1);
+crate::<usize as pow::Pow<u32>>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/pow.rs <usize as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<usize as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<usize as pow::Pow<&'a u32>>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/pow.rs <&'a usize as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a usize as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a usize as pow::Pow<u32>>::pow(p0, p1);
+<&'a usize>::pow(p0, p1);
-----------------
src/pow.rs <&'b usize as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b usize as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b usize as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b usize>::pow(p0, p1);
-----------------
src/pow.rs <usize as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<usize as pow::Pow<usize>>::pow(p0, p1);
+crate::<usize as pow::Pow<usize>>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/pow.rs <usize as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<usize as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<usize as pow::Pow<&'a usize>>::pow(p0, p1);
+<usize>::pow(p0, p1);
-----------------
src/pow.rs <&'a usize as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a usize as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a usize as pow::Pow<usize>>::pow(p0, p1);
+<&'a usize>::pow(p0, p1);
-----------------
src/pow.rs <&'b usize as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b usize as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b usize as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b usize>::pow(p0, p1);
-----------------
src/pow.rs <isize as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<isize as pow::Pow<u8>>::pow(p0, p1);
+crate::<isize as pow::Pow<u8>>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/pow.rs <isize as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<isize as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<isize as pow::Pow<&'a u8>>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/pow.rs <&'a isize as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a isize as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a isize as pow::Pow<u8>>::pow(p0, p1);
+<&'a isize>::pow(p0, p1);
-----------------
src/pow.rs <&'b isize as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b isize as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b isize as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b isize>::pow(p0, p1);
-----------------
src/pow.rs <isize as pow::Pow<u16>>::pow
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<isize as pow::Pow<u16>>::pow(p0, p1);
+crate::<isize as pow::Pow<u16>>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/pow.rs <isize as pow::Pow<&'a u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<isize as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<isize as pow::Pow<&'a u16>>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/pow.rs <&'a isize as pow::Pow<u16>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+<&'a isize as pow::Pow<u16>>::pow(p0, p1);
+crate::<&'a isize as pow::Pow<u16>>::pow(p0, p1);
+<&'a isize>::pow(p0, p1);
-----------------
src/pow.rs <&'b isize as pow::Pow<&'a u16>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+<&'b isize as pow::Pow<&'a u16>>::pow(p0, p1);
+crate::<&'b isize as pow::Pow<&'a u16>>::pow(p0, p1);
+<&'b isize>::pow(p0, p1);
-----------------
src/pow.rs <isize as pow::Pow<u32>>::pow
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<isize as pow::Pow<u32>>::pow(p0, p1);
+crate::<isize as pow::Pow<u32>>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/pow.rs <isize as pow::Pow<&'a u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<isize as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<isize as pow::Pow<&'a u32>>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/pow.rs <&'a isize as pow::Pow<u32>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = 0u32; // None+u32
+p0.pow(p1);
+<&'a isize as pow::Pow<u32>>::pow(p0, p1);
+crate::<&'a isize as pow::Pow<u32>>::pow(p0, p1);
+<&'a isize>::pow(p0, p1);
-----------------
src/pow.rs <&'b isize as pow::Pow<&'a u32>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0u32; // None+u32
+p0.pow(p1);
+<&'b isize as pow::Pow<&'a u32>>::pow(p0, p1);
+crate::<&'b isize as pow::Pow<&'a u32>>::pow(p0, p1);
+<&'b isize>::pow(p0, p1);
-----------------
src/pow.rs <isize as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<isize as pow::Pow<usize>>::pow(p0, p1);
+crate::<isize as pow::Pow<usize>>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/pow.rs <isize as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<isize as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<isize as pow::Pow<&'a usize>>::pow(p0, p1);
+<isize>::pow(p0, p1);
-----------------
src/pow.rs <&'a isize as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a isize as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a isize as pow::Pow<usize>>::pow(p0, p1);
+<&'a isize>::pow(p0, p1);
-----------------
src/pow.rs <&'b isize as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b isize as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b isize as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b isize>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u8> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u8>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u8> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u8> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<u8>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u8>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<u8>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u8> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u8>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<u8> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u8> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<u8>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u8>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<u8>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u8> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u8>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u8> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u8> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<u8>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u8>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<u8>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u8> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u8>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<u8> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u8> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<u8>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u8>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<u8>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i8> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i8>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i8> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i8> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<i8>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i8>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<i8>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i8> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i8>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<i8> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i8> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<i8>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i8>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<i8>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i8> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i8>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i8> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i8> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<i8>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i8>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<i8>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i8> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i8>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<i8> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i8> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<i8>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i8>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<i8>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u16> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u16>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u16> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u16> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<u16>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u16>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<u16>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u16> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u16>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<u16> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u16> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<u16>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u16>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<u16>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u16> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u16>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u16> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u16> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<u16>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u16>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<u16>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u16> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u16>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<u16> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u16> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<u16>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u16>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<u16>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i16> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i16>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i16> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i16> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<i16>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i16>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<i16>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i16> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i16>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<i16> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i16> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<i16>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i16>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<i16>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i16> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i16>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i16> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i16> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<i16>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i16>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<i16>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i16> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i16>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<i16> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i16> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<i16>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i16>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<i16>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u32> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u32>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u32> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u32> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<u32>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u32>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<u32>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u32> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u32>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<u32> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u32> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<u32>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u32>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<u32>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u32> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u32>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u32> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u32> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<u32>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u32>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<u32>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u32> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u32>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<u32> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u32> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<u32>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u32>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<u32>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i32> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i32>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i32> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i32> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<i32>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i32>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<i32>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i32> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i32>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<i32> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i32> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<i32>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i32>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<i32>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i32> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i32>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i32> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i32> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<i32>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i32>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<i32>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i32> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i32>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<i32> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i32> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<i32>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i32>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<i32>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u64> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u64>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u64> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u64> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<u64>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u64>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<u64>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u64> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u64>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<u64> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u64> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<u64>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u64>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<u64>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u64> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u64>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u64> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u64> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<u64>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u64>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<u64>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u64> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u64>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<u64> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u64> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<u64>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u64>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<u64>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i64> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i64>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i64> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i64> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<i64>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i64>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<i64>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i64> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i64>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<i64> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i64> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<i64>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i64>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<i64>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i64> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i64>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i64> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i64> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<i64>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i64>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<i64>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i64> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i64>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<i64> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i64> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<i64>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i64>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<i64>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u128> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u128>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u128> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u128> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<u128>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u128>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<u128>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u128> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u128>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<u128> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u128> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<u128>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u128>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<u128>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u128> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u128>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u128> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u128> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<u128>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u128>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<u128>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<u128> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u128>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<u128> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<u128> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<u128>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<u128>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<u128>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i128> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i128>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i128> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i128> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<i128>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i128>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<i128>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i128> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i128>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<i128> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i128> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<i128>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i128>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<i128>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i128> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i128>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i128> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i128> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<i128>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i128>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<i128>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<i128> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i128>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<i128> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<i128> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<i128>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<i128>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<i128>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<usize> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<usize>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<usize> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<usize> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<usize>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<usize>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<usize>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<usize> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<usize>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<usize> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<usize> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<usize>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<usize>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<usize>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<usize> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<usize>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<usize> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<usize> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<usize>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<usize>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<usize>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<usize> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<usize>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<usize> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<usize> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<usize>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<usize>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<usize>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<isize> as pow::Pow<u8>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<isize>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<isize> as pow::Pow<u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<isize> as pow::Pow<u8>>::pow(p0, p1);
+<std::num::Wrapping<isize>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<isize>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<std::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<std::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow(p0, p1);
+<std::num::Wrapping<isize>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<isize> as pow::Pow<u8>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<isize>
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+<&'a std::num::Wrapping<isize> as pow::Pow<u8>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<isize> as pow::Pow<u8>>::pow(p0, p1);
+<&'a std::num::Wrapping<isize>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<isize>
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+<&'b std::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow(p0, p1);
+<&'b std::num::Wrapping<isize>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<isize> as pow::Pow<usize>>::pow
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<isize>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<isize> as pow::Pow<usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<isize> as pow::Pow<usize>>::pow(p0, p1);
+<std::num::Wrapping<isize>>::pow(p0, p1);
-----------------
src/pow.rs <std::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::Wrapping<isize>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<std::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<std::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow(p0, p1);
+<std::num::Wrapping<isize>>::pow(p0, p1);
-----------------
src/pow.rs <&'a std::num::Wrapping<isize> as pow::Pow<usize>>::pow
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<isize>
let mut p1 = 0usize; // None+usize
+p0.pow(p1);
+<&'a std::num::Wrapping<isize> as pow::Pow<usize>>::pow(p0, p1);
+crate::<&'a std::num::Wrapping<isize> as pow::Pow<usize>>::pow(p0, p1);
+<&'a std::num::Wrapping<isize>>::pow(p0, p1);
-----------------
src/pow.rs <&'b std::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<isize>
let mut p1 = & 0usize; // None+usize
+p0.pow(p1);
+<&'b std::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow(p0, p1);
+crate::<&'b std::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow(p0, p1);
+<&'b std::num::Wrapping<isize>>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i8> for f32>::pow
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0i8; // None+i8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i8> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i8> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i8> for f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = & 0i8; // None+i8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i8> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i8> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i8> for &'a f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = 0i8; // None+i8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i8> for &'a f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i8> for &'a f32>::pow(p0, p1);
+<&'a f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i8> for &'b f32>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0i8; // None+i8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i8> for &'b f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i8> for &'b f32>::pow(p0, p1);
+<&'b f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<u8> for f32>::pow
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<u8> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<u8> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a u8> for f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a u8> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a u8> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<u8> for &'a f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<u8> for &'a f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<u8> for &'a f32>::pow(p0, p1);
+<&'a f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a u8> for &'b f32>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a u8> for &'b f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a u8> for &'b f32>::pow(p0, p1);
+<&'b f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i16> for f32>::pow
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0i16; // None+i16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i16> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i16> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i16> for f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = & 0i16; // None+i16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i16> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i16> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i16> for &'a f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = 0i16; // None+i16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i16> for &'a f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i16> for &'a f32>::pow(p0, p1);
+<&'a f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i16> for &'b f32>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0i16; // None+i16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i16> for &'b f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i16> for &'b f32>::pow(p0, p1);
+<&'b f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<u16> for f32>::pow
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<u16> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<u16> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a u16> for f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a u16> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a u16> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<u16> for &'a f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<u16> for &'a f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<u16> for &'a f32>::pow(p0, p1);
+<&'a f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a u16> for &'b f32>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a u16> for &'b f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a u16> for &'b f32>::pow(p0, p1);
+<&'b f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i32> for f32>::pow
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0i32; // None+i32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i32> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i32> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i32> for f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = & 0i32; // None+i32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i32> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i32> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i32> for &'a f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = 0i32; // None+i32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i32> for &'a f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i32> for &'a f32>::pow(p0, p1);
+<&'a f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i32> for &'b f32>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0i32; // None+i32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i32> for &'b f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i32> for &'b f32>::pow(p0, p1);
+<&'b f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i8> for f64>::pow
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0i8; // None+i8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i8> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i8> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i8> for f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = & 0i8; // None+i8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i8> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i8> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i8> for &'a f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = 0i8; // None+i8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i8> for &'a f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i8> for &'a f64>::pow(p0, p1);
+<&'a f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i8> for &'b f64>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0i8; // None+i8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i8> for &'b f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i8> for &'b f64>::pow(p0, p1);
+<&'b f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<u8> for f64>::pow
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<u8> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<u8> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a u8> for f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a u8> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a u8> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<u8> for &'a f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = 0u8; // None+u8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<u8> for &'a f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<u8> for &'a f64>::pow(p0, p1);
+<&'a f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a u8> for &'b f64>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0u8; // None+u8
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a u8> for &'b f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a u8> for &'b f64>::pow(p0, p1);
+<&'b f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i16> for f64>::pow
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0i16; // None+i16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i16> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i16> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i16> for f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = & 0i16; // None+i16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i16> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i16> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i16> for &'a f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = 0i16; // None+i16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i16> for &'a f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i16> for &'a f64>::pow(p0, p1);
+<&'a f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i16> for &'b f64>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0i16; // None+i16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i16> for &'b f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i16> for &'b f64>::pow(p0, p1);
+<&'b f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<u16> for f64>::pow
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<u16> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<u16> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a u16> for f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a u16> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a u16> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<u16> for &'a f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = 0u16; // None+u16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<u16> for &'a f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<u16> for &'a f64>::pow(p0, p1);
+<&'a f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a u16> for &'b f64>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0u16; // None+u16
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a u16> for &'b f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a u16> for &'b f64>::pow(p0, p1);
+<&'b f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i32> for f64>::pow
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0i32; // None+i32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i32> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i32> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i32> for f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = & 0i32; // None+i32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i32> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i32> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<i32> for &'a f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = 0i32; // None+i32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<i32> for &'a f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<i32> for &'a f64>::pow(p0, p1);
+<&'a f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a i32> for &'b f64>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0i32; // None+i32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a i32> for &'b f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a i32> for &'b f64>::pow(p0, p1);
+<&'b f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<f32> for f32>::pow
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<f32> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<f32> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a f32> for f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = & 0f32; // None+f32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a f32> for f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a f32> for f32>::pow(p0, p1);
+<f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<f32> for &'a f32>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = 0f32; // None+f32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<f32> for &'a f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<f32> for &'a f32>::pow(p0, p1);
+<&'a f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a f32> for &'b f32>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0f32; // None+f32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a f32> for &'b f32>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a f32> for &'b f32>::pow(p0, p1);
+<&'b f32>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<f32> for f64>::pow
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f32; // None+f32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<f32> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<f32> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a f32> for f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = & 0f32; // None+f32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a f32> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a f32> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<f32> for &'a f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = 0f32; // None+f32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<f32> for &'a f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<f32> for &'a f64>::pow(p0, p1);
+<&'a f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a f32> for &'b f64>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0f32; // None+f32
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a f32> for &'b f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a f32> for &'b f64>::pow(p0, p1);
+<&'b f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<f64> for f64>::pow
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<f64> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<f64> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a f64> for f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = & 0f64; // None+f64
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a f64> for f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a f64> for f64>::pow(p0, p1);
+<f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<f64> for &'a f64>::pow
'a
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = 0f64; // None+f64
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<f64> for &'a f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<f64> for &'a f64>::pow(p0, p1);
+<&'a f64>::pow(p0, p1);
-----------------
src/pow.rs pow::float_impls::<impl pow::Pow<&'a f64> for &'b f64>::pow
'a,'b
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0f64; // None+f64
+p0.pow(p1);
+pow::float_impls::<impl pow::Pow<&'a f64> for &'b f64>::pow(p0, p1);
+crate::pow::float_impls::<impl pow::Pow<&'a f64> for &'b f64>::pow(p0, p1);
+<&'b f64>::pow(p0, p1);
-----------------
src/macros.rs <T as real::Real>::min_value
deps:{"<T as real::Real>::min_value":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::min_value":{"T":[]}}
+<T as real::Real>::min_value();
+crate::<T as real::Real>::min_value();
+<T>::min_value();
-----------------
src/macros.rs <T as real::Real>::min_positive_value
deps:{"<T as real::Real>::min_positive_value":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::min_positive_value":{"T":[]}}
+<T as real::Real>::min_positive_value();
+crate::<T as real::Real>::min_positive_value();
+<T>::min_positive_value();
-----------------
src/macros.rs <T as real::Real>::epsilon
deps:{"<T as real::Real>::epsilon":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::epsilon":{"T":[]}}
+<T as real::Real>::epsilon();
+crate::<T as real::Real>::epsilon();
+<T>::epsilon();
-----------------
src/macros.rs <T as real::Real>::max_value
deps:{"<T as real::Real>::max_value":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::max_value":{"T":[]}}
+<T as real::Real>::max_value();
+crate::<T as real::Real>::max_value();
+<T>::max_value();
-----------------
src/macros.rs <T as real::Real>::floor
deps:{"<T as real::Real>::floor":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::floor":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.floor();
+<T as real::Real>::floor(p0);
+crate::<T as real::Real>::floor(p0);
+<T>::floor(p0);
-----------------
src/macros.rs <T as real::Real>::ceil
deps:{"<T as real::Real>::ceil":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::ceil":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.ceil();
+<T as real::Real>::ceil(p0);
+crate::<T as real::Real>::ceil(p0);
+<T>::ceil(p0);
-----------------
src/macros.rs <T as real::Real>::round
deps:{"<T as real::Real>::round":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::round":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.round();
+<T as real::Real>::round(p0);
+crate::<T as real::Real>::round(p0);
+<T>::round(p0);
-----------------
src/macros.rs <T as real::Real>::trunc
deps:{"<T as real::Real>::trunc":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::trunc":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.trunc();
+<T as real::Real>::trunc(p0);
+crate::<T as real::Real>::trunc(p0);
+<T>::trunc(p0);
-----------------
src/macros.rs <T as real::Real>::fract
deps:{"<T as real::Real>::fract":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::fract":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.fract();
+<T as real::Real>::fract(p0);
+crate::<T as real::Real>::fract(p0);
+<T>::fract(p0);
-----------------
src/macros.rs <T as real::Real>::abs
deps:{"<T as real::Real>::abs":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::abs":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.abs();
+<T as real::Real>::abs(p0);
+crate::<T as real::Real>::abs(p0);
+<T>::abs(p0);
-----------------
src/macros.rs <T as real::Real>::signum
deps:{"<T as real::Real>::signum":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::signum":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.signum();
+<T as real::Real>::signum(p0);
+crate::<T as real::Real>::signum(p0);
+<T>::signum(p0);
-----------------
src/macros.rs <T as real::Real>::is_sign_positive
deps:{"<T as real::Real>::is_sign_positive":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::is_sign_positive":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.is_sign_positive();
+<T as real::Real>::is_sign_positive(p0);
+crate::<T as real::Real>::is_sign_positive(p0);
+<T>::is_sign_positive(p0);
-----------------
src/macros.rs <T as real::Real>::is_sign_negative
deps:{"<T as real::Real>::is_sign_negative":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::is_sign_negative":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.is_sign_negative();
+<T as real::Real>::is_sign_negative(p0);
+crate::<T as real::Real>::is_sign_negative(p0);
+<T>::is_sign_negative(p0);
-----------------
src/macros.rs <T as real::Real>::mul_add
deps:{"<T as real::Real>::mul_add":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::mul_add":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.mul_add(p1, p2);
+<T as real::Real>::mul_add(p0, p1, p2);
+crate::<T as real::Real>::mul_add(p0, p1, p2);
+<T>::mul_add(p0, p1, p2);
-----------------
src/macros.rs <T as real::Real>::recip
deps:{"<T as real::Real>::recip":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::recip":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.recip();
+<T as real::Real>::recip(p0);
+crate::<T as real::Real>::recip(p0);
+<T>::recip(p0);
-----------------
src/macros.rs <T as real::Real>::powi
deps:{"<T as real::Real>::powi":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::powi":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0i32; // None+i32
+p0.powi(p1);
+<T as real::Real>::powi(p0, p1);
+crate::<T as real::Real>::powi(p0, p1);
+<T>::powi(p0, p1);
-----------------
src/macros.rs <T as real::Real>::powf
deps:{"<T as real::Real>::powf":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::powf":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.powf(p1);
+<T as real::Real>::powf(p0, p1);
+crate::<T as real::Real>::powf(p0, p1);
+<T>::powf(p0, p1);
-----------------
src/macros.rs <T as real::Real>::sqrt
deps:{"<T as real::Real>::sqrt":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::sqrt":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.sqrt();
+<T as real::Real>::sqrt(p0);
+crate::<T as real::Real>::sqrt(p0);
+<T>::sqrt(p0);
-----------------
src/macros.rs <T as real::Real>::exp
deps:{"<T as real::Real>::exp":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::exp":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.exp();
+<T as real::Real>::exp(p0);
+crate::<T as real::Real>::exp(p0);
+<T>::exp(p0);
-----------------
src/macros.rs <T as real::Real>::exp2
deps:{"<T as real::Real>::exp2":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::exp2":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.exp2();
+<T as real::Real>::exp2(p0);
+crate::<T as real::Real>::exp2(p0);
+<T>::exp2(p0);
-----------------
src/macros.rs <T as real::Real>::ln
deps:{"<T as real::Real>::ln":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::ln":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.ln();
+<T as real::Real>::ln(p0);
+crate::<T as real::Real>::ln(p0);
+<T>::ln(p0);
-----------------
src/macros.rs <T as real::Real>::log
deps:{"<T as real::Real>::log":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::log":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.log(p1);
+<T as real::Real>::log(p0, p1);
+crate::<T as real::Real>::log(p0, p1);
+<T>::log(p0, p1);
-----------------
src/macros.rs <T as real::Real>::log2
deps:{"<T as real::Real>::log2":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::log2":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.log2();
+<T as real::Real>::log2(p0);
+crate::<T as real::Real>::log2(p0);
+<T>::log2(p0);
-----------------
src/macros.rs <T as real::Real>::log10
deps:{"<T as real::Real>::log10":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::log10":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.log10();
+<T as real::Real>::log10(p0);
+crate::<T as real::Real>::log10(p0);
+<T>::log10(p0);
-----------------
src/macros.rs <T as real::Real>::to_degrees
deps:{"<T as real::Real>::to_degrees":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::to_degrees":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.to_degrees();
+<T as real::Real>::to_degrees(p0);
+crate::<T as real::Real>::to_degrees(p0);
+<T>::to_degrees(p0);
-----------------
src/macros.rs <T as real::Real>::to_radians
deps:{"<T as real::Real>::to_radians":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::to_radians":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.to_radians();
+<T as real::Real>::to_radians(p0);
+crate::<T as real::Real>::to_radians(p0);
+<T>::to_radians(p0);
-----------------
src/macros.rs <T as real::Real>::max
deps:{"<T as real::Real>::max":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::max":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.max(p1);
+<T as real::Real>::max(p0, p1);
+crate::<T as real::Real>::max(p0, p1);
+<T>::max(p0, p1);
-----------------
src/macros.rs <T as real::Real>::min
deps:{"<T as real::Real>::min":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::min":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.min(p1);
+<T as real::Real>::min(p0, p1);
+crate::<T as real::Real>::min(p0, p1);
+<T>::min(p0, p1);
-----------------
src/macros.rs <T as real::Real>::abs_sub
deps:{"<T as real::Real>::abs_sub":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::abs_sub":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.abs_sub(p1);
+<T as real::Real>::abs_sub(p0, p1);
+crate::<T as real::Real>::abs_sub(p0, p1);
+<T>::abs_sub(p0, p1);
-----------------
src/macros.rs <T as real::Real>::cbrt
deps:{"<T as real::Real>::cbrt":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::cbrt":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.cbrt();
+<T as real::Real>::cbrt(p0);
+crate::<T as real::Real>::cbrt(p0);
+<T>::cbrt(p0);
-----------------
src/macros.rs <T as real::Real>::hypot
deps:{"<T as real::Real>::hypot":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::hypot":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.hypot(p1);
+<T as real::Real>::hypot(p0, p1);
+crate::<T as real::Real>::hypot(p0, p1);
+<T>::hypot(p0, p1);
-----------------
src/macros.rs <T as real::Real>::sin
deps:{"<T as real::Real>::sin":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::sin":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.sin();
+<T as real::Real>::sin(p0);
+crate::<T as real::Real>::sin(p0);
+<T>::sin(p0);
-----------------
src/macros.rs <T as real::Real>::cos
deps:{"<T as real::Real>::cos":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::cos":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.cos();
+<T as real::Real>::cos(p0);
+crate::<T as real::Real>::cos(p0);
+<T>::cos(p0);
-----------------
src/macros.rs <T as real::Real>::tan
deps:{"<T as real::Real>::tan":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::tan":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.tan();
+<T as real::Real>::tan(p0);
+crate::<T as real::Real>::tan(p0);
+<T>::tan(p0);
-----------------
src/macros.rs <T as real::Real>::asin
deps:{"<T as real::Real>::asin":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::asin":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.asin();
+<T as real::Real>::asin(p0);
+crate::<T as real::Real>::asin(p0);
+<T>::asin(p0);
-----------------
src/macros.rs <T as real::Real>::acos
deps:{"<T as real::Real>::acos":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::acos":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.acos();
+<T as real::Real>::acos(p0);
+crate::<T as real::Real>::acos(p0);
+<T>::acos(p0);
-----------------
src/macros.rs <T as real::Real>::atan
deps:{"<T as real::Real>::atan":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::atan":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.atan();
+<T as real::Real>::atan(p0);
+crate::<T as real::Real>::atan(p0);
+<T>::atan(p0);
-----------------
src/macros.rs <T as real::Real>::atan2
deps:{"<T as real::Real>::atan2":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::atan2":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.atan2(p1);
+<T as real::Real>::atan2(p0, p1);
+crate::<T as real::Real>::atan2(p0, p1);
+<T>::atan2(p0, p1);
-----------------
src/macros.rs <T as real::Real>::sin_cos
deps:{"<T as real::Real>::sin_cos":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::sin_cos":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.sin_cos();
+<T as real::Real>::sin_cos(p0);
+crate::<T as real::Real>::sin_cos(p0);
+<T>::sin_cos(p0);
-----------------
src/macros.rs <T as real::Real>::exp_m1
deps:{"<T as real::Real>::exp_m1":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::exp_m1":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.exp_m1();
+<T as real::Real>::exp_m1(p0);
+crate::<T as real::Real>::exp_m1(p0);
+<T>::exp_m1(p0);
-----------------
src/macros.rs <T as real::Real>::ln_1p
deps:{"<T as real::Real>::ln_1p":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::ln_1p":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.ln_1p();
+<T as real::Real>::ln_1p(p0);
+crate::<T as real::Real>::ln_1p(p0);
+<T>::ln_1p(p0);
-----------------
src/macros.rs <T as real::Real>::sinh
deps:{"<T as real::Real>::sinh":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::sinh":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.sinh();
+<T as real::Real>::sinh(p0);
+crate::<T as real::Real>::sinh(p0);
+<T>::sinh(p0);
-----------------
src/macros.rs <T as real::Real>::cosh
deps:{"<T as real::Real>::cosh":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::cosh":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.cosh();
+<T as real::Real>::cosh(p0);
+crate::<T as real::Real>::cosh(p0);
+<T>::cosh(p0);
-----------------
src/macros.rs <T as real::Real>::tanh
deps:{"<T as real::Real>::tanh":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::tanh":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.tanh();
+<T as real::Real>::tanh(p0);
+crate::<T as real::Real>::tanh(p0);
+<T>::tanh(p0);
-----------------
src/macros.rs <T as real::Real>::asinh
deps:{"<T as real::Real>::asinh":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::asinh":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.asinh();
+<T as real::Real>::asinh(p0);
+crate::<T as real::Real>::asinh(p0);
+<T>::asinh(p0);
-----------------
src/macros.rs <T as real::Real>::acosh
deps:{"<T as real::Real>::acosh":{"T":["std::marker::Sized","float::Float"]}}
candidates:{"<T as real::Real>::acosh":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.acosh();
+<T as real::Real>::acosh(p0);
+crate::<T as real::Real>::acosh(p0);
+<T>::acosh(p0);
-----------------
src/macros.rs <T as real::Real>::atanh
deps:{"<T as real::Real>::atanh":{"T":["float::Float","std::marker::Sized"]}}
candidates:{"<T as real::Real>::atanh":{"T":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.atanh();
+<T as real::Real>::atanh(p0);
+crate::<T as real::Real>::atanh(p0);
+<T>::atanh(p0);
-----------------
src/sign.rs <isize as sign::Signed>::abs
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.abs();
+<isize as sign::Signed>::abs(p0);
+crate::<isize as sign::Signed>::abs(p0);
+<isize>::abs(p0);
-----------------
src/sign.rs <isize as sign::Signed>::abs_sub
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & 0isize; // None+isize
+p0.abs_sub(p1);
+<isize as sign::Signed>::abs_sub(p0, p1);
+crate::<isize as sign::Signed>::abs_sub(p0, p1);
+<isize>::abs_sub(p0, p1);
-----------------
src/sign.rs <isize as sign::Signed>::signum
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.signum();
+<isize as sign::Signed>::signum(p0);
+crate::<isize as sign::Signed>::signum(p0);
+<isize>::signum(p0);
-----------------
src/sign.rs <isize as sign::Signed>::is_positive
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.is_positive();
+<isize as sign::Signed>::is_positive(p0);
+crate::<isize as sign::Signed>::is_positive(p0);
+<isize>::is_positive(p0);
-----------------
src/sign.rs <isize as sign::Signed>::is_negative
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
+p0.is_negative();
+<isize as sign::Signed>::is_negative(p0);
+crate::<isize as sign::Signed>::is_negative(p0);
+<isize>::is_negative(p0);
-----------------
src/sign.rs <i8 as sign::Signed>::abs
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.abs();
+<i8 as sign::Signed>::abs(p0);
+crate::<i8 as sign::Signed>::abs(p0);
+<i8>::abs(p0);
-----------------
src/sign.rs <i8 as sign::Signed>::abs_sub
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & 0i8; // None+i8
+p0.abs_sub(p1);
+<i8 as sign::Signed>::abs_sub(p0, p1);
+crate::<i8 as sign::Signed>::abs_sub(p0, p1);
+<i8>::abs_sub(p0, p1);
-----------------
src/sign.rs <i8 as sign::Signed>::signum
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.signum();
+<i8 as sign::Signed>::signum(p0);
+crate::<i8 as sign::Signed>::signum(p0);
+<i8>::signum(p0);
-----------------
src/sign.rs <i8 as sign::Signed>::is_positive
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.is_positive();
+<i8 as sign::Signed>::is_positive(p0);
+crate::<i8 as sign::Signed>::is_positive(p0);
+<i8>::is_positive(p0);
-----------------
src/sign.rs <i8 as sign::Signed>::is_negative
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
+p0.is_negative();
+<i8 as sign::Signed>::is_negative(p0);
+crate::<i8 as sign::Signed>::is_negative(p0);
+<i8>::is_negative(p0);
-----------------
src/sign.rs <i16 as sign::Signed>::abs
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.abs();
+<i16 as sign::Signed>::abs(p0);
+crate::<i16 as sign::Signed>::abs(p0);
+<i16>::abs(p0);
-----------------
src/sign.rs <i16 as sign::Signed>::abs_sub
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & 0i16; // None+i16
+p0.abs_sub(p1);
+<i16 as sign::Signed>::abs_sub(p0, p1);
+crate::<i16 as sign::Signed>::abs_sub(p0, p1);
+<i16>::abs_sub(p0, p1);
-----------------
src/sign.rs <i16 as sign::Signed>::signum
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.signum();
+<i16 as sign::Signed>::signum(p0);
+crate::<i16 as sign::Signed>::signum(p0);
+<i16>::signum(p0);
-----------------
src/sign.rs <i16 as sign::Signed>::is_positive
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.is_positive();
+<i16 as sign::Signed>::is_positive(p0);
+crate::<i16 as sign::Signed>::is_positive(p0);
+<i16>::is_positive(p0);
-----------------
src/sign.rs <i16 as sign::Signed>::is_negative
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
+p0.is_negative();
+<i16 as sign::Signed>::is_negative(p0);
+crate::<i16 as sign::Signed>::is_negative(p0);
+<i16>::is_negative(p0);
-----------------
src/sign.rs <i32 as sign::Signed>::abs
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.abs();
+<i32 as sign::Signed>::abs(p0);
+crate::<i32 as sign::Signed>::abs(p0);
+<i32>::abs(p0);
-----------------
src/sign.rs <i32 as sign::Signed>::abs_sub
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & 0i32; // None+i32
+p0.abs_sub(p1);
+<i32 as sign::Signed>::abs_sub(p0, p1);
+crate::<i32 as sign::Signed>::abs_sub(p0, p1);
+<i32>::abs_sub(p0, p1);
-----------------
src/sign.rs <i32 as sign::Signed>::signum
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.signum();
+<i32 as sign::Signed>::signum(p0);
+crate::<i32 as sign::Signed>::signum(p0);
+<i32>::signum(p0);
-----------------
src/sign.rs <i32 as sign::Signed>::is_positive
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.is_positive();
+<i32 as sign::Signed>::is_positive(p0);
+crate::<i32 as sign::Signed>::is_positive(p0);
+<i32>::is_positive(p0);
-----------------
src/sign.rs <i32 as sign::Signed>::is_negative
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
+p0.is_negative();
+<i32 as sign::Signed>::is_negative(p0);
+crate::<i32 as sign::Signed>::is_negative(p0);
+<i32>::is_negative(p0);
-----------------
src/sign.rs <i64 as sign::Signed>::abs
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.abs();
+<i64 as sign::Signed>::abs(p0);
+crate::<i64 as sign::Signed>::abs(p0);
+<i64>::abs(p0);
-----------------
src/sign.rs <i64 as sign::Signed>::abs_sub
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & 0i64; // None+i64
+p0.abs_sub(p1);
+<i64 as sign::Signed>::abs_sub(p0, p1);
+crate::<i64 as sign::Signed>::abs_sub(p0, p1);
+<i64>::abs_sub(p0, p1);
-----------------
src/sign.rs <i64 as sign::Signed>::signum
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.signum();
+<i64 as sign::Signed>::signum(p0);
+crate::<i64 as sign::Signed>::signum(p0);
+<i64>::signum(p0);
-----------------
src/sign.rs <i64 as sign::Signed>::is_positive
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.is_positive();
+<i64 as sign::Signed>::is_positive(p0);
+crate::<i64 as sign::Signed>::is_positive(p0);
+<i64>::is_positive(p0);
-----------------
src/sign.rs <i64 as sign::Signed>::is_negative
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.is_negative();
+<i64 as sign::Signed>::is_negative(p0);
+crate::<i64 as sign::Signed>::is_negative(p0);
+<i64>::is_negative(p0);
-----------------
src/sign.rs <i128 as sign::Signed>::abs
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.abs();
+<i128 as sign::Signed>::abs(p0);
+crate::<i128 as sign::Signed>::abs(p0);
+<i128>::abs(p0);
-----------------
src/sign.rs <i128 as sign::Signed>::abs_sub
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
let mut p1 = & 0i128; // None+i128
+p0.abs_sub(p1);
+<i128 as sign::Signed>::abs_sub(p0, p1);
+crate::<i128 as sign::Signed>::abs_sub(p0, p1);
+<i128>::abs_sub(p0, p1);
-----------------
src/sign.rs <i128 as sign::Signed>::signum
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.signum();
+<i128 as sign::Signed>::signum(p0);
+crate::<i128 as sign::Signed>::signum(p0);
+<i128>::signum(p0);
-----------------
src/sign.rs <i128 as sign::Signed>::is_positive
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.is_positive();
+<i128 as sign::Signed>::is_positive(p0);
+crate::<i128 as sign::Signed>::is_positive(p0);
+<i128>::is_positive(p0);
-----------------
src/sign.rs <i128 as sign::Signed>::is_negative
deps:{}
candidates:{}
let mut p0 = & 0i128; // None+i128
+p0.is_negative();
+<i128 as sign::Signed>::is_negative(p0);
+crate::<i128 as sign::Signed>::is_negative(p0);
+<i128>::is_negative(p0);
-----------------
src/sign.rs <std::num::Wrapping<T> as sign::Signed>::abs
deps:{"<std::num::Wrapping<T> as sign::Signed>::abs":{"T":["std::marker::Sized","sign::Signed"],"std::num::Wrapping<T>":["std::ops::Neg","Num"]},"std::num::Wrapping":{"T":["ops::wrapping::WrappingSub","sign::Signed","cast::NumCast","sign::Unsigned","cast::ToPrimitive","ops::wrapping::WrappingShl","std::marker::Sized","identities::One","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","identities::Zero","bounds::Bounded","ops::wrapping::WrappingShr","cast::FromPrimitive","Num"]}}
candidates:{"<std::num::Wrapping<T> as sign::Signed>::abs":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":[]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.abs();
+<std::num::Wrapping<T> as sign::Signed>::abs(p0);
+crate::<std::num::Wrapping<T> as sign::Signed>::abs(p0);
+<std::num::Wrapping<T>>::abs(p0);
-----------------
src/sign.rs <std::num::Wrapping<T> as sign::Signed>::abs_sub
deps:{"<std::num::Wrapping<T> as sign::Signed>::abs_sub":{"T":["sign::Signed","std::marker::Sized"],"std::num::Wrapping<T>":["Num","std::ops::Neg"]},"std::num::Wrapping":{"T":["sign::Unsigned","ops::wrapping::WrappingNeg","std::marker::Sized","ops::wrapping::WrappingAdd","cast::NumCast","identities::Zero","cast::ToPrimitive","ops::wrapping::WrappingMul","Num","ops::wrapping::WrappingShl","ops::wrapping::WrappingSub","cast::FromPrimitive","ops::wrapping::WrappingShr","identities::One","bounds::Bounded","sign::Signed"]}}
candidates:{"<std::num::Wrapping<T> as sign::Signed>::abs_sub":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":[]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.abs_sub(p1);
+<std::num::Wrapping<T> as sign::Signed>::abs_sub(p0, p1);
+crate::<std::num::Wrapping<T> as sign::Signed>::abs_sub(p0, p1);
+<std::num::Wrapping<T>>::abs_sub(p0, p1);
-----------------
src/sign.rs <std::num::Wrapping<T> as sign::Signed>::signum
deps:{"<std::num::Wrapping<T> as sign::Signed>::signum":{"T":["sign::Signed","std::marker::Sized"],"std::num::Wrapping<T>":["Num","std::ops::Neg"]},"std::num::Wrapping":{"T":["cast::ToPrimitive","bounds::Bounded","ops::wrapping::WrappingMul","std::marker::Sized","identities::Zero","ops::wrapping::WrappingAdd","ops::wrapping::WrappingNeg","cast::NumCast","identities::One","sign::Signed","ops::wrapping::WrappingSub","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","cast::FromPrimitive","sign::Unsigned","Num"]}}
candidates:{"<std::num::Wrapping<T> as sign::Signed>::signum":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":[]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.signum();
+<std::num::Wrapping<T> as sign::Signed>::signum(p0);
+crate::<std::num::Wrapping<T> as sign::Signed>::signum(p0);
+<std::num::Wrapping<T>>::signum(p0);
-----------------
src/sign.rs <std::num::Wrapping<T> as sign::Signed>::is_positive
deps:{"<std::num::Wrapping<T> as sign::Signed>::is_positive":{"T":["sign::Signed","std::marker::Sized"],"std::num::Wrapping<T>":["Num","std::ops::Neg"]},"std::num::Wrapping":{"T":["identities::One","cast::NumCast","identities::Zero","ops::wrapping::WrappingAdd","sign::Signed","std::marker::Sized","bounds::Bounded","ops::wrapping::WrappingMul","ops::wrapping::WrappingSub","cast::FromPrimitive","ops::wrapping::WrappingShr","ops::wrapping::WrappingShl","sign::Unsigned","ops::wrapping::WrappingNeg","cast::ToPrimitive","Num"]}}
candidates:{"<std::num::Wrapping<T> as sign::Signed>::is_positive":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":[]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.is_positive();
+<std::num::Wrapping<T> as sign::Signed>::is_positive(p0);
+crate::<std::num::Wrapping<T> as sign::Signed>::is_positive(p0);
+<std::num::Wrapping<T>>::is_positive(p0);
-----------------
src/sign.rs <std::num::Wrapping<T> as sign::Signed>::is_negative
deps:{"<std::num::Wrapping<T> as sign::Signed>::is_negative":{"T":["std::marker::Sized","sign::Signed"],"std::num::Wrapping<T>":["Num","std::ops::Neg"]},"std::num::Wrapping":{"T":["std::marker::Sized","ops::wrapping::WrappingAdd","sign::Unsigned","cast::ToPrimitive","identities::Zero","ops::wrapping::WrappingShl","Num","ops::wrapping::WrappingShr","bounds::Bounded","ops::wrapping::WrappingMul","identities::One","cast::NumCast","ops::wrapping::WrappingSub","cast::FromPrimitive","sign::Signed","ops::wrapping::WrappingNeg"]}}
candidates:{"<std::num::Wrapping<T> as sign::Signed>::is_negative":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":[]},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::num::Wrapping<T>
+p0.is_negative();
+<std::num::Wrapping<T> as sign::Signed>::is_negative(p0);
+crate::<std::num::Wrapping<T> as sign::Signed>::is_negative(p0);
+<std::num::Wrapping<T>>::is_negative(p0);
-----------------
src/sign.rs <f32 as sign::Signed>::abs
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.abs();
+<f32 as sign::Signed>::abs(p0);
+crate::<f32 as sign::Signed>::abs(p0);
+<f32>::abs(p0);
-----------------
src/sign.rs <f32 as sign::Signed>::abs_sub
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & 0f32; // None+f32
+p0.abs_sub(p1);
+<f32 as sign::Signed>::abs_sub(p0, p1);
+crate::<f32 as sign::Signed>::abs_sub(p0, p1);
+<f32>::abs_sub(p0, p1);
-----------------
src/sign.rs <f32 as sign::Signed>::signum
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.signum();
+<f32 as sign::Signed>::signum(p0);
+crate::<f32 as sign::Signed>::signum(p0);
+<f32>::signum(p0);
-----------------
src/sign.rs <f32 as sign::Signed>::is_positive
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.is_positive();
+<f32 as sign::Signed>::is_positive(p0);
+crate::<f32 as sign::Signed>::is_positive(p0);
+<f32>::is_positive(p0);
-----------------
src/sign.rs <f32 as sign::Signed>::is_negative
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
+p0.is_negative();
+<f32 as sign::Signed>::is_negative(p0);
+crate::<f32 as sign::Signed>::is_negative(p0);
+<f32>::is_negative(p0);
-----------------
src/sign.rs <f64 as sign::Signed>::abs
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.abs();
+<f64 as sign::Signed>::abs(p0);
+crate::<f64 as sign::Signed>::abs(p0);
+<f64>::abs(p0);
-----------------
src/sign.rs <f64 as sign::Signed>::abs_sub
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & 0f64; // None+f64
+p0.abs_sub(p1);
+<f64 as sign::Signed>::abs_sub(p0, p1);
+crate::<f64 as sign::Signed>::abs_sub(p0, p1);
+<f64>::abs_sub(p0, p1);
-----------------
src/sign.rs <f64 as sign::Signed>::signum
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.signum();
+<f64 as sign::Signed>::signum(p0);
+crate::<f64 as sign::Signed>::signum(p0);
+<f64>::signum(p0);
-----------------
src/sign.rs <f64 as sign::Signed>::is_positive
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.is_positive();
+<f64 as sign::Signed>::is_positive(p0);
+crate::<f64 as sign::Signed>::is_positive(p0);
+<f64>::is_positive(p0);
-----------------
src/sign.rs <f64 as sign::Signed>::is_negative
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.is_negative();
+<f64 as sign::Signed>::is_negative(p0);
+crate::<f64 as sign::Signed>::is_negative(p0);
+<f64>::is_negative(p0);
-----------------
src/lib.rs <usize as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<usize as Num>::from_str_radix(&p0, p1);
+crate::<usize as Num>::from_str_radix(&p0, p1);
+<usize>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <u8 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<u8 as Num>::from_str_radix(&p0, p1);
+crate::<u8 as Num>::from_str_radix(&p0, p1);
+<u8>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <u16 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<u16 as Num>::from_str_radix(&p0, p1);
+crate::<u16 as Num>::from_str_radix(&p0, p1);
+<u16>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <u32 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<u32 as Num>::from_str_radix(&p0, p1);
+crate::<u32 as Num>::from_str_radix(&p0, p1);
+<u32>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <u64 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<u64 as Num>::from_str_radix(&p0, p1);
+crate::<u64 as Num>::from_str_radix(&p0, p1);
+<u64>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <u128 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<u128 as Num>::from_str_radix(&p0, p1);
+crate::<u128 as Num>::from_str_radix(&p0, p1);
+<u128>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <isize as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<isize as Num>::from_str_radix(&p0, p1);
+crate::<isize as Num>::from_str_radix(&p0, p1);
+<isize>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <i8 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<i8 as Num>::from_str_radix(&p0, p1);
+crate::<i8 as Num>::from_str_radix(&p0, p1);
+<i8>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <i16 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<i16 as Num>::from_str_radix(&p0, p1);
+crate::<i16 as Num>::from_str_radix(&p0, p1);
+<i16>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <i32 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<i32 as Num>::from_str_radix(&p0, p1);
+crate::<i32 as Num>::from_str_radix(&p0, p1);
+<i32>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <i64 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<i64 as Num>::from_str_radix(&p0, p1);
+crate::<i64 as Num>::from_str_radix(&p0, p1);
+<i64>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <i128 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<i128 as Num>::from_str_radix(&p0, p1);
+crate::<i128 as Num>::from_str_radix(&p0, p1);
+<i128>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <std::num::Wrapping<T> as Num>::from_str_radix
deps:{"<&'a std::num::Saturating<i128> as std::ops::Div<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Div<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Div<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Sub<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Div<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Sub<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Rem<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Mul<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Mul<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Rem<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Mul<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Mul<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Div<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Sub<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Sub<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Mul<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Mul<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Rem<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Div<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Mul<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Mul<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Rem<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Mul<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Div<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Sub<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Sub<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Sub<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Rem<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Sub<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Rem<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Mul<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Mul<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Mul<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Rem<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Rem<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Div<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Sub<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Rem<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Mul<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Mul<&std::num::Wrapping<usize>>>":{},"<T as NumOps<Rhs, Output>>":{"T":["std::ops::Add","std::ops::Sub","std::ops::Mul","std::ops::Div","std::ops::Rem","std::marker::Sized"]},"<std::num::Wrapping<T> as Num>::from_str_radix":{"T":["std::marker::Sized","Num"],"std::num::Wrapping<T>":["NumOps"]},"core::core_simd::ops::deref::<impl std::ops::Rem<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Rem<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["bounds::Bounded","identities::One","sign::Signed","ops::wrapping::WrappingShr","cast::FromPrimitive","ops::wrapping::WrappingNeg","ops::wrapping::WrappingSub","sign::Unsigned","cast::NumCast","ops::wrapping::WrappingMul","ops::wrapping::WrappingShl","identities::Zero","std::marker::Sized","cast::ToPrimitive","Num","ops::wrapping::WrappingAdd"]}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Div<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Div<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Div<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Sub<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Div<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Sub<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Rem<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Mul<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Mul<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Rem<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Mul<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Mul<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Div<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Sub<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Sub<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Mul<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Mul<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Rem<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Div<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Mul<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Mul<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Rem<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Mul<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Div<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Sub<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Sub<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Sub<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Rem<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Sub<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Rem<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Mul<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Mul<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Mul<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Rem<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Rem<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Div<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Sub<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Rem<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Mul<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Mul<&std::num::Wrapping<usize>>>":{},"<T as NumOps<Rhs, Output>>":{"T":["std::simd::Simd<f32, N>","std::simd::Simd<i32, N>","std::simd::Simd<i16, N>","std::simd::Simd<f64, N>","std::simd::Simd<isize, N>","std::simd::Simd<u8, N>","std::simd::Simd<u64, N>","std::simd::Simd<i8, N>","std::simd::Simd<i64, N>","std::simd::Simd<u16, N>","std::simd::Simd<usize, N>","std::simd::Simd<T, LANES>","std::simd::Simd<u32, N>","<&std::num::Saturating<u64> as std::ops::Sub<&std::num::Saturating<u64>>>"]},"<std::num::Wrapping<T> as Num>::from_str_radix":{"T":["std::num::Wrapping"],"std::num::Wrapping<T>":["<T as NumOps<Rhs, Output>>"]},"core::core_simd::ops::deref::<impl std::ops::Rem<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Rem<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{},"std::num::Wrapping":{"T":["std::num::Wrapping"]}}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<std::num::Wrapping<T> as Num>::from_str_radix(&p0, p1);
+crate::<std::num::Wrapping<T> as Num>::from_str_radix(&p0, p1);
+<std::num::Wrapping<T>>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <FloatErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // FloatErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<FloatErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<FloatErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<FloatErrorKind>::fmt(p0, p1);
-----------------
src/lib.rs <ParseFloatError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ParseFloatError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ParseFloatError as std::fmt::Debug>::fmt(p0, p1);
+crate::<ParseFloatError as std::fmt::Debug>::fmt(p0, p1);
+<ParseFloatError>::fmt(p0, p1);
-----------------
src/lib.rs <ParseFloatError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ParseFloatError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ParseFloatError as std::fmt::Display>::fmt(p0, p1);
+crate::<ParseFloatError as std::fmt::Display>::fmt(p0, p1);
+<ParseFloatError>::fmt(p0, p1);
-----------------
src/lib.rs <f32 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<f32 as Num>::from_str_radix(&p0, p1);
+crate::<f32 as Num>::from_str_radix(&p0, p1);
+<f32>::from_str_radix(&p0, p1);
-----------------
src/lib.rs <f64 as Num>::from_str_radix
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u32; // None+u32
+<f64 as Num>::from_str_radix(&p0, p1);
+crate::<f64 as Num>::from_str_radix(&p0, p1);
+<f64>::from_str_radix(&p0, p1);