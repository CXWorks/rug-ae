========================================
    use crate::Sha1Core;
    use digest::Reset;

    #[test]
    fn sha1core_reset_test() {
        let mut core = Sha1Core::default();

        // Change the internal state.
        core.h = [1, 2, 3, 4, 5];
        core.block_len = 123;

        // Reset the internal state.
        core.reset();

        let default_core = Sha1Core::default();

        // After reset, the internal state should be the same as a new default.
        assert_eq!(core.h, default_core.h, "h field did not reset as expected");
        assert_eq!(core.block_len, default_core.block_len, "block_len field did not reset as expected");
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::fmt;
    
    #[test]
    fn test_write_alg_name() {
        struct TestSha1Core;
        impl Sha1Core for TestSha1Core {
            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("Sha1")
            }
        }
        
        let test_sha1_core = TestSha1Core;
        let alg_name = format!("{}", test_sha1_core.alg_name());
        assert_eq!(&alg_name, "Sha1");
    }
}
False
========================================
    use crate::Sha1Core;
    use crate::compress;
    use crate::consts::STATE_LEN;
    use crate::utils::from_ref;
    use digest::core_api::{Buffer, BufferKindUser, FixedOutputCore, UpdateCore};
    use digest::crypto_common::BlockSizeUser;
    use digest::FixedOutput;
    use hex_literal::hex;

    #[test]
    fn test_finalize_fixed_core() {
        let mut core = Sha1Core::default();
        let mut buffer = <Sha1Core as BufferKindUser>::BufferKind::default();
        let mut out = <Sha1Core as FixedOutputCore>::Output::default();
        let bs = Sha1Core::BlockSize::to_usize();
        let data = [];

        // Update buffer with empty data to set the position
        buffer.update(&data, bs, &mut core, |h, b| compress(h, from_ref(b)));

        // Finalize with empty data
        core.finalize_fixed_core(&mut buffer, &mut out);
        let result_empty = hex::encode(out);
        assert_eq!(result_empty, "da39a3ee5e6b4b0d3255bfef95601890afd80709");

        // Reset core and buffer for the next test
        core.reset();
        buffer.reset();

        // Update buffer with "abc" and finalize
        let data = b"abc";
        buffer.update(data, bs, &mut core, |h, b| compress(h, from_ref(b)));
        core.finalize_fixed_core(&mut buffer, &mut out);
        let result_abc = hex::encode(out);
        assert_eq!(result_abc, "a9993e364706816aba3e25717850c26c9cd0d89d");
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::Sha1Core; // Assuming `Sha1Core` is in the current crate's scope.
    use digest::core_api::Block; // Utilize Block from `digest::core_api`
    use digest::core_api::UpdateCore; // Correcting the import path for `UpdateCore`

    #[test]
    fn test_update_blocks() {
        let mut hasher = Sha1Core::default();
        let initial_state = hasher.clone();

        // Assuming Block<Self> is similar to a generic array type.
        // We need to know how to construct a `Block<Self>` for `Sha1Core`.
        // If Block<Self> is a type alias for a fixed-size array (e.g., [u8; 64]),
        // then refactor the code to use the correct type.
        // For demonstration, let's assume Block<Self> is a type alias for [u8; 64]
        // so I am replacing `Block::<Sha1Core>::default();` with `[0u8; 64];`
        // This should be replaced with the appropriate code to construct a Block
        
        // Prepare a single block to update the state.
        let block = [0u8; 64]; // Assuming Block<Self> is a type alias for [u8; 64]
        let block_slice = &[block]; // Temporary slice, will be fixed in the next lines
        // hasher.update_blocks expects &[Block<Self>]
        // Fixing the type to be compatible with the update_blocks signature.
        let block_refs = [&block]; // Creating a slice of references to blocks
        
        // Update block representation to compress function.
        let mut blocks_compressed = vec![Default::default(); block_refs.len()]; // Assuming Block<Self> is initializable.
        for (block_compressed, block_ref) in blocks_compressed.iter_mut().zip(block_refs.iter()) {
            // Assuming we need to copy data from the block_ref to block_compressed
            // This code assumes block_ref is &[u8] which we can copy to block_compressed.
            block_compressed.copy_from_slice(block_ref); // This should be replaced with correct block preparation.
        }
        
        // Update hasher with blocks in the expected format.
        hasher.update_blocks(&blocks_compressed);
        
        // Ensure the block count is incremented.
        assert_eq!(hasher.block_len, initial_state.block_len + blocks_compressed.len() as u64);
        
        // Ensure the state is changed due to compress function.
        assert_ne!(hasher.h, initial_state.h);
        
        // Update with multiple blocks to see the correct increment.
        let block_count = 5;
        // Assuming a similar pattern as single block for multiple blocks
        let mut multiple_blocks = vec![Default::default(); block_count]; // See assumption above for Block<Self>.
        for block in multiple_blocks.iter_mut() {
            // Prepare each block as we did for a single block.
            // Block preparation depends on how Block<Self> is defined for Sha1Core
            // Replace with the correct initialization of block as needed.
            *block = [0u8; 64]; // This should be replaced with correct block initialization.
        }
        
        // Update hasher with multiple blocks.
        hasher.update_blocks(&multiple_blocks);
        
        // Ensure the block_len is correctly updated to reflect 5 new blocks.
        assert_eq!(hasher.block_len, initial_state.block_len + block_count as u64);
        
        // The state should be changed again due to compress function.
        assert_ne!(hasher.h, initial_state.h);
    }
}
False
========================================
    use crate::Sha1Core;
    use std::default::Default;

    #[test]
    fn default_initializes_correct_state() {
        let sha1_core = Sha1Core::default();
        assert_eq!(sha1_core.h, [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
        assert_eq!(sha1_core.block_len, 0);
    }
}
True
========================================
    use crate::compress::compress;
    use crate::compress::Sha1Core;
    use crate::digest::generic_array::GenericArray;
    use crate::{Block, Digest, Digest as _};
    use crate::digest::FixedOutput as _;
    use crate::digest::Update as _;

    const BLOCK_SIZE: usize = 64;

    #[test]
    fn test_compress() {
        let mut state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
        let mut core = Sha1Core::new();
        let data = b"The quick brown fox jumps over the lazy dog";

        // We assume the existence of the necessary traits and methods
        core.update(data);
        let hash = core.finalize();
        let blocks = core.finalize_fixed_block(Some(data.len() as u64 * 8));

        let blocks_generic_array: &[GenericArray<u8, <Sha1Core as Digest>::OutputSize>] = 
            &[GenericArray::clone_from_slice(&blocks)];
        let blocks: &[Block<Sha1Core>] = unsafe {
            &*(blocks_generic_array as *const _ as *const [Block<Sha1Core>])
        };

        let original_state = state;
        compress(&mut state, blocks);

        // We assume the compress function actually changes the state
        // and the `expected_state` is the correct result
        let expected_state = [
            0x2fd4e1c6, 0x7a2d28fc, 0xed849ee1, 0xbb76e739, 0x1b93eb12,
        ];

        assert_eq!(state, expected_state, "SHA-1 compress function failed");

        // as the compress function is pure, compressing the same blocks again with the original
        // state should result in the same state
        state = original_state;
        compress(&mut state, blocks);
        assert_eq!(state, expected_state, "SHA-1 compress function is not pure");
    }
}
False
========================================
    use crate::add;

    #[test]
    fn test_add() {
        assert_eq!(add([0, 0, 0, 0], [1, 1, 1, 1]), [1, 1, 1, 1]);
        assert_eq!(add([1, 2, 3, 4], [5, 6, 7, 8]), [6, 8, 10, 12]);
        assert_eq!(add([0xffffffff; 4], [1; 4]), [0, 0, 0, 0]);
    }
}
False
========================================
    use crate::super::compress;
    use crate::digest::consts::U64;
    use crate::digest::generic_array::GenericArray;
    use crate::digest::generic_array::typenum::Unsigned;
    use crate::Sha1;

    fn create_blocks(data: &[u8]) -> Vec<GenericArray<u8, U64>> {
        data.chunks(U64::to_usize())
            .map(|chunk| {
                let mut block = GenericArray::default();
                block[..chunk.len()].copy_from_slice(chunk);
                block
            })
            .collect()
    }

    #[test]
    fn test_compress_single_block() {
        let mut state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
        let block = [0u8; 64];
        let blocks = create_blocks(&block);
        let expected_state = [0x5BAA61E4, 0xC9B93F3F, 0x06825571, 0xB2AA2F2E, 0x40B2FD3B];
        compress(&mut state, &blocks);

        assert_eq!(state, expected_state, "State after compressing single zero block should match expected state.");
    }

    #[test]
    fn test_compress_multiple_blocks() {
        let mut state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
        let blocks = [0u8; 64 * 2];
        let blocks = create_blocks(&blocks);
        let expected_state = [0x66B27417, 0x572EDEC0, 0x1D3F6383, 0xDFD6B8B3, 0x4566E0E4];
        compress(&mut state, &blocks);

        assert_eq!(state, expected_state, "State after compressing multiple zero blocks should match expected state.");
    }

    #[test]
    fn test_compress_with_actual_data() {
        let mut state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
        let data = [0x61, 0x62, 0x63, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18];
        let blocks = create_blocks(&data);
        let expected_state = [0xA9993E36, 0x4706816A, 0xBA3E2571, 0x7850C26C, 0x9CD0D89D];
        compress(&mut state, &blocks);

        assert_eq!(state, expected_state, "State after compressing 'abc' should match expected state.");
    }
}
False
========================================
    use crate::sha1_digest_block_u32;

    #[test]
    fn test_sha1_digest_block_u32() {
        let mut state = [
            0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0,
        ];
        let block = [
            0x61626380, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
            0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
            0x00000000, 0x00000018,
        ];

        let expected_state = [
            0x99F82E02, 0x78D39F3E, 0xB82F2D17, 0x831E119F, 0x66EFE4E4,
        ];

        sha1_digest_block_u32(&mut state, &block);

        assert_eq!(state, expected_state, "SHA1 digest block calculation mismatch");
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_sha1_digest_round_x4() {
        let abcd = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];
        let work = [0xdeadbeef, 0xcafebabe, 0x8badf00d, 0x0badc0de];

        let output_0 = sha1_digest_round_x4(abcd, work, 0);
        let expected_0 = sha1rnds4c(abcd, add(work, [K[0]; 4]));
        assert_eq!(output_0, expected_0, "sha1_digest_round_x4 failed for i = 0");

        let output_1 = sha1_digest_round_x4(abcd, work, 1);
        let expected_1 = sha1rnds4p(abcd, add(work, [K[1]; 4]));
        assert_eq!(output_1, expected_1, "sha1_digest_round_x4 failed for i = 1");

        let output_2 = sha1_digest_round_x4(abcd, work, 2);
        let expected_2 = sha1rnds4m(abcd, add(work, [K[2]; 4]));
        assert_eq!(output_2, expected_2, "sha1_digest_round_x4 failed for i = 2");

        let output_3 = sha1_digest_round_x4(abcd, work, 3);
        let expected_3 = sha1rnds4p(abcd, add(work, [K[3]; 4]));
        assert_eq!(output_3, expected_3, "sha1_digest_round_x4 failed for i = 3");

        let result = std::panic::catch_unwind(|| {
            sha1_digest_round_x4(abcd, work, 4);
        });
        assert!(result.is_err(), "sha1_digest_round_x4 should panic for invalid i");
    }
}
True
========================================
    use crate::sha1_first_add;

    #[test]
    fn test_sha1_first_add() {
        let e: u32 = 0x12345678;
        let w0: [u32; 4] = [0x89abcdef, 0xfedcba98, 0x76543210, 0x01234567];

        let result = sha1_first_add(e, w0);
        let expected: [u32; 4] = [0x9abcdef67, 0xfedcba98, 0x76543210, 0x01234567];

        assert_eq!(result, expected, "sha1_first_add did not produce the expected result");
    }
}
False
========================================
    use crate::sha1_first_half;

    #[test]
    fn test_sha1_first_half() {
        // Setup an internal function for the sake of the test
        fn sha1_first_add(abcd: [u32; 4], msg: [u32; 4]) -> [u32; 4] {
            // ... (omitted) implement the `sha1_first_add` function here or
            // mock the expected behavior if the actual function is private
        }

        // Mock the `sha1_first_add` function for testing `sha1_first_half`
        // This is just a placeholder; actual implementation details are needed
        impl super::SoftSha1 {
            fn sha1_first_add(abcd: u32, msg: [u32; 4]) -> [u32; 4] {
                // Assuming the `sha1_first_add` is a method of SoftSha1 for the sake of example
                sha1_first_add([abcd; 4], msg)
            }
        }

        // Setup test cases
        let test_cases = vec![
            // Test that the function applies rotate left and sha1_first_add correctly
            (
                [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476],
                [0x12345678, 0x9ABCDEF0, 0x0FEDCBA9, 0x87654321],
                // Mocked expected result, actual result may differ
                [0x8F1BBCDC, 0x98BADCFE, 0x10325476, 0x67452301],
            ),
            // Test with zeros
            (
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                // Mocked expected result, actual result may differ
                [0, 0, 0, 0],
            ),
            // Test with 32-bit MAX values
            (
                [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF],
                [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF],
                // Mocked expected result, actual result may differ
                [0x8F1BBCDC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF],
            ),
        ];

        // Run the test cases
        for (abcd, msg, expected) in test_cases {
            let result = sha1_first_half(abcd, msg);
            assert_eq!(result, expected);
        }
    }
}
False
========================================
    use crate::sha1msg1;

    #[test]
    fn test_sha1msg1() {
        // Test vectors
        let input_a = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];
        let input_b = [0x89ABCDEF, 0x01234567, 0xFEDCBA98, 0x76543210];

        // Expected output
        let expected = [input_a[0] ^ input_a[2],    // 0x67452301 ^ 0x98BADCFE
                        input_a[1] ^ input_a[3],    // 0xEFCDAB89 ^ 0x10325476
                        input_a[2] ^ input_b[0],    // 0x98BADCFE ^ 0x89ABCDEF
                        input_a[3] ^ input_b[1]];   // 0x10325476 ^ 0x01234567

        // Perform the test
        let result = sha1msg1(input_a, input_b);

        // Verify the result
        assert_eq!(result, expected);
    }
}
False
========================================
    use crate::sha1msg2;

    #[test]
    fn test_sha1msg2() {
        // Test vector 1
        {
            let a = [0x61626364, 0x62636465, 0x63646566, 0x64656667];
            let b = [0, 0x78797a7b, 0x797a7b7c, 0x7a7b7c7d];
            let expected = [0xe0e1e2e2, 0xe1e2e3e3, 0xe2e3e4e4, 0xe3e4e4e1];
            let result = sha1msg2(a, b);
            assert_eq!(result, expected);
        }

        // Test vector 2
        {
            let a = [0x00010203, 0x01020304, 0x02030405, 0x03040506];
            let b = [0, 0x18191a1b, 0x191a1b1c, 0x1a1b1c1d];
            let expected = [0x191a1b10, 0x1a1b1c11, 0x1b1c1d12, 0x1c1d1d14];
            let result = sha1msg2(a, b);
            assert_eq!(result, expected);
        }

        // Additional test vectors can be added here
    }
}
False
========================================
    use crate::sha1rnds4c;

    #[test]
    fn test_sha1rnds4c() {
        // Provide test values for abcd and msg for which the expected result is known
        let abcd = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];
        let msg = [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE];
        // Provide the expected result for the given test values
        let expected = [0xF0E1D143, 0x7DC311D4, 0x6D0B4CEB, 0xC0FBD4A2];
        assert_eq!(sha1rnds4c(abcd, msg), expected, "sha1rnds4c did not return the expected result");
    }
}
False
========================================
    use crate::sha1rnds4m;

    #[test]
    fn test_sha1rnds4m() {
        let abcd = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];
        let msg = [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE];
        let expected = [0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
        let result = sha1rnds4m(abcd, msg);

        assert_eq!(result, expected, "sha1rnds4m did not produce the expected result.");
    }
}
False
========================================
    use crate::sha1rnds4p;

    #[test]
    fn test_sha1rnds4p() {
        let abcd = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];
        let msg = [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE];
        let expected = [0x98badcfe, 0x10325476, 0xefcdab89, 0x67452301];
        assert_eq!(sha1rnds4p(abcd, msg), expected);
    }
}
False
========================================
    use crate::xor;

    #[test]
    fn test_xor() {
        assert_eq!(
            xor([0, 0, 0, 0], [0, 0, 0, 0]),
            [0, 0, 0, 0]
        );

        assert_eq!(
            xor([0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff], [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff]),
            [0, 0, 0, 0]
        );

        assert_eq!(
            xor([0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f], [0xf0f0f0f0, 0xf0f0f0f0, 0xf0f0f0f0, 0xf0f0f0f0]),
            [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff]
        );

        assert_eq!(
            xor([0x12345678, 0x9abcdef0, 0x13579bdf, 0xfedcba98], [0x12345678, 0x9abcdef0, 0x13579bdf, 0xfedcba98]),
            [0, 0, 0, 0]
        );

        assert_eq!(
            xor([0x12345678, 0x87654321, 0x11111111, 0x22222222], [0x00000000, 0xffffffff, 0x33333333, 0x44444444]),
            [0x12345678, 0x789abcde, 0x22222222, 0x66666666]
        );
    }
}
False
========================================
    use crate::compress::x86::compress;
    use crate::compress::soft::compress as soft_compress;
    use crate::compress::x86::shani_cpuid;
    use crate::digest::generic_array::GenericArray;
    use crate::digest::generic_array::typenum::U64;

    #[test]
    fn test_compress_equivalence() {
        let mut state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
        let mut soft_state = state;
        let block = GenericArray::clone_from_slice(b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
        let blocks = [block];

        compress(&mut state, &blocks);
        soft_compress(&mut soft_state, &blocks);

        assert_eq!(state, soft_state, "Hardware-accelerated and software implementations of compress should be equivalent");
    }

    #[test]
    fn test_compress_known_values() {
        let mut state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
        let block = GenericArray::clone_from_slice(b"The quick brown fox jumps over the lazy dog");
        let blocks = [block];

        compress(&mut state, &blocks);

        let expected_state = [0x2fd4e1c6, 0x7a2d28fc, 0xed849ee1, 0xbb76e739, 0x1b93eb12];
        assert_eq!(state, expected_state, "compress function did not produce the expected state");
    }

    #[test]
    fn test_compress_with_cpuid_check() {
        let mut state = [0x12345678, 0x9ABCDEF0, 0x0FEDCBA9, 0x87654321, 0xFEDCBA98];
        let block = GenericArray::clone_from_slice(b"Test block for CPUID check");
        let blocks = [block];

        if shani_cpuid::get() {
            unsafe {
                crate::compress::x86::digest_blocks(&mut state, &blocks);
            }
        } else {
            soft_compress(&mut state, &blocks);
        }

        let mut expected_state = state;
        compress(&mut expected_state, &blocks);

        assert_eq!(state, expected_state, "compress function should be consistent with CPUID check");
    }
}
False
========================================
    use crate::compress::x86::digest_blocks;
    use std::arch::x86_64::*;

    #[target_feature(enable = "sha")]
    unsafe fn run_digest_blocks(state: &mut [u32; 5], blocks: &[[u8; 64]]) {
        digest_blocks(state, blocks)
    }

    #[test]
    fn test_digest_blocks() {
        unsafe {
            // Initial state of the SHA1 algorithm after processing "abc"
            let mut state: [u32; 5] = [
                0x67452301,
                0xEFCDAB89,
                0x98BADCFE,
                0x10325476,
                0xC3D2E1F0,
            ];
            // "abc" in 512-bit block (64 bytes), the rest of block is padded according to the standard
            let blocks: &[[u8; 64]] = &[[
                0x61, 0x62, 0x63, 0x80, 0x00, 0x00, 0x00, 0x00, // "abc" + padding
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, // Length of "abc" in bits (24 bits = 0x18)
            ]];

            let expected: [u32; 5] = [
                0xA9993E36,
                0x4706816A,
                0xBA3E2571,
                0x7850C26C,
                0x9CD0D89D,
            ];

            run_digest_blocks(&mut state, blocks);

            assert_eq!(state, expected, "The resulting state does not match the expected one after processing the block");
        }
    }
}
True
hashes sha1 4 20
