-----------------
src/display.rs display::pad
deps:{"display::pad":{"impl FnOnce(&mut fmt::Formatter) -> fmt::Result":["std::marker::Sized","std::ops::FnOnce"],"impl FnOnce() -> usize":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"display::pad":{"impl FnOnce(&mut fmt::Formatter) -> fmt::Result":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::panic::AssertUnwindSafe<F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte"],"impl FnOnce() -> usize":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::panic::AssertUnwindSafe<F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut fmt::Formatter) -> fmt::Result
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> usize
+display::pad(p0, p1, p2);
+crate::display::pad(p0, p1, p2);
+crate::display::pad(p0, p1, p2);
-----------------
src/display.rs display::digits
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+display::digits(p0);
+crate::display::digits(p0);
+crate::display::digits(p0);
-----------------
src/eval.rs eval::matches_req
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // VersionReq
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::matches_req(p0, p1);
+crate::eval::matches_req(p0, p1);
+crate::eval::matches_req(p0, p1);
-----------------
src/eval.rs eval::matches_comparator
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::matches_comparator(p0, p1);
+crate::eval::matches_comparator(p0, p1);
+crate::eval::matches_comparator(p0, p1);
-----------------
src/eval.rs eval::matches_impl
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::matches_impl(p0, p1);
+crate::eval::matches_impl(p0, p1);
+crate::eval::matches_impl(p0, p1);
-----------------
src/eval.rs eval::matches_exact
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::matches_exact(p0, p1);
+crate::eval::matches_exact(p0, p1);
+crate::eval::matches_exact(p0, p1);
-----------------
src/eval.rs eval::matches_greater
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::matches_greater(p0, p1);
+crate::eval::matches_greater(p0, p1);
+crate::eval::matches_greater(p0, p1);
-----------------
src/eval.rs eval::matches_less
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::matches_less(p0, p1);
+crate::eval::matches_less(p0, p1);
+crate::eval::matches_less(p0, p1);
-----------------
src/eval.rs eval::matches_tilde
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::matches_tilde(p0, p1);
+crate::eval::matches_tilde(p0, p1);
+crate::eval::matches_tilde(p0, p1);
-----------------
src/eval.rs eval::matches_caret
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::matches_caret(p0, p1);
+crate::eval::matches_caret(p0, p1);
+crate::eval::matches_caret(p0, p1);
-----------------
src/eval.rs eval::pre_is_compatible
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+eval::pre_is_compatible(p0, p1);
+crate::eval::pre_is_compatible(p0, p1);
+crate::eval::pre_is_compatible(p0, p1);
-----------------
src/identifier.rs identifier::ptr_to_repr
deps:{}
candidates:{}
let mut p0 = 0u8; // None+*mut u8
+identifier::ptr_to_repr(p0);
+crate::identifier::ptr_to_repr(p0);
+crate::identifier::ptr_to_repr(p0);
-----------------
src/identifier.rs identifier::repr_to_ptr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ptr::NonNull<u8>
+identifier::repr_to_ptr(p0);
+crate::identifier::repr_to_ptr(p0);
+crate::identifier::repr_to_ptr(p0);
-----------------
src/identifier.rs identifier::repr_to_ptr_mut
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ptr::NonNull<u8>
+identifier::repr_to_ptr_mut(p0);
+crate::identifier::repr_to_ptr_mut(p0);
+crate::identifier::repr_to_ptr_mut(p0);
-----------------
src/identifier.rs identifier::inline_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
+identifier::inline_len(p0);
+crate::identifier::inline_len(p0);
+crate::identifier::inline_len(p0);
-----------------
src/identifier.rs identifier::inline_as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
+identifier::inline_as_str(p0);
+crate::identifier::inline_as_str(p0);
+crate::identifier::inline_as_str(p0);
-----------------
src/identifier.rs identifier::decode_len
deps:{}
candidates:{}
let mut p0 = 0u8; // None+*const u8
+identifier::decode_len(p0);
+crate::identifier::decode_len(p0);
+crate::identifier::decode_len(p0);
-----------------
src/identifier.rs identifier::decode_len::decode_len_cold
deps:{}
candidates:{}
let mut p0 = 0u8; // None+*const u8
+identifier::decode_len::decode_len_cold(p0);
+crate::identifier::decode_len::decode_len_cold(p0);
+crate::identifier::decode_len::decode_len_cold(p0);
-----------------
src/identifier.rs identifier::ptr_as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ptr::NonNull<u8>
+identifier::ptr_as_str(p0);
+crate::identifier::ptr_as_str(p0);
+crate::identifier::ptr_as_str(p0);
-----------------
src/identifier.rs identifier::bytes_for_varint
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::NonZeroUsize
+identifier::bytes_for_varint(p0);
+crate::identifier::bytes_for_varint(p0);
+crate::identifier::bytes_for_varint(p0);
-----------------
src/parse.rs parse::numeric_identifier
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // error::Position
+parse::numeric_identifier(&p0, p1);
+crate::parse::numeric_identifier(&p0, p1);
+crate::parse::numeric_identifier(&p0, p1);
-----------------
src/parse.rs parse::wildcard
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::wildcard(&p0);
+crate::parse::wildcard(&p0);
+crate::parse::wildcard(&p0);
-----------------
src/parse.rs parse::dot
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // error::Position
+parse::dot(&p0, p1);
+crate::parse::dot(&p0, p1);
+crate::parse::dot(&p0, p1);
-----------------
src/parse.rs parse::prerelease_identifier
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::prerelease_identifier(&p0);
+crate::parse::prerelease_identifier(&p0);
+crate::parse::prerelease_identifier(&p0);
-----------------
src/parse.rs parse::build_identifier
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::build_identifier(&p0);
+crate::parse::build_identifier(&p0);
+crate::parse::build_identifier(&p0);
-----------------
src/parse.rs parse::identifier
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // error::Position
+parse::identifier(&p0, p1);
+crate::parse::identifier(&p0, p1);
+crate::parse::identifier(&p0, p1);
-----------------
src/parse.rs parse::op
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::op(&p0);
+crate::parse::op(&p0);
+crate::parse::op(&p0);
-----------------
src/parse.rs parse::comparator
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::comparator(&p0);
+crate::parse::comparator(&p0);
+crate::parse::comparator(&p0);
-----------------
src/parse.rs parse::version_req
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<Comparator>
let mut p2 = 0usize; // None+usize
+parse::version_req(&p0, p1, p2);
+crate::parse::version_req(&p0, p1, p2);
+crate::parse::version_req(&p0, p1, p2);
-----------------
src/display.rs display::<impl std::fmt::Display for Version>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Version
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+display::<impl std::fmt::Display for Version>::fmt(p0, p1);
+crate::display::<impl std::fmt::Display for Version>::fmt(p0, p1);
+<Version>::fmt(p0, p1);
-----------------
src/display.rs display::<impl std::fmt::Display for VersionReq>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // VersionReq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+display::<impl std::fmt::Display for VersionReq>::fmt(p0, p1);
+crate::display::<impl std::fmt::Display for VersionReq>::fmt(p0, p1);
+<VersionReq>::fmt(p0, p1);
-----------------
src/display.rs display::<impl std::fmt::Display for Comparator>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+display::<impl std::fmt::Display for Comparator>::fmt(p0, p1);
+crate::display::<impl std::fmt::Display for Comparator>::fmt(p0, p1);
+<Comparator>::fmt(p0, p1);
-----------------
src/display.rs display::<impl std::fmt::Display for Prerelease>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+display::<impl std::fmt::Display for Prerelease>::fmt(p0, p1);
+crate::display::<impl std::fmt::Display for Prerelease>::fmt(p0, p1);
+<Prerelease>::fmt(p0, p1);
-----------------
src/display.rs display::<impl std::fmt::Display for BuildMetadata>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+display::<impl std::fmt::Display for BuildMetadata>::fmt(p0, p1);
+crate::display::<impl std::fmt::Display for BuildMetadata>::fmt(p0, p1);
+<BuildMetadata>::fmt(p0, p1);
-----------------
src/display.rs display::<impl std::fmt::Debug for Version>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Version
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+display::<impl std::fmt::Debug for Version>::fmt(p0, p1);
+crate::display::<impl std::fmt::Debug for Version>::fmt(p0, p1);
+<Version>::fmt(p0, p1);
-----------------
src/display.rs display::<impl std::fmt::Debug for Prerelease>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+display::<impl std::fmt::Debug for Prerelease>::fmt(p0, p1);
+crate::display::<impl std::fmt::Debug for Prerelease>::fmt(p0, p1);
+<Prerelease>::fmt(p0, p1);
-----------------
src/display.rs display::<impl std::fmt::Debug for BuildMetadata>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+display::<impl std::fmt::Debug for BuildMetadata>::fmt(p0, p1);
+crate::display::<impl std::fmt::Debug for BuildMetadata>::fmt(p0, p1);
+<BuildMetadata>::fmt(p0, p1);
-----------------
src/error.rs <error::Position as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Position
+p0.clone();
+<error::Position as std::clone::Clone>::clone(p0);
+crate::<error::Position as std::clone::Clone>::clone(p0);
+<error::Position>::clone(p0);
-----------------
src/error.rs <error::Position as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Position
+p0.assert_receiver_is_total_eq();
+<error::Position as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::Position as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::Position>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::Position as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Position
+p0.eq(p1);
+<error::Position as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Position as std::cmp::PartialEq>::eq(p0, p1);
+<error::Position>::eq(p0, p1);
-----------------
src/error.rs error::<impl std::fmt::Display for parse::Error>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parse::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+error::<impl std::fmt::Display for parse::Error>::fmt(p0, p1);
+crate::error::<impl std::fmt::Display for parse::Error>::fmt(p0, p1);
+<parse::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::Position as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Position
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Position as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Position as std::fmt::Display>::fmt(p0, p1);
+<error::Position>::fmt(p0, p1);
-----------------
src/error.rs error::<impl std::fmt::Debug for parse::Error>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parse::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+error::<impl std::fmt::Debug for parse::Error>::fmt(p0, p1);
+crate::error::<impl std::fmt::Debug for parse::Error>::fmt(p0, p1);
+<parse::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::QuotedChar as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::QuotedChar
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::QuotedChar as std::fmt::Display>::fmt(p0, p1);
+crate::<error::QuotedChar as std::fmt::Display>::fmt(p0, p1);
+<error::QuotedChar>::fmt(p0, p1);
-----------------
src/identifier.rs identifier::Identifier::empty
deps:{}
candidates:{}
+identifier::Identifier::empty();
+crate::identifier::Identifier::empty();
+<identifier::Identifier>::empty();
-----------------
src/identifier.rs identifier::Identifier::new_unchecked
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+identifier::Identifier::new_unchecked(&p0);
+crate::identifier::Identifier::new_unchecked(&p0);
+<identifier::Identifier>::new_unchecked(&p0);
-----------------
src/identifier.rs identifier::Identifier::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
+p0.is_empty();
+identifier::Identifier::is_empty(p0);
+crate::identifier::Identifier::is_empty(p0);
+<identifier::Identifier>::is_empty(p0);
-----------------
src/identifier.rs identifier::Identifier::is_inline
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
+p0.is_inline();
+identifier::Identifier::is_inline(p0);
+crate::identifier::Identifier::is_inline(p0);
+<identifier::Identifier>::is_inline(p0);
-----------------
src/identifier.rs identifier::Identifier::is_empty_or_inline
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
+p0.is_empty_or_inline();
+identifier::Identifier::is_empty_or_inline(p0);
+crate::identifier::Identifier::is_empty_or_inline(p0);
+<identifier::Identifier>::is_empty_or_inline(p0);
-----------------
src/identifier.rs identifier::Identifier::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
+p0.as_str();
+identifier::Identifier::as_str(p0);
+crate::identifier::Identifier::as_str(p0);
+<identifier::Identifier>::as_str(p0);
-----------------
src/identifier.rs <identifier::Identifier as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
+p0.clone();
+<identifier::Identifier as std::clone::Clone>::clone(p0);
+crate::<identifier::Identifier as std::clone::Clone>::clone(p0);
+<identifier::Identifier>::clone(p0);
-----------------
src/identifier.rs <identifier::Identifier as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // identifier::Identifier
+p0.drop();
+<identifier::Identifier as std::ops::Drop>::drop(p0);
+crate::<identifier::Identifier as std::ops::Drop>::drop(p0);
+<identifier::Identifier>::drop(p0);
-----------------
src/identifier.rs <identifier::Identifier as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
let mut p1 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
+p0.eq(p1);
+<identifier::Identifier as std::cmp::PartialEq>::eq(p0, p1);
+crate::<identifier::Identifier as std::cmp::PartialEq>::eq(p0, p1);
+<identifier::Identifier>::eq(p0, p1);
-----------------
src/impls.rs impls::<impl std::default::Default for identifier::Identifier>::default
deps:{}
candidates:{}
+impls::<impl std::default::Default for identifier::Identifier>::default();
+crate::impls::<impl std::default::Default for identifier::Identifier>::default();
+<identifier::Identifier>::default();
-----------------
src/impls.rs impls::<impl std::hash::Hash for identifier::Identifier>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"impls::<impl std::hash::Hash for identifier::Identifier>::hash":{"H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"impls::<impl std::hash::Hash for identifier::Identifier>::hash":{"H":["std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // identifier::Identifier
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+impls::<impl std::hash::Hash for identifier::Identifier>::hash(p0, p1);
+crate::impls::<impl std::hash::Hash for identifier::Identifier>::hash(p0, p1);
+<identifier::Identifier>::hash(p0, p1);
-----------------
src/impls.rs impls::<impl std::ops::Deref for Prerelease>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
+p0.deref();
+impls::<impl std::ops::Deref for Prerelease>::deref(p0);
+crate::impls::<impl std::ops::Deref for Prerelease>::deref(p0);
+<Prerelease>::deref(p0);
-----------------
src/impls.rs impls::<impl std::ops::Deref for BuildMetadata>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
+p0.deref();
+impls::<impl std::ops::Deref for BuildMetadata>::deref(p0);
+crate::impls::<impl std::ops::Deref for BuildMetadata>::deref(p0);
+<BuildMetadata>::deref(p0);
-----------------
src/impls.rs impls::<impl std::cmp::PartialOrd for Prerelease>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
let mut p1 = & MaybeUninit::uninit().assume_init(); // Prerelease
+p0.partial_cmp(p1);
+impls::<impl std::cmp::PartialOrd for Prerelease>::partial_cmp(p0, p1);
+crate::impls::<impl std::cmp::PartialOrd for Prerelease>::partial_cmp(p0, p1);
+<Prerelease>::partial_cmp(p0, p1);
-----------------
src/impls.rs impls::<impl std::cmp::PartialOrd for BuildMetadata>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
let mut p1 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
+p0.partial_cmp(p1);
+impls::<impl std::cmp::PartialOrd for BuildMetadata>::partial_cmp(p0, p1);
+crate::impls::<impl std::cmp::PartialOrd for BuildMetadata>::partial_cmp(p0, p1);
+<BuildMetadata>::partial_cmp(p0, p1);
-----------------
src/impls.rs impls::<impl std::cmp::Ord for Prerelease>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
let mut p1 = & MaybeUninit::uninit().assume_init(); // Prerelease
+p0.cmp(p1);
+impls::<impl std::cmp::Ord for Prerelease>::cmp(p0, p1);
+crate::impls::<impl std::cmp::Ord for Prerelease>::cmp(p0, p1);
+<Prerelease>::cmp(p0, p1);
-----------------
src/impls.rs impls::<impl std::cmp::Ord for BuildMetadata>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
let mut p1 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
+p0.cmp(p1);
+impls::<impl std::cmp::Ord for BuildMetadata>::cmp(p0, p1);
+crate::impls::<impl std::cmp::Ord for BuildMetadata>::cmp(p0, p1);
+<BuildMetadata>::cmp(p0, p1);
-----------------
src/impls.rs impls::<impl std::iter::FromIterator<Comparator> for VersionReq>::from_iter
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"impls::<impl std::iter::FromIterator<Comparator> for VersionReq>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::IntersperseWith<I, G>","std::collections::hash_map::IterMut<'a, K, V>","std::collections::btree_map::Iter<'a, K, V>","std::slice::ArrayChunks<'a, T, N>","std::char::CaseMappingIter","std::collections::btree_map::Range<'a, K, V>","std::slice::SplitNMut<'a, T, P>","std::slice::RChunksExact<'a, T>","std::collections::hash_set::Union<'a, T, S>","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::btree_map::Values<'a, K, V>","std::env::Vars","std::ascii::EscapeDefault","std::boxed::Box<I, A>","std::str::RMatchIndices<'a, P>","std::slice::SplitInclusiveMut<'a, T, P>","std::iter::FilterMap<I, F>","std::slice::RSplit<'a, T, P>","std::path::Iter<'a>","std::collections::vec_deque::Drain<'_, T, A>","std::sys::unix::fs::ReadDir","std::str::Chars<'a>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::str::SplitAsciiWhitespace<'a>","std::process::CommandArgs<'a>","std::collections::hash_map::IntoIter<K, V>","std::char::EscapeDebug","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::collections::linked_list::IntoIter<T>","std::iter::MapWhile<I, P>","core::slice::iter::GenericSplitN<I>","std::iter::FlatMap<I, U, F>","std::char::ToUppercase","std::collections::linked_list::IterMut<'a, T>","std::array::IntoIter<T, N>","std::env::SplitPaths<'a>","std::collections::vec_deque::IterMut<'a, T>","std::iter::OnceWith<F>","std::collections::vec_deque::IntoIter<T, A>","std::str::Split<'a, P>","std::slice::ChunksExactMut<'a, T>","std::str::LinesAny<'a>","std::iter::Fuse<I>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::collections::btree_map::IntoIter<K, V, A>","std::slice::GroupByMut<'a, T, P>","std::os::unix::net::Messages<'a>","std::path::Components<'a>","std::string::Drain<'_>","std::slice::RChunksExactMut<'a, T>","std::slice::ArrayWindows<'a, T, N>","std::iter::Once<T>","std::collections::hash_set::Drain<'a, K>","std::str::EncodeUtf16<'a>","std::str::RMatches<'a, P>","std::iter::TakeWhile<I, P>","std::collections::hash_set::Intersection<'a, T, S>","std::sys::unix::args::Args","std::os::unix::net::ScmCredentials<'a>","std::collections::btree_set::Range<'a, T>","std::slice::GroupBy<'a, T, P>","std::str::Bytes<'_>","std::str::SplitInclusive<'a, P>","std::iter::FromFn<F>","std::str::EscapeDebug<'a>","std::net::Incoming<'a>","std::iter::RepeatWith<F>","std::sys::unix::process::process_common::CommandArgs<'a>","std::iter::Chain<A, B>","std::ops::RangeFrom<A>","std::option::IterMut<'a, A>","std::str::EscapeUnicode<'a>","std::iter::Map<I, F>","std::fs::ReadDir","std::str::RSplitTerminator<'a, P>","std::str::MatchIndices<'a, P>","std::collections::btree_set::Difference<'a, T, A>","std::char::DecodeUtf16<I>","std::slice::SplitMut<'a, T, P>","std::collections::vec_deque::Iter<'a, T>","std::iter::Cloned<I>","std::ops::index_range::IndexRange","std::slice::Split<'a, T, P>","std::iter::SkipWhile<I, P>","std::collections::btree_set::Iter<'a, T>","std::collections::binary_heap::IntoIterSorted<T>","std::collections::btree_map::IntoKeys<K, V, A>","std::str::Utf8Chunks<'a>","std::str::CharIndices<'a>","std::option::Iter<'a, A>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::iter::Flatten<I>","std::io::Bytes<R>","std::option::IntoIter<A>","std::collections::binary_heap::DrainSorted<'_, T>","std::str::Matches<'a, P>","std::sys::unix::os::SplitPaths<'a>","std::io::Split<B>","std::slice::Iter<'a, T>","std::iter::Peekable<I>","std::collections::hash_set::DrainFilter<'_, K, F>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::iter::Filter<I, P>","std::iter::ByRefSized<'_, I>","std::iter::Empty<T>","std::str::SplitWhitespace<'a>","std::sys_common::wstr::WStrUnits<'_>","std::slice::RSplitMut<'a, T, P>","std::sync::mpsc::TryIter<'a, T>","std::result::IterMut<'a, T>","std::char::EscapeDefault","std::iter::Skip<I>","std::iter::StepBy<I>","std::collections::hash_map::IntoKeys<K, V>","std::iter::sources::from_generator::FromGenerator<G>","std::slice::EscapeAscii<'a>","std::collections::binary_heap::IntoIter<T>","std::str::SplitN<'a, P>","std::collections::btree_map::IterMut<'a, K, V>","std::sync::mpsc::IntoIter<T>","std::str::RSplitN<'a, P>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::collections::btree_set::Union<'a, T>","std::ops::Range<A>","std::collections::hash_map::Values<'a, K, V>","std::collections::binary_heap::Iter<'a, T>","core::error::Source<'a>","std::iter::Inspect<I, F>","std::sync::mpsc::Iter<'a, T>","std::io::Lines<B>","std::iter::Scan<I, St, F>","std::iter::Zip<A, B>","std::slice::ArrayChunksMut<'a, T, N>","std::sys_common::wtf8::EncodeWide<'a>","std::collections::hash_map::Drain<'a, K, V>","std::slice::RChunks<'a, T>","std::collections::linked_list::Iter<'a, T>","std::result::IntoIter<T>","std::vec::IntoIter<T, A>","std::vec::Splice<'_, I, A>","std::iter::adapters::GenericShunt<'_, I, R>","std::iter::Copied<I>","std::collections::btree_set::Intersection<'a, T, A>","std::option::Item<A>","<&mut I as std::iter::Iterator>","std::iter::Successors<T, F>","std::str::RSplit<'a, P>","std::iter::ArrayChunks<I, N>","std::sys_common::net::LookupHost","std::char::ToLowercase","std::slice::Windows<'a, T>","std::vec::Drain<'_, T, A>","std::slice::Chunks<'a, T>","std::iter::Rev<I>","std::slice::SplitN<'a, T, P>","std::iter::Enumerate<I>","std::env::VarsOs","std::collections::hash_map::Keys<'a, K, V>","std::slice::RSplitN<'a, T, P>","std::str::EscapeDefault<'a>","std::collections::hash_map::Iter<'a, K, V>","std::iter::Intersperse<I>","std::collections::linked_list::DrainFilter<'_, T, F>","std::iter::RepeatN<A>","std::iter::Take<I>","std::os::unix::net::Incoming<'a>","std::ops::RangeInclusive<A>","std::slice::ChunksExact<'a, T>","std::collections::hash_map::IntoValues<K, V>","std::collections::binary_heap::Drain<'_, T>","std::os::unix::net::ScmRights<'a>","std::collections::btree_map::ValuesMut<'a, K, V>","std::sys::unix::os::Env","std::collections::hash_set::Iter<'a, K>","std::collections::hash_set::Difference<'a, T, S>","std::slice::ChunksMut<'a, T>","std::slice::RSplitNMut<'a, T, P>","std::str::Lines<'a>","std::slice::IterMut<'a, T>","std::net::IntoIncoming","std::slice::RChunksMut<'a, T>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::iter::Repeat<A>","std::iter::Cycle<I>","std::env::Args","std::collections::btree_set::SymmetricDifference<'a, T>","std::env::ArgsOs","std::collections::btree_map::Keys<'a, K, V>","std::process::CommandEnvs<'a>","std::collections::btree_set::IntoIter<T, A>","std::collections::hash_set::IntoIter<K>","std::result::Iter<'a, T>","std::collections::btree_map::IntoValues<K, V, A>","std::slice::SplitInclusive<'a, T, P>","std::char::EscapeUnicode","std::collections::btree_map::RangeMut<'a, K, V>","std::str::SplitTerminator<'a, P>","std::vec::DrainFilter<'_, T, F, A>","std::path::Ancestors<'a>"]},"impls::<impl std::iter::FromIterator<Comparator> for VersionReq>::from_iter":{"I":["std::vec::Vec<T, A>","std::option::Option<T>","std::collections::LinkedList<T>","&'a std::os::unix::net::UnixListener","std::sync::mpsc::Receiver<T>","std::collections::BinaryHeap<T>","std::collections::BTreeMap<K, V, A>","std::result::Result<T, E>","std::collections::VecDeque<T, A>","std::collections::HashSet<T, S>","<&'a mut std::option::Option<T> as std::iter::IntoIterator>","<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","&'a std::path::Path","&'a std::path::PathBuf","std::collections::BTreeSet<T, A>","std::collections::HashMap<K, V, S>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+impls::<impl std::iter::FromIterator<Comparator> for VersionReq>::from_iter(p0);
+crate::impls::<impl std::iter::FromIterator<Comparator> for VersionReq>::from_iter(p0);
+<VersionReq>::from_iter(p0);
-----------------
src/parse.rs parse::<impl std::str::FromStr for Version>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::<impl std::str::FromStr for Version>::from_str(&p0);
+crate::parse::<impl std::str::FromStr for Version>::from_str(&p0);
+<Version>::from_str(&p0);
-----------------
src/parse.rs parse::<impl std::str::FromStr for VersionReq>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::<impl std::str::FromStr for VersionReq>::from_str(&p0);
+crate::parse::<impl std::str::FromStr for VersionReq>::from_str(&p0);
+<VersionReq>::from_str(&p0);
-----------------
src/parse.rs parse::<impl std::str::FromStr for Comparator>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::<impl std::str::FromStr for Comparator>::from_str(&p0);
+crate::parse::<impl std::str::FromStr for Comparator>::from_str(&p0);
+<Comparator>::from_str(&p0);
-----------------
src/parse.rs parse::<impl std::str::FromStr for Prerelease>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::<impl std::str::FromStr for Prerelease>::from_str(&p0);
+crate::parse::<impl std::str::FromStr for Prerelease>::from_str(&p0);
+<Prerelease>::from_str(&p0);
-----------------
src/parse.rs parse::<impl std::str::FromStr for BuildMetadata>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parse::<impl std::str::FromStr for BuildMetadata>::from_str(&p0);
+crate::parse::<impl std::str::FromStr for BuildMetadata>::from_str(&p0);
+<BuildMetadata>::from_str(&p0);
-----------------
src/parse.rs parse::Error::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+parse::Error::new(p0);
+crate::parse::Error::new(p0);
+<parse::Error>::new(p0);
-----------------
src/lib.rs <Version as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Version
+p0.clone();
+<Version as std::clone::Clone>::clone(p0);
+crate::<Version as std::clone::Clone>::clone(p0);
+<Version>::clone(p0);
-----------------
src/lib.rs <Version as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Version
+p0.assert_receiver_is_total_eq();
+<Version as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<Version as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<Version>::assert_receiver_is_total_eq(p0);
-----------------
src/lib.rs <Version as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Version
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+p0.eq(p1);
+<Version as std::cmp::PartialEq>::eq(p0, p1);
+crate::<Version as std::cmp::PartialEq>::eq(p0, p1);
+<Version>::eq(p0, p1);
-----------------
src/lib.rs <Version as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Version
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+p0.cmp(p1);
+<Version as std::cmp::Ord>::cmp(p0, p1);
+crate::<Version as std::cmp::Ord>::cmp(p0, p1);
+<Version>::cmp(p0, p1);
-----------------
src/lib.rs <Version as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Version
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+p0.partial_cmp(p1);
+<Version as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<Version as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<Version>::partial_cmp(p0, p1);
-----------------
src/lib.rs <Version as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<Version as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<Version as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Version
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<Version as std::hash::Hash>::hash(p0, p1);
+crate::<Version as std::hash::Hash>::hash(p0, p1);
+<Version>::hash(p0, p1);
-----------------
src/lib.rs <VersionReq as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // VersionReq
+p0.clone();
+<VersionReq as std::clone::Clone>::clone(p0);
+crate::<VersionReq as std::clone::Clone>::clone(p0);
+<VersionReq>::clone(p0);
-----------------
src/lib.rs <VersionReq as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // VersionReq
+p0.assert_receiver_is_total_eq();
+<VersionReq as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<VersionReq as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<VersionReq>::assert_receiver_is_total_eq(p0);
-----------------
src/lib.rs <VersionReq as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // VersionReq
let mut p1 = & MaybeUninit::uninit().assume_init(); // VersionReq
+p0.eq(p1);
+<VersionReq as std::cmp::PartialEq>::eq(p0, p1);
+crate::<VersionReq as std::cmp::PartialEq>::eq(p0, p1);
+<VersionReq>::eq(p0, p1);
-----------------
src/lib.rs <VersionReq as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<VersionReq as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<VersionReq as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // VersionReq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<VersionReq as std::hash::Hash>::hash(p0, p1);
+crate::<VersionReq as std::hash::Hash>::hash(p0, p1);
+<VersionReq>::hash(p0, p1);
-----------------
src/lib.rs <VersionReq as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // VersionReq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<VersionReq as std::fmt::Debug>::fmt(p0, p1);
+crate::<VersionReq as std::fmt::Debug>::fmt(p0, p1);
+<VersionReq>::fmt(p0, p1);
-----------------
src/lib.rs <Comparator as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
+p0.clone();
+<Comparator as std::clone::Clone>::clone(p0);
+crate::<Comparator as std::clone::Clone>::clone(p0);
+<Comparator>::clone(p0);
-----------------
src/lib.rs <Comparator as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
+p0.assert_receiver_is_total_eq();
+<Comparator as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<Comparator as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<Comparator>::assert_receiver_is_total_eq(p0);
-----------------
src/lib.rs <Comparator as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Comparator
+p0.eq(p1);
+<Comparator as std::cmp::PartialEq>::eq(p0, p1);
+crate::<Comparator as std::cmp::PartialEq>::eq(p0, p1);
+<Comparator>::eq(p0, p1);
-----------------
src/lib.rs <Comparator as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<Comparator as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<Comparator as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<Comparator as std::hash::Hash>::hash(p0, p1);
+crate::<Comparator as std::hash::Hash>::hash(p0, p1);
+<Comparator>::hash(p0, p1);
-----------------
src/lib.rs <Comparator as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<Comparator as std::fmt::Debug>::fmt(p0, p1);
+crate::<Comparator as std::fmt::Debug>::fmt(p0, p1);
+<Comparator>::fmt(p0, p1);
-----------------
src/lib.rs <Op as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Op
+p0.clone();
+<Op as std::clone::Clone>::clone(p0);
+crate::<Op as std::clone::Clone>::clone(p0);
+<Op>::clone(p0);
-----------------
src/lib.rs <Op as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Op
+p0.assert_receiver_is_total_eq();
+<Op as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<Op as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<Op>::assert_receiver_is_total_eq(p0);
-----------------
src/lib.rs <Op as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Op
let mut p1 = & MaybeUninit::uninit().assume_init(); // Op
+p0.eq(p1);
+<Op as std::cmp::PartialEq>::eq(p0, p1);
+crate::<Op as std::cmp::PartialEq>::eq(p0, p1);
+<Op>::eq(p0, p1);
-----------------
src/lib.rs <Op as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<Op as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<Op as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Op
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<Op as std::hash::Hash>::hash(p0, p1);
+crate::<Op as std::hash::Hash>::hash(p0, p1);
+<Op>::hash(p0, p1);
-----------------
src/lib.rs <Op as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Op
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<Op as std::fmt::Debug>::fmt(p0, p1);
+crate::<Op as std::fmt::Debug>::fmt(p0, p1);
+<Op>::fmt(p0, p1);
-----------------
src/lib.rs <Prerelease as std::default::Default>::default
deps:{}
candidates:{}
+<Prerelease as std::default::Default>::default();
+crate::<Prerelease as std::default::Default>::default();
+<Prerelease>::default();
-----------------
src/lib.rs <Prerelease as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
+p0.clone();
+<Prerelease as std::clone::Clone>::clone(p0);
+crate::<Prerelease as std::clone::Clone>::clone(p0);
+<Prerelease>::clone(p0);
-----------------
src/lib.rs <Prerelease as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
+p0.assert_receiver_is_total_eq();
+<Prerelease as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<Prerelease as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<Prerelease>::assert_receiver_is_total_eq(p0);
-----------------
src/lib.rs <Prerelease as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
let mut p1 = & MaybeUninit::uninit().assume_init(); // Prerelease
+p0.eq(p1);
+<Prerelease as std::cmp::PartialEq>::eq(p0, p1);
+crate::<Prerelease as std::cmp::PartialEq>::eq(p0, p1);
+<Prerelease>::eq(p0, p1);
-----------------
src/lib.rs <Prerelease as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<Prerelease as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<Prerelease as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<Prerelease as std::hash::Hash>::hash(p0, p1);
+crate::<Prerelease as std::hash::Hash>::hash(p0, p1);
+<Prerelease>::hash(p0, p1);
-----------------
src/lib.rs <BuildMetadata as std::default::Default>::default
deps:{}
candidates:{}
+<BuildMetadata as std::default::Default>::default();
+crate::<BuildMetadata as std::default::Default>::default();
+<BuildMetadata>::default();
-----------------
src/lib.rs <BuildMetadata as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
+p0.clone();
+<BuildMetadata as std::clone::Clone>::clone(p0);
+crate::<BuildMetadata as std::clone::Clone>::clone(p0);
+<BuildMetadata>::clone(p0);
-----------------
src/lib.rs <BuildMetadata as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
+p0.assert_receiver_is_total_eq();
+<BuildMetadata as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<BuildMetadata as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<BuildMetadata>::assert_receiver_is_total_eq(p0);
-----------------
src/lib.rs <BuildMetadata as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
let mut p1 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
+p0.eq(p1);
+<BuildMetadata as std::cmp::PartialEq>::eq(p0, p1);
+crate::<BuildMetadata as std::cmp::PartialEq>::eq(p0, p1);
+<BuildMetadata>::eq(p0, p1);
-----------------
src/lib.rs <BuildMetadata as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<BuildMetadata as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<BuildMetadata as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<BuildMetadata as std::hash::Hash>::hash(p0, p1);
+crate::<BuildMetadata as std::hash::Hash>::hash(p0, p1);
+<BuildMetadata>::hash(p0, p1);
-----------------
src/lib.rs Version::new
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u64; // None+u64
let mut p2 = 0u64; // None+u64
+Version::new(p0, p1, p2);
+crate::Version::new(p0, p1, p2);
+<Version>::new(p0, p1, p2);
-----------------
src/lib.rs Version::parse
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+Version::parse(&p0);
+crate::Version::parse(&p0);
+<Version>::parse(&p0);
-----------------
src/lib.rs VersionReq::parse
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+VersionReq::parse(&p0);
+crate::VersionReq::parse(&p0);
+<VersionReq>::parse(&p0);
-----------------
src/lib.rs VersionReq::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // VersionReq
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+p0.matches(p1);
+VersionReq::matches(p0, p1);
+crate::VersionReq::matches(p0, p1);
+<VersionReq>::matches(p0, p1);
-----------------
src/lib.rs <VersionReq as std::default::Default>::default
deps:{}
candidates:{}
+<VersionReq as std::default::Default>::default();
+crate::<VersionReq as std::default::Default>::default();
+<VersionReq>::default();
-----------------
src/lib.rs Comparator::parse
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+Comparator::parse(&p0);
+crate::Comparator::parse(&p0);
+<Comparator>::parse(&p0);
-----------------
src/lib.rs Comparator::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Comparator
let mut p1 = & MaybeUninit::uninit().assume_init(); // Version
+p0.matches(p1);
+Comparator::matches(p0, p1);
+crate::Comparator::matches(p0, p1);
+<Comparator>::matches(p0, p1);
-----------------
src/lib.rs Prerelease::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+Prerelease::new(&p0);
+crate::Prerelease::new(&p0);
+<Prerelease>::new(&p0);
-----------------
src/lib.rs Prerelease::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
+p0.as_str();
+Prerelease::as_str(p0);
+crate::Prerelease::as_str(p0);
+<Prerelease>::as_str(p0);
-----------------
src/lib.rs Prerelease::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Prerelease
+p0.is_empty();
+Prerelease::is_empty(p0);
+crate::Prerelease::is_empty(p0);
+<Prerelease>::is_empty(p0);
-----------------
src/lib.rs BuildMetadata::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+BuildMetadata::new(&p0);
+crate::BuildMetadata::new(&p0);
+<BuildMetadata>::new(&p0);
-----------------
src/lib.rs BuildMetadata::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
+p0.as_str();
+BuildMetadata::as_str(p0);
+crate::BuildMetadata::as_str(p0);
+<BuildMetadata>::as_str(p0);
-----------------
src/lib.rs BuildMetadata::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // BuildMetadata
+p0.is_empty();
+BuildMetadata::is_empty(p0);
+crate::BuildMetadata::is_empty(p0);
+<BuildMetadata>::is_empty(p0);