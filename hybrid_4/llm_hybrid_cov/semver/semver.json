{"dependencies":{"<BuildMetadata as std::clone::Clone>::clone":["BuildMetadata","identifier::Identifier","std::ptr::NonNull"],"<BuildMetadata as std::cmp::Eq>::assert_receiver_is_total_eq":["BuildMetadata","identifier::Identifier","std::ptr::NonNull"],"<BuildMetadata as std::cmp::PartialEq>::eq":["BuildMetadata","identifier::Identifier","std::ptr::NonNull"],"<BuildMetadata as std::default::Default>::default":["BuildMetadata","identifier::Identifier","std::ptr::NonNull"],"<BuildMetadata as std::hash::Hash>::hash":["BuildMetadata","identifier::Identifier","std::hash::Hasher","std::marker::Sized","std::ptr::NonNull"],"<Comparator as std::clone::Clone>::clone":["Comparator","Op","Prerelease","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<Comparator as std::cmp::Eq>::assert_receiver_is_total_eq":["Comparator","Op","Prerelease","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<Comparator as std::cmp::PartialEq>::eq":["Comparator","Op","Prerelease","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<Comparator as std::fmt::Debug>::fmt":["Comparator","Op","Prerelease","identifier::Identifier","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result"],"<Comparator as std::hash::Hash>::hash":["Comparator","Op","Prerelease","identifier::Identifier","std::hash::Hasher","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<Op as std::clone::Clone>::clone":["Op"],"<Op as std::cmp::Eq>::assert_receiver_is_total_eq":["Op"],"<Op as std::cmp::PartialEq>::eq":["Op"],"<Op as std::fmt::Debug>::fmt":["Op","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<Op as std::hash::Hash>::hash":["Op","std::hash::Hasher","std::marker::Sized"],"<Prerelease as std::clone::Clone>::clone":["Prerelease","identifier::Identifier","std::ptr::NonNull"],"<Prerelease as std::cmp::Eq>::assert_receiver_is_total_eq":["Prerelease","identifier::Identifier","std::ptr::NonNull"],"<Prerelease as std::cmp::PartialEq>::eq":["Prerelease","identifier::Identifier","std::ptr::NonNull"],"<Prerelease as std::default::Default>::default":["Prerelease","identifier::Identifier","std::ptr::NonNull"],"<Prerelease as std::hash::Hash>::hash":["Prerelease","identifier::Identifier","std::hash::Hasher","std::marker::Sized","std::ptr::NonNull"],"<Version as std::clone::Clone>::clone":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::ptr::NonNull"],"<Version as std::cmp::Eq>::assert_receiver_is_total_eq":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::ptr::NonNull"],"<Version as std::cmp::Ord>::cmp":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::cmp::Ordering","std::ptr::NonNull"],"<Version as std::cmp::PartialEq>::eq":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::ptr::NonNull"],"<Version as std::cmp::PartialOrd>::partial_cmp":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<Version as std::hash::Hash>::hash":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::hash::Hasher","std::marker::Sized","std::ptr::NonNull"],"<VersionReq as std::clone::Clone>::clone":["VersionReq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<VersionReq as std::cmp::Eq>::assert_receiver_is_total_eq":["VersionReq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<VersionReq as std::cmp::PartialEq>::eq":["VersionReq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<VersionReq as std::default::Default>::default":["VersionReq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<VersionReq as std::fmt::Debug>::fmt":["VersionReq","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<VersionReq as std::hash::Hash>::hash":["VersionReq","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::vec::Vec"],"<error::Position as std::clone::Clone>::clone":["error::Position"],"<error::Position as std::cmp::Eq>::assert_receiver_is_total_eq":["error::Position"],"<error::Position as std::cmp::PartialEq>::eq":["error::Position"],"<error::Position as std::fmt::Display>::fmt":["error::Position","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::QuotedChar as std::fmt::Display>::fmt":["error::QuotedChar","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<identifier::Identifier as std::clone::Clone>::clone":["identifier::Identifier","std::ptr::NonNull"],"<identifier::Identifier as std::cmp::PartialEq>::eq":["identifier::Identifier","std::ptr::NonNull"],"<identifier::Identifier as std::ops::Drop>::drop":["identifier::Identifier","std::ptr::NonNull"],"BuildMetadata":["BuildMetadata","identifier::Identifier","std::ptr::NonNull"],"BuildMetadata::as_str":["BuildMetadata","identifier::Identifier","std::ptr::NonNull"],"BuildMetadata::is_empty":["BuildMetadata","identifier::Identifier","std::ptr::NonNull"],"BuildMetadata::new":["std::marker::Sized","std::result::Result"],"Comparator":["Comparator","Op","Prerelease","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"Comparator::matches":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"Comparator::parse":["std::marker::Sized","std::result::Result"],"Op":["Op"],"Prerelease":["Prerelease","identifier::Identifier","std::ptr::NonNull"],"Prerelease::as_str":["Prerelease","identifier::Identifier","std::ptr::NonNull"],"Prerelease::is_empty":["Prerelease","identifier::Identifier","std::ptr::NonNull"],"Prerelease::new":["std::marker::Sized","std::result::Result"],"Version":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::ptr::NonNull"],"Version::new":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::ptr::NonNull"],"Version::parse":["std::marker::Sized","std::result::Result"],"VersionReq":["VersionReq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"VersionReq::matches":["BuildMetadata","Prerelease","Version","VersionReq","identifier::Identifier","std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"VersionReq::parse":["std::marker::Sized","std::result::Result"],"display::<impl std::fmt::Debug for BuildMetadata>::fmt":["BuildMetadata","identifier::Identifier","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"display::<impl std::fmt::Debug for Prerelease>::fmt":["Prerelease","identifier::Identifier","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"display::<impl std::fmt::Debug for Version>::fmt":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"display::<impl std::fmt::Display for BuildMetadata>::fmt":["BuildMetadata","identifier::Identifier","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"display::<impl std::fmt::Display for Comparator>::fmt":["Comparator","Op","Prerelease","identifier::Identifier","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result"],"display::<impl std::fmt::Display for Prerelease>::fmt":["Prerelease","identifier::Identifier","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"display::<impl std::fmt::Display for Version>::fmt":["BuildMetadata","Prerelease","Version","identifier::Identifier","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"display::<impl std::fmt::Display for VersionReq>::fmt":["VersionReq","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"display::digits":[],"display::pad":["std::fmt::Formatter","std::marker::Sized","std::ops::FnOnce","std::result::Result"],"error::<impl std::fmt::Debug for parse::Error>::fmt":["error::ErrorKind","error::Position","parse::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"error::<impl std::fmt::Display for parse::Error>::fmt":["error::ErrorKind","error::Position","parse::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"error::ErrorKind":["error::ErrorKind","error::Position"],"error::Position":["error::Position"],"error::QuotedChar":["error::QuotedChar"],"eval::matches_caret":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"eval::matches_comparator":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"eval::matches_exact":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"eval::matches_greater":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"eval::matches_impl":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"eval::matches_less":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"eval::matches_req":["BuildMetadata","Prerelease","Version","VersionReq","identifier::Identifier","std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"eval::matches_tilde":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"eval::pre_is_compatible":["BuildMetadata","Comparator","Op","Prerelease","Version","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"identifier::Identifier":["identifier::Identifier","std::ptr::NonNull"],"identifier::Identifier::as_str":["identifier::Identifier","std::ptr::NonNull"],"identifier::Identifier::empty":["identifier::Identifier","std::ptr::NonNull"],"identifier::Identifier::is_empty":["identifier::Identifier","std::ptr::NonNull"],"identifier::Identifier::is_empty_or_inline":["identifier::Identifier","std::ptr::NonNull"],"identifier::Identifier::is_inline":["identifier::Identifier","std::ptr::NonNull"],"identifier::Identifier::new_unchecked":["identifier::Identifier","std::ptr::NonNull"],"identifier::bytes_for_varint":["std::num::NonZeroUsize"],"identifier::decode_len":["std::num::NonZeroUsize"],"identifier::decode_len::decode_len_cold":["std::num::NonZeroUsize"],"identifier::inline_as_str":["identifier::Identifier","std::ptr::NonNull"],"identifier::inline_len":["identifier::Identifier","std::num::NonZeroUsize","std::ptr::NonNull"],"identifier::ptr_as_str":["std::ptr::NonNull"],"identifier::ptr_to_repr":["std::ptr::NonNull"],"identifier::repr_to_ptr":["std::ptr::NonNull"],"identifier::repr_to_ptr_mut":["std::ptr::NonNull"],"impls::<impl std::cmp::Ord for BuildMetadata>::cmp":["BuildMetadata","identifier::Identifier","std::cmp::Ordering","std::ptr::NonNull"],"impls::<impl std::cmp::Ord for Prerelease>::cmp":["Prerelease","identifier::Identifier","std::cmp::Ordering","std::ptr::NonNull"],"impls::<impl std::cmp::PartialOrd for BuildMetadata>::partial_cmp":["BuildMetadata","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impls::<impl std::cmp::PartialOrd for Prerelease>::partial_cmp":["Prerelease","identifier::Identifier","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impls::<impl std::default::Default for identifier::Identifier>::default":["identifier::Identifier","std::ptr::NonNull"],"impls::<impl std::hash::Hash for identifier::Identifier>::hash":["identifier::Identifier","std::hash::Hasher","std::marker::Sized","std::ptr::NonNull"],"impls::<impl std::iter::FromIterator<Comparator> for VersionReq>::from_iter":["VersionReq","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"impls::<impl std::ops::Deref for BuildMetadata>::deref":["BuildMetadata","identifier::Identifier","std::ptr::NonNull"],"impls::<impl std::ops::Deref for Prerelease>::deref":["Prerelease","identifier::Identifier","std::ptr::NonNull"],"parse::<impl std::str::FromStr for BuildMetadata>::from_str":["std::marker::Sized","std::result::Result"],"parse::<impl std::str::FromStr for Comparator>::from_str":["std::marker::Sized","std::result::Result"],"parse::<impl std::str::FromStr for Prerelease>::from_str":["std::marker::Sized","std::result::Result"],"parse::<impl std::str::FromStr for Version>::from_str":["std::marker::Sized","std::result::Result"],"parse::<impl std::str::FromStr for VersionReq>::from_str":["std::marker::Sized","std::result::Result"],"parse::Error":["error::ErrorKind","error::Position","parse::Error"],"parse::Error::new":["error::ErrorKind","error::Position","parse::Error"],"parse::build_identifier":["std::marker::Sized","std::result::Result"],"parse::comparator":["std::marker::Sized","std::result::Result"],"parse::dot":["error::Position","std::marker::Sized","std::result::Result"],"parse::identifier":["error::Position","std::marker::Sized","std::result::Result"],"parse::numeric_identifier":["error::Position","std::marker::Sized","std::result::Result"],"parse::op":["Op"],"parse::prerelease_identifier":["std::marker::Sized","std::result::Result"],"parse::version_req":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"parse::wildcard":["std::marker::Sized","std::option::Option"]},"glob_path_import":{},"self_to_fn":{"BuildMetadata":["Clone","Default","Eq","Hash","PartialEq","impl BuildMetadata {\n    pub const EMPTY: Self = BuildMetadata {\n        identifier: Identifier::empty(),\n    };\n\n    pub fn new(text: &str) -> Result<Self, Error> {\n        BuildMetadata::from_str(text)\n    }\n\n    pub fn as_str(&self) -> &str {\n        self.identifier.as_str()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.identifier.is_empty()\n    }\n}","impl Debug for BuildMetadata {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        write!(formatter, \"BuildMetadata(\\\"{}\\\")\", self)\n    }\n}","impl Deref for BuildMetadata {\n    type Target = str;\n\n    fn deref(&self) -> &Self::Target {\n        self.identifier.as_str()\n    }\n}","impl Display for BuildMetadata {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(self.as_str())\n    }\n}","impl FromStr for BuildMetadata {\n    type Err = Error;\n\n    fn from_str(text: &str) -> Result<Self, Self::Err> {\n        let (build, rest) = build_identifier(text)?;\n        if !rest.is_empty() {\n            return Err(Error::new(ErrorKind::IllegalCharacter(Position::Build)));\n        }\n        Ok(build)\n    }\n}","impl Ord for BuildMetadata {\n    fn cmp(&self, rhs: &Self) -> Ordering {\n        let lhs = self.as_str().split('.');\n        let mut rhs = rhs.as_str().split('.');\n\n        for lhs in lhs {\n            let rhs = match rhs.next() {\n                None => return Ordering::Greater,\n                Some(rhs) => rhs,\n            };\n\n            let is_ascii_digit = |b: u8| b.is_ascii_digit();\n            let ordering = match (\n                lhs.bytes().all(is_ascii_digit),\n                rhs.bytes().all(is_ascii_digit),\n            ) {\n                (true, true) => {\n                    // 0 < 00 < 1 < 01 < 001 < 2 < 02 < 002 < 10\n                    let lhval = lhs.trim_start_matches('0');\n                    let rhval = rhs.trim_start_matches('0');\n                    Ord::cmp(&lhval.len(), &rhval.len())\n                        .then_with(|| Ord::cmp(lhval, rhval))\n                        .then_with(|| Ord::cmp(&lhs.len(), &rhs.len()))\n                }\n                (true, false) => return Ordering::Less,\n                (false, true) => return Ordering::Greater,\n                (false, false) => Ord::cmp(lhs, rhs),\n            };\n\n            if ordering != Ordering::Equal {\n                return ordering;\n            }\n        }\n\n        if rhs.next().is_none() {\n            Ordering::Equal\n        } else {\n            Ordering::Less\n        }\n    }\n}","impl PartialOrd for BuildMetadata {\n    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n        Some(Ord::cmp(self, rhs))\n    }\n}"],"Comparator":["Clone","Debug","Eq","Hash","PartialEq","impl Comparator {\n    pub fn parse(text: &str) -> Result<Self, Error> {\n        Comparator::from_str(text)\n    }\n\n    pub fn matches(&self, version: &Version) -> bool {\n        eval::matches_comparator(self, version)\n    }\n}","impl Display for Comparator {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        let op = match self.op {\n            Op::Exact => \"=\",\n            Op::Greater => \">\",\n            Op::GreaterEq => \">=\",\n            Op::Less => \"<\",\n            Op::LessEq => \"<=\",\n            Op::Tilde => \"~\",\n            Op::Caret => \"^\",\n            Op::Wildcard => \"\",\n            #[cfg(no_non_exhaustive)]\n            Op::__NonExhaustive => unreachable!(),\n        };\n        formatter.write_str(op)?;\n        write!(formatter, \"{}\", self.major)?;\n        if let Some(minor) = &self.minor {\n            write!(formatter, \".{}\", minor)?;\n            if let Some(patch) = &self.patch {\n                write!(formatter, \".{}\", patch)?;\n                if !self.pre.is_empty() {\n                    write!(formatter, \"-{}\", self.pre)?;\n                }\n            } else if self.op == Op::Wildcard {\n                formatter.write_str(\".*\")?;\n            }\n        } else if self.op == Op::Wildcard {\n            formatter.write_str(\".*\")?;\n        }\n        Ok(())\n    }\n}","impl FromStr for Comparator {\n    type Err = Error;\n\n    fn from_str(text: &str) -> Result<Self, Self::Err> {\n        let text = text.trim_start_matches(' ');\n        let (comparator, pos, rest) = comparator(text)?;\n        if !rest.is_empty() {\n            let unexpected = rest.chars().next().unwrap();\n            return Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)));\n        }\n        Ok(comparator)\n    }\n}"],"Op":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Op {\n    const DEFAULT: Self = Op::Caret;\n}"],"Prerelease":["Clone","Default","Eq","Hash","PartialEq","impl Debug for Prerelease {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        write!(formatter, \"Prerelease(\\\"{}\\\")\", self)\n    }\n}","impl Deref for Prerelease {\n    type Target = str;\n\n    fn deref(&self) -> &Self::Target {\n        self.identifier.as_str()\n    }\n}","impl Display for Prerelease {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(self.as_str())\n    }\n}","impl FromStr for Prerelease {\n    type Err = Error;\n\n    fn from_str(text: &str) -> Result<Self, Self::Err> {\n        let (pre, rest) = prerelease_identifier(text)?;\n        if !rest.is_empty() {\n            return Err(Error::new(ErrorKind::IllegalCharacter(Position::Pre)));\n        }\n        Ok(pre)\n    }\n}","impl Ord for Prerelease {\n    fn cmp(&self, rhs: &Self) -> Ordering {\n        match self.is_empty() {\n            true if rhs.is_empty() => return Ordering::Equal,\n            // A real release compares greater than prerelease.\n            true => return Ordering::Greater,\n            // Prerelease compares less than the real release.\n            false if rhs.is_empty() => return Ordering::Less,\n            false => {}\n        }\n\n        let lhs = self.as_str().split('.');\n        let mut rhs = rhs.as_str().split('.');\n\n        for lhs in lhs {\n            let rhs = match rhs.next() {\n                // Spec: \"A larger set of pre-release fields has a higher\n                // precedence than a smaller set, if all of the preceding\n                // identifiers are equal.\"\n                None => return Ordering::Greater,\n                Some(rhs) => rhs,\n            };\n\n            let string_cmp = || Ord::cmp(lhs, rhs);\n            let is_ascii_digit = |b: u8| b.is_ascii_digit();\n            let ordering = match (\n                lhs.bytes().all(is_ascii_digit),\n                rhs.bytes().all(is_ascii_digit),\n            ) {\n                // Respect numeric ordering, for example 99 < 100. Spec says:\n                // \"Identifiers consisting of only digits are compared\n                // numerically.\"\n                (true, true) => Ord::cmp(&lhs.len(), &rhs.len()).then_with(string_cmp),\n                // Spec: \"Numeric identifiers always have lower precedence than\n                // non-numeric identifiers.\"\n                (true, false) => return Ordering::Less,\n                (false, true) => return Ordering::Greater,\n                // Spec: \"Identifiers with letters or hyphens are compared\n                // lexically in ASCII sort order.\"\n                (false, false) => string_cmp(),\n            };\n\n            if ordering != Ordering::Equal {\n                return ordering;\n            }\n        }\n\n        if rhs.next().is_none() {\n            Ordering::Equal\n        } else {\n            Ordering::Less\n        }\n    }\n}","impl PartialOrd for Prerelease {\n    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n        Some(Ord::cmp(self, rhs))\n    }\n}","impl Prerelease {\n    pub const EMPTY: Self = Prerelease {\n        identifier: Identifier::empty(),\n    };\n\n    pub fn new(text: &str) -> Result<Self, Error> {\n        Prerelease::from_str(text)\n    }\n\n    pub fn as_str(&self) -> &str {\n        self.identifier.as_str()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.identifier.is_empty()\n    }\n}"],"Version":["Clone","Eq","Hash","Ord","PartialEq","PartialOrd","impl Debug for Version {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        let mut debug = formatter.debug_struct(\"Version\");\n        debug\n            .field(\"major\", &self.major)\n            .field(\"minor\", &self.minor)\n            .field(\"patch\", &self.patch);\n        if !self.pre.is_empty() {\n            debug.field(\"pre\", &self.pre);\n        }\n        if !self.build.is_empty() {\n            debug.field(\"build\", &self.build);\n        }\n        debug.finish()\n    }\n}","impl Display for Version {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        let do_display = |formatter: &mut fmt::Formatter| -> fmt::Result {\n            write!(formatter, \"{}.{}.{}\", self.major, self.minor, self.patch)?;\n            if !self.pre.is_empty() {\n                write!(formatter, \"-{}\", self.pre)?;\n            }\n            if !self.build.is_empty() {\n                write!(formatter, \"+{}\", self.build)?;\n            }\n            Ok(())\n        };\n\n        let do_len = || -> usize {\n            digits(self.major)\n                + 1\n                + digits(self.minor)\n                + 1\n                + digits(self.patch)\n                + !self.pre.is_empty() as usize\n                + self.pre.len()\n                + !self.build.is_empty() as usize\n                + self.build.len()\n        };\n\n        pad(formatter, do_display, do_len)\n    }\n}","impl FromStr for Version {\n    type Err = Error;\n\n    fn from_str(text: &str) -> Result<Self, Self::Err> {\n        if text.is_empty() {\n            return Err(Error::new(ErrorKind::Empty));\n        }\n\n        let mut pos = Position::Major;\n        let (major, text) = numeric_identifier(text, pos)?;\n        let text = dot(text, pos)?;\n\n        pos = Position::Minor;\n        let (minor, text) = numeric_identifier(text, pos)?;\n        let text = dot(text, pos)?;\n\n        pos = Position::Patch;\n        let (patch, text) = numeric_identifier(text, pos)?;\n\n        if text.is_empty() {\n            return Ok(Version::new(major, minor, patch));\n        }\n\n        let (pre, text) = if let Some(text) = text.strip_prefix('-') {\n            pos = Position::Pre;\n            let (pre, text) = prerelease_identifier(text)?;\n            if pre.is_empty() {\n                return Err(Error::new(ErrorKind::EmptySegment(pos)));\n            }\n            (pre, text)\n        } else {\n            (Prerelease::EMPTY, text)\n        };\n\n        let (build, text) = if let Some(text) = text.strip_prefix('+') {\n            pos = Position::Build;\n            let (build, text) = build_identifier(text)?;\n            if build.is_empty() {\n                return Err(Error::new(ErrorKind::EmptySegment(pos)));\n            }\n            (build, text)\n        } else {\n            (BuildMetadata::EMPTY, text)\n        };\n\n        if let Some(unexpected) = text.chars().next() {\n            return Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)));\n        }\n\n        Ok(Version {\n            major,\n            minor,\n            patch,\n            pre,\n            build,\n        })\n    }\n}","impl Version {\n    /// Create `Version` with an empty pre-release and build metadata.\n    ///\n    /// Equivalent to:\n    ///\n    /// ```\n    /// # use semver::{BuildMetadata, Prerelease, Version};\n    /// #\n    /// # const fn new(major: u64, minor: u64, patch: u64) -> Version {\n    /// Version {\n    ///     major,\n    ///     minor,\n    ///     patch,\n    ///     pre: Prerelease::EMPTY,\n    ///     build: BuildMetadata::EMPTY,\n    /// }\n    /// # }\n    /// ```\n    pub const fn new(major: u64, minor: u64, patch: u64) -> Self {\n        Version {\n            major,\n            minor,\n            patch,\n            pre: Prerelease::EMPTY,\n            build: BuildMetadata::EMPTY,\n        }\n    }\n\n    /// Create `Version` by parsing from string representation.\n    ///\n    /// # Errors\n    ///\n    /// Possible reasons for the parse to fail include:\n    ///\n    /// - `1.0` &mdash; too few numeric components. A SemVer version must have\n    ///   exactly three. If you are looking at something that has fewer than\n    ///   three numbers in it, it's possible it is a `VersionReq` instead (with\n    ///   an implicit default `^` comparison operator).\n    ///\n    /// - `1.0.01` &mdash; a numeric component has a leading zero.\n    ///\n    /// - `1.0.unknown` &mdash; unexpected character in one of the components.\n    ///\n    /// - `1.0.0-` or `1.0.0+` &mdash; the pre-release or build metadata are\n    ///   indicated present but empty.\n    ///\n    /// - `1.0.0-alpha_123` &mdash; pre-release or build metadata have something\n    ///   outside the allowed characters, which are `0-9`, `A-Z`, `a-z`, `-`,\n    ///   and `.` (dot).\n    ///\n    /// - `23456789999999999999.0.0` &mdash; overflow of a u64.\n    pub fn parse(text: &str) -> Result<Self, Error> {\n        Version::from_str(text)\n    }\n}"],"VersionReq":["Clone","Debug","Eq","Hash","PartialEq","impl Default for VersionReq {\n    fn default() -> Self {\n        VersionReq::STAR\n    }\n}","impl Display for VersionReq {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        if self.comparators.is_empty() {\n            return formatter.write_str(\"*\");\n        }\n        for (i, comparator) in self.comparators.iter().enumerate() {\n            if i > 0 {\n                formatter.write_str(\", \")?;\n            }\n            write!(formatter, \"{}\", comparator)?;\n        }\n        Ok(())\n    }\n}","impl FromIterator<Comparator> for VersionReq {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = Comparator>,\n    {\n        let comparators = Vec::from_iter(iter);\n        VersionReq { comparators }\n    }\n}","impl FromStr for VersionReq {\n    type Err = Error;\n\n    fn from_str(text: &str) -> Result<Self, Self::Err> {\n        let text = text.trim_start_matches(' ');\n        if let Some((ch, text)) = wildcard(text) {\n            let rest = text.trim_start_matches(' ');\n            if rest.is_empty() {\n                #[cfg(not(no_const_vec_new))]\n                return Ok(VersionReq::STAR);\n                #[cfg(no_const_vec_new)] // rustc <1.39\n                return Ok(VersionReq {\n                    comparators: Vec::new(),\n                });\n            } else if rest.starts_with(',') {\n                return Err(Error::new(ErrorKind::WildcardNotTheOnlyComparator(ch)));\n            } else {\n                return Err(Error::new(ErrorKind::UnexpectedAfterWildcard));\n            }\n        }\n\n        let depth = 0;\n        let mut comparators = Vec::new();\n        let len = version_req(text, &mut comparators, depth)?;\n        unsafe { comparators.set_len(len) }\n        Ok(VersionReq { comparators })\n    }\n}","impl VersionReq {\n    /// A `VersionReq` with no constraint on the version numbers it matches.\n    /// Equivalent to `VersionReq::parse(\"*\").unwrap()`.\n    ///\n    /// In terms of comparators this is equivalent to `>=0.0.0`.\n    ///\n    /// Counterintuitively a `*` VersionReq does not match every possible\n    /// version number. In particular, in order for *any* `VersionReq` to match\n    /// a pre-release version, the `VersionReq` must contain at least one\n    /// `Comparator` that has an explicit major, minor, and patch version\n    /// identical to the pre-release being matched, and that has a nonempty\n    /// pre-release component. Since `*` is not written with an explicit major,\n    /// minor, and patch version, and does not contain a nonempty pre-release\n    /// component, it does not match any pre-release versions.\n    #[cfg(not(no_const_vec_new))] // rustc <1.39\n    pub const STAR: Self = VersionReq {\n        comparators: Vec::new(),\n    };\n\n    /// Create `VersionReq` by parsing from string representation.\n    ///\n    /// # Errors\n    ///\n    /// Possible reasons for the parse to fail include:\n    ///\n    /// - `>a.b` &mdash; unexpected characters in the partial version.\n    ///\n    /// - `@1.0.0` &mdash; unrecognized comparison operator.\n    ///\n    /// - `^1.0.0, ` &mdash; unexpected end of input.\n    ///\n    /// - `>=1.0 <2.0` &mdash; missing comma between comparators.\n    ///\n    /// - `*.*` &mdash; unsupported wildcard syntax.\n    pub fn parse(text: &str) -> Result<Self, Error> {\n        VersionReq::from_str(text)\n    }\n\n    /// Evaluate whether the given `Version` satisfies the version requirement\n    /// described by `self`.\n    pub fn matches(&self, version: &Version) -> bool {\n        eval::matches_req(self, version)\n    }\n}"],"error::Position":["Clone","Copy","Eq","PartialEq","impl Display for Position {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(match self {\n            Position::Major => \"major version number\",\n            Position::Minor => \"minor version number\",\n            Position::Patch => \"patch version number\",\n            Position::Pre => \"pre-release identifier\",\n            Position::Build => \"build metadata\",\n        })\n    }\n}"],"error::QuotedChar":["impl Display for QuotedChar {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        // Standard library versions prior to https://github.com/rust-lang/rust/pull/95345\n        // print character 0 as '\\u{0}'. We prefer '\\0' to keep error messages\n        // the same across all supported Rust versions.\n        if self.0 == '\\0' {\n            formatter.write_str(\"'\\\\0'\")\n        } else {\n            write!(formatter, \"{:?}\", self.0)\n        }\n    }\n}"],"identifier::Identifier":["impl Clone for Identifier {\n    fn clone(&self) -> Self {\n        if self.is_empty_or_inline() {\n            Identifier {\n                head: self.head,\n                tail: self.tail,\n            }\n        } else {\n            let ptr = repr_to_ptr(self.head);\n            // SAFETY: ptr is one of our own heap allocations.\n            let len = unsafe { decode_len(ptr) };\n            let size = bytes_for_varint(len) + len.get();\n            let align = 2;\n            // SAFETY: align is not zero, align is a power of two, and rounding\n            // size up to align does not overflow isize::MAX. This is just\n            // duplicating a previous allocation where all of these guarantees\n            // were already made.\n            let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n            // SAFETY: layout's size is nonzero.\n            let clone = unsafe { alloc(layout) };\n            if clone.is_null() {\n                handle_alloc_error(layout);\n            }\n            // SAFETY: new allocation cannot overlap the previous one (this was\n            // not a realloc). The argument ptrs are readable/writeable\n            // respectively for size bytes.\n            unsafe { ptr::copy_nonoverlapping(ptr, clone, size) }\n            Identifier {\n                head: ptr_to_repr(clone),\n                tail: [0; TAIL_BYTES],\n            }\n        }\n    }\n}","impl Default for Identifier {\n    fn default() -> Self {\n        Identifier::empty()\n    }\n}","impl Drop for Identifier {\n    fn drop(&mut self) {\n        if self.is_empty_or_inline() {\n            return;\n        }\n        let ptr = repr_to_ptr_mut(self.head);\n        // SAFETY: ptr is one of our own heap allocations.\n        let len = unsafe { decode_len(ptr) };\n        let size = bytes_for_varint(len) + len.get();\n        let align = 2;\n        // SAFETY: align is not zero, align is a power of two, and rounding\n        // size up to align does not overflow usize::MAX. These guarantees were\n        // made when originally allocating this memory.\n        let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n        // SAFETY: ptr was previously allocated by the same allocator with the\n        // same layout.\n        unsafe { dealloc(ptr, layout) }\n    }\n}","impl Eq for Identifier {}","impl Hash for Identifier {\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        self.as_str().hash(hasher);\n    }\n}","impl Identifier {\n    pub(crate) const fn empty() -> Self {\n        // This is a separate constant because unsafe function calls are not\n        // allowed in a const fn body, only in a const, until later rustc than\n        // what we support.\n        const HEAD: NonNull<u8> = unsafe { NonNull::new_unchecked(!0 as *mut u8) };\n\n        // `mov rax, -1`\n        Identifier {\n            head: HEAD,\n            tail: [!0; TAIL_BYTES],\n        }\n    }\n\n    // SAFETY: string must be ASCII and not contain \\0 bytes.\n    pub(crate) unsafe fn new_unchecked(string: &str) -> Self {\n        let len = string.len();\n        debug_assert!(len <= isize::MAX as usize);\n        match len as u64 {\n            0 => Self::empty(),\n            1..=8 => {\n                let mut bytes = [0u8; mem::size_of::<Identifier>()];\n                // SAFETY: string is big enough to read len bytes, bytes is big\n                // enough to write len bytes, and they do not overlap.\n                unsafe { ptr::copy_nonoverlapping(string.as_ptr(), bytes.as_mut_ptr(), len) };\n                // SAFETY: the head field is nonzero because the input string\n                // was at least 1 byte of ASCII and did not contain \\0.\n                unsafe { mem::transmute::<[u8; mem::size_of::<Identifier>()], Identifier>(bytes) }\n            }\n            9..=0xff_ffff_ffff_ffff => {\n                // SAFETY: len is in a range that does not contain 0.\n                let size = bytes_for_varint(unsafe { NonZeroUsize::new_unchecked(len) }) + len;\n                let align = 2;\n                // On 32-bit and 16-bit architecture, check for size overflowing\n                // isize::MAX. Making an allocation request bigger than this to\n                // the allocator is considered UB. All allocations (including\n                // static ones) are limited to isize::MAX so we're guaranteed\n                // len <= isize::MAX, and we know bytes_for_varint(len) <= 5\n                // because 128**5 > isize::MAX, which means the only problem\n                // that can arise is when isize::MAX - 5 <= len <= isize::MAX.\n                // This is pretty much guaranteed to be malicious input so we\n                // don't need to care about returning a good error message.\n                if mem::size_of::<usize>() < 8 {\n                    let max_alloc = usize::MAX / 2 - align;\n                    assert!(size <= max_alloc);\n                }\n                // SAFETY: align is not zero, align is a power of two, and\n                // rounding size up to align does not overflow isize::MAX.\n                let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n                // SAFETY: layout's size is nonzero.\n                let ptr = unsafe { alloc(layout) };\n                if ptr.is_null() {\n                    handle_alloc_error(layout);\n                }\n                let mut write = ptr;\n                let mut varint_remaining = len;\n                while varint_remaining > 0 {\n                    // SAFETY: size is bytes_for_varint(len) bytes + len bytes.\n                    // This is writing the first bytes_for_varint(len) bytes.\n                    unsafe { ptr::write(write, varint_remaining as u8 | 0x80) };\n                    varint_remaining >>= 7;\n                    // SAFETY: still in bounds of the same allocation.\n                    write = unsafe { write.add(1) };\n                }\n                // SAFETY: size is bytes_for_varint(len) bytes + len bytes. This\n                // is writing to the last len bytes.\n                unsafe { ptr::copy_nonoverlapping(string.as_ptr(), write, len) };\n                Identifier {\n                    head: ptr_to_repr(ptr),\n                    tail: [0; TAIL_BYTES],\n                }\n            }\n            0x100_0000_0000_0000..=0xffff_ffff_ffff_ffff => {\n                unreachable!(\"please refrain from storing >64 petabytes of text in semver version\");\n            }\n            #[cfg(no_exhaustive_int_match)] // rustc <1.33\n            _ => unreachable!(),\n        }\n    }\n\n    pub(crate) fn is_empty(&self) -> bool {\n        // `cmp rdi, -1` -- basically: `repr as i64 == -1`\n        let empty = Self::empty();\n        let is_empty = self.head == empty.head && self.tail == empty.tail;\n        // The empty representation does nothing on Drop. We can't let this one\n        // drop normally because `impl Drop for Identifier` calls is_empty; that\n        // would be an infinite recursion.\n        mem::forget(empty);\n        is_empty\n    }\n\n    fn is_inline(&self) -> bool {\n        // `test rdi, rdi` -- basically: `repr as i64 >= 0`\n        self.head.as_ptr() as usize >> (PTR_BYTES * 8 - 1) == 0\n    }\n\n    fn is_empty_or_inline(&self) -> bool {\n        // `cmp rdi, -2` -- basically: `repr as i64 > -2`\n        self.is_empty() || self.is_inline()\n    }\n\n    pub(crate) fn as_str(&self) -> &str {\n        if self.is_empty() {\n            \"\"\n        } else if self.is_inline() {\n            // SAFETY: repr is in the inline representation.\n            unsafe { inline_as_str(self) }\n        } else {\n            // SAFETY: repr is in the heap allocated representation.\n            unsafe { ptr_as_str(&self.head) }\n        }\n    }\n}","impl PartialEq for Identifier {\n    fn eq(&self, rhs: &Self) -> bool {\n        if self.is_empty_or_inline() {\n            // Fast path (most common)\n            self.head == rhs.head && self.tail == rhs.tail\n        } else if rhs.is_empty_or_inline() {\n            false\n        } else {\n            // SAFETY: both reprs are in the heap allocated representation.\n            unsafe { ptr_as_str(&self.head) == ptr_as_str(&rhs.head) }\n        }\n    }\n}","unsafe impl Send for Identifier {}","unsafe impl Sync for Identifier {}"],"parse::Error":["impl Debug for Error {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"Error(\\\"\")?;\n        Display::fmt(self, formatter)?;\n        formatter.write_str(\"\\\")\")?;\n        Ok(())\n    }\n}","impl Display for Error {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match &self.kind {\n            ErrorKind::Empty => formatter.write_str(\"empty string, expected a semver version\"),\n            ErrorKind::UnexpectedEnd(pos) => {\n                write!(formatter, \"unexpected end of input while parsing {}\", pos)\n            }\n            ErrorKind::UnexpectedChar(pos, ch) => {\n                write!(\n                    formatter,\n                    \"unexpected character {} while parsing {}\",\n                    QuotedChar(*ch),\n                    pos,\n                )\n            }\n            ErrorKind::UnexpectedCharAfter(pos, ch) => {\n                write!(\n                    formatter,\n                    \"unexpected character {} after {}\",\n                    QuotedChar(*ch),\n                    pos,\n                )\n            }\n            ErrorKind::ExpectedCommaFound(pos, ch) => {\n                write!(\n                    formatter,\n                    \"expected comma after {}, found {}\",\n                    pos,\n                    QuotedChar(*ch),\n                )\n            }\n            ErrorKind::LeadingZero(pos) => {\n                write!(formatter, \"invalid leading zero in {}\", pos)\n            }\n            ErrorKind::Overflow(pos) => {\n                write!(formatter, \"value of {} exceeds u64::MAX\", pos)\n            }\n            ErrorKind::EmptySegment(pos) => {\n                write!(formatter, \"empty identifier segment in {}\", pos)\n            }\n            ErrorKind::IllegalCharacter(pos) => {\n                write!(formatter, \"unexpected character in {}\", pos)\n            }\n            ErrorKind::WildcardNotTheOnlyComparator(ch) => {\n                write!(\n                    formatter,\n                    \"wildcard req ({}) must be the only comparator in the version req\",\n                    ch,\n                )\n            }\n            ErrorKind::UnexpectedAfterWildcard => {\n                formatter.write_str(\"unexpected character after wildcard in version req\")\n            }\n            ErrorKind::ExcessiveComparators => {\n                formatter.write_str(\"excessive number of version comparators\")\n            }\n        }\n    }\n}","impl Error {\n    fn new(kind: ErrorKind) -> Self {\n        Error { kind }\n    }\n}","impl std::error::Error for Error {}"]},"single_path_import":{"parse::Error":"Error"},"srcs":{"<VersionReq as std::default::Default>::default":["fn default() -> Self{\n        VersionReq::STAR\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<error::Position as std::fmt::Display>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        formatter.write_str(match self {\n            Position::Major => \"major version number\",\n            Position::Minor => \"minor version number\",\n            Position::Patch => \"patch version number\",\n            Position::Pre => \"pre-release identifier\",\n            Position::Build => \"build metadata\",\n        })\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::QuotedChar as std::fmt::Display>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        // Standard library versions prior to https://github.com/rust-lang/rust/pull/95345\n        // print character 0 as '\\u{0}'. We prefer '\\0' to keep error messages\n        // the same across all supported Rust versions.\n        if self.0 == '\\0' {\n            formatter.write_str(\"'\\\\0'\")\n        } else {\n            write!(formatter, \"{:?}\", self.0)\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<identifier::Identifier as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        if self.is_empty_or_inline() {\n            Identifier {\n                head: self.head,\n                tail: self.tail,\n            }\n        } else {\n            let ptr = repr_to_ptr(self.head);\n            // SAFETY: ptr is one of our own heap allocations.\n            let len = unsafe { decode_len(ptr) };\n            let size = bytes_for_varint(len) + len.get();\n            let align = 2;\n            // SAFETY: align is not zero, align is a power of two, and rounding\n            // size up to align does not overflow isize::MAX. This is just\n            // duplicating a previous allocation where all of these guarantees\n            // were already made.\n            let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n            // SAFETY: layout's size is nonzero.\n            let clone = unsafe { alloc(layout) };\n            if clone.is_null() {\n                handle_alloc_error(layout);\n            }\n            // SAFETY: new allocation cannot overlap the previous one (this was\n            // not a realloc). The argument ptrs are readable/writeable\n            // respectively for size bytes.\n            unsafe { ptr::copy_nonoverlapping(ptr, clone, size) }\n            Identifier {\n                head: ptr_to_repr(clone),\n                tail: [0; TAIL_BYTES],\n            }\n        }\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"<identifier::Identifier as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &Self) -> bool{\n        if self.is_empty_or_inline() {\n            // Fast path (most common)\n            self.head == rhs.head && self.tail == rhs.tail\n        } else if rhs.is_empty_or_inline() {\n            false\n        } else {\n            // SAFETY: both reprs are in the heap allocated representation.\n            unsafe { ptr_as_str(&self.head) == ptr_as_str(&rhs.head) }\n        }\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"<identifier::Identifier as std::ops::Drop>::drop":["fn drop(&mut self){\n        if self.is_empty_or_inline() {\n            return;\n        }\n        let ptr = repr_to_ptr_mut(self.head);\n        // SAFETY: ptr is one of our own heap allocations.\n        let len = unsafe { decode_len(ptr) };\n        let size = bytes_for_varint(len) + len.get();\n        let align = 2;\n        // SAFETY: align is not zero, align is a power of two, and rounding\n        // size up to align does not overflow usize::MAX. These guarantees were\n        // made when originally allocating this memory.\n        let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n        // SAFETY: ptr was previously allocated by the same allocator with the\n        // same layout.\n        unsafe { dealloc(ptr, layout) }\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"BuildMetadata":["/// Optional build metadata identifier. This comes after `+` in a SemVer\n/// version, as in `0.8.1+zstd.1.5.0`.\n///\n/// # Examples\n///\n/// Some real world build metadata idioms drawn from crates.io:\n///\n/// - **[libgit2-sys]** <code>0.12.20+<b>1.1.0</b></code> &mdash; for this\n///   crate, the build metadata indicates the version of the C libgit2 library\n///   that the Rust crate is built against.\n///\n/// - **[mashup]** <code>0.1.13+<b>deprecated</b></code> &mdash; just the word\n///   \"deprecated\" for a crate that has been superseded by another. Eventually\n///   people will take notice of this in Cargo's build output where it lists the\n///   crates being compiled.\n///\n/// - **[google-bigquery2]** <code>2.0.4+<b>20210327</b></code> &mdash; this\n///   library is automatically generated from an official API schema, and the\n///   build metadata indicates the date on which that schema was last captured.\n///\n/// - **[fbthrift-git]** <code>0.0.6+<b>c7fcc0e</b></code> &mdash; this crate is\n///   published from snapshots of a big company monorepo. In monorepo\n///   development, there is no concept of versions, and all downstream code is\n///   just updated atomically in the same commit that breaking changes to a\n///   library are landed. Therefore for crates.io purposes, every published\n///   version must be assumed to be incompatible with the previous. The build\n///   metadata provides the source control hash of the snapshotted code.\n///\n/// [libgit2-sys]: https://crates.io/crates/libgit2-sys\n/// [mashup]: https://crates.io/crates/mashup\n/// [google-bigquery2]: https://crates.io/crates/google-bigquery2\n/// [fbthrift-git]: https://crates.io/crates/fbthrift-git\n///\n/// # Syntax\n///\n/// Build metadata is a series of dot separated identifiers immediately\n/// following the patch or pre-release version. Identifiers must comprise only\n/// ASCII alphanumerics and hyphens: `0-9`, `A-Z`, `a-z`, `-`. Identifiers must\n/// not be empty. Leading zeros *are* allowed, unlike any other place in the\n/// SemVer grammar.\n///\n/// # Total ordering\n///\n/// Build metadata is ignored in evaluating `VersionReq`; it plays no role in\n/// whether a `Version` matches any one of the comparison operators.\n///\n/// However for comparing build metadatas among one another, they do have a\n/// total order which is determined by lexicographic ordering of dot-separated\n/// components. Identifiers consisting of only digits are compared numerically.\n/// Otherwise, identifiers are compared in ASCII sort order. Any numeric\n/// identifier is always less than any non-numeric identifier.\n///\n/// Example:&ensp;`demo`&ensp;&lt;&ensp;`demo.85`&ensp;&lt;&ensp;`demo.90`&ensp;&lt;&ensp;`demo.090`&ensp;&lt;&ensp;`demo.200`&ensp;&lt;&ensp;`demo.1a0`&ensp;&lt;&ensp;`demo.a`&ensp;&lt;&ensp;`memo`\npub struct BuildMetadata {\n    identifier: Identifier,\n}","Real(LocalPath(\"src/lib.rs\"))"],"BuildMetadata::as_str":["pub fn as_str(&self) -> &str{\n        self.identifier.as_str()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"BuildMetadata::is_empty":["pub fn is_empty(&self) -> bool{\n        self.identifier.is_empty()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"BuildMetadata::new":["pub fn new(text: &str) -> Result<Self, Error>{\n        BuildMetadata::from_str(text)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Comparator":["/// A pair of comparison operator and partial version, such as `>=1.2`. Forms\n/// one piece of a VersionReq.\npub struct Comparator {\n    pub op: Op,\n    pub major: u64,\n    pub minor: Option<u64>,\n    /// Patch is only allowed if minor is Some.\n    pub patch: Option<u64>,\n    /// Non-empty pre-release is only allowed if patch is Some.\n    pub pre: Prerelease,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Comparator::matches":["pub fn matches(&self, version: &Version) -> bool{\n        eval::matches_comparator(self, version)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Comparator::parse":["pub fn parse(text: &str) -> Result<Self, Error>{\n        Comparator::from_str(text)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Op":["/// SemVer comparison operator: `=`, `>`, `>=`, `<`, `<=`, `~`, `^`, `*`.\n///\n/// # Op::Exact\n/// - &ensp;**`=I.J.K`**&emsp;&mdash;&emsp;exactly the version I.J.K\n/// - &ensp;**`=I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.J.0, <I.(J+1).0`\n/// - &ensp;**`=I`**&emsp;&mdash;&emsp;equivalent to `>=I.0.0, <(I+1).0.0`\n///\n/// # Op::Greater\n/// - &ensp;**`>I.J.K`**\n/// - &ensp;**`>I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.(J+1).0`\n/// - &ensp;**`>I`**&emsp;&mdash;&emsp;equivalent to `>=(I+1).0.0`\n///\n/// # Op::GreaterEq\n/// - &ensp;**`>=I.J.K`**\n/// - &ensp;**`>=I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.J.0`\n/// - &ensp;**`>=I`**&emsp;&mdash;&emsp;equivalent to `>=I.0.0`\n///\n/// # Op::Less\n/// - &ensp;**`<I.J.K`**\n/// - &ensp;**`<I.J`**&emsp;&mdash;&emsp;equivalent to `<I.J.0`\n/// - &ensp;**`<I`**&emsp;&mdash;&emsp;equivalent to `<I.0.0`\n///\n/// # Op::LessEq\n/// - &ensp;**`<=I.J.K`**\n/// - &ensp;**`<=I.J`**&emsp;&mdash;&emsp;equivalent to `<I.(J+1).0`\n/// - &ensp;**`<=I`**&emsp;&mdash;&emsp;equivalent to `<(I+1).0.0`\n///\n/// # Op::Tilde&emsp;(\"patch\" updates)\n/// *Tilde requirements allow the **patch** part of the semver version (the third number) to increase.*\n/// - &ensp;**`~I.J.K`**&emsp;&mdash;&emsp;equivalent to `>=I.J.K, <I.(J+1).0`\n/// - &ensp;**`~I.J`**&emsp;&mdash;&emsp;equivalent to `=I.J`\n/// - &ensp;**`~I`**&emsp;&mdash;&emsp;equivalent to `=I`\n///\n/// # Op::Caret&emsp;(\"compatible\" updates)\n/// *Caret requirements allow parts that are **right of the first nonzero** part of the semver version to increase.*\n/// - &ensp;**`^I.J.K`**&ensp;(for I\\>0)&emsp;&mdash;&emsp;equivalent to `>=I.J.K, <(I+1).0.0`\n/// - &ensp;**`^0.J.K`**&ensp;(for J\\>0)&emsp;&mdash;&emsp;equivalent to `>=0.J.K, <0.(J+1).0`\n/// - &ensp;**`^0.0.K`**&emsp;&mdash;&emsp;equivalent to `=0.0.K`\n/// - &ensp;**`^I.J`**&ensp;(for I\\>0 or J\\>0)&emsp;&mdash;&emsp;equivalent to `^I.J.0`\n/// - &ensp;**`^0.0`**&emsp;&mdash;&emsp;equivalent to `=0.0`\n/// - &ensp;**`^I`**&emsp;&mdash;&emsp;equivalent to `=I`\n///\n/// # Op::Wildcard\n/// - &ensp;**`I.J.*`**&emsp;&mdash;&emsp;equivalent to `=I.J`\n/// - &ensp;**`I.*`**&ensp;or&ensp;**`I.*.*`**&emsp;&mdash;&emsp;equivalent to `=I`\nnon_exhaustive\npub enum Op {\n    Exact,\n    Greater,\n    GreaterEq,\n    Less,\n    LessEq,\n    Tilde,\n    Caret,\n    Wildcard,\n\n    #[cfg(no_non_exhaustive)] // rustc <1.40\n    #[doc(hidden)]\n    __NonExhaustive,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Prerelease":["/// Optional pre-release identifier on a version string. This comes after `-` in\n/// a SemVer version, like `1.0.0-alpha.1`\n///\n/// # Examples\n///\n/// Some real world pre-release idioms drawn from crates.io:\n///\n/// - **[mio]** <code>0.7.0-<b>alpha.1</b></code> &mdash; the most common style\n///   for numbering pre-releases.\n///\n/// - **[pest]** <code>1.0.0-<b>beta.8</b></code>,&ensp;<code>1.0.0-<b>rc.0</b></code>\n///   &mdash; this crate makes a distinction between betas and release\n///   candidates.\n///\n/// - **[sassers]** <code>0.11.0-<b>shitshow</b></code> &mdash; ???.\n///\n/// - **[atomic-utils]** <code>0.0.0-<b>reserved</b></code> &mdash; a squatted\n///   crate name.\n///\n/// [mio]: https://crates.io/crates/mio\n/// [pest]: https://crates.io/crates/pest\n/// [atomic-utils]: https://crates.io/crates/atomic-utils\n/// [sassers]: https://crates.io/crates/sassers\n///\n/// *Tip:* Be aware that if you are planning to number your own pre-releases,\n/// you should prefer to separate the numeric part from any non-numeric\n/// identifiers by using a dot in between. That is, prefer pre-releases\n/// `alpha.1`, `alpha.2`, etc rather than `alpha1`, `alpha2` etc. The SemVer\n/// spec's rule for pre-release precedence has special treatment of numeric\n/// components in the pre-release string, but only if there are no non-digit\n/// characters in the same dot-separated component. So you'd have `alpha.2` &lt;\n/// `alpha.11` as intended, but `alpha11` &lt; `alpha2`.\n///\n/// # Syntax\n///\n/// Pre-release strings are a series of dot separated identifiers immediately\n/// following the patch version. Identifiers must comprise only ASCII\n/// alphanumerics and hyphens: `0-9`, `A-Z`, `a-z`, `-`. Identifiers must not be\n/// empty. Numeric identifiers must not include leading zeros.\n///\n/// # Total ordering\n///\n/// Pre-releases have a total order defined by the SemVer spec. It uses\n/// lexicographic ordering of dot-separated components. Identifiers consisting\n/// of only digits are compared numerically. Otherwise, identifiers are compared\n/// in ASCII sort order. Any numeric identifier is always less than any\n/// non-numeric identifier.\n///\n/// Example:&ensp;`alpha`&ensp;&lt;&ensp;`alpha.85`&ensp;&lt;&ensp;`alpha.90`&ensp;&lt;&ensp;`alpha.200`&ensp;&lt;&ensp;`alpha.0a`&ensp;&lt;&ensp;`alpha.1a0`&ensp;&lt;&ensp;`alpha.a`&ensp;&lt;&ensp;`beta`\npub struct Prerelease {\n    identifier: Identifier,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Prerelease::as_str":["pub fn as_str(&self) -> &str{\n        self.identifier.as_str()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Prerelease::is_empty":["pub fn is_empty(&self) -> bool{\n        self.identifier.is_empty()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Prerelease::new":["pub fn new(text: &str) -> Result<Self, Error>{\n        Prerelease::from_str(text)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Version":["/// **SemVer version** as defined by <https://semver.org>.\n///\n/// # Syntax\n///\n/// - The major, minor, and patch numbers may be any integer 0 through u64::MAX.\n///   When representing a SemVer version as a string, each number is written as\n///   a base 10 integer. For example, `1.0.119`.\n///\n/// - Leading zeros are forbidden in those positions. For example `1.01.00` is\n///   invalid as a SemVer version.\n///\n/// - The pre-release identifier, if present, must conform to the syntax\n///   documented for [`Prerelease`].\n///\n/// - The build metadata, if present, must conform to the syntax documented for\n///   [`BuildMetadata`].\n///\n/// - Whitespace is not allowed anywhere in the version.\n///\n/// # Total ordering\n///\n/// Given any two SemVer versions, one is less than, greater than, or equal to\n/// the other. Versions may be compared against one another using Rust's usual\n/// comparison operators.\n///\n/// - The major, minor, and patch number are compared numerically from left to\n/// right, lexicographically ordered as a 3-tuple of integers. So for example\n/// version `1.5.0` is less than version `1.19.0`, despite the fact that\n/// \"1.19.0\" &lt; \"1.5.0\" as ASCIIbetically compared strings and 1.19 &lt; 1.5\n/// as real numbers.\n///\n/// - When major, minor, and patch are equal, a pre-release version is\n///   considered less than the ordinary release:&ensp;version `1.0.0-alpha.1` is\n///   less than version `1.0.0`.\n///\n/// - Two pre-releases of the same major, minor, patch are compared by\n///   lexicographic ordering of dot-separated components of the pre-release\n///   string.\n///\n///   - Identifiers consisting of only digits are compared\n///     numerically:&ensp;`1.0.0-pre.8` is less than `1.0.0-pre.12`.\n///\n///   - Identifiers that contain a letter or hyphen are compared in ASCII sort\n///     order:&ensp;`1.0.0-pre12` is less than `1.0.0-pre8`.\n///\n///   - Any numeric identifier is always less than any non-numeric\n///     identifier:&ensp;`1.0.0-pre.1` is less than `1.0.0-pre.x`.\n///\n/// Example:&ensp;`1.0.0-alpha`&ensp;&lt;&ensp;`1.0.0-alpha.1`&ensp;&lt;&ensp;`1.0.0-alpha.beta`&ensp;&lt;&ensp;`1.0.0-beta`&ensp;&lt;&ensp;`1.0.0-beta.2`&ensp;&lt;&ensp;`1.0.0-beta.11`&ensp;&lt;&ensp;`1.0.0-rc.1`&ensp;&lt;&ensp;`1.0.0`\npub struct Version {\n    pub major: u64,\n    pub minor: u64,\n    pub patch: u64,\n    pub pre: Prerelease,\n    pub build: BuildMetadata,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Version::new":["/// Create `Version` with an empty pre-release and build metadata.\n///\n/// Equivalent to:\n///\n/// ```\n/// # use semver::{BuildMetadata, Prerelease, Version};\n/// #\n/// # const fn new(major: u64, minor: u64, patch: u64) -> Version {\n/// Version {\n///     major,\n///     minor,\n///     patch,\n///     pre: Prerelease::EMPTY,\n///     build: BuildMetadata::EMPTY,\n/// }\n/// # }\n/// ```\npub const fn new(major: u64, minor: u64, patch: u64) -> Self{\n        Version {\n            major,\n            minor,\n            patch,\n            pre: Prerelease::EMPTY,\n            build: BuildMetadata::EMPTY,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Version::parse":["/// Create `Version` by parsing from string representation.\n///\n/// # Errors\n///\n/// Possible reasons for the parse to fail include:\n///\n/// - `1.0` &mdash; too few numeric components. A SemVer version must have\n///   exactly three. If you are looking at something that has fewer than\n///   three numbers in it, it's possible it is a `VersionReq` instead (with\n///   an implicit default `^` comparison operator).\n///\n/// - `1.0.01` &mdash; a numeric component has a leading zero.\n///\n/// - `1.0.unknown` &mdash; unexpected character in one of the components.\n///\n/// - `1.0.0-` or `1.0.0+` &mdash; the pre-release or build metadata are\n///   indicated present but empty.\n///\n/// - `1.0.0-alpha_123` &mdash; pre-release or build metadata have something\n///   outside the allowed characters, which are `0-9`, `A-Z`, `a-z`, `-`,\n///   and `.` (dot).\n///\n/// - `23456789999999999999.0.0` &mdash; overflow of a u64.\npub fn parse(text: &str) -> Result<Self, Error>{\n        Version::from_str(text)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"VersionReq":["/// **SemVer version requirement** describing the intersection of some version\n/// comparators, such as `>=1.2.3, <1.8`.\n///\n/// # Syntax\n///\n/// - Either `*` (meaning \"any\"), or one or more comma-separated comparators.\n///\n/// - A [`Comparator`] is an operator ([`Op`]) and a partial version, separated\n///   by optional whitespace. For example `>=1.0.0` or `>=1.0`.\n///\n/// - Build metadata is syntactically permitted on the partial versions, but is\n///   completely ignored, as it's never relevant to whether any comparator\n///   matches a particular version.\n///\n/// - Whitespace is permitted around commas and around operators. Whitespace is\n///   not permitted within a partial version, i.e. anywhere between the major\n///   version number and its minor, patch, pre-release, or build metadata.\npub struct VersionReq {\n    pub comparators: Vec<Comparator>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"VersionReq::matches":["/// Evaluate whether the given `Version` satisfies the version requirement\n/// described by `self`.\npub fn matches(&self, version: &Version) -> bool{\n        eval::matches_req(self, version)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"VersionReq::parse":["/// Create `VersionReq` by parsing from string representation.\n///\n/// # Errors\n///\n/// Possible reasons for the parse to fail include:\n///\n/// - `>a.b` &mdash; unexpected characters in the partial version.\n///\n/// - `@1.0.0` &mdash; unrecognized comparison operator.\n///\n/// - `^1.0.0, ` &mdash; unexpected end of input.\n///\n/// - `>=1.0 <2.0` &mdash; missing comma between comparators.\n///\n/// - `*.*` &mdash; unsupported wildcard syntax.\npub fn parse(text: &str) -> Result<Self, Error>{\n        VersionReq::from_str(text)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"display::<impl std::fmt::Debug for BuildMetadata>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        write!(formatter, \"BuildMetadata(\\\"{}\\\")\", self)\n    }","Real(LocalPath(\"src/display.rs\"))"],"display::<impl std::fmt::Debug for Prerelease>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        write!(formatter, \"Prerelease(\\\"{}\\\")\", self)\n    }","Real(LocalPath(\"src/display.rs\"))"],"display::<impl std::fmt::Debug for Version>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        let mut debug = formatter.debug_struct(\"Version\");\n        debug\n            .field(\"major\", &self.major)\n            .field(\"minor\", &self.minor)\n            .field(\"patch\", &self.patch);\n        if !self.pre.is_empty() {\n            debug.field(\"pre\", &self.pre);\n        }\n        if !self.build.is_empty() {\n            debug.field(\"build\", &self.build);\n        }\n        debug.finish()\n    }","Real(LocalPath(\"src/display.rs\"))"],"display::<impl std::fmt::Display for BuildMetadata>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        formatter.write_str(self.as_str())\n    }","Real(LocalPath(\"src/display.rs\"))"],"display::<impl std::fmt::Display for Comparator>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        let op = match self.op {\n            Op::Exact => \"=\",\n            Op::Greater => \">\",\n            Op::GreaterEq => \">=\",\n            Op::Less => \"<\",\n            Op::LessEq => \"<=\",\n            Op::Tilde => \"~\",\n            Op::Caret => \"^\",\n            Op::Wildcard => \"\",\n            #[cfg(no_non_exhaustive)]\n            Op::__NonExhaustive => unreachable!(),\n        };\n        formatter.write_str(op)?;\n        write!(formatter, \"{}\", self.major)?;\n        if let Some(minor) = &self.minor {\n            write!(formatter, \".{}\", minor)?;\n            if let Some(patch) = &self.patch {\n                write!(formatter, \".{}\", patch)?;\n                if !self.pre.is_empty() {\n                    write!(formatter, \"-{}\", self.pre)?;\n                }\n            } else if self.op == Op::Wildcard {\n                formatter.write_str(\".*\")?;\n            }\n        } else if self.op == Op::Wildcard {\n            formatter.write_str(\".*\")?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/display.rs\"))"],"display::<impl std::fmt::Display for Prerelease>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        formatter.write_str(self.as_str())\n    }","Real(LocalPath(\"src/display.rs\"))"],"display::<impl std::fmt::Display for Version>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        let do_display = |formatter: &mut fmt::Formatter| -> fmt::Result {\n            write!(formatter, \"{}.{}.{}\", self.major, self.minor, self.patch)?;\n            if !self.pre.is_empty() {\n                write!(formatter, \"-{}\", self.pre)?;\n            }\n            if !self.build.is_empty() {\n                write!(formatter, \"+{}\", self.build)?;\n            }\n            Ok(())\n        };\n\n        let do_len = || -> usize {\n            digits(self.major)\n                + 1\n                + digits(self.minor)\n                + 1\n                + digits(self.patch)\n                + !self.pre.is_empty() as usize\n                + self.pre.len()\n                + !self.build.is_empty() as usize\n                + self.build.len()\n        };\n\n        pad(formatter, do_display, do_len)\n    }","Real(LocalPath(\"src/display.rs\"))"],"display::<impl std::fmt::Display for VersionReq>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        if self.comparators.is_empty() {\n            return formatter.write_str(\"*\");\n        }\n        for (i, comparator) in self.comparators.iter().enumerate() {\n            if i > 0 {\n                formatter.write_str(\", \")?;\n            }\n            write!(formatter, \"{}\", comparator)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/display.rs\"))"],"display::digits":["fn digits(val: u64) -> usize{\n    if val < 10 {\n        1\n    } else {\n        1 + digits(val / 10)\n    }\n}","Real(LocalPath(\"src/display.rs\"))"],"display::pad":["fn pad(\n    formatter: &mut fmt::Formatter,\n    do_display: impl FnOnce(&mut fmt::Formatter) -> fmt::Result,\n    do_len: impl FnOnce() -> usize,\n) -> fmt::Result{\n    let min_width = match formatter.width() {\n        Some(min_width) => min_width,\n        None => return do_display(formatter),\n    };\n\n    let len = do_len();\n    if len >= min_width {\n        return do_display(formatter);\n    }\n\n    let default_align = Alignment::Left;\n    let align = formatter.align().unwrap_or(default_align);\n    let padding = min_width - len;\n    let (pre_pad, post_pad) = match align {\n        Alignment::Left => (0, padding),\n        Alignment::Right => (padding, 0),\n        Alignment::Center => (padding / 2, (padding + 1) / 2),\n    };\n\n    let fill = formatter.fill();\n    for _ in 0..pre_pad {\n        formatter.write_char(fill)?;\n    }\n\n    do_display(formatter)?;\n\n    for _ in 0..post_pad {\n        formatter.write_char(fill)?;\n    }\n    Ok(())\n}","Real(LocalPath(\"src/display.rs\"))"],"error::<impl std::fmt::Debug for parse::Error>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        formatter.write_str(\"Error(\\\"\")?;\n        Display::fmt(self, formatter)?;\n        formatter.write_str(\"\\\")\")?;\n        Ok(())\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::<impl std::fmt::Display for parse::Error>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match &self.kind {\n            ErrorKind::Empty => formatter.write_str(\"empty string, expected a semver version\"),\n            ErrorKind::UnexpectedEnd(pos) => {\n                write!(formatter, \"unexpected end of input while parsing {}\", pos)\n            }\n            ErrorKind::UnexpectedChar(pos, ch) => {\n                write!(\n                    formatter,\n                    \"unexpected character {} while parsing {}\",\n                    QuotedChar(*ch),\n                    pos,\n                )\n            }\n            ErrorKind::UnexpectedCharAfter(pos, ch) => {\n                write!(\n                    formatter,\n                    \"unexpected character {} after {}\",\n                    QuotedChar(*ch),\n                    pos,\n                )\n            }\n            ErrorKind::ExpectedCommaFound(pos, ch) => {\n                write!(\n                    formatter,\n                    \"expected comma after {}, found {}\",\n                    pos,\n                    QuotedChar(*ch),\n                )\n            }\n            ErrorKind::LeadingZero(pos) => {\n                write!(formatter, \"invalid leading zero in {}\", pos)\n            }\n            ErrorKind::Overflow(pos) => {\n                write!(formatter, \"value of {} exceeds u64::MAX\", pos)\n            }\n            ErrorKind::EmptySegment(pos) => {\n                write!(formatter, \"empty identifier segment in {}\", pos)\n            }\n            ErrorKind::IllegalCharacter(pos) => {\n                write!(formatter, \"unexpected character in {}\", pos)\n            }\n            ErrorKind::WildcardNotTheOnlyComparator(ch) => {\n                write!(\n                    formatter,\n                    \"wildcard req ({}) must be the only comparator in the version req\",\n                    ch,\n                )\n            }\n            ErrorKind::UnexpectedAfterWildcard => {\n                formatter.write_str(\"unexpected character after wildcard in version req\")\n            }\n            ErrorKind::ExcessiveComparators => {\n                formatter.write_str(\"excessive number of version comparators\")\n            }\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorKind":["pub(crate) enum ErrorKind {\n    Empty,\n    UnexpectedEnd(Position),\n    UnexpectedChar(Position, char),\n    UnexpectedCharAfter(Position, char),\n    ExpectedCommaFound(Position, char),\n    LeadingZero(Position),\n    Overflow(Position),\n    EmptySegment(Position),\n    IllegalCharacter(Position),\n    WildcardNotTheOnlyComparator(char),\n    UnexpectedAfterWildcard,\n    ExcessiveComparators,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Position":["pub(crate) enum Position {\n    Major,\n    Minor,\n    Patch,\n    Pre,\n    Build,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::QuotedChar":["struct QuotedChar(char);","Real(LocalPath(\"src/error.rs\"))"],"eval::matches_caret":["fn matches_caret(cmp: &Comparator, ver: &Version) -> bool{\n    if ver.major != cmp.major {\n        return false;\n    }\n\n    let minor = match cmp.minor {\n        None => return true,\n        Some(minor) => minor,\n    };\n\n    let patch = match cmp.patch {\n        None => {\n            if cmp.major > 0 {\n                return ver.minor >= minor;\n            } else {\n                return ver.minor == minor;\n            }\n        }\n        Some(patch) => patch,\n    };\n\n    if cmp.major > 0 {\n        if ver.minor != minor {\n            return ver.minor > minor;\n        } else if ver.patch != patch {\n            return ver.patch > patch;\n        }\n    } else if minor > 0 {\n        if ver.minor != minor {\n            return false;\n        } else if ver.patch != patch {\n            return ver.patch > patch;\n        }\n    } else if ver.minor != minor || ver.patch != patch {\n        return false;\n    }\n\n    ver.pre >= cmp.pre\n}","Real(LocalPath(\"src/eval.rs\"))"],"eval::matches_comparator":["pub(crate) fn matches_comparator(cmp: &Comparator, ver: &Version) -> bool{\n    matches_impl(cmp, ver) && (ver.pre.is_empty() || pre_is_compatible(cmp, ver))\n}","Real(LocalPath(\"src/eval.rs\"))"],"eval::matches_exact":["fn matches_exact(cmp: &Comparator, ver: &Version) -> bool{\n    if ver.major != cmp.major {\n        return false;\n    }\n\n    if let Some(minor) = cmp.minor {\n        if ver.minor != minor {\n            return false;\n        }\n    }\n\n    if let Some(patch) = cmp.patch {\n        if ver.patch != patch {\n            return false;\n        }\n    }\n\n    ver.pre == cmp.pre\n}","Real(LocalPath(\"src/eval.rs\"))"],"eval::matches_greater":["fn matches_greater(cmp: &Comparator, ver: &Version) -> bool{\n    if ver.major != cmp.major {\n        return ver.major > cmp.major;\n    }\n\n    match cmp.minor {\n        None => return false,\n        Some(minor) => {\n            if ver.minor != minor {\n                return ver.minor > minor;\n            }\n        }\n    }\n\n    match cmp.patch {\n        None => return false,\n        Some(patch) => {\n            if ver.patch != patch {\n                return ver.patch > patch;\n            }\n        }\n    }\n\n    ver.pre > cmp.pre\n}","Real(LocalPath(\"src/eval.rs\"))"],"eval::matches_impl":["fn matches_impl(cmp: &Comparator, ver: &Version) -> bool{\n    match cmp.op {\n        Op::Exact | Op::Wildcard => matches_exact(cmp, ver),\n        Op::Greater => matches_greater(cmp, ver),\n        Op::GreaterEq => matches_exact(cmp, ver) || matches_greater(cmp, ver),\n        Op::Less => matches_less(cmp, ver),\n        Op::LessEq => matches_exact(cmp, ver) || matches_less(cmp, ver),\n        Op::Tilde => matches_tilde(cmp, ver),\n        Op::Caret => matches_caret(cmp, ver),\n        #[cfg(no_non_exhaustive)]\n        Op::__NonExhaustive => unreachable!(),\n    }\n}","Real(LocalPath(\"src/eval.rs\"))"],"eval::matches_less":["fn matches_less(cmp: &Comparator, ver: &Version) -> bool{\n    if ver.major != cmp.major {\n        return ver.major < cmp.major;\n    }\n\n    match cmp.minor {\n        None => return false,\n        Some(minor) => {\n            if ver.minor != minor {\n                return ver.minor < minor;\n            }\n        }\n    }\n\n    match cmp.patch {\n        None => return false,\n        Some(patch) => {\n            if ver.patch != patch {\n                return ver.patch < patch;\n            }\n        }\n    }\n\n    ver.pre < cmp.pre\n}","Real(LocalPath(\"src/eval.rs\"))"],"eval::matches_req":["pub(crate) fn matches_req(req: &VersionReq, ver: &Version) -> bool{\n    for cmp in &req.comparators {\n        if !matches_impl(cmp, ver) {\n            return false;\n        }\n    }\n\n    if ver.pre.is_empty() {\n        return true;\n    }\n\n    // If a version has a prerelease tag (for example, 1.2.3-alpha.3) then it\n    // will only be allowed to satisfy req if at least one comparator with the\n    // same major.minor.patch also has a prerelease tag.\n    for cmp in &req.comparators {\n        if pre_is_compatible(cmp, ver) {\n            return true;\n        }\n    }\n\n    false\n}","Real(LocalPath(\"src/eval.rs\"))"],"eval::matches_tilde":["fn matches_tilde(cmp: &Comparator, ver: &Version) -> bool{\n    if ver.major != cmp.major {\n        return false;\n    }\n\n    if let Some(minor) = cmp.minor {\n        if ver.minor != minor {\n            return false;\n        }\n    }\n\n    if let Some(patch) = cmp.patch {\n        if ver.patch != patch {\n            return ver.patch > patch;\n        }\n    }\n\n    ver.pre >= cmp.pre\n}","Real(LocalPath(\"src/eval.rs\"))"],"eval::pre_is_compatible":["fn pre_is_compatible(cmp: &Comparator, ver: &Version) -> bool{\n    cmp.major == ver.major\n        && cmp.minor == Some(ver.minor)\n        && cmp.patch == Some(ver.patch)\n        && !cmp.pre.is_empty()\n}","Real(LocalPath(\"src/eval.rs\"))"],"identifier::Identifier":["#[repr(C, align(8))]\npub(crate) struct Identifier {\n    head: NonNull<u8>,\n    tail: [u8; TAIL_BYTES],\n}","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::Identifier::as_str":["pub(crate) fn as_str(&self) -> &str{\n        if self.is_empty() {\n            \"\"\n        } else if self.is_inline() {\n            // SAFETY: repr is in the inline representation.\n            unsafe { inline_as_str(self) }\n        } else {\n            // SAFETY: repr is in the heap allocated representation.\n            unsafe { ptr_as_str(&self.head) }\n        }\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::Identifier::empty":["pub(crate) const fn empty() -> Self{\n        // This is a separate constant because unsafe function calls are not\n        // allowed in a const fn body, only in a const, until later rustc than\n        // what we support.\n        const HEAD: NonNull<u8> = unsafe { NonNull::new_unchecked(!0 as *mut u8) };\n\n        // `mov rax, -1`\n        Identifier {\n            head: HEAD,\n            tail: [!0; TAIL_BYTES],\n        }\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::Identifier::is_empty":["pub(crate) fn is_empty(&self) -> bool{\n        // `cmp rdi, -1` -- basically: `repr as i64 == -1`\n        let empty = Self::empty();\n        let is_empty = self.head == empty.head && self.tail == empty.tail;\n        // The empty representation does nothing on Drop. We can't let this one\n        // drop normally because `impl Drop for Identifier` calls is_empty; that\n        // would be an infinite recursion.\n        mem::forget(empty);\n        is_empty\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::Identifier::is_empty_or_inline":["fn is_empty_or_inline(&self) -> bool{\n        // `cmp rdi, -2` -- basically: `repr as i64 > -2`\n        self.is_empty() || self.is_inline()\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::Identifier::is_inline":["fn is_inline(&self) -> bool{\n        // `test rdi, rdi` -- basically: `repr as i64 >= 0`\n        self.head.as_ptr() as usize >> (PTR_BYTES * 8 - 1) == 0\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::Identifier::new_unchecked":["pub(crate) unsafe fn new_unchecked(string: &str) -> Self{\n        let len = string.len();\n        debug_assert!(len <= isize::MAX as usize);\n        match len as u64 {\n            0 => Self::empty(),\n            1..=8 => {\n                let mut bytes = [0u8; mem::size_of::<Identifier>()];\n                // SAFETY: string is big enough to read len bytes, bytes is big\n                // enough to write len bytes, and they do not overlap.\n                unsafe { ptr::copy_nonoverlapping(string.as_ptr(), bytes.as_mut_ptr(), len) };\n                // SAFETY: the head field is nonzero because the input string\n                // was at least 1 byte of ASCII and did not contain \\0.\n                unsafe { mem::transmute::<[u8; mem::size_of::<Identifier>()], Identifier>(bytes) }\n            }\n            9..=0xff_ffff_ffff_ffff => {\n                // SAFETY: len is in a range that does not contain 0.\n                let size = bytes_for_varint(unsafe { NonZeroUsize::new_unchecked(len) }) + len;\n                let align = 2;\n                // On 32-bit and 16-bit architecture, check for size overflowing\n                // isize::MAX. Making an allocation request bigger than this to\n                // the allocator is considered UB. All allocations (including\n                // static ones) are limited to isize::MAX so we're guaranteed\n                // len <= isize::MAX, and we know bytes_for_varint(len) <= 5\n                // because 128**5 > isize::MAX, which means the only problem\n                // that can arise is when isize::MAX - 5 <= len <= isize::MAX.\n                // This is pretty much guaranteed to be malicious input so we\n                // don't need to care about returning a good error message.\n                if mem::size_of::<usize>() < 8 {\n                    let max_alloc = usize::MAX / 2 - align;\n                    assert!(size <= max_alloc);\n                }\n                // SAFETY: align is not zero, align is a power of two, and\n                // rounding size up to align does not overflow isize::MAX.\n                let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n                // SAFETY: layout's size is nonzero.\n                let ptr = unsafe { alloc(layout) };\n                if ptr.is_null() {\n                    handle_alloc_error(layout);\n                }\n                let mut write = ptr;\n                let mut varint_remaining = len;\n                while varint_remaining > 0 {\n                    // SAFETY: size is bytes_for_varint(len) bytes + len bytes.\n                    // This is writing the first bytes_for_varint(len) bytes.\n                    unsafe { ptr::write(write, varint_remaining as u8 | 0x80) };\n                    varint_remaining >>= 7;\n                    // SAFETY: still in bounds of the same allocation.\n                    write = unsafe { write.add(1) };\n                }\n                // SAFETY: size is bytes_for_varint(len) bytes + len bytes. This\n                // is writing to the last len bytes.\n                unsafe { ptr::copy_nonoverlapping(string.as_ptr(), write, len) };\n                Identifier {\n                    head: ptr_to_repr(ptr),\n                    tail: [0; TAIL_BYTES],\n                }\n            }\n            0x100_0000_0000_0000..=0xffff_ffff_ffff_ffff => {\n                unreachable!(\"please refrain from storing >64 petabytes of text in semver version\");\n            }\n            #[cfg(no_exhaustive_int_match)] // rustc <1.33\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::bytes_for_varint":["fn bytes_for_varint(len: NonZeroUsize) -> usize{\n    #[cfg(no_nonzero_bitscan)] // rustc <1.53\n    let len = len.get();\n\n    let usize_bits = mem::size_of::<usize>() * 8;\n    let len_bits = usize_bits - len.leading_zeros() as usize;\n    (len_bits + 6) / 7\n}","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::decode_len":["unsafe fn decode_len(ptr: *const u8) -> NonZeroUsize{\n    // SAFETY: There is at least one byte of varint followed by at least 9 bytes\n    // of string content, which is at least 10 bytes total for the allocation,\n    // so reading the first two is no problem.\n    let [first, second] = unsafe { ptr::read(ptr as *const [u8; 2]) };\n    if second < 0x80 {\n        // SAFETY: the length of this heap allocated string has been encoded as\n        // one base-128 digit, so the length is at least 9 and at most 127. It\n        // cannot be zero.\n        unsafe { NonZeroUsize::new_unchecked((first & 0x7f) as usize) }\n    } else {\n        return unsafe { decode_len_cold(ptr) };\n\n        // Identifiers 128 bytes or longer. This is not exercised by any crate\n        // version currently published to crates.io.\n        #[cold]\n        #[inline(never)]\n        unsafe fn decode_len_cold(mut ptr: *const u8) -> NonZeroUsize {\n            let mut len = 0;\n            let mut shift = 0;\n            loop {\n                // SAFETY: varint continues while there are bytes having the\n                // most significant bit set, i.e. until we start hitting the\n                // ASCII string content with msb unset.\n                let byte = unsafe { *ptr };\n                if byte < 0x80 {\n                    // SAFETY: the string length is known to be 128 bytes or\n                    // longer.\n                    return unsafe { NonZeroUsize::new_unchecked(len) };\n                }\n                // SAFETY: still in bounds of the same allocation.\n                ptr = unsafe { ptr.add(1) };\n                len += ((byte & 0x7f) as usize) << shift;\n                shift += 7;\n            }\n        }\n    }\n}","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::decode_len::decode_len_cold":["#[cold]\n#[inline(never)]\nunsafe fn decode_len_cold(mut ptr: *const u8) -> NonZeroUsize{\n            let mut len = 0;\n            let mut shift = 0;\n            loop {\n                // SAFETY: varint continues while there are bytes having the\n                // most significant bit set, i.e. until we start hitting the\n                // ASCII string content with msb unset.\n                let byte = unsafe { *ptr };\n                if byte < 0x80 {\n                    // SAFETY: the string length is known to be 128 bytes or\n                    // longer.\n                    return unsafe { NonZeroUsize::new_unchecked(len) };\n                }\n                // SAFETY: still in bounds of the same allocation.\n                ptr = unsafe { ptr.add(1) };\n                len += ((byte & 0x7f) as usize) << shift;\n                shift += 7;\n            }\n        }","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::inline_as_str":["unsafe fn inline_as_str(repr: &Identifier) -> &str{\n    let ptr = repr as *const Identifier as *const u8;\n    let len = unsafe { inline_len(repr) }.get();\n    // SAFETY: we are viewing the nonzero ASCII prefix of the inline repr's\n    // contents as a slice of bytes. Input/output lifetimes are correctly\n    // associated.\n    let slice = unsafe { slice::from_raw_parts(ptr, len) };\n    // SAFETY: the string contents are known to be only ASCII bytes, which are\n    // always valid UTF-8.\n    unsafe { str::from_utf8_unchecked(slice) }\n}","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::inline_len":["unsafe fn inline_len(repr: &Identifier) -> NonZeroUsize{\n    // SAFETY: Identifier's layout is align(8) and at least size 8. We're doing\n    // an aligned read of the first 8 bytes from it. The bytes are not all zero\n    // because inline strings are at least 1 byte long and cannot contain \\0.\n    let repr = unsafe { ptr::read(repr as *const Identifier as *const NonZeroU64) };\n\n    // Rustc >=1.53 has intrinsics for counting zeros on a non-zeroable integer.\n    // On many architectures these are more efficient than counting on ordinary\n    // zeroable integers (bsf vs cttz). On rustc <1.53 without those intrinsics,\n    // we count zeros in the u64 rather than the NonZeroU64.\n    #[cfg(no_nonzero_bitscan)]\n    let repr = repr.get();\n\n    #[cfg(target_endian = \"little\")]\n    let zero_bits_on_string_end = repr.leading_zeros();\n    #[cfg(target_endian = \"big\")]\n    let zero_bits_on_string_end = repr.trailing_zeros();\n\n    let nonzero_bytes = 8 - zero_bits_on_string_end as usize / 8;\n\n    // SAFETY: repr is nonzero, so it has at most 63 zero bits on either end,\n    // thus at least one nonzero byte.\n    unsafe { NonZeroUsize::new_unchecked(nonzero_bytes) }\n}","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::ptr_as_str":["unsafe fn ptr_as_str(repr: &NonNull<u8>) -> &str{\n    let ptr = repr_to_ptr(*repr);\n    let len = unsafe { decode_len(ptr) };\n    let header = bytes_for_varint(len);\n    let slice = unsafe { slice::from_raw_parts(ptr.add(header), len.get()) };\n    // SAFETY: all identifier contents are ASCII bytes, which are always valid\n    // UTF-8.\n    unsafe { str::from_utf8_unchecked(slice) }\n}","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::ptr_to_repr":["fn ptr_to_repr(original: *mut u8) -> NonNull<u8>{\n    // `mov eax, 1`\n    // `shld rax, rdi, 63`\n    let modified = (original as usize | 1).rotate_right(1);\n\n    // `original + (modified - original)`, but being mindful of provenance.\n    let diff = modified.wrapping_sub(original as usize);\n    let modified = original.wrapping_add(diff);\n\n    // SAFETY: the most significant bit of repr is known to be set, so the value\n    // is not zero.\n    unsafe { NonNull::new_unchecked(modified) }\n}","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::repr_to_ptr":["fn repr_to_ptr(modified: NonNull<u8>) -> *const u8{\n    // `lea rax, [rdi + rdi]`\n    let modified = modified.as_ptr();\n    let original = (modified as usize) << 1;\n\n    // `modified + (original - modified)`, but being mindful of provenance.\n    let diff = original.wrapping_sub(modified as usize);\n    modified.wrapping_add(diff)\n}","Real(LocalPath(\"src/identifier.rs\"))"],"identifier::repr_to_ptr_mut":["fn repr_to_ptr_mut(repr: NonNull<u8>) -> *mut u8{\n    repr_to_ptr(repr) as *mut u8\n}","Real(LocalPath(\"src/identifier.rs\"))"],"impls::<impl std::cmp::Ord for BuildMetadata>::cmp":["fn cmp(&self, rhs: &Self) -> Ordering{\n        let lhs = self.as_str().split('.');\n        let mut rhs = rhs.as_str().split('.');\n\n        for lhs in lhs {\n            let rhs = match rhs.next() {\n                None => return Ordering::Greater,\n                Some(rhs) => rhs,\n            };\n\n            let is_ascii_digit = |b: u8| b.is_ascii_digit();\n            let ordering = match (\n                lhs.bytes().all(is_ascii_digit),\n                rhs.bytes().all(is_ascii_digit),\n            ) {\n                (true, true) => {\n                    // 0 < 00 < 1 < 01 < 001 < 2 < 02 < 002 < 10\n                    let lhval = lhs.trim_start_matches('0');\n                    let rhval = rhs.trim_start_matches('0');\n                    Ord::cmp(&lhval.len(), &rhval.len())\n                        .then_with(|| Ord::cmp(lhval, rhval))\n                        .then_with(|| Ord::cmp(&lhs.len(), &rhs.len()))\n                }\n                (true, false) => return Ordering::Less,\n                (false, true) => return Ordering::Greater,\n                (false, false) => Ord::cmp(lhs, rhs),\n            };\n\n            if ordering != Ordering::Equal {\n                return ordering;\n            }\n        }\n\n        if rhs.next().is_none() {\n            Ordering::Equal\n        } else {\n            Ordering::Less\n        }\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl std::cmp::Ord for Prerelease>::cmp":["fn cmp(&self, rhs: &Self) -> Ordering{\n        match self.is_empty() {\n            true if rhs.is_empty() => return Ordering::Equal,\n            // A real release compares greater than prerelease.\n            true => return Ordering::Greater,\n            // Prerelease compares less than the real release.\n            false if rhs.is_empty() => return Ordering::Less,\n            false => {}\n        }\n\n        let lhs = self.as_str().split('.');\n        let mut rhs = rhs.as_str().split('.');\n\n        for lhs in lhs {\n            let rhs = match rhs.next() {\n                // Spec: \"A larger set of pre-release fields has a higher\n                // precedence than a smaller set, if all of the preceding\n                // identifiers are equal.\"\n                None => return Ordering::Greater,\n                Some(rhs) => rhs,\n            };\n\n            let string_cmp = || Ord::cmp(lhs, rhs);\n            let is_ascii_digit = |b: u8| b.is_ascii_digit();\n            let ordering = match (\n                lhs.bytes().all(is_ascii_digit),\n                rhs.bytes().all(is_ascii_digit),\n            ) {\n                // Respect numeric ordering, for example 99 < 100. Spec says:\n                // \"Identifiers consisting of only digits are compared\n                // numerically.\"\n                (true, true) => Ord::cmp(&lhs.len(), &rhs.len()).then_with(string_cmp),\n                // Spec: \"Numeric identifiers always have lower precedence than\n                // non-numeric identifiers.\"\n                (true, false) => return Ordering::Less,\n                (false, true) => return Ordering::Greater,\n                // Spec: \"Identifiers with letters or hyphens are compared\n                // lexically in ASCII sort order.\"\n                (false, false) => string_cmp(),\n            };\n\n            if ordering != Ordering::Equal {\n                return ordering;\n            }\n        }\n\n        if rhs.next().is_none() {\n            Ordering::Equal\n        } else {\n            Ordering::Less\n        }\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl std::cmp::PartialOrd for BuildMetadata>::partial_cmp":["fn partial_cmp(&self, rhs: &Self) -> Option<Ordering>{\n        Some(Ord::cmp(self, rhs))\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl std::cmp::PartialOrd for Prerelease>::partial_cmp":["fn partial_cmp(&self, rhs: &Self) -> Option<Ordering>{\n        Some(Ord::cmp(self, rhs))\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl std::default::Default for identifier::Identifier>::default":["fn default() -> Self{\n        Identifier::empty()\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl std::hash::Hash for identifier::Identifier>::hash":["fn hash<H: Hasher>(&self, hasher: &mut H){\n        self.as_str().hash(hasher);\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl std::iter::FromIterator<Comparator> for VersionReq>::from_iter":["fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = Comparator>,{\n        let comparators = Vec::from_iter(iter);\n        VersionReq { comparators }\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl std::ops::Deref for BuildMetadata>::deref":["fn deref(&self) -> &Self::Target{\n        self.identifier.as_str()\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl std::ops::Deref for Prerelease>::deref":["fn deref(&self) -> &Self::Target{\n        self.identifier.as_str()\n    }","Real(LocalPath(\"src/impls.rs\"))"],"parse::<impl std::str::FromStr for BuildMetadata>::from_str":["fn from_str(text: &str) -> Result<Self, Self::Err>{\n        let (build, rest) = build_identifier(text)?;\n        if !rest.is_empty() {\n            return Err(Error::new(ErrorKind::IllegalCharacter(Position::Build)));\n        }\n        Ok(build)\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::<impl std::str::FromStr for Comparator>::from_str":["fn from_str(text: &str) -> Result<Self, Self::Err>{\n        let text = text.trim_start_matches(' ');\n        let (comparator, pos, rest) = comparator(text)?;\n        if !rest.is_empty() {\n            let unexpected = rest.chars().next().unwrap();\n            return Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)));\n        }\n        Ok(comparator)\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::<impl std::str::FromStr for Prerelease>::from_str":["fn from_str(text: &str) -> Result<Self, Self::Err>{\n        let (pre, rest) = prerelease_identifier(text)?;\n        if !rest.is_empty() {\n            return Err(Error::new(ErrorKind::IllegalCharacter(Position::Pre)));\n        }\n        Ok(pre)\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::<impl std::str::FromStr for Version>::from_str":["fn from_str(text: &str) -> Result<Self, Self::Err>{\n        if text.is_empty() {\n            return Err(Error::new(ErrorKind::Empty));\n        }\n\n        let mut pos = Position::Major;\n        let (major, text) = numeric_identifier(text, pos)?;\n        let text = dot(text, pos)?;\n\n        pos = Position::Minor;\n        let (minor, text) = numeric_identifier(text, pos)?;\n        let text = dot(text, pos)?;\n\n        pos = Position::Patch;\n        let (patch, text) = numeric_identifier(text, pos)?;\n\n        if text.is_empty() {\n            return Ok(Version::new(major, minor, patch));\n        }\n\n        let (pre, text) = if let Some(text) = text.strip_prefix('-') {\n            pos = Position::Pre;\n            let (pre, text) = prerelease_identifier(text)?;\n            if pre.is_empty() {\n                return Err(Error::new(ErrorKind::EmptySegment(pos)));\n            }\n            (pre, text)\n        } else {\n            (Prerelease::EMPTY, text)\n        };\n\n        let (build, text) = if let Some(text) = text.strip_prefix('+') {\n            pos = Position::Build;\n            let (build, text) = build_identifier(text)?;\n            if build.is_empty() {\n                return Err(Error::new(ErrorKind::EmptySegment(pos)));\n            }\n            (build, text)\n        } else {\n            (BuildMetadata::EMPTY, text)\n        };\n\n        if let Some(unexpected) = text.chars().next() {\n            return Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)));\n        }\n\n        Ok(Version {\n            major,\n            minor,\n            patch,\n            pre,\n            build,\n        })\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::<impl std::str::FromStr for VersionReq>::from_str":["fn from_str(text: &str) -> Result<Self, Self::Err>{\n        let text = text.trim_start_matches(' ');\n        if let Some((ch, text)) = wildcard(text) {\n            let rest = text.trim_start_matches(' ');\n            if rest.is_empty() {\n                #[cfg(not(no_const_vec_new))]\n                return Ok(VersionReq::STAR);\n                #[cfg(no_const_vec_new)] // rustc <1.39\n                return Ok(VersionReq {\n                    comparators: Vec::new(),\n                });\n            } else if rest.starts_with(',') {\n                return Err(Error::new(ErrorKind::WildcardNotTheOnlyComparator(ch)));\n            } else {\n                return Err(Error::new(ErrorKind::UnexpectedAfterWildcard));\n            }\n        }\n\n        let depth = 0;\n        let mut comparators = Vec::new();\n        let len = version_req(text, &mut comparators, depth)?;\n        unsafe { comparators.set_len(len) }\n        Ok(VersionReq { comparators })\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::Error":["/// Error parsing a SemVer version or version requirement.\n///\n/// # Example\n///\n/// ```\n/// use semver::Version;\n///\n/// fn main() {\n///     let err = Version::parse(\"1.q.r\").unwrap_err();\n///\n///     // \"unexpected character 'q' while parsing minor version number\"\n///     eprintln!(\"{}\", err);\n/// }\n/// ```\npub struct Error {\n    pub(crate) kind: ErrorKind,\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::Error::new":["fn new(kind: ErrorKind) -> Self{\n        Error { kind }\n    }","Real(LocalPath(\"src/parse.rs\"))"],"parse::build_identifier":["fn build_identifier(input: &str) -> Result<(BuildMetadata, &str), Error>{\n    let (string, rest) = identifier(input, Position::Build)?;\n    let identifier = unsafe { Identifier::new_unchecked(string) };\n    Ok((BuildMetadata { identifier }, rest))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::comparator":["fn comparator(input: &str) -> Result<(Comparator, Position, &str), Error>{\n    let (mut op, text) = op(input);\n    let default_op = input.len() == text.len();\n    let text = text.trim_start_matches(' ');\n\n    let mut pos = Position::Major;\n    let (major, text) = numeric_identifier(text, pos)?;\n    let mut has_wildcard = false;\n\n    let (minor, text) = if let Some(text) = text.strip_prefix('.') {\n        pos = Position::Minor;\n        if let Some((_, text)) = wildcard(text) {\n            has_wildcard = true;\n            if default_op {\n                op = Op::Wildcard;\n            }\n            (None, text)\n        } else {\n            let (minor, text) = numeric_identifier(text, pos)?;\n            (Some(minor), text)\n        }\n    } else {\n        (None, text)\n    };\n\n    let (patch, text) = if let Some(text) = text.strip_prefix('.') {\n        pos = Position::Patch;\n        if let Some((_, text)) = wildcard(text) {\n            if default_op {\n                op = Op::Wildcard;\n            }\n            (None, text)\n        } else if has_wildcard {\n            return Err(Error::new(ErrorKind::UnexpectedAfterWildcard));\n        } else {\n            let (patch, text) = numeric_identifier(text, pos)?;\n            (Some(patch), text)\n        }\n    } else {\n        (None, text)\n    };\n\n    let (pre, text) = if patch.is_some() && text.starts_with('-') {\n        pos = Position::Pre;\n        let text = &text[1..];\n        let (pre, text) = prerelease_identifier(text)?;\n        if pre.is_empty() {\n            return Err(Error::new(ErrorKind::EmptySegment(pos)));\n        }\n        (pre, text)\n    } else {\n        (Prerelease::EMPTY, text)\n    };\n\n    let text = if patch.is_some() && text.starts_with('+') {\n        pos = Position::Build;\n        let text = &text[1..];\n        let (build, text) = build_identifier(text)?;\n        if build.is_empty() {\n            return Err(Error::new(ErrorKind::EmptySegment(pos)));\n        }\n        text\n    } else {\n        text\n    };\n\n    let text = text.trim_start_matches(' ');\n\n    let comparator = Comparator {\n        op,\n        major,\n        minor,\n        patch,\n        pre,\n    };\n\n    Ok((comparator, pos, text))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::dot":["fn dot(input: &str, pos: Position) -> Result<&str, Error>{\n    if let Some(rest) = input.strip_prefix('.') {\n        Ok(rest)\n    } else if let Some(unexpected) = input.chars().next() {\n        Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)))\n    } else {\n        Err(Error::new(ErrorKind::UnexpectedEnd(pos)))\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::identifier":["fn identifier(input: &str, pos: Position) -> Result<(&str, &str), Error>{\n    let mut accumulated_len = 0;\n    let mut segment_len = 0;\n    let mut segment_has_nondigit = false;\n\n    loop {\n        match input.as_bytes().get(accumulated_len + segment_len) {\n            Some(b'A'..=b'Z') | Some(b'a'..=b'z') | Some(b'-') => {\n                segment_len += 1;\n                segment_has_nondigit = true;\n            }\n            Some(b'0'..=b'9') => {\n                segment_len += 1;\n            }\n            boundary => {\n                if segment_len == 0 {\n                    if accumulated_len == 0 && boundary != Some(&b'.') {\n                        return Ok((\"\", input));\n                    } else {\n                        return Err(Error::new(ErrorKind::EmptySegment(pos)));\n                    }\n                }\n                if pos == Position::Pre\n                    && segment_len > 1\n                    && !segment_has_nondigit\n                    && input[accumulated_len..].starts_with('0')\n                {\n                    return Err(Error::new(ErrorKind::LeadingZero(pos)));\n                }\n                accumulated_len += segment_len;\n                if boundary == Some(&b'.') {\n                    accumulated_len += 1;\n                    segment_len = 0;\n                    segment_has_nondigit = false;\n                } else {\n                    return Ok(input.split_at(accumulated_len));\n                }\n            }\n        }\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::numeric_identifier":["fn numeric_identifier(input: &str, pos: Position) -> Result<(u64, &str), Error>{\n    let mut len = 0;\n    let mut value = 0u64;\n\n    while let Some(&digit) = input.as_bytes().get(len) {\n        if digit < b'0' || digit > b'9' {\n            break;\n        }\n        if value == 0 && len > 0 {\n            return Err(Error::new(ErrorKind::LeadingZero(pos)));\n        }\n        match value\n            .checked_mul(10)\n            .and_then(|value| value.checked_add((digit - b'0') as u64))\n        {\n            Some(sum) => value = sum,\n            None => return Err(Error::new(ErrorKind::Overflow(pos))),\n        }\n        len += 1;\n    }\n\n    if len > 0 {\n        Ok((value, &input[len..]))\n    } else if let Some(unexpected) = input[len..].chars().next() {\n        Err(Error::new(ErrorKind::UnexpectedChar(pos, unexpected)))\n    } else {\n        Err(Error::new(ErrorKind::UnexpectedEnd(pos)))\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::op":["fn op(input: &str) -> (Op, &str){\n    let bytes = input.as_bytes();\n    if bytes.first() == Some(&b'=') {\n        (Op::Exact, &input[1..])\n    } else if bytes.first() == Some(&b'>') {\n        if bytes.get(1) == Some(&b'=') {\n            (Op::GreaterEq, &input[2..])\n        } else {\n            (Op::Greater, &input[1..])\n        }\n    } else if bytes.first() == Some(&b'<') {\n        if bytes.get(1) == Some(&b'=') {\n            (Op::LessEq, &input[2..])\n        } else {\n            (Op::Less, &input[1..])\n        }\n    } else if bytes.first() == Some(&b'~') {\n        (Op::Tilde, &input[1..])\n    } else if bytes.first() == Some(&b'^') {\n        (Op::Caret, &input[1..])\n    } else {\n        (Op::DEFAULT, input)\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::prerelease_identifier":["fn prerelease_identifier(input: &str) -> Result<(Prerelease, &str), Error>{\n    let (string, rest) = identifier(input, Position::Pre)?;\n    let identifier = unsafe { Identifier::new_unchecked(string) };\n    Ok((Prerelease { identifier }, rest))\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::version_req":["fn version_req(input: &str, out: &mut Vec<Comparator>, depth: usize) -> Result<usize, Error>{\n    let (comparator, pos, text) = match comparator(input) {\n        Ok(success) => success,\n        Err(mut error) => {\n            if let Some((ch, mut rest)) = wildcard(input) {\n                rest = rest.trim_start_matches(' ');\n                if rest.is_empty() || rest.starts_with(',') {\n                    error.kind = ErrorKind::WildcardNotTheOnlyComparator(ch);\n                }\n            }\n            return Err(error);\n        }\n    };\n\n    if text.is_empty() {\n        out.reserve_exact(depth + 1);\n        unsafe { out.as_mut_ptr().add(depth).write(comparator) }\n        return Ok(depth + 1);\n    }\n\n    let text = if let Some(text) = text.strip_prefix(',') {\n        text.trim_start_matches(' ')\n    } else {\n        let unexpected = text.chars().next().unwrap();\n        return Err(Error::new(ErrorKind::ExpectedCommaFound(pos, unexpected)));\n    };\n\n    const MAX_COMPARATORS: usize = 32;\n    if depth + 1 == MAX_COMPARATORS {\n        return Err(Error::new(ErrorKind::ExcessiveComparators));\n    }\n\n    // Recurse to collect parsed Comparator objects on the stack. We perform a\n    // single allocation to allocate exactly the right sized Vec only once the\n    // total number of comparators is known.\n    let len = version_req(text, out, depth + 1)?;\n    unsafe { out.as_mut_ptr().add(depth).write(comparator) }\n    Ok(len)\n}","Real(LocalPath(\"src/parse.rs\"))"],"parse::wildcard":["fn wildcard(input: &str) -> Option<(char, &str)>{\n    if let Some(rest) = input.strip_prefix('*') {\n        Some(('*', rest))\n    } else if let Some(rest) = input.strip_prefix('x') {\n        Some(('x', rest))\n    } else if let Some(rest) = input.strip_prefix('X') {\n        Some(('X', rest))\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/parse.rs\"))"]},"struct_constructor":{"&<BuildMetadata as std::ops::Deref>::Target":["deref"],"&<Prerelease as std::ops::Deref>::Target":["deref"],"&str":["as_str","inline_as_str","ptr_as_str"],"(&str, &str)":["identifier"],"(BuildMetadata, &str)":["build_identifier"],"(Comparator, error::Position, &str)":["comparator"],"(Op, &str)":["op"],"(Prerelease, &str)":["prerelease_identifier"],"(char, &str)":["wildcard"],"(u64, &str)":["numeric_identifier"],"*const u8":["repr_to_ptr"],"*mut u8":["repr_to_ptr_mut"],"BuildMetadata":["clone","default","from_str","new"],"Comparator":["clone","from_str","parse"],"Op":["clone"],"Prerelease":["clone","default","from_str","new"],"Version":["clone","from_str","new","parse"],"VersionReq":["clone","default","from_iter","from_str","parse"],"bool":["eq","is_empty","is_empty_or_inline","is_inline","matches","matches_caret","matches_comparator","matches_exact","matches_greater","matches_impl","matches_less","matches_req","matches_tilde","pre_is_compatible"],"error::Position":["clone"],"identifier::Identifier":["clone","default","empty","new_unchecked"],"parse::Error":["new"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::num::NonZeroUsize":["decode_len","decode_len_cold","inline_len"],"std::ptr::NonNull":["ptr_to_repr"],"usize":["bytes_for_varint","digits"]},"struct_to_trait":{"BuildMetadata":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"],"Comparator":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"Op":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"Prerelease":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"],"Version":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"VersionReq":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::iter::FromIterator","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"error::Position":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::QuotedChar":["std::fmt::Display"],"identifier::Identifier":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::hash::Hash","std::marker::Send","std::marker::Sync","std::ops::Drop"],"parse::Error":["std::error::Error","std::fmt::Debug","std::fmt::Display"]},"targets":{"<VersionReq as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<error::Position as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::QuotedChar as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<identifier::Identifier as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/identifier.rs\"))","std::clone::Clone"],"<identifier::Identifier as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/identifier.rs\"))","std::cmp::PartialEq"],"<identifier::Identifier as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/identifier.rs\"))","std::ops::Drop"],"BuildMetadata::as_str":["as_str","Real(LocalPath(\"src/lib.rs\"))",""],"BuildMetadata::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"BuildMetadata::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Comparator::matches":["matches","Real(LocalPath(\"src/lib.rs\"))",""],"Comparator::parse":["parse","Real(LocalPath(\"src/lib.rs\"))",""],"Prerelease::as_str":["as_str","Real(LocalPath(\"src/lib.rs\"))",""],"Prerelease::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"Prerelease::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Version::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Version::parse":["parse","Real(LocalPath(\"src/lib.rs\"))",""],"VersionReq::matches":["matches","Real(LocalPath(\"src/lib.rs\"))",""],"VersionReq::parse":["parse","Real(LocalPath(\"src/lib.rs\"))",""],"display::<impl std::fmt::Debug for BuildMetadata>::fmt":["fmt","Real(LocalPath(\"src/display.rs\"))","std::fmt::Debug"],"display::<impl std::fmt::Debug for Prerelease>::fmt":["fmt","Real(LocalPath(\"src/display.rs\"))","std::fmt::Debug"],"display::<impl std::fmt::Debug for Version>::fmt":["fmt","Real(LocalPath(\"src/display.rs\"))","std::fmt::Debug"],"display::<impl std::fmt::Display for BuildMetadata>::fmt":["fmt","Real(LocalPath(\"src/display.rs\"))","std::fmt::Display"],"display::<impl std::fmt::Display for Comparator>::fmt":["fmt","Real(LocalPath(\"src/display.rs\"))","std::fmt::Display"],"display::<impl std::fmt::Display for Prerelease>::fmt":["fmt","Real(LocalPath(\"src/display.rs\"))","std::fmt::Display"],"display::<impl std::fmt::Display for Version>::fmt":["fmt","Real(LocalPath(\"src/display.rs\"))","std::fmt::Display"],"display::<impl std::fmt::Display for VersionReq>::fmt":["fmt","Real(LocalPath(\"src/display.rs\"))","std::fmt::Display"],"display::digits":["digits","Real(LocalPath(\"src/display.rs\"))",""],"display::pad":["pad","Real(LocalPath(\"src/display.rs\"))",""],"error::<impl std::fmt::Debug for parse::Error>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Debug"],"error::<impl std::fmt::Display for parse::Error>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"eval::matches_caret":["matches_caret","Real(LocalPath(\"src/eval.rs\"))",""],"eval::matches_comparator":["matches_comparator","Real(LocalPath(\"src/eval.rs\"))",""],"eval::matches_exact":["matches_exact","Real(LocalPath(\"src/eval.rs\"))",""],"eval::matches_greater":["matches_greater","Real(LocalPath(\"src/eval.rs\"))",""],"eval::matches_impl":["matches_impl","Real(LocalPath(\"src/eval.rs\"))",""],"eval::matches_less":["matches_less","Real(LocalPath(\"src/eval.rs\"))",""],"eval::matches_req":["matches_req","Real(LocalPath(\"src/eval.rs\"))",""],"eval::matches_tilde":["matches_tilde","Real(LocalPath(\"src/eval.rs\"))",""],"eval::pre_is_compatible":["pre_is_compatible","Real(LocalPath(\"src/eval.rs\"))",""],"identifier::Identifier::as_str":["as_str","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::Identifier::empty":["empty","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::Identifier::is_empty":["is_empty","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::Identifier::is_empty_or_inline":["is_empty_or_inline","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::Identifier::is_inline":["is_inline","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::Identifier::new_unchecked":["new_unchecked","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::bytes_for_varint":["bytes_for_varint","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::decode_len":["decode_len","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::decode_len::decode_len_cold":["decode_len_cold","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::inline_as_str":["inline_as_str","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::inline_len":["inline_len","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::ptr_as_str":["ptr_as_str","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::ptr_to_repr":["ptr_to_repr","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::repr_to_ptr":["repr_to_ptr","Real(LocalPath(\"src/identifier.rs\"))",""],"identifier::repr_to_ptr_mut":["repr_to_ptr_mut","Real(LocalPath(\"src/identifier.rs\"))",""],"impls::<impl std::cmp::Ord for BuildMetadata>::cmp":["cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::Ord"],"impls::<impl std::cmp::Ord for Prerelease>::cmp":["cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::Ord"],"impls::<impl std::cmp::PartialOrd for BuildMetadata>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::<impl std::cmp::PartialOrd for Prerelease>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::<impl std::default::Default for identifier::Identifier>::default":["default","Real(LocalPath(\"src/impls.rs\"))","std::default::Default"],"impls::<impl std::hash::Hash for identifier::Identifier>::hash":["hash","Real(LocalPath(\"src/impls.rs\"))","std::hash::Hash"],"impls::<impl std::iter::FromIterator<Comparator> for VersionReq>::from_iter":["from_iter","Real(LocalPath(\"src/impls.rs\"))","std::iter::FromIterator"],"impls::<impl std::ops::Deref for BuildMetadata>::deref":["deref","Real(LocalPath(\"src/impls.rs\"))","std::ops::Deref"],"impls::<impl std::ops::Deref for Prerelease>::deref":["deref","Real(LocalPath(\"src/impls.rs\"))","std::ops::Deref"],"parse::<impl std::str::FromStr for BuildMetadata>::from_str":["from_str","Real(LocalPath(\"src/parse.rs\"))","std::str::FromStr"],"parse::<impl std::str::FromStr for Comparator>::from_str":["from_str","Real(LocalPath(\"src/parse.rs\"))","std::str::FromStr"],"parse::<impl std::str::FromStr for Prerelease>::from_str":["from_str","Real(LocalPath(\"src/parse.rs\"))","std::str::FromStr"],"parse::<impl std::str::FromStr for Version>::from_str":["from_str","Real(LocalPath(\"src/parse.rs\"))","std::str::FromStr"],"parse::<impl std::str::FromStr for VersionReq>::from_str":["from_str","Real(LocalPath(\"src/parse.rs\"))","std::str::FromStr"],"parse::Error::new":["new","Real(LocalPath(\"src/parse.rs\"))",""],"parse::build_identifier":["build_identifier","Real(LocalPath(\"src/parse.rs\"))",""],"parse::comparator":["comparator","Real(LocalPath(\"src/parse.rs\"))",""],"parse::dot":["dot","Real(LocalPath(\"src/parse.rs\"))",""],"parse::identifier":["identifier","Real(LocalPath(\"src/parse.rs\"))",""],"parse::numeric_identifier":["numeric_identifier","Real(LocalPath(\"src/parse.rs\"))",""],"parse::op":["op","Real(LocalPath(\"src/parse.rs\"))",""],"parse::prerelease_identifier":["prerelease_identifier","Real(LocalPath(\"src/parse.rs\"))",""],"parse::version_req":["version_req","Real(LocalPath(\"src/parse.rs\"))",""],"parse::wildcard":["wildcard","Real(LocalPath(\"src/parse.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["BuildMetadata","Comparator","Op","Prerelease","Version","VersionReq","error::Position","identifier::Identifier"],"std::cmp::Eq":["BuildMetadata","Comparator","Op","Prerelease","Version","VersionReq","error::Position","identifier::Identifier"],"std::cmp::Ord":["BuildMetadata","Prerelease","Version"],"std::cmp::PartialEq":["BuildMetadata","Comparator","Op","Prerelease","Version","VersionReq","error::Position","identifier::Identifier"],"std::cmp::PartialOrd":["BuildMetadata","Prerelease","Version"],"std::default::Default":["BuildMetadata","Prerelease","VersionReq","identifier::Identifier"],"std::error::Error":["parse::Error"],"std::fmt::Debug":["BuildMetadata","Comparator","Op","Prerelease","Version","VersionReq","parse::Error"],"std::fmt::Display":["BuildMetadata","Comparator","Prerelease","Version","VersionReq","error::Position","error::QuotedChar","parse::Error"],"std::hash::Hash":["BuildMetadata","Comparator","Op","Prerelease","Version","VersionReq","identifier::Identifier"],"std::iter::FromIterator":["VersionReq"],"std::marker::Copy":["Op","error::Position"],"std::marker::Send":["identifier::Identifier"],"std::marker::StructuralEq":["BuildMetadata","Comparator","Op","Prerelease","Version","VersionReq","error::Position"],"std::marker::StructuralPartialEq":["BuildMetadata","Comparator","Op","Prerelease","Version","VersionReq","error::Position"],"std::marker::Sync":["identifier::Identifier"],"std::ops::Deref":["BuildMetadata","Prerelease"],"std::ops::Drop":["identifier::Identifier"],"std::str::FromStr":["BuildMetadata","Comparator","Prerelease","Version","VersionReq"]},"type_to_def_path":{"BuildMetadata":"BuildMetadata","Comparator":"Comparator","Op":"Op","Prerelease":"Prerelease","Version":"Version","VersionReq":"VersionReq","error::ErrorKind":"error::ErrorKind","error::Position":"error::Position","error::QuotedChar":"error::QuotedChar","identifier::Identifier":"identifier::Identifier","parse::Error":"parse::Error"}}