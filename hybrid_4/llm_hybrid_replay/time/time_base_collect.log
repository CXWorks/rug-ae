========================================
    use crate::{Date, Duration};
    use crate::ext::NumericalDuration;
    use std::ops::Add;

    #[test]
    fn add_duration_to_date() {
        let date = Date::from_calendar_date(2023, crate::Month::April, 15)
            .expect("Failed to construct Date");

        // Add positive duration (300 days)
        let duration = 300.days();
        let expected = Date::from_calendar_date(2024, crate::Month::February, 9)
            .expect("Failed to construct expected Date");
        assert_eq!(date.add(duration), expected);

        // Add zero duration
        assert_eq!(date.add(Duration::ZERO), date);

        // Add negative duration (-300 days)
        let duration = (-300).days();
        let expected = Date::from_calendar_date(2022, crate::Month::June, 21)
            .expect("Failed to construct expected Date");
        assert_eq!(date.add(duration), expected);

        // Add duration leading to overflow (Date::MAX + 1 day)
        let date = Date::MAX;
        let duration = 1.days();
        let result = std::panic::catch_unwind(|| date.add(duration));
        assert!(result.is_err());

        // Add duration leading to underflow (Date::MIN - 1 day)
        let date = Date::MIN;
        let duration = (-1).days();
        let result = std::panic::catch_unwind(|| date.add(duration));
        assert!(result.is_err());

        // Add duration that results in leap day
        let date = Date::from_calendar_date(2023, crate::Month::February, 28)
            .expect("Failed to construct Date");
        let duration = 1.days();
        let expected = Date::from_calendar_date(2023, crate::Month::March, 1)
            .expect("Failed to construct expected Date");
        assert_eq!(date.add(duration), expected);

        // Add duration that skips leap day
        let date = Date::from_calendar_date(2023, crate::Month::February, 28)
            .expect("Failed to construct Date");
        let duration = 2.days();
        let expected = Date::from_calendar_date(2023, crate::Month::March, 2)
            .expect("Failed to construct expected Date");
        assert_eq!(date.add(duration), expected);

        // Add negative duration that results in leap day
        let date = Date::from_calendar_date(2023, crate::Month::March, 1)
            .expect("Failed to construct Date");
        let duration = (-1).days();
        let expected = Date::from_calendar_date(2023, crate::Month::February, 28)
            .expect("Failed to construct expected Date");
        assert_eq!(date.add(duration), expected);

        // Add duration that should result in overflow
        let date = Date::from_calendar_date(2023, crate::Month::March, 1)
            .expect("Failed to construct Date");
        let duration = Duration::new(i64::MAX, 0);
        let result = std::panic::catch_unwind(|| date.add(duration));
        assert!(result.is_err());
    }
}
True
========================================
    use crate::Date;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDuration;
    use std::crate::Duration as StdDuration;
    use crate::macros::date;

    #[test]
    fn test_add_std_duration() {
        let date = date!(2020 - 01 - 01);
        let duration = StdDuration::from_secs(86_400 * 1); // One day
        let result = date + duration;
        assert_eq!(result, date!(2020 - 01 - 02));
        
        let date = date!(2020 - 01 - 01);
        let duration = StdDuration::from_secs(86_400 * 30); // 30 days
        let result = date + duration;
        assert_eq!(result, date!(2020 - 01 - 31));
        
        let date = date!(2020 - 01 - 31);
        let duration = StdDuration::from_secs(86_400 * 1); // One day
        let result = date + duration;
        assert_eq!(result, date!(2020 - 02 - 01));
        
        let date = date!(2020 - 12 - 31);
        let duration = StdDuration::from_secs(86_400 * 1); // One day
        let result = date + duration;
        assert_eq!(result, date!(2021 - 01 - 01));
        
        // Edge case for leap year
        let date = date!(2020 - 02 - 28);
        let duration = StdDuration::from_secs(86_400 * 1); // One day
        let result = date + duration;
        assert_eq!(result, date!(2020 - 02 - 29));
    }
}
False
========================================
    use crate::date::Date;
    use crate::duration::Duration;
    use crate::ext::NumericalDuration;
    use std::ops::AddAssign;

    #[test]
    fn add_assign_duration_to_date() {
        let mut date = Date::from_calendar_date(2020, crate::Month::January, 1).unwrap();
        let duration = 1.days();
        date.add_assign(duration);
        assert_eq!(
            date,
            Date::from_calendar_date(2020, crate::Month::January, 2).unwrap()
        );

        let mut date = Date::from_calendar_date(2020, crate::Month::December, 31).unwrap();
        let duration = 1.days();
        date.add_assign(duration);
        assert_eq!(
            date,
            Date::from_calendar_date(2021, crate::Month::January, 1).unwrap()
        );

        let mut date = Date::from_calendar_date(2020, crate::Month::February, 28).unwrap();
        let duration = 1.days();
        date.add_assign(duration);
        assert_eq!(
            date,
            Date::from_calendar_date(2020, crate::Month::February, 29).unwrap()
        );

        let mut date = Date::from_calendar_date(2021, crate::Month::February, 28).unwrap();
        let duration = 1.days();
        date.add_assign(duration);
        assert_eq!(
            date,
            Date::from_calendar_date(2021, crate::Month::March, 1).unwrap()
        );

        let mut date = Date::MIN;
        let duration = Duration::MIN;
        date.add_assign(duration);
        assert_eq!(
            date,
            Date::MIN
        );

        let mut date = Date::MAX;
        let duration = Duration::MAX;
        date.add_assign(duration);
        assert_eq!(
            date,
            Date::MAX
        );

        let mut date = Date::MIN;
        let duration = Duration::MAX;
        date.add_assign(duration);
        assert_eq!(
            date,
            Date::from_calendar_date(2022, crate::Month::September, 0).unwrap() // Some large year
        );

        let mut date = Date::MAX;
        let duration = Duration::MIN;
        date.add_assign(duration);
        assert_eq!(
            date,
            Date::from_calendar_date(-1958, crate::Month::May, 11).unwrap() // Some large year
        );
    }
}
True
========================================
    use std::crate::Duration as StdDuration;
    use crate::{Date, Month, ext::NumericalDuration};

    #[test]
    fn add_assign_duration_to_date() {
        let mut date = Date::from_calendar_date(2021, Month::January, 1).unwrap();
        date += 5.std_days();
        assert_eq!(date, Date::from_calendar_date(2021, Month::January, 6).unwrap());

        let mut date = Date::from_calendar_date(2020, Month::February, 28).unwrap();
        date += 1.std_days();
        assert_eq!(date, Date::from_calendar_date(2020, Month::February, 29).unwrap());

        let mut date = Date::from_calendar_date(2021, Month::December, 31).unwrap();
        date += 1.std_days();
        assert_eq!(date, Date::from_calendar_date(2022, Month::January, 1).unwrap());

        let mut date = Date::from_calendar_date(2021, Month::January, 1).unwrap();
        date += StdDuration::from_secs(86400 * 5);
        assert_eq!(date, Date::from_calendar_date(2021, Month::January, 6).unwrap());

        let mut date = Date::from_calendar_date(2020, Month::February, 28).unwrap();
        date += StdDuration::from_secs(86400);
        assert_eq!(date, Date::from_calendar_date(2020, Month::February, 29).unwrap());

        let mut date = Date::from_calendar_date(2021, Month::December, 31).unwrap();
        date += StdDuration::from_secs(86400);
        assert_eq!(date, Date::from_calendar_date(2022, Month::January, 1).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_sub_positive_duration() {
        let date = Date::from_ordinal_date(2023, 90).unwrap(); // 2023-03-31
        let duration = 5.days();
        let expected = Date::from_ordinal_date(2023, 85).unwrap(); // 2023-03-26
        assert_eq!(date - duration, expected);
    }

    #[test]
    fn test_sub_negative_duration() {
        let date = Date::from_ordinal_date(2023, 90).unwrap(); // 2023-03-31
        let duration = (-5).days();
        let expected = Date::from_ordinal_date(2023, 95).unwrap(); // 2023-04-05
        assert_eq!(date - duration, expected);
    }

    #[test]
    #[should_panic(expected = "overflow subtracting duration from date")]
    fn test_sub_overflow() {
        let date = Date::MIN;
        let duration = 1.days();
        let _ = date - duration;
    }

    #[test]
    fn test_sub_std_duration() {
        let date = Date::from_ordinal_date(2023, 90).unwrap(); // 2023-03-31
        let duration = 48.std_hours();
        let expected = Date::from_ordinal_date(2023, 88).unwrap(); // 2023-03-29
        assert_eq!(date - duration, expected);
    }

    #[test]
    #[should_panic(expected = "overflow subtracting duration from date")]
    fn test_sub_std_duration_overflow() {
        let date = Date::MIN;
        let duration = 48.std_hours();
        let _ = date - duration;
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;
    use crate::Month;

    #[test]
    fn date_sub_std_duration() {
        // Subtract a `StdDuration` from a `Date` and expect a valid `Date` result.
        let date = Date::from_calendar_date(2023, Month::January, 15).unwrap();
        let std_duration = StdDuration::new(7 * 24 * 3600, 0); // 7 days
        let result = date - std_duration;
        let expected = Date::from_calendar_date(2023, Month::January, 8).unwrap();
        assert_eq!(result, expected, "Subtracting 7 days should result in January 8th, 2023");

        // Subtract a StdDuration that exceeds the valid date range and expect a panic.
        let date = Date::from_calendar_date(2023, Month::January, 15).unwrap();
        let std_duration = StdDuration::new(1_000_000 * 24 * 3600, 0); // 1_000_000 days
        let result = std::panic::catch_unwind(|| date - std_duration);
        assert!(result.is_err(), "Subtracting 1_000_000 days should overflow and panic");

        // Subtract a zero `StdDuration` and expect the original date.
        let date = Date::from_calendar_date(2023, Month::January, 15).unwrap();
        let std_duration = StdDuration::new(0, 0);
        let result = date - std_duration;
        assert_eq!(result, date, "Subtracting zero duration should yield the original date");

        // Subtract a `StdDuration` that results in the minimum valid `Date`.
        let date = Date::MIN;
        let std_duration = StdDuration::new(0, 0); // 0 days
        let result = date - std_duration;
        assert_eq!(result, Date::MIN, "Subtracting zero duration from Date::MIN should yield Date::MIN");

        // Subtract a `StdDuration` that would result in a date before `Date::MIN` and expect panic.
        let date = Date::MIN;
        let std_duration = StdDuration::from_std(1.std_days());
        let result = std::panic::catch_unwind(|| date - std_duration);
        assert!(result.is_err(), "Subtracting 1 day from Date::MIN should overflow and panic");

        // Subtract a `StdDuration` that results in the maximum valid `Date`.
        let date = Date::MAX;
        let result = date - StdDuration::new(0, 0); // 0 days
        assert_eq!(result, Date::MAX, "Subtracting zero duration from Date::MAX should yield Date::MAX");

        // Subtract a `StdDuration` that would result in a date after `Date::MAX` and expect panic.
        let date = Date::MAX;
        let std_duration = StdDuration::new(24 * 3600, 0); // 1 day
        let result = std::panic::catch_unwind(|| date - std_duration);
        assert!(result.is_err(), "Subtracting 1 day should result in overflow and panic");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;

    #[test]
    fn test_sub_same_date() {
        let date1 = Date::from_calendar_date(2022, Month::December, 31).unwrap();
        let date2 = date1;
        assert_eq!(date1 - date2, Duration::ZERO);
    }

    #[test]
    fn test_sub_different_date() {
        let date1 = Date::from_calendar_date(2022, Month::December, 31).unwrap();
        let date2 = Date::from_calendar_date(2022, Month::January, 1).unwrap();
        assert_eq!(date1 - date2, Duration::days(364));
    }

    #[test]
    fn test_sub_across_years() {
        let date1 = Date::from_calendar_date(2023, Month::January, 1).unwrap();
        let date2 = Date::from_calendar_date(2022, Month::January, 1).unwrap();
        assert_eq!(date1 - date2, Duration::days(365));
    }

    #[test]
    fn test_sub_negative_result() {
        let date1 = Date::from_calendar_date(2022, Month::January, 1).unwrap();
        let date2 = Date::from_calendar_date(2022, Month::December, 31).unwrap();
        assert_eq!(date1 - date2, Duration::days(-364));
    }

    #[test]
    fn test_sub_with_leap_year() {
        let date1 = Date::from_calendar_date(2020, Month::December, 31).unwrap();
        let date2 = Date::from_calendar_date(2020, Month::January, 1).unwrap();
        assert_eq!(date1 - date2, Duration::days(365));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{Date, Duration};

    #[test]
    fn sub_assign_positive_duration() {
        let mut date = Date::from_ordinal_date(2023, 100).unwrap();
        let duration = Duration::days(10);
        date -= duration;
        assert_eq!(Date::from_ordinal_date(2023, 90).unwrap(), date);
    }

    #[test]
    fn sub_assign_negative_duration() {
        let mut date = Date::from_ordinal_date(2023, 100).unwrap();
        let duration = Duration::days(-10);
        date -= duration;
        assert_eq!(Date::from_ordinal_date(2023, 110).unwrap(), date);
    }

    #[test]
    fn sub_assign_zero_duration() {
        let mut date = Date::from_ordinal_date(2023, 100).unwrap();
        let duration = Duration::ZERO;
        date -= duration;
        assert_eq!(Date::from_ordinal_date(2023, 100).unwrap(), date);
    }

    #[test]
    fn sub_assign_to_min_date() {
        let mut date = Date::MIN;
        let duration = Duration::days(1);
        date -= duration;
        assert_eq!(Date::MIN, date);
    }

    #[test]
    fn sub_assign_to_max_date() {
        let mut date = Date::MAX;
        let duration = Duration::days(-1);
        date -= duration;
        assert_eq!(Date::MAX, date);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn test_sub_assign_duration() {
        let mut date = Date::from_calendar_date(2023, Month::March, 4).unwrap();
        date -= StdDuration::from_secs(86_400); // Subtract one day
        assert_eq!(date, Date::from_calendar_date(2023, Month::March, 3).unwrap());
    }

    #[test]
    #[should_panic(expected = "overflow subtracting duration from date")]
    fn test_sub_assign_duration_overflow() {
        let mut date = Date::from_calendar_date(1, Month::January, 1).unwrap();
        date -= StdDuration::from_secs(86_400); // Subtract one day
    }
    
    #[test]
    fn test_sub_assign_duration_to_wrap() {
        let mut date = Date::from_calendar_date(2023, Month::March, 1).unwrap();
        date -= StdDuration::from_secs(86_400 * 2); // Subtract two days
        assert_eq!(date, Date::from_calendar_date(2023, Month::February, 27).unwrap());
    }

    #[test]
    fn test_sub_assign_duration_no_change() {
        let mut date = Date::from_calendar_date(2023, Month::March, 4).unwrap();
        date -= StdDuration::from_secs(0); // Subtract zero days
        assert_eq!(date, Date::from_calendar_date(2023, Month::March, 4).unwrap());
    }
    
    // Additional tests for edge cases, such as leap years, can be added as needed
}
False
========================================
    use crate::prelude::*;
    use crate::Date;
    use crate::Time;
    use crate::UtcOffset;
    use crate::PrimitiveDateTime as DateTime;
    use time_macros::datetime;

    #[test]
    fn clone_date_time() {
        let dt = datetime!(2022-01-01 00:00);
        let dt_cloned = dt.clone();
        assert_eq!(dt, dt_cloned);
    }

    #[test]
    fn clone_date_time_with_time() {
        let dt = datetime!(2022-01-01 12:34:56.789);
        let dt_cloned = dt.clone();
        assert_eq!(dt, dt_cloned);
    }

    #[test]
    fn clone_date_time_with_offset() {
        let dt = datetime!(2022-01-01 00:00 +0);
        let dt_cloned = dt.clone();
        assert_eq!(dt, dt_cloned);
    }

    #[test]
    fn clone_max_date_time() {
        let dt = DateTime::MAX;
        let dt_cloned = dt.clone();
        assert_eq!(dt, dt_cloned);
    }

    #[test]
    fn clone_midnight() {
        let dt = datetime!(2022-01-01 0:00);
        let dt_cloned = dt.clone();
        assert_eq!(dt, dt_cloned);
    }

    #[test]
    fn clone_time_max() {
        let dt = DateTime {
            date: Date::from_calendar_date(2022, crate::Month::January, 1).unwrap(),
            time: Time::MIDNIGHT,
            offset: UtcOffset::UTC,
        };
        let dt_cloned = dt.clone();
        assert_eq!(dt, dt_cloned);
    }

    #[test]
    fn clone_time_midnight() {
        let dt = DateTime {
            date: Date::from_calendar_date(2022, crate::Month::January, 1).unwrap(),
            time: Time::MIDNIGHT,
            offset: UtcOffset::UTC,
        };
        let dt_cloned = dt.clone();
        assert_eq!(dt, dt_cloned);
    }

    #[test]
    fn clone_time_with_nanos() {
        let dt = DateTime {
            date: Date::from_calendar_date(2022, crate::Month::January, 1).unwrap(),
            time: Time::from_hms_nano(12, 34, 56, 789_012_345).unwrap(),
            offset: UtcOffset::UTC,
        };
        let dt_cloned = dt.clone();
        assert_eq!(dt, dt_cloned);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::OffsetDateTime;
    use crate::UtcOffset;
    use std::cmp::Ordering;

    #[test]
    fn cmp_same_dates() {
        let dt1 = OffsetDateTime::now_utc();
        let dt2 = dt1;
        assert_eq!(dt1.cmp(&dt2), Ordering::Equal);
    }

    #[test]
    fn cmp_different_dates() {
        let dt1 = OffsetDateTime::UNIX_EPOCH;
        let dt2 = dt1 + 1.seconds();
        assert_eq!(dt1.cmp(&dt2), Ordering::Less);
        assert_eq!(dt2.cmp(&dt1), Ordering::Greater);
    }

    #[test]
    fn cmp_dates_across_dst_boundary() {
        let dt1 = OffsetDateTime::UNIX_EPOCH;
        let dt2 = dt1 + 1.days();
        assert_eq!(dt1.cmp(&dt2), Ordering::Less);
        assert_eq!(dt2.cmp(&dt1), Ordering::Greater);
    }

    #[test]
    fn cmp_with_offset_adjustment() {
        let dt1 = OffsetDateTime::UNIX_EPOCH;
        let dt2 = dt1.to_offset(UtcOffset::hours(1));
        assert_eq!(dt1.cmp(&dt2), Ordering::Less);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date_crate::DateTime;
    use crate::date::Date;
    use crate::crate::Time;
    use crate::crate::Duration;
    use crate::crate::UtcOffset;
    use crate::date_crate::offset_kind::Fixed;
    use crate::date_crate::offset_kind::None;
    use crate::Month;

    #[test]
    fn test_eq_with_utc_offset() {
        let dt1 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        )
        .assume_utc();
        let dt2 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        )
        .assume_utc();
        let dt3 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2022, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        )
        .assume_utc();

        assert!(dt1 == dt2, "DateTime with UTC offset should be equal");
        assert!(dt1 != dt3, "DateTime with UTC offset should not be equal");
    }

    #[test]
    fn test_eq_without_utc_offset() {
        let dt1 = DateTime::<None>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        );
        let dt2 = DateTime::<None>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        );
        let dt3 = DateTime::<None>::new(
            Date::from_calendar_date(2022, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        );

        assert!(dt1 == dt2, "DateTime without UTC offset should be equal");
        assert!(dt1 != dt3, "DateTime without UTC offset should not be equal");
    }

    #[test]
    fn test_eq_with_offset_change() {
        let dt1 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        )
        .assume_offset(UtcOffset::from_hms(0, 0, 0).unwrap());
        let dt2 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        )
        .assume_offset(UtcOffset::from_hms(1, 0, 0).unwrap());

        assert!(dt1 != dt2, "DateTime with different UTC offsets should not be equal");
    }

    #[test]
    fn test_eq_across_fixed_none() {
        let dt1 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        )
        .assume_utc();
        let dt2 = DateTime::<None>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        );

        assert!(dt1 != dt2, "DateTime with and without UTC offset should not be equal");
    }

    #[test]
    fn test_eq_across_days() {
        let dt1 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(23, 59, 59).unwrap(),
        )
        .assume_utc();
        let dt2 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2021, Month::January, 2).unwrap(),
            Time::from_hms(0, 0, 0).unwrap(),
        )
        .assume_utc();

        assert!(dt1 != dt2, "DateTime on different days should not be equal");
    }

    #[test]
    fn test_eq_with_duration() {
        let dt1 = DateTime::<Fixed>::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            Time::from_hms(12, 0, 0).unwrap(),
        )
        .assume_utc();
        let dt2 = dt1 + Duration::hours(1);
        let dt3 = dt1 + Duration::ZERO;

        assert!(dt1 != dt2, "DateTime with duration added should not be equal");
        assert!(dt1 == dt3, "DateTime with zero duration added should be equal");
    }
}
False
========================================
    use crate::{
        date_crate::DateTime, date::Date, crate::Time, defs::UtcOffset, ext::NumericalDuration,
        std::crate::Duration as StdDuration,
    };
    use std::cmp::Ordering;

    #[test]
    fn partial_cmp_equal_datetimes() {
        let datetime1 = DateTime::UNIX_EPOCH;
        let datetime2 = DateTime::UNIX_EPOCH;
        assert_eq!(datetime1.partial_cmp(&datetime2), Some(Ordering::Equal));
    }

    #[test]
    fn partial_cmp_earlier_datetime() {
        let datetime1 = DateTime::UNIX_EPOCH;
        let datetime2 = DateTime {
            date: Date::from_ordinal_date(1970, 2).unwrap(),
            time: Time::MIDNIGHT,
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime1.partial_cmp(&datetime2), Some(Ordering::Less));
    }

    #[test]
    fn partial_cmp_later_datetime() {
        let datetime1 = DateTime::UNIX_EPOCH;
        let datetime2 = DateTime::UNIX_EPOCH + StdDuration::from_secs(1);
        assert_eq!(datetime1.partial_cmp(&datetime2), Some(Ordering::Greater));
    }

    #[test]
    fn partial_cmp_different_dates() {
        let datetime1 = DateTime {
            date: Date::from_ordinal_date(1970, 1).unwrap(),
            time: Time::MIDNIGHT,
            offset: UtcOffset::UTC,
        };
        let datetime2 = DateTime {
            date: Date::from_ordinal_date(1970, 365).unwrap(),
            time: Time::from_hms(23, 59, 59).unwrap(),
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime1.partial_cmp(&datetime2), Some(Ordering::Less));
    }

    #[test]
    fn partial_cmp_different_times() {
        let datetime1: DateTime<crate::date_crate::offset_kind::Utc> = DateTime {
            date: Date::from_ordinal_date(1970, 1).unwrap(),
            time: Time::from_hms(0, 0, 0).unwrap(),
            offset: UtcOffset::UTC,
        };
        let datetime2: DateTime<crate::date_crate::offset_kind::Utc> = DateTime {
            date: Date::from_ordinal_date(1970, 1).unwrap(),
            time: Time::from_hms(23, 59, 59).unwrap(),
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime1.partial_cmp(&datetime2), Some(Ordering::Less));
    }

    #[test]
    fn partial_cmp_different_offsets() {
        let datetime1: DateTime<crate::date_crate::offset_kind::Utc> = DateTime {
            date: Date::from_ordinal_date(1970, 1).unwrap(),
            time: Time::from_hms(0, 0, 0).unwrap(),
            offset: UtcOffset::UTC,
        };
        let datetime2: DateTime<crate::date_crate::offset_kind::Utc> = DateTime {
            date: Date::from_ordinal_date(1970, 1).unwrap(),
            time: Time::from_hms(1, 0, 0).unwrap(),
            offset: UtcOffset::hours(1),
        };
        assert_eq!(datetime1.partial_cmp(&datetime2), Some(Ordering::Equal));
    }

    #[test]
    fn partial_cmp_different_dates_and_offsets() {
        let datetime1: DateTime<crate::date_crate::offset_kind::Utc> = DateTime {
            date: Date::from_ordinal_date(1970, 1).unwrap(),
            time: Time::from_hms(1, 0, 0).unwrap(),
            offset: UtcOffset::hours(1),
        };
        let datetime2: DateTime<crate::date_crate::offset_kind::Utc> = DateTime {
            date: Date::from_ordinal_date(1970, 2).unwrap(),
            time: Time::from_hms(0, 0, 0).unwrap(),
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime1.partial_cmp(&datetime2), Some(Ordering::Less));
    }
}
False
========================================
    use crate::date::Date;
    use crate::date_crate::DateTime;
    use crate::offset::UtcOffset;
    use crate::crate::Time;
    use crate::util::days_in_year;
    use crate::PrimitiveDateTime;
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    #[test]
    fn test_hash() {
        let date = Date {
            value: (2021 << 9) | 200,
        };
        let date_time = PrimitiveDateTime::new(date, Time::MIDNIGHT);
        let date_time = DateTime::from(date_time).assume_utc();

        let mut hasher = DefaultHasher::new();
        date_time.hash(&mut hasher);
        let hash_with_offset = hasher.finish();

        let mut hasher_no_offset = DefaultHasher::new();
        (date_time.date(), date_time.time()).hash(&mut hasher_no_offset);
        let hash_no_offset = hasher_no_offset.finish();

        assert_eq!(hash_with_offset, hash_no_offset, "Hashes with and without offset should be equal for a DateTime with UTC offset");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;
    use std::ops::Add;

    #[test]
    fn add_duration_to_datetime() {
        let datetime = DateTime::UNIX_EPOCH;
        let duration = Duration::seconds(5);

        let result = DateTime::add(datetime, duration);
        let expected = DateTime::UNIX_EPOCH + Duration::seconds(5);
        assert_eq!(result, expected);
    }

    #[test]
    fn add_duration_to_min_datetime() {
        let datetime = DateTime::<offset_kind::None>::MIN;
        let duration = Duration::seconds(1);

        let result = DateTime::add(datetime, duration);
        let expected = datetime + Duration::seconds(1);
        assert_eq!(result, expected);
    }

    #[test]
    fn add_duration_to_max_datetime() {
        let datetime = DateTime::<offset_kind::None>::MAX;
        let duration = Duration::seconds(-1);

        let result = DateTime::add(datetime, duration);
        let expected = datetime + Duration::seconds(-1);
        assert_eq!(result, expected);
    }

    #[test]
    #[should_panic(expected = "resulting value is out of range")]
    fn add_overflow() {
        let datetime = DateTime::<offset_kind::None>::MAX;
        let duration = Duration::seconds(1);
        let _ = DateTime::add(datetime, duration);
    }

    #[test]
    #[should_panic(expected = "resulting value is out of range")]
    fn add_underflow() {
        let datetime = DateTime::<offset_kind::None>::MIN;
        let duration = Duration::seconds(-1);
        let _ = DateTime::add(datetime, duration);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::crate::Time;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use std::crate::Duration as StdDuration;
    use crate::Duration;

    #[test]
    fn add_std_duration_to_date_time() {
        let date = Date::from_calendar_date(2021, crate::Month::January, 1).unwrap();
        let time = Time::from_hms(12, 30, 45).unwrap();
        let datetime = DateTime::<Fixed>::new(date, time).assume_offset(crate::UtcOffset::UTC);
        let duration = StdDuration::new(2 * 24 * 3600 + 3600 + 60 + 1, 123_456_789);
        let result = datetime + duration;

        assert_eq!(
            result,
            DateTime::<Fixed>::new(
                Date::from_calendar_date(2021, crate::Month::January, 3).unwrap(),
                Time::from_hms_nano(13, 31, 46, 123_456_789).unwrap(),
            ).assume_offset(crate::UtcOffset::UTC)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date_crate::offset_kind::Fixed;
    use crate::date_crate::DateTime;
    use crate::duration::Duration;
    use crate::Date;
    use crate::Month;
    use crate::Time;
    use crate::UtcOffset;

    #[test]
    fn add_assign_duration() {
        let mut ny_datetime = DateTime::<Fixed>::new(
            Date::from_calendar_date(2022, Month::January, 1).unwrap(),
            Time::from_hms(0, 0, 0).unwrap(),
        )
        .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap());

        ny_datetime += Duration::seconds(86400 * 2 + 3600 * 3 + 60 * 4 + 5);

        assert_eq!(
            ny_datetime,
            DateTime::new(
                Date::from_calendar_date(2022, Month::January, 3).unwrap(),
                Time::from_hms(3, 4, 5).unwrap()
            )
            .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
        );
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::Time;
    use std::ops::AddAssign;
    use std::crate::Duration as StdDuration;
    use crate::macros::datetime;

    #[test]
    fn test_add_assign_std_duration_to_fixed_offset_datetime() {
        // This test case checks that the `add_assign` function correctly adds the `StdDuration`
        // to the `DateTime<FixedOffset>`, considering that `DateTime<FixedOffset>` is
        // `OffsetDateTime` in the `time` crate.
        let mut date_time = OffsetDateTime::now_utc();
        let std_duration = StdDuration::from_secs(60 * 60 * 24); // 24 hours
        let expected = date_time + StdDuration::from_secs(60 * 60 * 24);
        date_time.add_assign(std_duration);
        assert_eq!(date_time, expected);
    }

    #[test]
    fn test_add_assign_std_duration_to_primitive_time() {
        // This test case checks that the `add_assign` function correctly adds the `StdDuration`
        // to time, considering the potential overflow to the next day.
        let mut time = Time::MIDNIGHT;
        let std_duration = StdDuration::from_secs(2); // 2 seconds
        let expected = Time::from_hms(0, 0, 2).unwrap();
        time.add_assign(std_duration);
        assert_eq!(time, expected);
    }
}
False
========================================
    use crate::{Duration, Time, UtcOffset};
    use crate::{offset, time, PrimitiveDateTime as DateTime};
    use crate::date::{Date};
    use crate::Month;

    #[test]
    fn sub_duration() {
        // Create a DateTime object from a known Date and Time
        let dt = DateTime::new(
            Date::from_calendar_date(2023, Month::January, 1).unwrap(),
            Time::from_hms(0, 0, 0).unwrap(),
        ).assume_offset(UtcOffset::UTC);

        // Subtract a duration of one hour
        let result = dt - Duration::hours(1);
        let expected = DateTime::new(
            Date::from_calendar_date(2022, Month::December, 31).unwrap(),
            Time::from_hms(23, 0, 0).unwrap(),
        ).assume_offset(UtcOffset::UTC);
        assert_eq!(result, expected);

        // Subtract a duration of 24 hours, resulting in the previous day
        let result = dt - Duration::hours(24);
        let expected = DateTime::new(
            Date::from_calendar_date(2022, Month::December, 31).unwrap(),
            Time::from_hms(0, 0, 0).unwrap(),
        ).assume_offset(UtcOffset::UTC);
        assert_eq!(result, expected);

        // Subtract a duration of one minute
        let result = dt - Duration::minutes(1);
        let expected = DateTime::new(
            Date::from_calendar_date(2022, Month::December, 31).unwrap(),
            Time::from_hms(23, 59, 0).unwrap(),
        ).assume_offset(UtcOffset::UTC);
        assert_eq!(result, expected);

        // Subtract a duration of one second
        let result = dt - Duration::seconds(1);
        let expected = DateTime::new(
            Date::from_calendar_date(2022, Month::December, 31).unwrap(),
            Time::from_hms(23, 59, 59).unwrap(),
        ).assume_offset(UtcOffset::UTC);
        assert_eq!(result, expected);

        // Subtract a duration of one millisecond
        let result = dt - Duration::milliseconds(1);
        let expected = DateTime::new(
            Date::from_calendar_date(2022, Month::December, 31).unwrap(),
            Time::from_hms_milli(23, 59, 59, 999).unwrap(),
        ).assume_offset(UtcOffset::UTC);
        assert_eq!(result, expected);

        // Subtract a duration of one microsecond
        let result = dt - Duration::microseconds(1);
        let expected = DateTime::new(
            Date::from_calendar_date(2022, Month::December, 31).unwrap(),
            Time::from_hms_micro(23, 59, 59, 999_999).unwrap(),
        ).assume_offset(UtcOffset::UTC);
        assert_eq!(result, expected);

        // Subtract a duration of one nanosecond
        let result = dt - Duration::nanoseconds(1);
        let expected = DateTime::new(
            Date::from_calendar_date(2022, Month::December, 31).unwrap(),
            Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap(),
        ).assume_offset(UtcOffset::UTC);
        assert_eq!(result, expected);
    }
}
False
========================================
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDuration;
    use crate::macros::{datetime, offset};
    use crate::Duration;
    use std::crate::Duration as StdDuration;

    #[test]
    fn sub_std_duration_wrapping_to_previous_day() {
        let dt = datetime!(2023-03-15 0:00 UTC);
        let std_duration = 2.std_hours();
        let result = dt - std_duration;
        assert_eq!(result, datetime!(2023-03-14 22:00 UTC));
    }

    #[test]
    fn sub_std_duration_no_wrapping() {
        let dt = datetime!(2023-03-15 12:00 UTC);
        let std_duration = 2.std_hours();
        let result = dt - std_duration;
        assert_eq!(result, datetime!(2023-03-15 10:00 UTC));
    }

    #[test]
    fn sub_std_duration_wrapping_with_offset() {
        let dt = datetime!(2023-03-15 0:00 +2);
        let std_duration = 3.std_hours();
        let result = dt - std_duration;
        assert_eq!(result, datetime!(2023-03-14 21:00 +2));
    }

    #[test]
    fn sub_duration_wrapping_to_previous_day() {
        let dt = datetime!(2023-03-15 0:00 UTC);
        let duration = 2.hours();
        let result = dt - duration;
        assert_eq!(result, datetime!(2023-03-14 22:00 UTC));
    }

    #[test]
    fn sub_duration_no_wrapping() {
        let dt = datetime!(2023-03-15 12:00 UTC);
        let duration = 2.hours();
        let result = dt - duration;
        assert_eq!(result, datetime!(2023-03-15 10:00 UTC));
    }

    #[test]
    fn sub_duration_wrapping_with_offset() {
        let dt = datetime!(2023-03-15 0:00 +2);
        let duration = 3.hours();
        let result = dt - duration;
        assert_eq!(result, datetime!(2023-03-14 21:00 +2));
    }
}
False
========================================
#[cfg(test)]
mod date_time_sub_tests {
    use crate::{Date, Time, Duration, PrimitiveDateTime, Weekday, UtcOffset};

    #[test]
    fn test_sub_same_date_time() {
        let dt1 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_utc();
        let dt2 = dt1;
        assert_eq!(dt1 - dt2, Duration::ZERO);
    }

    #[test]
    fn test_sub_different_date_time() {
        let dt1 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 2).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_utc();
        let dt2 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_utc();
        assert_eq!(dt1 - dt2, Duration::DAY);
    }

    #[test]
    fn test_sub_different_time_same_date() {
        let dt1 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(2, 2, 3).unwrap(),
        ).assume_utc();
        let dt2 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_utc();
        assert_eq!(dt1 - dt2, Duration::hour(1));
    }

    #[test]
    fn test_sub_same_time_different_date() {
        let dt1 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 2).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_utc();
        let dt2 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_utc();
        assert_eq!(dt1 - dt2, Duration::DAY);
    }

    #[test]
    fn test_sub_different_offset() {
        let dt1 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_offset(UtcOffset::hours(1));
        let dt2 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_offset(UtcOffset::hours(-1));
        assert_eq!(dt1 - dt2, Duration::hours(2));
    }

    #[test]
    fn test_sub_different_offset_and_time() {
        let dt1 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(2, 2, 3).unwrap(),
        ).assume_offset(UtcOffset::hours(1));
        let dt2 = PrimitiveDateTime::new(
            Date::from_calendar_date(2020, Weekday::Wednesday, 1).unwrap(),
            Time::from_hms(1, 2, 3).unwrap(),
        ).assume_offset(UtcOffset::hours(-1));
        assert_eq!(dt1 - dt2, Duration::hours(3));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration; // Need to use the crate name
    use crate::ext::NumericalStdDuration; // Need to use the crate name
    use std::crate::Duration as StdDuration; // Correct the path for std Duration
    use time_macros::{date, datetime, time}; // Use `time_macros` directly

    #[test]
    fn sub_assign_duration() {
        let mut datetime: DateTime<Fixed> = datetime!(2000-01-01 0:00 UTC);
        datetime -= 1.seconds();
        assert_eq!(datetime, datetime!(1999-12-31 23:59:59 UTC));

        let mut datetime: DateTime<Fixed> = datetime!(2000-01-01 0:00 UTC);
        datetime -= StdDuration::new(0, 1_000_000_000);
        assert_eq!(datetime, datetime!(1999-12-31 23:59:59 UTC));

        let mut datetime: DateTime<Fixed> = datetime!(1999-12-31 23:59:59 UTC);
        datetime -= (-1).seconds();
        assert_eq!(datetime, datetime!(2000-01-01 0:00 UTC));

        let mut datetime: DateTime<Fixed> = datetime!(1999-12-31 23:59:59 UTC);
        datetime -= StdDuration::new(1, 0);
        assert_eq!(datetime, datetime!(1999-12-31 23:59:58 UTC));
    }
}
False
========================================
    use crate::{Duration, ext::{NumericalDuration, NumericalStdDuration}};
    use std::{crate::Duration as StdDuration};
    use crate::macros::datetime;
    use crate::PrimitiveDateTime as DateTime;
    use std::ops::SubAssign;

    #[test]
    fn sub_assign_std_duration() {
        // Subtraction that doesn't change date
        let mut dt1 = datetime!(2022-03-15 12:00:00 UTC);
        dt1.sub_assign(StdDuration::from_secs(30 * 60)); // 30 minutes as StdDuration
        assert_eq!(dt1, datetime!(2022-03-15 11:30:00 UTC));

        // Subtraction that changes date
        let mut dt2 = datetime!(2022-03-15 00:30:00 UTC);
        dt2.sub_assign(StdDuration::from_secs(1 * 60 * 60)); // 1 hour as StdDuration
        assert_eq!(dt2, datetime!(2022-03-14 23:30:00 UTC));

        // Subtraction that results in overflow (earlier than possible representation)
        let mut dt3 = datetime!(0000-01-01 00:00:00 UTC);
        let overflow = StdDuration::from_secs(24 * 60 * 60 * 2); // 2 days to ensure overflow
        dt3.sub_assign(overflow);
        // Test will fail if overflow is not handled, no change expected as it's minimum value
        assert_eq!(dt3, datetime!(0000-01-01 00:00:00 UTC));
    }

    #[test]
    fn sub_assign_duration() {
        // Subtraction that doesn't change date
        let mut dt1 = datetime!(2022-03-15 12:00:00 UTC);
        dt1.sub_assign(30.minutes());
        assert_eq!(dt1, datetime!(2022-03-15 11:30:00 UTC));

        // Subtraction that changes date
        let mut dt2 = datetime!(2022-03-15 00:30:00 UTC);
        dt2.sub_assign(1.hours());
        assert_eq!(dt2, datetime!(2022-03-14 23:30:00 UTC));

        // Subtraction that results in overflow (earlier than possible representation)
        let mut dt3 = datetime!(0000-01-01 00:00:00 UTC);
        let overflow = Duration::new(2 * 86_400, 0); // 2 days
        dt3.sub_assign(overflow);
        // Test will fail if overflow is not handled, no change expected as it's minimum value
        assert_eq!(dt3, datetime!(0000-01-01 00:00:00 UTC));
    }
}

False
========================================
    use super::*;

use crate::*;
    use std::crate::SystemTime;
    use crate::macros::datetime;
    use crate::{Date, Month, Time, UtcOffset, OffsetDateTime};

    #[test]
    fn test_datetime_eq_systime() {
        // Fixed date-time to test equality with SystemTime
        let fixed_datetime = OffsetDateTime::from_unix_timestamp(0).unwrap(); // 1970-01-01 0:00 UTC
        let fixed_systime = SystemTime::UNIX_EPOCH;

        // Test equality
        assert!(fixed_datetime.eq(&fixed_systime));

        // Test inequality due to different date
        let non_eq_datetime = datetime!(1970-01-02 0:00).assume_utc();
        assert!(!non_eq_datetime.eq(&fixed_systime));

        // Test inequality due to different time
        let non_eq_datetime = datetime!(1970-01-01 1:00).assume_utc();
        assert!(!non_eq_datetime.eq(&fixed_systime));

        // Test inequality with a time before UNIX_EPOCH
        let early_datetime = datetime!(1969-12-31 23:59:59).assume_utc();
        assert!(!early_datetime.eq(&fixed_systime));

        // Use SystemTime as the base of comparison
        let systime_now = SystemTime::now();
        assert!(OffsetDateTime::from(systime_now).eq(&systime_now));

        // Date-time with a non-zero UTC offset should not be equal to the same instant as a SystemTime
        let non_eq_datetime = OffsetDateTime::from_unix_timestamp(0).unwrap()
            .to_offset(UtcOffset::from_hms(1, 0, 0).unwrap()); // 1970-01-01 1:00 UTC+1
        assert!(!non_eq_datetime.eq(&fixed_systime));
    }
}
False
========================================
    use crate::date_crate::{DateTime, offset_kind::Fixed};
    use crate::OffsetDateTime;
    use std::cmp::Ordering;
    use std::crate::SystemTime;
    use crate::macros::datetime;

    #[test]
    fn partial_cmp_with_system_time() {
        let fixed_dt = datetime!(2023-04-01 0:00:00 UTC).assume_utc();
        let sys_time = SystemTime::UNIX_EPOCH;

        // SystemTime is UNIX_EPOCH, DateTime is after
        assert_eq!(
            fixed_dt.partial_cmp(&sys_time),
            Some(Ordering::Greater)
        );

        // SystemTime is UNIX_EPOCH, DateTime is at the same moment
        let fixed_dt_at_epoch = DateTime::<Fixed>::UNIX_EPOCH;
        assert_eq!(
            fixed_dt_at_epoch.partial_cmp(&sys_time),
            Some(Ordering::Equal)
        );

        // SystemTime is after UNIX_EPOCH, DateTime is UNIX_EPOCH
        let sys_time_after = SystemTime::UNIX_EPOCH
            .checked_add(std::crate::Duration::from_secs(60 * 60 * 24))
            .unwrap();
        assert_eq!(
            DateTime::<Fixed>::UNIX_EPOCH.partial_cmp(&sys_time_after),
            Some(Ordering::Less)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;
    use std::crate::{Duration as StdDuration, SystemTime};
    use crate::{date, ext::NumericalDuration, ext::NumericalStdDuration, Date, Duration, Time};

    #[test]
    fn system_time_before_unix_epoch() {
        let system_time = SystemTime::UNIX_EPOCH - StdDuration::new(5, 0);
        let datetime_from_offset = DateTime::from(system_time);
        let manual_datetime = DateTime::UNIX_EPOCH - Duration::new(5, 0);
        assert_eq!(datetime_from_offset, manual_datetime);
    }

    #[test]
    fn system_time_after_unix_epoch() {
        let system_time = SystemTime::UNIX_EPOCH + StdDuration::new(5, 0);
        let datetime_from_offset = DateTime::from(system_time);
        let manual_datetime = DateTime::UNIX_EPOCH + Duration::new(5, 0);
        assert_eq!(datetime_from_offset, manual_datetime);
    }

    #[test]
    fn system_time_unix_epoch() {
        let system_time = SystemTime::UNIX_EPOCH;
        let datetime_from_offset = DateTime::from(system_time);
        let manual_datetime = DateTime::UNIX_EPOCH;
        assert_eq!(datetime_from_offset, manual_datetime);
    }

    #[test]
    fn system_time_far_future() {
        let system_time = SystemTime::UNIX_EPOCH + StdDuration::new(u64::MAX / 2, 0);
        let datetime_from_offset = DateTime::from(system_time);
        let manual_datetime = DateTime::UNIX_EPOCH + (u64::MAX / 2).seconds();
        assert!(datetime_from_offset >= manual_datetime);
    }

    #[test]
    fn system_time_far_past() {
        let system_time = SystemTime::UNIX_EPOCH - StdDuration::new(u64::MAX / 2, 0);
        let datetime_from_offset = DateTime::from(system_time);
        assert!(datetime_from_offset <= DateTime::UNIX_EPOCH - (u64::MAX / 2).seconds());
    }

    #[test]
    fn from_system_time_min_max() {
        let system_time_min = SystemTime::UNIX_EPOCH - Duration::MAX;
        let system_time_max = SystemTime::UNIX_EPOCH + Duration::MAX;
        let datetime_min = DateTime::UNIX_EPOCH - Duration::MAX;
        let datetime_max = DateTime::UNIX_EPOCH + Duration::MAX;
        assert_eq!(DateTime::from(system_time_min), datetime_min);
        assert_eq!(DateTime::from(system_time_max), datetime_max);
    }

    #[test]
    fn from_system_time_with_date_wrapping() {
        let date = Date::from_calendar_date(2000, crate::Month::January, 1).unwrap();
        let time = Time::from_hms(0, 0, 0).unwrap();
        assert_eq!(DateTime::from(SystemTime::UNIX_EPOCH), date.midnight().assume_utc());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::SystemTime;
    use crate::macros::datetime;
    use crate::OffsetDateTime;
    
    // Ensure the use statements do not prefix with `crate::` or `std::crate::`
    use crate::Duration; // The correct path for `Duration`

    #[test]
    fn sub_system_time() {
        let dt = datetime!(2023-03-15 12:00:00 UTC);
        let system_time: SystemTime = dt.into();
        let result = dt.sub(system_time);
        assert_eq!(result, Duration::ZERO);
        
        let system_time = SystemTime::UNIX_EPOCH;
        let result = dt.sub(system_time);
        assert_eq!(result, dt.unix_timestamp().expect("valid timestamp").seconds());

        let dt = datetime!(1969-12-31 23:59:59 UTC);
        let system_time: SystemTime = dt.into();
        let result = dt.sub(system_time);
        assert_eq!(result, Duration::ZERO);
    }

    #[test]
    fn sub_system_time_checked() {
        // Check if the duration calculation is consistent when converted back to a SystemTime
        let dt = datetime!(2023-03-15 12:00:00 UTC);
        let system_time: SystemTime = dt.into();
        let duration = dt.sub(system_time);
        let expected: SystemTime = (DateTime::<offset_kind::Fixed>::UNIX_EPOCH + duration).into();
        assert_eq!(expected, system_time);
    }

    #[test]
    fn sub_system_time_edge_cases() {
        // Check the edge case just before the UNIX_EPOCH
        let dt = DateTime::<offset_kind::Fixed>::UNIX_EPOCH - Duration::nanoseconds(1);
        let system_time: SystemTime = dt.into();
        let duration = dt.sub(system_time);
        assert_eq!(duration, Duration::nanoseconds(-1));
        
        // Check the edge case just after the UNIX_EPOCH
        let dt = DateTime::<offset_kind::Fixed>::UNIX_EPOCH + Duration::nanoseconds(1);
        let system_time: SystemTime = dt.into();
        let duration = dt.sub(system_time);
        assert_eq!(duration, Duration::nanoseconds(1));
    }
    
    // Test sub with a variety of SystemTime values
    #[test]
    fn sub_various_system_times() {
        let dt = datetime!(2023-03-15 12:00:00 UTC);
        
        let system_time = SystemTime::UNIX_EPOCH
            + Duration::seconds(10);
        let duration_since_epoch = dt - DateTime::<offset_kind::Fixed>::UNIX_EPOCH;
        let expected_duration = duration_since_epoch - Duration::seconds(10);
        assert_eq!(dt.sub(system_time), expected_duration);

        let system_time = SystemTime::UNIX_EPOCH
            - Duration::seconds(10);
        let expected_duration = duration_since_epoch + Duration::seconds(10);
        assert_eq!(dt.sub(system_time), expected_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;
    use std::crate::Duration as StdDuration;

    #[test]
    fn duration_eq_std_duration_positive() {
        let time_duration = Duration::new(5, 0);
        let std_duration: StdDuration = time_duration.try_into().unwrap();
        assert!(time_duration.eq(&std_duration));
    }

    #[test]
    fn duration_eq_std_duration_negative() {
        let time_duration = Duration::new(-5, 0);
        let std_duration: Result<StdDuration, _> = time_duration.try_into();
        assert!(std_duration.is_err());
    }

    #[test]
    fn duration_eq_std_duration_positive_with_nanoseconds() {
        let time_duration = Duration::new(10, 500_000_000);
        let std_duration = StdDuration::new(10, 500_000_000);
        assert!(time_duration.eq(&std_duration));
    }

    #[test]
    fn duration_eq_std_duration_negative_with_nanoseconds() {
        let time_duration = Duration::new(-10, -500_000_000);
        let std_duration: Result<StdDuration, _> = time_duration.try_into();
        assert!(std_duration.is_err());
    }

    #[test]
    fn duration_eq_std_duration_zero() {
        let time_duration = Duration::new(0, 0);
        let std_duration = StdDuration::from_secs(0);
        assert!(time_duration.eq(&std_duration));
    }

    #[test]
    fn duration_eq_std_duration_edge_case() {
        let time_duration = Duration::new(i64::MAX, 999_999_999);
        let std_duration = StdDuration::new(i64::MAX as u64, 999_999_999);
        assert!(time_duration.eq(&std_duration));
    }

    #[test]
    fn duration_eq_std_duration_overflow() {
        let time_duration = Duration::MAX;
        let std_duration: Result<StdDuration, _> = time_duration.try_into();
        assert!(std_duration.is_err());
    }
}
False
========================================
    use crate::Duration;
    use std::crate::Duration as StdDuration;
    use std::cmp::Ordering;

    #[test]
    fn partial_cmp_std_greater_than_max() {
        let time_duration = Duration::seconds(i64::MAX);
        let std_duration = StdDuration::new(i64::MAX as u64 + 1, 0);
        assert_eq!(time_duration.partial_cmp(&std_duration), Some(Ordering::Less));
    }

    #[test]
    fn partial_cmp_std_less() {
        let time_duration = Duration::seconds(1);
        let std_duration = StdDuration::new(0, 500_000_001); // slightly more than 1 second
        assert_eq!(time_duration.partial_cmp(&std_duration), Some(Ordering::Less));
    }

    #[test]
    fn partial_cmp_std_equal() {
        let time_duration = Duration::seconds(5);
        let std_duration = StdDuration::new(5, 0);
        assert_eq!(time_duration.partial_cmp(&std_duration), Some(Ordering::Equal));
    }

    #[test]
    fn partial_cmp_std_greater() {
        let time_duration = Duration::new(1, 500_000_000); // 1.5 seconds
        let std_duration = StdDuration::new(1, 0); // 1 second
        assert_eq!(time_duration.partial_cmp(&std_duration), Some(Ordering::Greater));
    }

    #[test]
    fn partial_cmp_std_with_nanoseconds() {
        let time_duration = Duration::new(1, 1_000_000_000); // 2 seconds (overflow by design)
        let std_duration = StdDuration::new(2, 0);
        assert_eq!(time_duration.partial_cmp(&std_duration), Some(Ordering::Equal));
    }

    #[test]
    fn partial_cmp_std_less_with_nanoseconds() {
        let time_duration = Duration::new(1, 0);
        let std_duration = StdDuration::new(1, 1); // slightly more than 1 second
        assert_eq!(time_duration.partial_cmp(&std_duration), Some(Ordering::Less));
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;
    use crate::error::ConversionRange;
    use crate::Duration;

    // Helper function to return max value std::crate::Duration can hold.
    fn max_std_duration() -> StdDuration {
        StdDuration::new(u64::MAX, 999_999_999)
    }

    #[test]
    fn try_from_std_duration_success() {
        let std_duration = StdDuration::new(5, 123_456_789);
        let time_duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(time_duration.whole_seconds(), 5);
        assert_eq!(time_duration.subsec_nanoseconds(), 123_456_789);
    }

    #[test]
    fn try_from_std_duration_with_max_value_success() {
        let std_duration = max_std_duration();
        let time_duration = Duration::try_from(std_duration).unwrap();
        let max_value_secs = u64::MAX as i64;
        assert_eq!(time_duration.whole_seconds(), max_value_secs);
        assert_eq!(time_duration.subsec_nanoseconds(), 999_999_999);
    }

    #[test]
    fn try_from_std_duration_with_overflow_fails() {
        let mut std_duration = max_std_duration();
        let extra_duration = StdDuration::new(0, 1);
        let std_duration = std_duration.checked_add(extra_duration).unwrap();
        assert!(Duration::try_from(std_duration).is_err());
    }

    #[test]
    fn try_from_std_duration_with_zero() {
        let std_duration = StdDuration::new(0, 0);
        let time_duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(time_duration.whole_seconds(), 0);
        assert_eq!(time_duration.subsec_nanoseconds(), 0);
    }
}
False
========================================
    use std::iter::Sum;
    use crate::duration::Duration;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn sum_durations() {
        let durations = vec![
            Duration::seconds(5),
            Duration::milliseconds(1500),
            Duration::nanoseconds(2500000000),
            Duration::ZERO,
        ];
        let total_duration: Duration = durations.iter().sum();
        let expected_duration = Duration::seconds(5)
            + Duration::milliseconds(1500)
            + Duration::nanoseconds(2500000000);
        assert_eq!(total_duration, expected_duration);
    }

    #[test]
    fn sum_no_durations() {
        let durations: Vec<Duration> = Vec::new();
        let total_duration: Duration = durations.iter().sum();
        assert_eq!(total_duration, Duration::ZERO);
    }

    #[test]
    fn sum_negative_durations() {
        let durations = vec![
            Duration::seconds(5),
            Duration::milliseconds(-2500),
            Duration::nanoseconds(-500000000),
        ];
        let total_duration: Duration = durations.iter().sum();
        let expected_duration = Duration::seconds(5)
            + Duration::milliseconds(-2500)
            + Duration::nanoseconds(-500000000);
        assert_eq!(total_duration, expected_duration);
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn sum_overflow() {
        let durations = vec![
            Duration::MAX,
            Duration::nanoseconds(1),
        ];
        let _total_duration: Duration = durations.iter().sum();
    }
}
False
========================================
    use crate::Duration;
    use std::iter::Sum;

    #[test]
    fn sum_empty() {
        let durations: Vec<Duration> = Vec::new();
        assert_eq!(Duration::sum(durations.into_iter()), Duration::ZERO);
    }

    #[test]
    fn sum_single_element() {
        let durations = vec![Duration::seconds(5)];
        assert_eq!(Duration::sum(durations.into_iter()), Duration::seconds(5));
    }

    #[test]
    fn sum_multiple_elements() {
        let durations = vec![Duration::seconds(5), Duration::seconds(10), Duration::seconds(15)];
        assert_eq!(Duration::sum(durations.into_iter()), Duration::seconds(30));
    }

    #[test]
    fn sum_negative_and_positive() {
        let durations = vec![Duration::seconds(5), Duration::seconds(-3), Duration::seconds(2)];
        assert_eq!(Duration::sum(durations.into_iter()), Duration::seconds(4));
    }

    #[test]
    fn sum_with_nanoseconds() {
        let durations = vec![Duration::nanoseconds(5), Duration::nanoseconds(10), Duration::nanoseconds(15)];
        assert_eq!(Duration::sum(durations.into_iter()), Duration::nanoseconds(30));
    }

    #[test]
    fn sum_with_overflow() {
        let max_safe_seconds = i64::MAX / 2;
        let durations = vec![Duration::seconds(max_safe_seconds), Duration::seconds(max_safe_seconds)];
        assert_eq!(Duration::sum(durations.into_iter()), Duration::seconds(max_safe_seconds * 2));
    }

    #[test]
    fn sum_with_underflow() {
        let min_safe_seconds = i64::MIN / 2;
        let durations = vec![Duration::seconds(min_safe_seconds), Duration::seconds(min_safe_seconds)];
        assert_eq!(Duration::sum(durations.into_iter()), Duration::seconds(min_safe_seconds * 2));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::Duration as TimeDuration;

    #[test]
    fn add_std_duration_to_time_duration() {
        let time_duration = TimeDuration::new(5, 0); // 5 seconds
        let std_duration = StdDuration::new(10, 0); // 10 seconds
        let result = <TimeDuration as std::ops::Add<StdDuration>>::add(time_duration, std_duration);
        assert_eq!(result, TimeDuration::new(15, 0));
    }

    #[test]
    #[should_panic(expected = "overflow converting `std::crate::Duration` to `crate::Duration`")]
    fn add_std_duration_to_time_duration_overflow() {
        let time_duration = TimeDuration::new(i64::MAX, 0); // Max i64 seconds
        let std_duration = StdDuration::new(1, 0); // 1 second
        let _result = <TimeDuration as std::ops::Add<StdDuration>>::add(time_duration, std_duration);
        // should panic
    }

    #[test]
    fn add_time_duration_to_std_duration() {
        let time_duration = TimeDuration::new(5, 0); // 5 seconds
        let std_duration = StdDuration::new(10, 0); // 10 seconds
        let result = <StdDuration as std::ops::Add<TimeDuration>>::add(std_duration, time_duration);
        assert_eq!(result, TimeDuration::new(15, 0));
    }

    #[test]
    fn add_time_duration_to_std_duration_with_nanos() {
        let time_duration = TimeDuration::new(5, 500_000_000); // 5.5 seconds
        let std_duration = StdDuration::new(10, 250_000_000); // 10.25 seconds
        let result = <StdDuration as std::ops::Add<TimeDuration>>::add(std_duration, time_duration);
        assert_eq!(result, TimeDuration::new(15, 750_000_000));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_add() {
        assert_eq!(
            Duration::new(5, 0) + Duration::new(5, 0),
            Duration::new(10, 0)
        );

        assert_eq!(
            Duration::new(5, 500_000_000) + Duration::new(5, 500_000_000),
            Duration::new(11, 0)
        );

        assert_eq!(
            Duration::new(-5, -500_000_000) + Duration::new(-5, -500_000_000),
            Duration::new(-11, 0)
        );

        assert_eq!(
            Duration::MAX + Duration::new(0, 1),
            Duration::MAX
        );

        assert_eq!(
            Duration::new(5, 999_999_999) + Duration::new(0, 1),
            Duration::new(6, 0)
        );

        assert_eq!(
            Duration::new(0, 0) + Duration::new(0, 0),
            Duration::new(0, 0)
        );

        assert_eq!(
            Duration::new(i64::MAX, 999_999_999) + Duration::new(0,1),
            Duration::MAX
        );

        assert_eq!(
            Duration::new(i64::MIN, -999_999_999) + Duration::new(0,-1),
            Duration::MIN
        );

        // This test could panic due to the std::crate::Duration being larger than the max value
        // for the crate::Duration, if the max value constraint in the time crate was not respected.
        // assert_eq!(
        //     Duration::new(1, 0) + StdDuration::new(1, 0),
        //     Duration::new(2, 0)
        // );
    }
}
False
========================================
    use crate::Duration;
    use std::crate::Duration as StdDuration;
    use std::ops::AddAssign;

    #[test]
    fn duration_add_assign_std_duration() {
        let mut duration = Duration::seconds(5);
        let std_duration = StdDuration::new(5, 0);
        duration.add_assign(std_duration);
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn duration_add_assign_std_duration_with_nanoseconds() {
        let mut duration = Duration::new(1, 500_000_000); // 1.5 seconds
        let std_duration = StdDuration::new(1, 500_000_000); // 1.5 seconds
        duration.add_assign(std_duration);
        assert_eq!(duration, Duration::seconds(3));
    }

    #[test]
    fn duration_add_assign_std_duration_with_overflow() {
        let mut duration = Duration::new(i64::MAX, 999_999_999); // Maximum seconds + 999999999 nanoseconds
        let std_duration = StdDuration::new(0, 1); // 1 nanosecond, which should overflow
        duration.add_assign(std_duration);
        assert_eq!(duration, Duration::MAX); // Should saturate at Duration::MAX
    }

    #[test]
    fn duration_add_assign_std_duration_negative() {
        let mut duration = Duration::new(-5, 0); // -5 seconds
        let std_duration = StdDuration::new(3, 0); // 3 seconds
        duration.add_assign(std_duration);
        assert_eq!(duration, Duration::seconds(-2));
    }

    #[test]
    fn duration_add_assign_std_duration_negative_with_nanoseconds() {
        let mut duration = Duration::new(-1, -500_000_000); // -1.5 seconds
        let std_duration = StdDuration::new(1, 500_000_000); // 1.5 seconds
        duration.add_assign(std_duration);
        assert_eq!(duration, Duration::ZERO); // Should result in ZERO duration
    }

    #[test]
    fn duration_add_assign_std_duration_negative_overflow() {
        let mut duration = Duration::new(i64::MIN, -999_999_999); // Minimum seconds - 999999999 nanoseconds (Max negative duration)
        let std_duration = StdDuration::new(0, 1); // 1 nanosecond
        duration.add_assign(std_duration);
        assert_eq!(duration, Duration::new(i64::MIN, -999_999_998));
    }

    #[test]
    fn duration_add_assign_std_duration_to_zero() {
        let mut duration = Duration::ZERO;
        let std_duration = StdDuration::new(0, 0);
        duration.add_assign(std_duration);
        assert_eq!(duration, Duration::ZERO);
    }
}
False
========================================
    use crate::Duration;
    use std::ops::AddAssign;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_add_assign_duration() {
        let mut duration = Duration::seconds(5);
        duration.add_assign(Duration::seconds(3));
        assert_eq!(duration, Duration::seconds(8));
    }

    #[test]
    fn test_add_assign_std_duration() {
        let mut duration = Duration::seconds(5);
        let std_duration = StdDuration::new(3, 0);
        duration.add_assign(Duration::from(std_duration));
        assert_eq!(duration, Duration::seconds(8));
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn test_add_assign_overflow() {
        let mut duration = Duration::MAX;
        duration.add_assign(Duration::seconds(1));
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn test_add_assign_std_overflow() {
        let mut duration = Duration::MAX;
        let std_duration = StdDuration::new(2, 0);
        duration.add_assign(Duration::from(std_duration));
    }

    #[test]
    fn test_add_assign_negative() {
        let mut duration = Duration::seconds(-5);
        duration.add_assign(Duration::seconds(3));
        assert_eq!(duration, Duration::seconds(-2));
    }

    #[test]
    fn test_add_assign_negative_std() {
        let mut duration = Duration::seconds(-5);
        let std_duration = StdDuration::new(3, 0);
        duration.add_assign(Duration::from(std_duration));
        assert_eq!(duration, Duration::seconds(-2));
    }

    #[test]
    fn test_add_assign_zero() {
        let mut duration = Duration::seconds(5);
        duration.add_assign(Duration::seconds(0));
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn test_add_assign_zero_std() {
        let mut duration = Duration::seconds(5);
        let std_duration = StdDuration::new(0, 0);
        duration.add_assign(Duration::from(std_duration));
        assert_eq!(duration, Duration::seconds(5));
    }
    
    #[test]
    fn duration_add_assign_nanos() {
        let mut duration = Duration::new(1, 500_000_000);
        let std_duration = Duration::nanoseconds(600_000_000);
        duration.add_assign(std_duration);
        assert_eq!(duration, Duration::new(2, 100_000_000));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use std::ops::Div;
    use std::convert::TryInto;

    #[test]
    fn div_by_positive() {
        let duration = Duration::seconds(10);
        let divisor = 2.0f32;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(5));
    }

    #[test]
    fn div_by_negative() {
        let duration = Duration::seconds(10);
        let divisor = -2.0f32;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(-5));
    }

    #[test]
    fn div_by_zero() {
        let duration = Duration::seconds(10);
        let divisor = 0.0f32;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds_f32(f32::INFINITY));
    }

    #[test]
    fn div_by_fraction() {
        let duration = Duration::seconds(10);
        let divisor = 2.5f32;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds_f32(4.0));
    }

    #[test]
    fn div_by_large_number() {
        let duration = Duration::seconds(10);
        let divisor = 1e6f32;
        let result = duration.div(divisor);
        assert!(result < Duration::seconds_f32(1.0));
    }

    #[test]
    fn div_by_small_fraction() {
        let duration = Duration::seconds(10);
        let divisor = 0.1f32;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(100));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Div;

    #[test]
    fn div_duration_by_positive_float() {
        let duration = Duration::seconds(10);
        let divisor = 2.0f64;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(5));
    }

    #[test]
    fn div_duration_by_negative_float() {
        let duration = Duration::seconds(10);
        let divisor = -2.0f64;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(-5));
    }

    #[test]
    fn div_duration_by_one() {
        let duration = Duration::seconds(10);
        let result = duration.div(1.0f64);
        assert_eq!(result, duration);
    }

    #[test]
    #[should_panic(expected = "division by zero")]
    fn div_duration_by_zero() {
        let duration = Duration::seconds(10);
        let _result = duration.div(0.0f64);
    }

    #[test]
    fn div_max_duration_by_float() {
        let duration = Duration::MAX;
        let divisor = 2.0f64;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::new(i64::MAX / 2, 499_999_999));
    }

    #[test]
    fn div_min_duration_by_float() {
        let duration = Duration::MIN;
        let divisor = 2.0f64;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::new(i64::MIN / 2, -500_000_000));
    }

    #[test]
    fn div_duration_with_fractional_part_by_float() {
        let duration = Duration::new(10, 500_000_000); // 10.5 seconds
        let divisor = 2.0f64;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::new(5, 250_000_000));
    }

    #[test]
    fn div_negative_duration_with_fractional_part_by_float() {
        let duration = Duration::new(-10, -500_000_000); // -10.5 seconds
        let divisor = 2.0f64;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::new(-5, -250_000_000));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Div;

    #[test]
    fn test_div_duration_by_i16() {
        // Create test cases
        let test_cases = vec![
            (Duration::new(2, 0), 2i16, Duration::new(1, 0)),
            (Duration::new(-2, 0), 2i16, Duration::new(-1, 0)),
            (Duration::new(2, 500_000_000), 2i16, Duration::new(1, 250_000_000)),
            (Duration::new(1, 0), 0i16, Duration::new(0, 0)),  // Expected to panic
            (Duration::new(1, 0), -1i16, Duration::new(-1, 0)),
            (Duration::nanoseconds_i128(2_000_000_000_000i128), 2i16, Duration::seconds(1)),
        ];

        for (duration, divisor, expected) in test_cases {
            let result = duration.div(divisor);
            assert_eq!(result, expected, "Dividing {:?} by {} failed", duration, divisor);
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Div;
    
    #[test]
    fn test_div_by_positive() {
        let duration = Duration::new(10, 500_000_000); // 10.5 seconds
        assert_eq!(duration / 2, Duration::new(5, 250_000_000));
    }

    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn test_div_by_zero() {
        let duration = Duration::new(10, 500_000_000); // 10.5 seconds
        let _ = duration / 0; // Should panic when dividing by zero
    }

    #[test]
    fn test_div_by_negative() {
        let duration = Duration::new(10, 0); // 10 seconds
        assert_eq!(duration / -2, Duration::new(-5, 0));
    }

    #[test]
    fn test_div_result_negative() {
        let duration = Duration::new(-10, 0); // -10 seconds
        assert_eq!(duration / 2, Duration::new(-5, 0));
    }

    #[test]
    fn test_div_with_fractional() {
        let duration = Duration::new(1, 500_000_000); // 1.5 seconds
        let result = duration / 2;
        // Since we can't specify the exact result due to the division implementation
        // details, we expect the seconds part to be zero and nanos to be roughly half.
        let expected_seconds = 0;
        let expected_nanos_range = 500_000_000..1_000_000_000;
        assert_eq!(result.whole_seconds(), expected_seconds);
        assert!(expected_nanos_range.contains(&result.subsec_nanoseconds()));
    }

    #[test]
    fn test_div_by_one() {
        let duration = Duration::new(10, 500_000_000); // 10.5 seconds
        assert_eq!(duration / 1, duration);
    }    
}
False
========================================
    use super::*;

use crate::*;
    use std::ops::Div;

    #[test]
    fn test_div_positive_duration_by_positive_i8() {
        let duration = Duration::seconds(8);
        let divisor: i8 = 2;
        let result = Duration::seconds(4);
        assert_eq!(duration.div(divisor), result);
    }

    #[test]
    fn test_div_positive_duration_by_negative_i8() {
        let duration = Duration::seconds(8);
        let divisor: i8 = -2;
        let result = Duration::seconds(-4);
        assert_eq!(duration.div(divisor), result);
    }

    #[test]
    fn test_div_negative_duration_by_positive_i8() {
        let duration = Duration::seconds(-8);
        let divisor: i8 = 2;
        let result = Duration::seconds(-4);
        assert_eq!(duration.div(divisor), result);
    }

    #[test]
    fn test_div_negative_duration_by_negative_i8() {
        let duration = Duration::seconds(-8);
        let divisor: i8 = -2;
        let result = Duration::seconds(4);
        assert_eq!(duration.div(divisor), result);
    }

    #[test]
    fn test_div_duration_by_zero_i8() {
        let duration = Duration::seconds(8);
        let divisor: i8 = 0;
        let result = duration.div(divisor);
        assert!(result.is_negative()); // division by zero should overflow to negative infinity
    }

    #[test]
    fn test_div_max_duration_by_i8() {
        let duration = Duration::MAX;
        let divisor: i8 = 1;
        assert_eq!(duration.div(divisor), Duration::MAX);
    }

    #[test]
    fn test_div_min_duration_by_i8() {
        let duration = Duration::MIN;
        let divisor: i8 = 1;
        assert_eq!(duration.div(divisor), Duration::MIN);
    }

    #[test]
    fn test_div_duration_by_max_i8() {
        let duration = Duration::seconds(127);
        let divisor: i8 = i8::MAX;
        assert_eq!(duration.div(divisor), Duration::seconds(1));
    }

    #[test]
    fn test_div_duration_by_min_i8() {
        let duration = Duration::seconds(127);
        let divisor: i8 = i8::MIN;
        assert_eq!(duration.div(divisor), Duration::seconds(-1));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_div_duration_by_std_duration() {
        // Zero duration divided by 1 second std duration
        let dur = Duration::new(0, 0);
        let std_dur = StdDuration::new(1, 0);
        assert_eq!(dur / std_dur, 0.0);

        // One second duration divided by 1 second std duration
        let dur = Duration::new(1, 0);
        let std_dur = StdDuration::new(1, 0);
        assert_eq!(dur / std_dur, 1.0);

        // One second duration divided by 2 second std duration
        let dur = Duration::new(1, 0);
        let std_dur = StdDuration::new(2, 0);
        assert_eq!(dur / std_dur, 0.5);

        // Duration with nanos divided by 1 second std duration
        let dur = Duration::new(0, 500_000_000);
        let std_dur = StdDuration::new(1, 0);
        assert_eq!(dur / std_dur, 0.5);

        // Negative duration divided by 1 second std duration
        let dur = Duration::new(-1, 0);
        let std_dur = StdDuration::new(1, 0);
        assert_eq!(dur / std_dur, -1.0);

        // Duration divided by zero std duration
        let dur = Duration::new(1, 0);
        let std_dur = StdDuration::new(0, 0);
        let result = std::panic::catch_unwind(|| dur / std_dur);
        assert!(result.is_err());
    }
}
False
========================================
    use super::*; // Adjust this path according to the module structure

use crate::*;
    use std::ops::Div;

    #[test]
    fn div_by_zero() {
        let duration = Duration::seconds(10);
        let result = std::panic::catch_unwind(|| {
            let _ = duration.div(0);
        });
        assert!(result.is_err(), "Dividing duration by zero should panic");
    }

    #[test]
    fn positive_duration_division() {
        let duration = Duration::seconds(10);
        let divisor: u16 = 2;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(5), "10s divided by 2 should be 5s");
    }

    #[test]
    fn negative_duration_division() {
        let duration = Duration::seconds(-10);
        let divisor: u16 = 2;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(-5), "(-10)s divided by 2 should be (-5)s");
    }

    #[test]
    fn division_with_nanoseconds() {
        let duration = Duration::new(10, 500_000_000); // 10.5s
        let divisor: u16 = 2;
        let result = duration.div(divisor);
        // Result should be 5s + 250_000_000ns which is 5.25s
        assert_eq!(result, Duration::new(5, 250_000_000), "10.5s divided by 2 should be 5.25s");
    }

    #[test]
    fn duration_division_with_fractional_result() {
        let duration = Duration::seconds(10);
        let divisor: u16 = 3;
        let result = duration.div(divisor);
        // Result should be 3s + 333_333_333ns which is approximately 3.333333333s
        assert_eq!(result, Duration::new(3, 333_333_333), "10s divided by 3 should be approximately 3.333333333s");
    }

    #[test]
    fn large_duration_division() {
        let duration = Duration::seconds(i64::MAX);
        let divisor: u16 = u16::MAX;
        let result = duration.div(divisor);
        // Perform the division manually and check the result.
        let expected_seconds = i64::MAX / u16::MAX as i64;
        let expected_nanoseconds = ((i64::MAX % u16::MAX as i64) * 1_000_000_000i64 / u16::MAX as i64) as i32;
        let expected_duration = Duration::new(expected_seconds, expected_nanoseconds);
        assert_eq!(result, expected_duration, "Division of maximum i64 seconds by maximum u16 should be correct");
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Div;

    #[test]
    fn test_div_duration_by_u32_zero() {
        let duration = Duration::seconds(10);
        let divisor: u32 = 0;
        let result = std::panic::catch_unwind(|| duration.div(divisor));
        assert!(result.is_err());
    }

    #[test]
    fn test_div_duration_by_u32_non_zero() {
        let duration = Duration::seconds(10);
        let divisor: u32 = 2;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(5));
    }

    #[test]
    fn test_div_duration_by_u32_with_nanoseconds() {
        let duration = Duration::new(10, 500_000_000); // 10.5 seconds
        let divisor: u32 = 2;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::new(5, 250_000_000)); // 5.25 seconds
    }

    #[test]
    fn test_div_duration_by_u32_with_negative_duration() {
        let duration = Duration::seconds(-10);
        let divisor: u32 = 2;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::seconds(-5));
    }

    #[test]
    fn test_div_duration_by_u32_with_negative_duration_and_nanoseconds() {
        let duration = Duration::new(-10, -500_000_000); // -10.5 seconds
        let divisor: u32 = 2;
        let result = duration.div(divisor);
        assert_eq!(result, Duration::new(-5, -250_000_000)); // -5.25 seconds
    }

    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn test_div_duration_by_zero_panics() {
        let duration = Duration::seconds(1);
        let _result = duration.div(0_u32);
    }

    #[test]
    fn test_div_duration_by_one() {
        let duration = Duration::seconds(1);
        assert_eq!(duration.div(1_u32), Duration::seconds(1));
    }

    #[test]
    fn test_div_duration_with_fractional_result() {
        let duration = Duration::new(0, 1_000_000_000); // 1 second
        assert_eq!(duration.div(10_u32), Duration::new(0, 100_000_000)); // 0.1 seconds
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn div_duration_by_zero() {
        let duration = Duration::seconds(10);
        let result = std::panic::catch_unwind(|| {
            let _ = duration.div(0_u8);
        });
        assert!(result.is_err(), "Division by zero should panic");
    }

    #[test]
    fn div_duration_by_one() {
        let duration = Duration::seconds(10);
        assert_eq!(duration.div(1_u8), duration, "Division by 1 should yield the original duration");
    }

    #[test]
    fn div_duration_integer() {
        let duration = Duration::seconds(10);
        assert_eq!(duration.div(2_u8), Duration::seconds(5), "10s / 2 should be 5s");
    }

    #[test]
    fn div_duration_result_positive() {
        let duration = Duration::seconds(10);
        assert!(duration.div(5_u8).is_positive(), "Division result should be positive");
    }

    #[test]
    fn div_duration_result_negative() {
        let duration = Duration::seconds(-10);
        assert!(duration.div(5_u8).is_negative(), "Division result should be negative");
    }

    #[test]
    fn div_duration_overflow() {
        let duration = Duration::new(i64::MAX, 999_999_999);
        let result = std::panic::catch_unwind(|| {
            let _ = duration.div(1_u8);
        });
        assert!(result.is_err(), "Division leading to overflow should panic");
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Div;

    #[test]
    fn zero_div_zero() {
        let zero = Duration::ZERO;
        assert!(zero.div(zero).is_nan());
    }

    #[test]
    fn zero_div_nonzero() {
        let zero = Duration::ZERO;
        let nonzero = Duration::seconds(5);
        assert_eq!(zero.div(nonzero), 0.0);
    }

    #[test]
    fn nonzero_div_zero() {
        let zero = Duration::ZERO;
        let nonzero = Duration::seconds(5);
        let result = nonzero.div(zero);
        assert!(result.is_infinite());
        assert!(result.is_sign_positive());
    }

    #[test]
    fn nonzero_div_nonzero() {
        let duration1 = Duration::seconds(15);
        let duration2 = Duration::seconds(5);
        assert_eq!(duration1.div(duration2), 3.0);
    }

    #[test]
    fn negative_div_positive() {
        let negative = Duration::seconds(-15);
        let positive = Duration::seconds(5);
        assert_eq!(negative.div(positive), -3.0);
    }

    #[test]
    fn positive_div_negative() {
        let positive = Duration::seconds(15);
        let negative = Duration::seconds(-5);
        assert_eq!(positive.div(negative), -3.0);
    }

    #[test]
    fn negative_div_negative() {
        let duration1 = Duration::seconds(-15);
        let duration2 = Duration::seconds(-5);
        assert_eq!(duration1.div(duration2), 3.0);
    }

    #[test]
    fn div_with_nanoseconds() {
        let duration1 = Duration::new(1, 500_000_000); // 1.5 seconds
        let duration2 = Duration::new(0, 500_000_000); // 0.5 seconds
        assert_eq!(duration1.div(duration2), 3.0);
    }

    #[test]
    fn div_with_negative_nanoseconds() {
        let duration1 = Duration::new(-1, -500_000_000); // -1.5 seconds
        let duration2 = Duration::new(0, -500_000_000); // -0.5 seconds
        assert_eq!(duration1.div(duration2), 3.0);
    }
}
True
========================================
    use crate::duration::Duration;
    use std::ops::DivAssign;

    #[test]
    fn div_assign_by_positive() {
        let mut duration = Duration::seconds(10);
        duration /= 2f32; // divide by a positive float
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn div_assign_by_negative() {
        let mut duration = Duration::seconds(10);
        duration /= -2f32; // divide by a negative float
        assert_eq!(duration, Duration::seconds(-5));
    }

    #[test]
    fn div_assign_by_zero() {
        let mut duration = Duration::seconds(10);
        duration /= 0f32; // divide by zero
        assert!(duration.is_zero()); // assumes div by 0 gives zero duration
    }

    #[test]
    fn div_assign_by_one() {
        let mut duration = Duration::seconds(10);
        duration /= 1f32; // divide by one
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn div_assign_by_zero_panic() {
        let mut duration = Duration::seconds(10);
        duration /= 0f32; // intentionally cause a panic
        // No assertions needed; test success is panic
    }

    #[test]
    fn div_assign_fractional() {
        let mut duration = Duration::milliseconds(1500);
        duration /= 1.5f32; // divide by a float
        assert_eq!(duration, Duration::milliseconds(1000));
    }

    #[test]
    fn div_assign_large() {
        let mut duration = Duration::seconds(i64::MAX);
        duration /= 2f32;  // divide by a float
        assert_eq!(duration, Duration::seconds(i64::MAX / 2));
    }

    #[test]
    fn div_assign_small() {
        let mut duration = Duration::milliseconds(1);
        duration /= 1e6f32;  // divide by a large float to get nanoseconds
        assert_eq!(duration, Duration::nanoseconds(1));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::DivAssign;

    #[test]
    fn test_div_assign_zero_by_nonzero() {
        let mut duration = Duration::seconds(0);
        duration.div_assign(2.0);
        assert_eq!(duration, Duration::seconds(0));
    }

    #[test]
    fn test_div_assign_integer_seconds() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(2.0);
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn test_div_assign_fractional_seconds() {
        let mut duration = Duration::seconds(5);
        duration.div_assign(2.0);
        assert_eq!(duration, Duration::seconds_f64(2.5));
    }

    #[test]
    fn test_div_assign_negative() {
        let mut duration = Duration::seconds(-10);
        duration.div_assign(2.0);
        assert_eq!(duration, Duration::seconds(-5));
    }

    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn test_div_assign_divide_by_zero() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(0.0);
    }

    // This test checks that nanosecond precision is maintained after division.
    #[test]
    fn test_div_assign_nanoseconds() {
        let mut duration = Duration::seconds(10) + Duration::nanoseconds(500_000_000);
        duration.div_assign(2.0);
        assert_eq!(duration, Duration::seconds(5) + Duration::nanoseconds(250_000_000));
    }
}
True
========================================
    use crate::Duration;
    use std::ops::DivAssign;

    #[test]
    fn div_assign_by_positive() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(2);
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn div_assign_by_negative() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(-2);
        assert_eq!(duration, Duration::seconds(-5));
    }

    #[test]
    fn div_assign_by_zero() {
        let mut duration = Duration::seconds(10);
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            duration.div_assign(0);
        }));
        assert!(result.is_err());
    }

    #[test]
    fn div_assign_to_zero() {
        let mut duration = Duration::seconds(0);
        duration.div_assign(2);
        assert_eq!(duration, Duration::seconds(0));
    }

    #[test]
    fn div_assign_by_one() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(1);
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn div_assign_large_number() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(i16::MAX);
        assert_eq!(duration, Duration::new(0, 305));
    }

    #[test]
    fn div_assign_small_number() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(i16::MIN);
        assert_eq!(duration, Duration::new(0, -305));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::DivAssign;

    #[test]
    fn div_assign_with_positive_number() {
        let mut duration = Duration::seconds(10);
        duration /= 2;
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn div_assign_with_negative_number() {
        let mut duration = Duration::seconds(10);
        duration /= -2;
        assert_eq!(duration, Duration::seconds(-5));
    }

    #[test]
    fn div_assign_with_zero() {
        let mut duration = Duration::seconds(10);
        let original_duration = duration;
        duration /= 0;
        assert_eq!(duration, original_duration);
    }

    #[test]
    fn div_assign_with_one() {
        let mut duration = Duration::seconds(10);
        duration /= 1;
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn div_assign_with_max_value() {
        let mut duration = Duration::seconds(i64::MAX);
        duration /= 1;
        assert_eq!(duration, Duration::seconds(i64::MAX));
    }

    #[test]
    fn div_assign_with_min_value() {
        let mut duration = Duration::seconds(i64::MIN);
        duration /= -1;
        assert_eq!(duration, Duration::seconds(i64::MAX));
    }

    #[test]
    fn div_assign_with_overflow() {
        let mut duration = Duration::seconds(i64::MAX);
        duration /= 2;
        assert_eq!(duration, Duration::seconds(i64::MAX / 2));
    }

    #[test]
    fn div_assign_with_underflow() {
        let mut duration = Duration::seconds(i64::MIN);
        duration /= 2;
        assert_eq!(duration, Duration::seconds(i64::MIN / 2));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::DivAssign;

    #[test]
    fn div_assign_with_positive_i8() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(2i8);
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn div_assign_with_negative_i8() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(-2i8);
        assert_eq!(duration, Duration::seconds(-5));
    }

    #[test]
    fn div_assign_with_zero_i8() {
        let mut duration = Duration::seconds(10);
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            duration.div_assign(0i8);
        }));
        assert!(result.is_err());
    }

    #[test]
    fn div_assign_with_one_i8() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(1i8);
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn div_assign_with_max_i8() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(i8::MAX);
        assert_eq!(duration, Duration::seconds(10 / i8::MAX as i64));
    }

    #[test]
    fn div_assign_with_min_i8() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(i8::MIN);
        assert_eq!(duration, Duration::seconds(10 / i8::MIN as i64));
    }

    #[test]
    fn div_assign_with_i8_and_nanoseconds() {
        let mut duration = Duration::new(0, 10_000_000); // 10 milliseconds
        duration.div_assign(10i8);
        assert_eq!(duration, Duration::new(0, 1_000_000)); // 1 millisecond
    }

    #[test]
    fn div_assign_with_i8_and_negative_nanoseconds() {
        let mut duration = Duration::new(0, -10_000_000); // -10 milliseconds
        duration.div_assign(10i8);
        assert_eq!(duration, Duration::new(0, -1_000_000)); // -1 millisecond
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::DivAssign;

    #[test]
    fn div_assign_by_positive() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(2u16);
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn div_assign_by_one() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(1u16);
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    #[should_panic]
    fn div_assign_by_zero() {
        let mut duration = Duration::seconds(10);
        duration.div_assign(0u16);
    }

    #[test]
    fn div_assign_negative() {
        let mut duration = Duration::seconds(-10);
        duration.div_assign(2u16);
        assert_eq!(duration, Duration::seconds(-5));
    }

    #[test]
    fn div_assign_max_value() {
        let mut duration = Duration::MAX;
        duration.div_assign(2u16);
        assert_ne!(duration, Duration::MAX);
    }

    #[test]
    fn div_assign_min_value() {
        let mut duration = Duration::MIN;
        duration.div_assign(2u16);
        assert_ne!(duration, Duration::MIN);
    }
}
True
========================================
    use crate::Duration;
    use std::ops::DivAssign;

    #[test]
    fn test_div_assign_by_zero() {
        let mut duration = Duration::seconds(10);
        let zero = 0;
        std::panic::catch_unwind(move || {
            duration /= zero;
        })
        .expect_err("Division by zero should panic");
    }

    #[test]
    fn test_div_assign() {
        let test_cases = [
            (Duration::seconds(10), 2, Duration::seconds(5)),
            (Duration::seconds(10), 1, Duration::seconds(10)),
            (Duration::seconds(10), 10, Duration::seconds(1)),
            (Duration::seconds(10), 5, Duration::seconds(2)),
            (Duration::seconds(10), 3, Duration::seconds(3)), // Integer division
        ];

        for (mut duration, divisor, expected) in test_cases {
            duration /= divisor;
            assert_eq!(duration, expected, "Testing {:?} /= {}", duration, divisor);
        }
    }

    #[test]
    fn duration_div_assign_negatives() {
        let test_cases = [
            (Duration::seconds(-10), 2, Duration::seconds(-5)),
            (Duration::seconds(10), -2, Duration::seconds(-5)),
            (Duration::seconds(-10), -2, Duration::seconds(5)),
        ];

        for (mut duration, divisor, expected) in test_cases {
            duration /= divisor;
            assert_eq!(duration, expected, "Testing {:?} /= {}", duration, divisor);
        }
    }

    #[test]
    fn test_div_assign_with_max_values() {
        let mut duration = Duration::seconds(i64::MAX);
        duration /= 2;
        assert_eq!(duration, Duration::seconds(i64::MAX / 2));

        let mut duration = Duration::seconds(i64::MIN);
        let negative_one = -1_i64;
        let expected = if let Some(result) = duration.seconds.checked_div(negative_one) {
            Duration::seconds(result)
        } else {
            // if overflow happens, the duration should theoretically be able to contain i64::MAX
            Duration::seconds(i64::MAX)
        };
        duration /= negative_one;
        assert_eq!(duration, expected);
    }
}
False
========================================
    use crate::Duration;
    use std::ops::DivAssign;

    #[test]
    fn div_assign_by_zero() {
        let mut duration = Duration::seconds(5);
        let rhs: u8 = 0;
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            duration /= rhs;
        }));
        assert!(result.is_err());
    }

    #[test]
    fn div_assign_by_positive() {
        let mut duration = Duration::seconds(10);
        let rhs: u8 = 2;
        duration /= rhs;
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn div_assign_by_one() {
        let mut duration = Duration::seconds(10);
        let rhs: u8 = 1;
        duration /= rhs;
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn div_assign_negative() {
        let mut duration = Duration::seconds(-15);
        let rhs: u8 = 3;
        duration /= rhs;
        assert_eq!(duration, Duration::seconds(-5));
    }

    #[test]
    fn div_assign_by_max() {
        let mut duration = Duration::seconds(15);
        let rhs: u8 = u8::MAX;
        duration /= rhs;
        assert!(duration.is_negative());
    }

    #[test]
    fn div_assign_max_duration() {
        let mut duration = Duration::MAX;
        let rhs: u8 = 2;
        duration /= rhs;
        assert_eq!(duration, Duration::new(i64::MAX / 2, 499_999_999));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;

    #[test]
    fn mul_zero() {
        let duration = Duration::seconds(5);
        let result = duration.mul(0.0_f32);
        assert_eq!(result, Duration::seconds(0));
    }

    #[test]
    fn mul_one() {
        let duration = Duration::seconds(5);
        let result = duration.mul(1.0_f32);
        assert_eq!(result, duration);
    }

    #[test]
    fn mul_fraction() {
        let duration = Duration::seconds(5);
        let result = duration.mul(0.5_f32);
        assert_eq!(result, Duration::seconds_f32(2.5));
    }

    #[test]
    fn mul_negative() {
        let duration = Duration::seconds(5);
        let result = duration.mul(-1.0_f32);
        assert_eq!(result, Duration::seconds(-5));
    }

    #[test]
    fn mul_large() {
        let duration = Duration::seconds(2);
        let result = duration.mul(f32::MAX);
        // Expected to overflow and possibly saturate, depending on the implementation
        // Asserting the exact result may vary based on the implementation details
        // of Duration::seconds_f32 and how it handles large or infinite values.
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;

    #[test]
    fn test_mul_with_positive() {
        let duration = Duration::seconds(5);
        let multiplier: f64 = 2.5;
        let result = duration.mul(multiplier);
        assert_eq!(result, Duration::seconds(12) + Duration::milliseconds(500));
    }

    #[test]
    fn test_mul_with_negative() {
        let duration = Duration::seconds(5);
        let multiplier: f64 = -2.5;
        let result = duration.mul(multiplier);
        assert_eq!(result, -Duration::seconds(12) - Duration::milliseconds(500));
    }

    #[test]
    fn test_mul_with_zero() {
        let duration = Duration::seconds(5);
        let multiplier: f64 = 0.0;
        let result = duration.mul(multiplier);
        assert_eq!(result, Duration::ZERO);
    }

    #[test]
    fn test_mul_with_fraction() {
        let duration = Duration::milliseconds(1000);
        let multiplier: f64 = 0.5;
        let result = duration.mul(multiplier);
        assert_eq!(result, Duration::milliseconds(500));
    }

    #[test]
    fn test_mul_with_large_multiplier() {
        let duration = Duration::seconds(5);
        let multiplier: f64 = 1e12;
        let result = duration.mul(multiplier);
        assert_eq!(result, Duration::seconds(5e12 as i64));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;

    #[test]
    fn test_mul_with_positive() {
        let duration = Duration::seconds(5);
        let result = duration.mul(2i16);
        assert_eq!(result, Duration::seconds(10));
    }

    #[test]
    fn test_mul_with_negative() {
        let duration = Duration::seconds(5);
        let result = duration.mul(-2i16);
        assert_eq!(result, Duration::seconds(-10));
    }

    #[test]
    fn test_mul_with_zero() {
        let duration = Duration::seconds(5);
        let result = duration.mul(0i16);
        assert_eq!(result, Duration::seconds(0));
    }

    #[test]
    #[should_panic(expected = "overflow when multiplying duration")]
    fn test_mul_with_overflow() {
        let duration = Duration::seconds(i64::MAX);
        let _ = duration.mul(2i16);
    }
}
True
========================================
    use crate::Duration;
    use std::ops::Mul;

    #[test]
    fn mul_with_zero() {
        let duration = Duration::seconds(5);
        let multiplier = 0;
        assert_eq!(
            duration.clone().mul(multiplier),
            Duration::seconds(0),
            "Multiplying with zero should yield zero duration."
        );
    }

    #[test]
    fn mul_with_positive() {
        let duration = Duration::seconds(5);
        let multiplier = 2;
        assert_eq!(
            duration.clone().mul(multiplier),
            Duration::seconds(10),
            "Multiplying duration should be equivalent to duration * multiplier."
        );
    }

    #[test]
    fn mul_with_negative() {
        let duration = Duration::seconds(5);
        let multiplier = -2;
        assert_eq!(
            duration.clone().mul(multiplier),
            Duration::seconds(-10),
            "Multiplying with negative should yield a negative duration."
        );
    }

    #[test]
    #[should_panic(expected = "overflow when multiplying duration")]
    fn mul_with_overflow() {
        let duration = Duration::seconds(i64::MAX);
        let multiplier = 2;
        let _result = duration.mul(multiplier);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;

    #[test]
    fn test_mul_positive() {
        let duration = Duration::seconds(5);
        let result = duration.mul(2);
        assert_eq!(result, Duration::seconds(10));
    }

    #[test]
    fn test_mul_negative() {
        let duration = Duration::seconds(5);
        let result = duration.mul(-2);
        assert_eq!(result, Duration::seconds(-10));
    }

    #[test]
    fn test_mul_zero() {
        let duration = Duration::seconds(5);
        let result = duration.mul(0);
        assert_eq!(result, Duration::seconds(0));
    }

    #[test]
    #[should_panic(expected = "overflow when multiplying duration")]
    fn test_mul_overflow() {
        let duration = Duration::new(i64::MAX, 0);
        let _result = duration.mul(i8::MAX);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;

    #[test]
    fn mul_with_zero() {
        let duration = Duration::seconds(5);
        let result = duration.mul(0u16);
        assert_eq!(result, Duration::seconds(0));
    }

    #[test]
    fn mul_with_pos() {
        let duration = Duration::seconds(5);
        let result = duration.mul(2u16);
        assert_eq!(result, Duration::seconds(10));
    }

    #[test]
    #[should_panic(expected = "overflow when multiplying duration")]
    fn mul_with_overflow() {
        let duration = Duration::seconds(i64::MAX);
        let _result = duration.mul(2u16);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;

    #[test]
    fn mul_with_zero() {
        let duration = Duration::seconds(5);
        let multiplier: u32 = 0;
        assert_eq!(duration.mul(multiplier), Duration::seconds(0));
    }

    #[test]
    fn mul_with_positive() {
        let duration = Duration::seconds(5);
        let multiplier: u32 = 2;
        assert_eq!(duration.mul(multiplier), Duration::seconds(10));
    }

    #[test]
    fn mul_with_large_number() {
        let duration = Duration::MAX;
        let multiplier: u32 = u32::MAX;
        let result = duration.mul(multiplier);
        assert!(result.is_positive() && result > duration);
    }

    #[test]
    #[should_panic(expected = "overflow when multiplying duration")]
    fn mul_with_overflow() {
        let duration = Duration::seconds(i64::MAX);
        let multiplier: u32 = 2;
        let _result = duration.mul(multiplier);
    }

    #[test]
    fn mul_with_one() {
        let duration = Duration::seconds(5);
        let multiplier: u32 = 1;
        assert_eq!(duration.mul(multiplier), Duration::seconds(5));
    }

    #[test]
    fn mul_with_max_value() {
        let duration = Duration::seconds(1);
        let multiplier: u32 = u32::MAX;
        let result = duration.mul(multiplier);
        // we expect the duration to be a positive value, technically greater than the initial value,
        // but we cannot assert for a specific value due to potential overflow
        assert!(result.is_positive() && result > duration);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;
    use crate::Duration;

    #[test]
    fn test_mul_zero() {
        let duration = Duration::seconds(5);
        let result = duration.mul(0);
        assert_eq!(result, Duration::seconds(0));
    }

    #[test]
    fn test_mul_one() {
        let duration = Duration::seconds(5);
        let result = duration.mul(1);
        assert_eq!(result, Duration::seconds(5));
    }

    #[test]
    fn test_mul_two() {
        let duration = Duration::seconds(5);
        let result = duration.mul(2);
        assert_eq!(result, Duration::seconds(10));
    }

    #[test]
    fn test_mul_with_overflow() {
        let duration = Duration::seconds(i64::MAX);
        let result = std::panic::catch_unwind(|| duration.mul(2));
        assert!(result.is_err());
    }

    #[test]
    fn test_mul_negative() {
        let duration = Duration::seconds(5);
        let result = duration.mul(-1);
        assert_eq!(result, Duration::seconds(-5));
    }

    #[test]
    fn test_multiply_fractions() {
        let duration = Duration::milliseconds(500);
        let result = duration.mul(2);
        assert_eq!(result, Duration::seconds(1));
    }
}
True
========================================
    use crate::duration::Duration;
    use std::ops::MulAssign;
    use std::panic::UnwindSafe;

    #[test]
    fn mul_assign_by_positive() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2.0);
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn mul_assign_by_zero() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(0.0);
        assert_eq!(duration, Duration::ZERO);
    }

    #[test]
    fn mul_assign_by_negative() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(-2.0);
        assert_eq!(duration, Duration::seconds(-10));
    }

    #[test]
    fn mul_assign_by_fraction() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(1.5);
        assert_eq!(duration, Duration::seconds(7) + Duration::milliseconds(500));
    }

    #[test]
    fn mul_assign_by_large_number() {
        let mut duration = Duration::milliseconds(1);
        duration.mul_assign(1e7);
        assert_eq!(duration, Duration::seconds(10_000));
    }

    #[test]
    fn mul_assign_with_overflow() {
        let mut duration = Duration::seconds(i64::MAX);
        let duration_ref = &mut duration as &mut (dyn UnwindSafe);
        let should_panic = std::panic::catch_unwind(move || {
            duration_ref.mul_assign(2.0);
        });
        assert!(should_panic.is_err());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::ops::MulAssign;

    #[test]
    fn duration_mul_assign_with_zero() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(0.0);
        assert_eq!(duration, Duration::ZERO);
    }

    #[test]
    fn duration_mul_assign_with_positive() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(1.5);
        assert_eq!(duration, Duration::seconds(7) + Duration::milliseconds(500));
    }

    #[test]
    fn duration_mul_assign_with_negative() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(-2.0);
        assert_eq!(duration, Duration::seconds(-10));
    }

    #[test]
    #[should_panic]
    fn duration_mul_assign_with_infinity() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(f64::INFINITY);
    }

    #[test]
    #[should_panic]
    fn duration_mul_assign_with_nan() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(f64::NAN);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::MulAssign;

    #[test]
    fn mul_assign_with_positive() {
        let mut duration = duration::Duration::seconds(5);
        let multiplier: i16 = 2;
        duration.mul_assign(multiplier);
        assert_eq!(duration, duration::Duration::seconds(10));
    }

    #[test]
    fn mul_assign_with_negative() {
        let mut duration = duration::Duration::seconds(5);
        let multiplier: i16 = -2;
        duration.mul_assign(multiplier);
        assert_eq!(duration, duration::Duration::seconds(-10));
    }

    #[test]
    fn mul_assign_with_zero() {
        let mut duration = duration::Duration::seconds(5);
        let multiplier: i16 = 0;
        duration.mul_assign(multiplier);
        assert_eq!(duration, duration::Duration::seconds(0));
    }

    #[test]
    fn mul_assign_with_overflow() {
        let mut duration = duration::Duration::seconds(i64::MAX);
        let multiplier: i16 = 2;
        duration.mul_assign(multiplier);
        // Check for overflow, it should saturate to Duration::MAX
        assert_eq!(duration, duration::Duration::MAX);
    }

    #[test]
    fn mul_assign_with_underflow() {
        let mut duration = duration::Duration::seconds(i64::MIN);
        let multiplier: i16 = 2;
        duration.mul_assign(multiplier);
        // Check for underflow, it should saturate to Duration::MIN
        assert_eq!(duration, duration::Duration::MIN);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::MulAssign;

    #[test]
    fn mul_assign_by_positive() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn mul_assign_by_negative() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(-2);
        assert_eq!(duration, Duration::seconds(-10));
    }

    #[test]
    fn mul_assign_by_zero() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::seconds(0));
    }

    #[test]
    fn mul_assign_large_number() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(i32::MAX);
        assert_eq!(duration, Duration::seconds(5i64 * i32::MAX as i64));
    }

    #[test]
    fn mul_assign_with_overflow() {
        let mut duration = Duration::seconds(i64::MAX / 2 + 1);
        duration.mul_assign(2);
        assert!(duration.is_positive());
        assert_eq!(duration.whole_seconds(), i64::MAX);
    }

    #[test]
    fn mul_assign_with_underflow() {
        let mut duration = Duration::seconds(i64::MIN / 2 - 1);
        duration.mul_assign(2);
        assert!(duration.is_negative());
        assert_eq!(duration.whole_seconds(), i64::MIN);
    }

    #[test]
    fn mul_assign_with_nanos() {
        let mut duration = Duration::new(1, 500_000_000); // 1.5 seconds
        duration.mul_assign(2);
        assert_eq!(duration, Duration::new(3, 0));
    }

    #[test]
    fn mul_assign_with_negative_nanos() {
        let mut duration = Duration::new(-1, -500_000_000); // -1.5 seconds
        duration.mul_assign(2);
        assert_eq!(duration, Duration::new(-3, 0));
    }
}
True
========================================
    use crate::Duration;
    use std::ops::MulAssign;

    #[test]
    fn mul_assign_by_positive() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn mul_assign_by_negative() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(-2);
        assert_eq!(duration, Duration::seconds(-10));
    }

    #[test]
    fn mul_assign_by_zero() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::seconds(0));
    }

    #[test]
    fn mul_assign_by_one() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(1);
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn mul_assign_to_max() {
        let mut duration = Duration::seconds(i64::MAX / 2);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(i64::MAX));
    }

    #[test]
    #[should_panic(expected = "overflow when multiplying duration")]
    fn mul_assign_overflow() {
        let mut duration = Duration::seconds(i64::MAX);
        duration.mul_assign(2); // This should cause a panic due to overflow
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;
    use std::panic::{self, AssertUnwindSafe};
    use std::ops::MulAssign;

    #[test]
    fn mul_assign_zero() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(0);
        assert_eq!(duration, Duration::ZERO);
    }

    #[test]
    fn mul_assign_one() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(1);
        assert_eq!(duration, Duration::seconds(5));
    }

    #[test]
    fn mul_assign_positive() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2);
        assert_eq!(duration, Duration::seconds(10));
    }

    #[test]
    fn mul_assign_with_nanoseconds() {
        let mut duration = Duration::new(5, 500_000_000); // 5.5 seconds
        duration.mul_assign(2);
        assert_eq!(duration, Duration::new(11, 0));
    }

    #[test]
    fn mul_assign_with_overflow() {
        let mut duration = Duration::new(i64::MAX / 2 + 1, 0); // Use a value that will overflow when doubled
        let duration = AssertUnwindSafe(&mut duration);

        // Use `catch_unwind` to test for overflow panic in debug mode
        let result = panic::catch_unwind(move || {
            duration.0.mul_assign(2);
        });

        assert!(result.is_err());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::ops::MulAssign;

    #[test]
    fn mul_assign_zero_by_zero() {
        let mut duration = Duration::ZERO;
        duration.mul_assign(0u32);
        assert_eq!(duration, Duration::ZERO);
    }

    #[test]
    fn mul_assign_second_by_one() {
        let mut duration = Duration::SECOND;
        duration.mul_assign(1u32);
        assert_eq!(duration, Duration::SECOND);
    }

    #[test]
    fn mul_assign_second_by_two() {
        let mut duration = Duration::SECOND;
        duration.mul_assign(2u32);
        assert_eq!(duration, Duration::seconds(2));
    }

    #[test]
    fn mul_assign_max_by_one() {
        let mut duration = Duration::MAX;
        duration.mul_assign(1u32);
        assert_eq!(duration, Duration::MAX);
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn mul_assign_max_by_two() {
        let mut duration = Duration::MAX;
        duration.mul_assign(2u32);
    }

    #[test]
    fn mul_assign_negative_by_two() {
        let mut duration = Duration::seconds(-1);
        duration.mul_assign(2u32);
        assert_eq!(duration, Duration::seconds(-2));
    }

    #[test]
    fn mul_assign_millisecond_by_thousand() {
        let mut duration = Duration::MILLISECOND;
        duration.mul_assign(1_000u32);
        assert_eq!(duration, Duration::SECOND);
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn mul_assign_second_by_max() {
        let mut duration = Duration::SECOND;
        duration.mul_assign(u32::MAX);
    }

    #[test]
    fn mul_assign_subsecond_by_ten() {
        let mut duration = Duration::new(0, 1_000_000); // 1 ms
        duration.mul_assign(10u32);
        assert_eq!(duration, Duration::milliseconds(10));
    }
}
True
========================================
    use crate::Duration;
    use std::ops::MulAssign;

    #[test]
    fn mul_assign_by_zero_should_yield_zero() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(0);
        assert_eq!(Duration::seconds(0), duration);
    }

    #[test]
    fn mul_assign_by_one_should_yield_same_duration() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(1);
        assert_eq!(Duration::seconds(5), duration);
    }

    #[test]
    fn mul_assign_by_two_should_double_duration() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(2);
        assert_eq!(Duration::seconds(10), duration);
    }

    #[test]
    fn mul_assign_by_negative_one_should_negate_duration() {
        let mut duration = Duration::seconds(5);
        duration.mul_assign(-1i8 as u8);
        assert_eq!(Duration::seconds(-5), duration);
    }

    #[test]
    fn mul_assign_by_255_should_result_in_overflow_for_positive_duration() {
        let mut duration = Duration::seconds(i64::MAX);
        duration.mul_assign(255);
        assert_eq!(Duration::seconds(i64::MIN), duration);
    }

    #[test]
    fn mul_assign_by_255_should_result_in_overflow_for_negative_duration() {
        let mut duration = Duration::seconds(i64::MIN);
        duration.mul_assign(255);
        assert_eq!(Duration::seconds(i64::MIN), duration);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn neg_zero() {
        assert_eq!(-Duration::ZERO, Duration::ZERO);
    }

    #[test]
    fn neg_positive() {
        assert_eq!(-Duration::SECOND, Duration::new(-1, 0));
    }

    #[test]
    fn neg_negative() {
        assert_eq!(-Duration::new(-1, 0), Duration::SECOND);
    }

    #[test]
    fn neg_edge_cases() {
        assert_eq!(-Duration::MIN, Duration::MIN);
        assert_eq!(-Duration::MAX, Duration::MAX);
    }

    #[test]
    fn neg_nanosecond() {
        assert_eq!(-Duration::NANOSECOND, Duration::new(0, -1));
    }

    #[test]
    fn neg_microsecond() {
        assert_eq!(-Duration::MICROSECOND, Duration::new(0, -1_000));
    }

    #[test]
    fn neg_millisecond() {
        assert_eq!(-Duration::MILLISECOND, Duration::new(0, -1_000_000));
    }

    #[test]
    fn neg_mixed() {
        assert_eq!(-Duration::new(1, 500_000_000), Duration::new(-1, -500_000_000));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;

    #[test]
    fn sub_std_duration_with_no_overflow() {
        let time_duration = Duration::seconds(5);
        let std_duration = StdDuration::new(3, 0);
        let result = Duration::try_from(std_duration).unwrap();
        assert_eq!(time_duration.sub(result), Duration::seconds(2));
    }

    #[test]
    fn sub_std_duration_with_overflow() {
        let time_duration = Duration::seconds(5);
        let std_duration = StdDuration::new(u64::MAX, 999_999_999); // This will cause overflow
        let sub_result = std::panic::catch_unwind(|| {
            time_duration.sub(Duration::try_from(std_duration).unwrap())
        });
        assert!(sub_result.is_err());
    }

    #[test]
    #[should_panic(expected = "overflow converting `std::crate::Duration` to `crate::Duration`")]
    fn sub_std_duration_with_panic() {
        let time_duration = Duration::seconds(i64::MAX);
        let std_duration = StdDuration::new(u64::MAX, 0);
        let _ = time_duration.sub(Duration::try_from(std_duration).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::ops::Sub;

    #[test]
    fn test_sub_positive_durations() {
        let duration_a = Duration::new(5, 0);
        let duration_b = Duration::new(3, 0);
        let duration_c = duration_a - duration_b;
        assert_eq!(duration_c, Duration::new(2, 0));
    }

    #[test]
    fn test_sub_negative_durations() {
        let duration_a = Duration::new(-5, 0);
        let duration_b = Duration::new(-3, 0);
        let duration_c = duration_a - duration_b;
        assert_eq!(duration_c, Duration::new(-2, 0));
    }

    #[test]
    fn test_sub_mixed_sign_durations() {
        let duration_a = Duration::new(5, 0);
        let duration_b = Duration::new(-3, 0);
        let duration_c = duration_a - duration_b;
        assert_eq!(duration_c, Duration::new(8, 0));

        let duration_d = duration_b - duration_a;
        assert_eq!(duration_d, Duration::new(-8, 0));
    }

    #[test]
    fn test_sub_with_nanoseconds() {
        let duration_a = Duration::new(0, 500_000_000); // 0.5 seconds
        let duration_b = Duration::new(0, 300_000_000); // 0.3 seconds
        let duration_c = duration_a - duration_b;
        assert_eq!(duration_c, Duration::new(0, 200_000_000));
    }

    #[test]
    #[should_panic]
    fn test_sub_overflow() {
        let _ = Duration::MIN - Duration::new(0, 1);
    }
}

True
========================================
    use super::*;

use crate::*;
    use std::ops::SubAssign;
    use std::crate::Duration as StdDuration;

    #[test]
    fn sub_assign_positive_durations() {
        let mut duration = Duration::new(5, 0); // 5s
        let std_duration = StdDuration::new(2, 0); // 2s
        duration.sub_assign(std_duration);
        assert_eq!(duration, Duration::new(3, 0)); // 3s
    }

    #[test]
    fn sub_assign_negative_durations() {
        let mut duration = Duration::new(-5, 0); // -5s
        let std_duration = StdDuration::new(2, 0); // 2s
        duration.sub_assign(std_duration);
        assert_eq!(duration, Duration::new(-7, 0)); // -7s
    }

    #[test]
    fn sub_assign_zero_duration() {
        let mut duration = Duration::new(5, 0); // 5s
        let std_duration = StdDuration::new(0, 0); // 0s
        duration.sub_assign(std_duration);
        assert_eq!(duration, Duration::new(5, 0)); // 5s
    }

    #[test]
    fn sub_assign_to_zero() {
        let mut duration = Duration::new(5, 0); // 5s
        let std_duration = StdDuration::new(5, 0); // 5s
        duration.sub_assign(std_duration);
        assert_eq!(duration, Duration::new(0, 0)); // 0s
    }

    #[test]
    fn sub_assign_nanoseconds() {
        let mut duration = Duration::new(5, 500_000_000); // 5.5s
        let std_duration = StdDuration::new(2, 750_000_000); // 2.75s
        duration.sub_assign(std_duration);
        assert_eq!(duration, Duration::new(2, 750_000_000)); // 2.75s
    }

    #[test]
    fn sub_assign_with_nanos_remainder() {
        let mut duration = Duration::new(5, 0); // 5s
        let std_duration = StdDuration::new(2, 500_000_000); // 2.5s
        duration.sub_assign(std_duration);
        assert_eq!(duration, Duration::new(2, 500_000_000)); // 2.5s
    }

    #[test]
    fn sub_assign_overflow() {
        let mut duration = Duration::MIN; // minimum value
        let std_duration = StdDuration::new(1, 0); // 1s
        duration.sub_assign(std_duration);
        assert_eq!(duration, Duration::MIN); // still minimum value
    }

    #[test]
    fn sub_assign_underflow() {
        let mut duration = Duration::MAX; // maximum value
        let std_duration = StdDuration::new(u64::MAX, 999_999_999); // maximum std::crate::Duration
        duration.sub_assign(std_duration);
        assert_eq!(duration, Duration::MAX); // still maximum value
    }
}
False
========================================
    use crate::Duration;
    use std::ops::SubAssign;

    #[test]
    fn sub_assign_positive_durations() {
        let mut duration1 = Duration::seconds(10);
        let duration2 = Duration::seconds(5);
        duration1.sub_assign(duration2);
        assert_eq!(duration1, Duration::seconds(5));
    }

    #[test]
    fn sub_assign_negative_duration() {
        let mut duration1 = Duration::seconds(5);
        let duration2 = Duration::seconds(10);
        duration1.sub_assign(duration2);
        assert_eq!(duration1, Duration::seconds(-5));
    }

    #[test]
    fn sub_assign_mixed_durations() {
        let mut duration1 = Duration::seconds(-5);
        let duration2 = Duration::seconds(3);
        duration1.sub_assign(duration2);
        assert_eq!(duration1, Duration::seconds(-8));
    }

    #[test]
    fn sub_assign_with_nanoseconds() {
        let mut duration1 = Duration::new(1, 500_000_000); // 1.5 seconds
        let duration2 = Duration::new(0, 750_000_000); // 0.75 seconds
        duration1.sub_assign(duration2);
        assert_eq!(duration1, Duration::new(0, 750_000_000));
    }

    #[test]
    fn sub_assign_to_zero() {
        let mut duration1 = Duration::seconds(5);
        let duration2 = Duration::seconds(5);
        duration1.sub_assign(duration2);
        assert!(duration1.is_zero());
    }

    #[test]
    fn sub_assign_overflow() {
        let mut duration1 = Duration::new(i64::MIN, 0); // Minimum possible duration
        let duration2 = Duration::seconds(1);
        duration1.sub_assign(duration2);
        assert_eq!(duration1, Duration::new(i64::MIN, 0));
    }

    #[test]
    fn sub_assign_underflow() {
        let mut duration1 = Duration::new(i64::MAX, 999_999_999); // Maximum possible duration
        let duration2 = Duration::seconds(-1);
        duration1.sub_assign(duration2);
        assert_eq!(duration1, Duration::new(i64::MAX, 999_999_999));
    }
}
True
========================================
    use crate::Padding;
    use std::default::Default;

    #[test]
    fn test_padding_default() {
        let padding_default = Padding::default();
        assert!(matches!(padding_default, Padding::Optimize));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::error::Error as StdError;

    #[test]
    fn error_source_conversion_range() {
        let err = Error::ConversionRange(ConversionRange);
        assert!(err.source().is_some());
    }

    #[test]
    fn error_source_component_range() {
        let err = Error::ComponentRange(ComponentRange {
            name: "test_component",
            minimum: 0,
            maximum: 0,
            value: 0,
            conditional_range: false,
        });
        assert!(err.source().is_some());
    }

    #[cfg(feature = "local-offset")]
    #[test]
    fn error_source_indeterminate_offset() {
        let err = Error::IndeterminateOffset(IndeterminateOffset);
        assert!(err.source().is_some());
    }

    #[cfg(feature = "formatting")]
    #[test]
    fn error_source_format() {
        let err = Error::Format(Format);
        assert!(err.source().is_some());
    }

    #[cfg(feature = "parsing")]
    #[test]
    fn error_source_parse_from_description() {
        let err = Error::ParseFromDescription(ParseFromDescription);
        assert!(err.source().is_some());
    }

    #[cfg(feature = "parsing")]
    #[test]
    fn error_source_unexpected_trailing_characters() {
        let err = Error::UnexpectedTrailingCharacters;
        assert!(err.source().is_none());
    }

    #[cfg(feature = "parsing")]
    #[test]
    fn error_source_try_from_parsed() {
        let err = Error::TryFromParsed(TryFromParsed);
        assert!(err.source().is_some());
    }

    #[cfg(all(any(feature = "formatting", feature = "parsing"), feature = "alloc"))]
    #[test]
    fn error_source_invalid_format_description() {
        let err = Error::InvalidFormatDescription(InvalidFormatDescription);
        assert!(err.source().is_some());
    }

    #[test]
    fn error_source_different_variant() {
        let err = Error::DifferentVariant(DifferentVariant);
        assert!(err.source().is_some());
    }

    #[test]
    fn error_source_invalid_variant() {
        let err = Error::InvalidVariant(InvalidVariant);
        assert!(err.source().is_some());
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::{ComponentRange, DifferentVariant, Error};
    use std::convert::TryFrom;

    #[test]
    fn test_try_from_component_range_error() {
        let component_range_error = ComponentRange {
            name: "test_component",
            minimum: 0,
            maximum: 10,
            value: 11,
            conditional_range: false,
        };
        let error = Error::from(component_range_error);

        if let Ok(result) = ComponentRange::try_from(error) {
            assert_eq!(result.name(), "test_component");
            assert_eq!(result.is_conditional(), false);
        } else {
            panic!("try_from should have parsed a ComponentRange error");
        }
    }

    #[test]
    fn test_try_from_different_error_variant() {
        let different_variant_error = DifferentVariant;
        let error = Error::from(different_variant_error);

        let result = ComponentRange::try_from(error);
        assert!(result.is_err());
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::conversion_range::ConversionRange;
    use crate::error::different_variant::DifferentVariant;
    use crate::error::Error;
    use std::convert::TryFrom;

    #[test]
    fn test_try_from_for_conversion_range() {
        let conversion_range_error = ConversionRange;
        let error: Error = Error::ConversionRange(conversion_range_error);
        let result = ConversionRange::try_from(error);
        assert!(result.is_ok());
    }

    #[test]
    fn test_try_from_for_different_variant() {
        let different_variant_error = DifferentVariant;
        let error: Error = Error::DifferentVariant(different_variant_error);
        let result = ConversionRange::try_from(error);
        assert!(result.is_err());
    }
}
True
========================================
    use crate::error::{ComponentRange, ConversionRange, DifferentVariant, Error, InvalidVariant};
    use std::convert::TryFrom;

    #[test]
    fn try_from_error_for_different_variant() {
        let err = Error::DifferentVariant(DifferentVariant);
        assert_eq!(
            DifferentVariant::try_from(err),
            Ok(DifferentVariant)
        );
    }

    #[test]
    fn try_from_error_for_conversion_range() {
        let err = Error::ConversionRange(ConversionRange);
        assert_eq!(
            DifferentVariant::try_from(err),
            Err(DifferentVariant)
        );
    }

    #[test]
    fn try_from_error_for_component_range() {
        let err = Error::ComponentRange(ComponentRange {
            name: "test_component",
            minimum: 0,
            maximum: 10,
            value: 20,
            conditional_range: false,
        });
        assert_eq!(
            DifferentVariant::try_from(err),
            Err(DifferentVariant)
        );
    }

    #[test]
    fn try_from_error_for_invalid_variant() {
        let err = Error::InvalidVariant(InvalidVariant);
        assert_eq!(
            DifferentVariant::try_from(err),
            Err(DifferentVariant)
        );
    }

    // Add tests for other enum variants if necessary
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::{ComponentRange, ConversionRange, DifferentVariant, InvalidVariant};

    #[test]
    fn test_try_from_invalid_variant_error() {
        let error = crate::Error::InvalidVariant(InvalidVariant);
        let result = InvalidVariant::try_from(error);
        assert!(result.is_ok());
    }

    #[test]
    fn test_try_from_different_error_variant() {
        let error = crate::Error::ComponentRange(ComponentRange {
            name: "minute",
            minimum: 0,
            maximum: 59,
            value: 60,
            conditional_range: false,
        });
        let result = InvalidVariant::try_from(error);
        assert!(matches!(result, Err(DifferentVariant)));

        let error = crate::Error::ConversionRange(ConversionRange);
        let result = InvalidVariant::try_from(error);
        assert!(matches!(result, Err(DifferentVariant)));

        let error = crate::Error::DifferentVariant(DifferentVariant);
        let result = InvalidVariant::try_from(error);
        assert!(matches!(result, Err(DifferentVariant)));
    }
}
True
========================================
    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn days_trait_for_f64() {
        let duration_from_trait = (1.0_f64).days();
        let expected_duration = Duration::DAY;
        assert_eq!(duration_from_trait, expected_duration);

        let duration_from_trait_zero = (0.0_f64).days();
        assert!(duration_from_trait_zero.is_zero());

        let duration_from_trait_negative = (-1.0_f64).days();
        assert!(duration_from_trait_negative.is_negative());

        let duration_from_trait_positive = (0.0000001_f64).days();
        assert!(duration_from_trait_positive.is_positive());

        // Test the edges
        let duration_from_trait_max = (f64::MAX).days();
        assert_eq!(duration_from_trait_max, Duration::MAX);

        let duration_from_trait_min = (f64::MIN).days();
        assert_eq!(duration_from_trait_min, Duration::MIN);

        // Test some random value
        let days = 3.5_f64;
        let expected_seconds = days * 86_400.0; // 86_400 seconds in a day
        let duration_from_trait_random = days.days();
        let duration_as_seconds = duration_from_trait_random.as_seconds_f64();
        assert_eq!(duration_as_seconds, expected_seconds);
    }
}
True
========================================
    use crate::ext::NumericalDuration;
    use crate::Duration;

    #[test]
    fn one_hour() {
        assert_eq!(1.0f64.hours(), Duration::seconds(3600));
    }

    #[test]
    fn half_hour() {
        assert_eq!(0.5f64.hours(), Duration::seconds(1800));
    }

    #[test]
    fn zero_hour() {
        assert_eq!(0.0f64.hours(), Duration::seconds(0));
    }

    #[test]
    fn negative_hour() {
        assert_eq!((-1.0f64).hours(), Duration::seconds(-3600));
    }

    #[test]
    fn multiple_hours() {
        assert_eq!(2.5f64.hours(), Duration::seconds(9000));
    }

    #[test]
    fn fractional_hour() {
        assert_eq!(1.75f64.hours(), Duration::seconds(6300));
    }

    #[test]
    fn large_hour() {
        let hours = 1_000_000.0f64;
        assert_eq!(hours.hours(), Duration::seconds(hours as i64 * 3600));
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn hours_overflow() {
        let hours = f64::MAX;
        let _ = hours.hours();
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn hours_negative_overflow() {
        let hours = f64::MIN;
        let _ = hours.hours();
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn microseconds_positive() {
        assert_eq!(0.5f64.microseconds(), Duration::nanoseconds(500));
        assert_eq!(1.0f64.microseconds(), Duration::nanoseconds(1000));
        assert_eq!(1.5f64.microseconds(), Duration::nanoseconds(1500));
    }

    #[test]
    fn microseconds_negative() {
        assert_eq!((-0.5f64).microseconds(), Duration::nanoseconds(-500));
        assert_eq!((-1.0f64).microseconds(), Duration::nanoseconds(-1000));
        assert_eq!((-1.5f64).microseconds(), Duration::nanoseconds(-1500));
    }

    #[test]
    fn microseconds_edge_cases() {
        assert_eq!(f64::INFINITY.microseconds(), Duration::MAX);
        assert_eq!(f64::NEG_INFINITY.microseconds(), Duration::MIN);
        assert!(f64::NAN.microseconds().is_zero());
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;

    #[test]
    fn milliseconds_positive() {
        let milliseconds = 1500.0_f64;
        let duration = milliseconds.milliseconds();
        assert_eq!(duration.whole_seconds(), 1);
        assert_eq!(duration.subsec_milliseconds(), 500);
    }

    #[test]
    fn milliseconds_negative() {
        let milliseconds = -1500.0_f64;
        let duration = milliseconds.milliseconds();
        assert_eq!(duration.whole_seconds(), -2);
        assert_eq!(duration.subsec_milliseconds(), -500);
    }

    #[test]
    fn milliseconds_zero() {
        let milliseconds = 0.0_f64;
        let duration = milliseconds.milliseconds();
        assert!(duration.is_zero());
    }

    #[test]
    fn milliseconds_fraction_positive() {
        let milliseconds = 0.7_f64;
        let duration = milliseconds.milliseconds();
        let expected_nanos = (milliseconds * (Nanosecond.per(Millisecond) as f64)) as i32;
        assert_eq!(duration.subsec_nanoseconds(), expected_nanos);
    }

    #[test]
    fn milliseconds_fraction_negative() {
        let milliseconds = -0.7_f64;
        let duration = milliseconds.milliseconds();
        let expected_nanos = (milliseconds * (Nanosecond.per(Millisecond) as f64)) as i32;
        assert_eq!(duration.subsec_nanoseconds(), expected_nanos);
    }

    #[test]
    fn milliseconds_max_value() {
        let milliseconds = f64::MAX;
        let duration = milliseconds.milliseconds();
        assert_eq!(duration, Duration::MAX);
    }

    #[test]
    fn milliseconds_min_value() {
        let milliseconds = f64::MIN;
        let duration = milliseconds.milliseconds();
        assert!(duration.is_negative());
        assert_eq!(duration, Duration::MIN);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Duration;
    use std::crate::Duration as StdDuration;

    #[test]
    fn minutes_positive() {
        assert_eq!(5.0f64.minutes(), Duration::minutes(5));
        assert_eq!(1.0f64.minutes(), Duration::minutes(1));
        assert_eq!(0.5f64.minutes(), Duration::seconds(30));
    }

    #[test]
    fn minutes_negative() {
        assert_eq!((-5.0f64).minutes(), Duration::minutes(-5));
        assert_eq!((-1.0f64).minutes(), Duration::minutes(-1));
        assert_eq!((-0.5f64).minutes(), Duration::seconds(-30));
    }

    #[test]
    fn minutes_zero() {
        assert_eq!(0.0f64.minutes(), Duration::seconds(0));
    }

    #[test]
    fn minutes_fractional() {
        assert_eq!(1.5f64.minutes(), Duration::seconds(90));
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn minutes_max_value() {
        let _ = f64::MAX.minutes();
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn minutes_min_value() {
        let _ = f64::MIN.minutes();
    }

    #[test]
    fn minutes_std_duration() {
        let std_duration = StdDuration::from_secs(300); // 5 minutes as a `std::crate::Duration`
        let time_duration = 5.0f64.minutes();
        assert_eq!(time_duration, Duration::try_from(std_duration).unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn nanoseconds_positive() {
        let duration = 42.0f64.nanoseconds();
        assert_eq!(duration, Duration::nanoseconds(42));
    }

    #[test]
    fn nanoseconds_negative() {
        let duration = (-42.0f64).nanoseconds();
        assert_eq!(duration, Duration::nanoseconds(-42));
    }

    #[test]
    fn nanoseconds_zero() {
        let duration = 0.0f64.nanoseconds();
        assert_eq!(duration, Duration::nanoseconds(0));
    }

    #[test]
    fn nanoseconds_fractional() {
        let duration = 42.7f64.nanoseconds();
        let expected = Duration::nanoseconds(42) + Duration::nanoseconds(1) / 10;
        assert_eq!(duration, expected);
    }

    #[test]
    fn nanoseconds_large() {
        let duration = 1e9f64.nanoseconds();
        assert_eq!(duration, Duration::seconds(1));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{ext::NumericalDuration, Duration};

    #[test]
    fn seconds_positive() {
        assert_eq!(5.0f64.seconds(), Duration::seconds(5));
    }

    #[test]
    fn seconds_negative() {
        assert_eq!((-5.0f64).seconds(), Duration::seconds(-5));
    }

    #[test]
    fn seconds_zero() {
        assert_eq!(0.0f64.seconds(), Duration::ZERO);
    }

    #[test]
    fn seconds_fractional() {
        let expected = Duration::seconds(1) + Duration::milliseconds(500);
        assert_eq!(1.5f64.seconds(), expected);
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn seconds_overflow() {
        let _ = f64::MAX.seconds();
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn seconds_underflow() {
        let _ = f64::MIN.seconds();
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{ext::NumericalDuration, Duration};

    #[test]
    fn test_weeks_positive() {
        assert_eq!(1.0f64.weeks(), Duration::WEEK);
        assert_eq!(0.5f64.weeks(), Duration::DAY * 3.5);
        assert_eq!(2.0f64.weeks(), Duration::WEEK * 2);
    }

    #[test]
    fn test_weeks_negative() {
        assert_eq!((-1.0f64).weeks(), Duration::WEEK * -1);
        assert_eq!((-0.5f64).weeks(), Duration::DAY * -3.5);
        assert_eq!((-2.0f64).weeks(), Duration::WEEK * -2);
    }

    #[test]
    fn test_weeks_zero() {
        assert_eq!(0.0f64.weeks(), Duration::ZERO);
    }

    #[test]
    fn test_weeks_fractional() {
        assert_eq!(1.5f64.weeks(), Duration::DAY * 10.5);
        assert_eq!(0.1f64.weeks(), Duration::HOUR * 16.8);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;
    use crate::Duration;

    #[test]
    fn std_days_non_negative() {
        let days = 1f64;
        let std_duration = days.std_days();
        let expected_duration = StdDuration::from_secs(86400); // 1 day = 86400 seconds
        assert_eq!(std_duration, expected_duration);
    }

    #[test]
    #[should_panic]
    fn std_days_negative() {
        let days = -1f64;
        days.std_days();
    }

    #[test]
    fn std_days_large_number() {
        let days = 1e5f64;
        let std_duration = days.std_days();
        let expected_duration = StdDuration::from_secs((1e5f64 * 86400f64) as u64);
        assert_eq!(std_duration, expected_duration);
    }

    #[test]
    fn std_days_fractional() {
        let days = 0.5f64;
        let std_duration = days.std_days();
        let expected_duration = StdDuration::from_secs(43200); // 0.5 days = 43200 seconds
        assert_eq!(std_duration, expected_duration);
    }

    #[test]
    fn std_days_zero() {
        let days = 0f64;
        let std_duration = days.std_days();
        let expected_duration = StdDuration::from_secs(0);
        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_std_hours_positive() {
        let hours = 5.0;
        let duration = hours.std_hours();
        let expected = StdDuration::from_secs(5 * 60 * 60);
        assert_eq!(duration, expected);
    }

    #[test]
    #[should_panic]
    fn test_std_hours_negative() {
        let hours = -5.0;
        let _duration = hours.std_hours();
    }

    #[test]
    fn test_std_hours_zero() {
        let hours = 0.0;
        let duration = hours.std_hours();
        let expected = StdDuration::from_secs(0);
        assert_eq!(duration, expected);
    }

    #[test]
    fn test_std_hours_fractional() {
        let hours = 2.5;
        let duration = hours.std_hours();
        let expected = StdDuration::from_secs(2 * 60 * 60) + StdDuration::from_secs_f64(30.0 * 60.0);
        assert_eq!(duration, expected);
    }

    #[test]
    fn test_std_hours_large() {
        let hours = 1e5;
        let duration = hours.std_hours();
        let expected_secs = (hours as u64) * 60 * 60;
        let expected = StdDuration::from_secs(expected_secs);
        assert_eq!(duration, expected);
    }

    #[test]
    fn test_std_hours_max_value() {
        let hours = f64::MAX;
        let duration = hours.std_hours();
        let expected_secs = StdDuration::from_secs_f64(hours * 60.0 * 60.0);
        assert_eq!(duration, expected_secs);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;
    use crate::ext::NumericalDuration;

    #[test]
    fn std_microseconds_positive() {
        let value = 2.5f64;
        let duration = value.std_microseconds();
        let expected = StdDuration::from_micros(2);
        assert_eq!(duration, expected);
    }

    #[test]
    #[should_panic(expected = "assertion failed")]
    fn std_microseconds_negative() {
        let value = -1.0f64;
        let _ = value.std_microseconds();
    }

    #[test]
    fn std_microseconds_zero() {
        let value = 0f64;
        let duration = value.std_microseconds();
        let expected = StdDuration::from_micros(0);
        assert_eq!(duration, expected);
    }

    #[test]
    fn std_microseconds_large() {
        let value = 1_000_000f64;
        let duration = value.std_microseconds();
        let expected = StdDuration::from_micros(1_000_000);
        assert_eq!(duration, expected);
    }

    #[test]
    fn std_microseconds_fractional() {
        let value = 0.000001f64;
        let duration = value.std_microseconds();
        let expected = StdDuration::from_nanos(1);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;
 
    #[test]
    fn std_milliseconds_positive() {
        let f_duration: f64 = 1500.0;
        let std_duration = f_duration.std_milliseconds();
        let expected_duration = StdDuration::from_millis(1500);
        assert_eq!(std_duration, expected_duration);
    }

    #[test]
    #[should_panic(expected = "assertion failed")]
    fn std_milliseconds_negative() {
        let f_duration: f64 = -1500.0;
        let _std_duration = f_duration.std_milliseconds();
    }

    #[test]
    fn std_milliseconds_zero() {
        let f_duration: f64 = 0.0;
        let std_duration = f_duration.std_milliseconds();
        let expected_duration = StdDuration::from_millis(0);
        assert_eq!(std_duration, expected_duration);
    }

    #[test]
    fn std_milliseconds_fractional() {
        let f_duration: f64 = 1234.567;
        let std_duration = f_duration.std_milliseconds();
        let expected_duration = StdDuration::from_nanos((1234.567 * 1_000_000.0) as u64);
        assert_eq!(std_duration, expected_duration);
    }

    #[test]
    fn std_milliseconds_large_value() {
        let f_duration: f64 = f64::MAX / 1_000_000.0;
        let std_duration = f_duration.std_milliseconds();
        let expected_duration: StdDuration = StdDuration::from_nanos((f_duration * 1_000_000.0) as u64);
        assert_eq!(std_duration, expected_duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryInto;

    const NANOS_PER_MINUTE: f64 = 60.0 * 1e9;

    #[test]
    fn std_minutes_positive() {
        let minutes = 5.0;
        let duration: StdDuration = minutes.std_minutes();
        let expected: StdDuration = StdDuration::from_secs_f64(minutes * 60.0);
        assert_eq!(duration, expected);
    }

    #[test]
    fn std_minutes_zero() {
        let minutes = 0.0;
        let duration: StdDuration = minutes.std_minutes();
        let expected: StdDuration = StdDuration::from_secs_f64(minutes * 60.0);
        assert_eq!(duration, expected);
    }

    #[test]
    #[should_panic]
    fn std_minutes_negative() {
        let minutes = -5.0;
        let _duration: StdDuration = minutes.std_minutes();
    }

    #[test]
    fn std_minutes_fraction() {
        let minutes = 2.5;
        let duration: StdDuration = minutes.std_minutes();
        let expected: StdDuration = StdDuration::from_nanos((minutes * NANOS_PER_MINUTE) as u64);
        assert_eq!(duration, expected);
    }

    #[test]
    fn std_minutes_large_number() {
        let minutes = 1e6;
        let duration: StdDuration = minutes.std_minutes();
        let expected: StdDuration = StdDuration::from_nanos((minutes * NANOS_PER_MINUTE) as u64);
        assert_eq!(duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use std::convert::TryFrom;
    use std::cmp::Ordering;

    trait NumericalStdDuration {
        fn std_nanoseconds(self) -> StdDuration;
    }

    impl NumericalStdDuration for f64 {
        fn std_nanoseconds(self) -> StdDuration {
            assert!(self >= 0.);
            StdDuration::from_nanos(self as _)
        }
    }

    #[test]
    fn test_std_nanoseconds_positive() {
        let nanos = 1_000_000_000_f64;
        let duration = nanos.std_nanoseconds();
        assert_eq!(StdDuration::from_nanos(nanos as u64), duration);
    }

    #[test]
    #[should_panic]
    fn test_std_nanoseconds_negative() {
        let nanos = -1_000_000_000_f64;
        let _ = nanos.std_nanoseconds();
    }

    #[test]
    fn test_std_nanoseconds_zero() {
        let nanos = 0_f64;
        let duration = nanos.std_nanoseconds();
        assert_eq!(StdDuration::from_nanos(nanos as u64), duration);
    }

    #[test]
    fn test_std_nanoseconds_fractional() {
        let nanos = 123_456_789_f64;
        let duration = nanos.std_nanoseconds();
        assert_eq!(StdDuration::from_nanos(nanos as u64), duration);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;
    use crate::Duration;
    use std::convert::TryFrom;
    use std::assert_matches::assert_matches;

    #[test]
    #[should_panic(expected = "assertion failed")]
    fn std_seconds_negative_input() {
        (-1.0f64).std_seconds();
    }

    #[test]
    fn std_seconds_zero() {
        let result = 0.0f64.std_seconds();
        assert_eq!(result, StdDuration::from_secs(0));
    }

    #[test]
    fn std_seconds_whole_number() {
        let result = 1.0f64.std_seconds();
        assert_eq!(result, StdDuration::from_secs(1));
    }

    #[test]
    fn std_seconds_fractional() {
        let result = 1.5f64.std_seconds();
        assert_eq!(result, StdDuration::from_secs_f64(1.5));
    }

    #[test]
    fn std_seconds_large_number() {
        let result = 1e9f64.std_seconds();
        assert_eq!(result, StdDuration::from_secs(1e9 as u64));
    }

    #[test]
    fn std_seconds_boundary() {
        let result = f64::EPSILON.std_seconds();
        assert_matches!(result, StdDuration::new(0, _) if _ > 0);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalStdDuration;
    use std::crate::Duration as StdDuration;
    
    const NANOS_PER_SEC: u64 = 1_000_000_000;
    const SECS_PER_MIN: u64 = 60;
    const MINS_PER_HOUR: u64 = 60;
    const HOURS_PER_DAY: u64 = 24;
    const DAYS_PER_WEEK: u64 = 7;
    
    #[test]
    fn std_weeks_positive() {
        let positive_weeks = 2.0;
        let duration = positive_weeks.std_weeks();
        assert_eq!(duration, StdDuration::from_secs(2 * DAYS_PER_WEEK * HOURS_PER_DAY * MINS_PER_HOUR * SECS_PER_MIN));
    }

    #[test]
    fn std_weeks_zero() {
        let zero_weeks = 0.0;
        let duration = zero_weeks.std_weeks();
        assert_eq!(duration, StdDuration::from_secs(0));
    }

    #[test]
    #[should_panic]
    fn std_weeks_negative() {
        let negative_weeks = -1.0;
        let _duration = negative_weeks.std_weeks();
    }

    #[test]
    fn std_weeks_fractional() {
        let fractional_weeks = 1.5;
        let duration = fractional_weeks.std_weeks();
        assert_eq!(
            duration,
            StdDuration::from_secs_f64(1.5 * (DAYS_PER_WEEK * HOURS_PER_DAY * MINS_PER_HOUR * SECS_PER_MIN) as f64)
        );
    }

    #[test]
    fn std_weeks_boundary() {
        let boundary_weeks = f64::EPSILON;
        let duration = boundary_weeks.std_weeks();
        assert!(duration > StdDuration::from_secs(0));
    }

    #[test]
    fn std_weeks_large_number() {
        let large_weeks = 1e10;
        let duration = large_weeks.std_weeks();
        let expected_seconds = 1e10 * DAYS_PER_WEEK as f64 * HOURS_PER_DAY as f64 * MINS_PER_HOUR as f64 * SECS_PER_MIN as f64;
        assert!(duration.as_secs_f64() - expected_seconds < f64::EPSILON);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_days_negative() {
        assert_eq!((-1).days(), Duration::new(-1 * 86_400, 0));
    }

    #[test]
    fn test_days_zero() {
        assert_eq!(0.days(), Duration::new(0, 0));
    }

    #[test]
    fn test_days_positive() {
        assert_eq!(1.days(), Duration::new(1 * 86_400, 0));
    }

    #[test]
    fn test_days_max() {
        assert_eq!(i64::MAX.days(), Duration::days(i64::MAX));
    }

    #[test]
    fn test_days_min() {
        assert_eq!(i64::MIN.days(), Duration::days(i64::MIN));
    }

    #[test]
    fn test_days_bounds() {
        assert_eq!(Duration::MIN, Duration::new(i64::MIN, -999_999_999));
        assert_eq!(Duration::MAX, Duration::new(i64::MAX, 999_999_999));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn hours_zero() {
        assert_eq!(0.hours(), Duration::new(0, 0));
    }

    #[test]
    fn hours_positive() {
        assert_eq!(1.hours(), Duration::new(3600, 0));
        assert_eq!(2.hours(), Duration::new(7200, 0));
        assert_eq!(24.hours(), Duration::new(86400, 0));
    }

    #[test]
    fn hours_negative() {
        assert_eq!((-1).hours(), Duration::new(-3600, 0));
        assert_eq!((-2).hours(), Duration::new(-7200, 0));
        assert_eq!((-24).hours(), Duration::new(-86400, 0));
    }

    #[test]
    fn hours_edge_cases() {
        assert_eq!(i64::MAX.hours(), Duration::new(i64::MAX, 0));
        assert_eq!(i64::MIN.hours(), Duration::new(i64::MIN, 0));
    }
}
True
========================================
    use crate::ext::NumericalDuration;
    use crate::Duration;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn microseconds_positive() {
        assert_eq!(5.microseconds(), Duration::new(0, 5_000));
        assert_eq!(1_000_000.microseconds(), Duration::new(1, 0));
    }
    
    #[test]
    fn microseconds_negative() {
        assert_eq!((-5).microseconds(), Duration::new(0, -5_000));
        assert_eq!((-1_000_000).microseconds(), Duration::new(-1, 0));
    }
    
    #[test]
    fn microseconds_edge_cases() {
        assert_eq!(i64::MIN.microseconds(), Duration::new(i64::MIN / 1_000_000, ((i64::MIN % 1_000_000) * 1_000) as i32));
        assert_eq!(i64::MAX.microseconds(), Duration::new(i64::MAX / 1_000_000, ((i64::MAX % 1_000_000) * 1_000) as i32));
    }
    
    #[test]
    fn microseconds_std_duration() {
        assert_eq!(Duration::microseconds(1_000_000), StdDuration::from_micros(1_000_000));
        assert_eq!(Duration::microseconds(1), StdDuration::from_micros(1));
    }
}
False
========================================
    use crate::ext::NumericalDuration;
    use crate::Duration;
    use std::ops::Neg;
    use crate::macros::time;

    #[test]
    fn test_milliseconds() {
        assert_eq!(0i64.milliseconds(), Duration::ZERO);
        assert_eq!(1i64.milliseconds(), Duration::MILLISECOND);
        assert_eq!(1_000i64.milliseconds(), Duration::SECOND);
        assert_eq!((-1_000i64).milliseconds(), Duration::SECOND.neg());
        assert_eq!(1_500i64.milliseconds(), Duration::MILLISECOND * 1_500);
        assert_eq!((-1_500i64).milliseconds(), Duration::MILLISECOND * -1_500);
        assert_eq!(i64::MAX.milliseconds(), Duration::new(i64::MAX / 1_000, (i64::MAX % 1_000 * 1_000_000) as i32));
        assert_eq!(i64::MIN.milliseconds(), Duration::new(i64::MIN / 1_000, (i64::MIN % 1_000 * 1_000_000) as i32));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use std::ops::Neg;

    #[test]
    fn minutes_zero() {
        assert_eq!(<i64 as NumericalDuration>::minutes(0), Duration::ZERO);
    }

    #[test]
    fn minutes_one() {
        assert_eq!(<i64 as NumericalDuration>::minutes(1), Duration::MINUTE);
    }

    #[test]
    fn minutes_negative() {
        assert_eq!(<i64 as NumericalDuration>::minutes(-1), Duration::MINUTE.neg());
    }

    #[test]
    fn minutes_multiple() {
        assert_eq!(<i64 as NumericalDuration>::minutes(60), Duration::HOUR);
    }

    #[test]
    fn minutes_max() {
        assert_eq!(<i64 as NumericalDuration>::minutes(i64::MAX), Duration::saturating_seconds(i64::MAX * 60));
    }

    #[test]
    fn minutes_min() {
        assert_eq!(<i64 as NumericalDuration>::minutes(i64::MIN), Duration::saturating_seconds(i64::MIN * 60));
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::Duration;
    use core::crate::Duration as StdDuration;

    #[test]
    fn test_nanoseconds_positive() {
        assert_eq!(5_i64.nanoseconds(), Duration::new(0, 5));
    }

    #[test]
    fn test_nanoseconds_negative() {
        assert_eq!((-5_i64).nanoseconds(), Duration::new(0, -5));
    }

    #[test]
    fn test_nanoseconds_zero() {
        assert_eq!(0_i64.nanoseconds(), Duration::ZERO);
    }

    #[test]
    fn test_nanoseconds_std_duration_conversion() {
        assert_eq!(1_i64.nanoseconds(), Duration::try_from(StdDuration::new(0, 1)).unwrap());
    }

    #[test]
    #[should_panic(expected = "overflow")]
    fn test_nanoseconds_max_boundary() {
        assert_eq!(i64::MAX.nanoseconds(), Duration::new(i64::MAX / 1_000_000_000, (i64::MAX % 1_000_000_000) as i32));
    }

    #[test]
    #[should_panic(expected = "overflow")]
    fn test_nanoseconds_min_boundary() {
        assert_eq!(i64::MIN.nanoseconds(), Duration::new(i64::MIN / 1_000_000_000, (i64::MIN % 1_000_000_000) as i32));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn test_zero_seconds() {
        assert_eq!(Duration::seconds(0), Duration::ZERO);
    }

    #[test]
    fn test_positive_seconds() {
        assert_eq!(Duration::seconds(5), Duration::new(5, 0));
    }

    #[test]
    fn test_negative_seconds() {
        assert_eq!(Duration::seconds(-5), Duration::new(-5, 0));
    }

    #[test]
    fn test_large_positive_seconds() {
        assert_eq!(Duration::seconds(i64::MAX), Duration::new(i64::MAX, 0));
    }

    #[test]
    fn test_large_negative_seconds() {
        assert_eq!(Duration::seconds(i64::MIN), Duration::new(i64::MIN, 0));
    }
}
True
========================================
    use crate::ext::NumericalDuration;
    use crate::Duration;
    use core::crate::Duration as StdDuration;

    #[test]
    fn weeks_zero() {
        assert_eq!(Duration::weeks(0), Duration::ZERO);
    }

    #[test]
    fn weeks_one() {
        assert_eq!(Duration::weeks(1), Duration::seconds(604_800));
    }
    
    #[test]
    fn weeks_multiple() {
        assert_eq!(Duration::weeks(3), Duration::seconds(604_800 * 3));
    }
    
    #[test]
    fn weeks_negative() {
        assert_eq!(Duration::weeks(-2), Duration::seconds(604_800 * -2));
    }

    #[test]
    fn weeks_max() {
        assert_eq!(Duration::weeks(i64::MAX), Duration::MAX);
    }

    #[test]
    fn weeks_min() {
        assert_eq!(Duration::weeks(i64::MIN), Duration::MIN);
    }

    #[test]
    #[should_panic]
    fn weeks_overflow() {
        let _ = Duration::weeks(i64::MAX / 604_800 + 1);
    }
    
    #[test]
    #[should_panic]
    fn weeks_underflow() {
        let _ = Duration::weeks(i64::MIN / 604_800 - 1);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Instant as StdInstant;

    #[test]
    fn borrow_returns_reference_to_std_instant() {
        let instant = Instant::now();
        let std_instant_borrowed: &StdInstant = instant.borrow();
        assert_eq!(StdInstant::from(instant), *std_instant_borrowed);
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::crate::Instant as StdInstant;
    use std::crate::Duration as StdDuration;
    use crate::Instant;
    use crate::Duration;

    #[test]
    fn test_instant_eq() {
        let std_instant_now = StdInstant::now();
        let time_instant_now = Instant::now();

        let std_instant_later = std_instant_now + StdDuration::from_secs(1);
        let time_instant_later = time_instant_now + Duration::seconds(1);

        let std_instant_earlier = std_instant_now - StdDuration::from_secs(1);
        let time_instant_earlier = time_instant_now - Duration::seconds(1);

        let converted_time_instant = Instant::from(std_instant_now);

        assert_eq!(time_instant_now.eq(&std_instant_now), true);
        assert_eq!(time_instant_later.eq(&std_instant_now), false);
        assert_eq!(time_instant_now.eq(&std_instant_later), false);
        assert_eq!(time_instant_earlier.eq(&std_instant_now), false);
        assert_eq!(converted_time_instant.eq(&std_instant_now), true);
    }
}
False
========================================
    use crate::Instant;
    use std::crate::{Instant as StdInstant, Duration as StdDuration};
    use std::cmp::Ordering;

    #[test]
    fn test_instant_partial_cmp() {
        let time_instant_1 = Instant::now();
        let time_instant_2 = time_instant_1 + StdDuration::from_secs(1);
        let std_instant_1 = StdInstant::now();
        let std_instant_2 = std_instant_1 + StdDuration::from_secs(1);
        
        // Time instant should equal to std instant converted from it
        assert_eq!(time_instant_1.partial_cmp(&StdInstant::from(time_instant_1)), Some(Ordering::Equal));
        
        // Time instant + 1s should be greater than std instant converted from it before increment
        assert_eq!(time_instant_2.partial_cmp(&std_instant_1), Some(Ordering::Greater));
        
        // Time instant should be less than std instant converted from it after increment
        assert_eq!(time_instant_1.partial_cmp(&std_instant_2), Some(Ordering::Less));
        
        // Future time instant should be greater than std now
        assert!(time_instant_2.partial_cmp(&std_instant_1).unwrap() == Ordering::Greater);
        
        // Past time instant should be less than std now
        assert!(time_instant_1.partial_cmp(&StdInstant::now()).unwrap() == Ordering::Less);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Instant as StdInstant;

    #[test]
    fn as_ref_returns_correct_std_instant_reference() {
        let std_instant = StdInstant::now();
        let instant = Instant(std_instant);

        let std_instant_ref = instant.as_ref();
        assert_eq!(&std_instant, std_instant_ref, "as_ref should return a reference to the std::crate::Instant inside Instant");
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Instant as StdInstant;
    use crate::Instant;

    #[test]
    fn from_std_instant() {
        let std_instant = StdInstant::now();
        let my_instant = Instant::from(std_instant);
        assert_eq!(my_instant.into_inner(), std_instant);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_add_positive_duration() {
        let base = Instant::now();
        let duration = Duration::seconds(5);
        let result = base.add(duration);
        let expected_std_duration = StdDuration::new(5, 0);
        assert_eq!((result - base).unsigned_abs(), expected_std_duration);
    }

    #[test]
    fn test_add_negative_duration() {
        let base = Instant::now();
        let duration = Duration::seconds(-5);
        let result = base.add(duration);
        let expected_std_duration = StdDuration::new(5, 0);
        assert_eq!((base - result).unsigned_abs(), expected_std_duration);
    }

    #[test]
    fn test_add_zero_duration() {
        let base = Instant::now();
        let duration = Duration::seconds(0);
        let result = base.add(duration);
        assert_eq!(base, result);
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn test_add_duration_overflow() {
        let base = Instant::now();
        let duration = Duration::MAX;
        let _ = base.add(duration);
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn test_add_duration_underflow() {
        let base = Instant::now();
        let duration = Duration::MIN;
        let _ = base.add(duration);
    }
}
False
========================================
    use crate::Instant;
    use std::crate::Duration as StdDuration;
    use std::ops::Add;

    #[test]
    fn add_duration_to_instant() {
        let duration = StdDuration::new(5, 0); // 5 seconds
        let instant = Instant::now();
        let later = instant.add(duration);

        // The difference between `later` and `instant` should be 5 seconds (or slightly more due to processing time)
        let elapsed = later - instant;
        assert!(elapsed.into_inner().as_secs() >= 5);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::ops::AddAssign;
    use std::crate::Duration as StdDuration;

    #[test]
    fn add_assign_duration() {
        let mut instant = Instant::now();
        let original = instant;
        let duration = Duration::seconds(5);
        instant += duration;
        assert!(instant > original);
    }

    #[test]
    fn add_assign_std_duration() {
        let mut instant = Instant::now();
        let original = instant;
        let std_duration = StdDuration::from_secs(5);
        instant += Duration::try_from(std_duration).unwrap();
        assert!(instant > original);
    }

    #[test]
    fn add_assign_negative_duration() {
        let mut instant = Instant::now();
        let original = instant;
        let negative_duration = Duration::seconds(-5);
        instant += negative_duration;
        assert!(instant < original);
    }

    #[test]
    #[should_panic(expected = "overflow when adding duration")]
    fn add_assign_duration_overflow() {
        let mut instant = Instant::now();
        let max_duration = Duration::MAX;
        instant += max_duration;
    }

    #[test]
    #[should_panic(expected = "AddAssign::add_assign() cannot overflow")]
    fn add_assign_negative_duration_overflow() {
        let mut instant = Instant::now();
        let min_duration = Duration::MIN;
        instant += min_duration;
    }
}
False
========================================
    use crate::Instant;
    use std::crate::{Duration as StdDuration, Instant as StdInstant};

    #[test]
    fn test_add_assign_duration() {
        let std_duration = StdDuration::new(5, 0); // 5 seconds
        let mut instant = Instant::now();
        let initial = instant.into_inner();
        let added_std_instant = initial + std_duration;
        
        instant += std_duration;

        assert_eq!(instant.into_inner(), added_std_instant);
    }

    #[test]
    fn test_add_assign_negative_duration() {
        let std_duration = StdDuration::new(5, 0); // 5 seconds
        let mut instant = Instant::now();
        let initial = instant.into_inner();

        // If the duration is negative, add_assign should subtract the duration
        let negative_duration = -crate::Duration::new(5, 0).unwrap();
        let subtracted_std_instant = initial - std_duration;
        
        instant += negative_duration;

        assert_eq!(instant.into_inner(), subtracted_std_instant);
    }

    // Test to ensure add_assign functionality is working with a zero duration.
    #[test]
    fn test_add_assign_zero_duration() {
        let zero_duration = StdDuration::new(0, 0);
        let mut instant = Instant::now();
        let initial = instant.into_inner();
        
        instant += zero_duration;

        assert_eq!(instant.into_inner(), initial);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn sub_positive_duration() {
        let initial = Instant::now();
        let duration = Duration::seconds(5);
        let earlier = initial - duration;

        // Assuming the subtraction wraps correctly and the duration increment is 5 seconds
        assert!(earlier.elapsed() >= duration);
    }

    #[test]
    fn sub_negative_duration() {
        let initial = Instant::now();
        let duration = Duration::seconds(-5);
        let later = initial - duration;

        // Assuming the subtraction works correctly as addition for negative duration
        assert!(later.elapsed() < Duration::ZERO);
    }

    #[test]
    fn sub_zero_duration() {
        let initial = Instant::now();
        let duration = Duration::ZERO;
        let same = initial - duration;

        // Assuming no time has passed between the creation of the two instants
        assert_eq!(initial, same);
    }

    #[test]
    fn sub_std_duration() {
        let initial = Instant::now();
        let std_duration = StdDuration::from_secs(5);
        let earlier = initial - Duration::from(std_duration);

        // We use the std::crate::Duration as the decrement, and should get the same result
        assert!(earlier.elapsed() >= Duration::from(std_duration));
    }

    #[test]
    #[should_panic]
    fn sub_duration_overflow() {
        let initial = Instant::now();
        let duration = Duration::MIN;
        let _ = initial - duration;
        // This test is expected to panic due to overflow
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::{Duration as StdDuration, Instant as StdInstant};
    use std::thread::sleep;
    use crate::Instant;
    use crate::Duration;

    #[test]
    fn sub_std_duration() {
        let std_duration = StdDuration::from_secs(1);
        let instant = Instant::now();
        let later = instant + std_duration;

        assert_eq!(later - std_duration, instant);
    }

    #[test]
    #[should_panic]
    fn sub_std_duration_panic() {
        let instant = Instant::now();
        let std_duration = StdDuration::from_secs(1);
        let _ = instant - std_duration;
    }

    #[test]
    fn sub_std_duration_with_sleep() {
        let std_duration = StdDuration::from_millis(200);
        let instant = Instant::now();

        sleep(std_duration);
        let elapsed = instant.elapsed(). unsigned_abs();

        assert!( (instant + elapsed) - std_duration < (instant + elapsed) );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Instant as StdInstant;
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use crate::Instant;
    use std::cmp::Ordering;
    use std::convert::TryFrom;

    #[test]
    fn test_sub_instant_from_std_instant() {
        let std_instant1 = StdInstant::now();
        let std_duration = StdDuration::from_secs(5);
        let std_instant2 = std_instant1 + std_duration;
        let instant1 = Instant(std_instant1);
        let instant2 = Instant(std_instant2);
        let duration_between = instant2 - instant1;

        // Instant - StdInstant should be equivalent to Instant - Instant
        assert_eq!(instant2 - std_instant1, duration_between);

        // The duration should be about 5 seconds
        assert_eq!(duration_between.whole_seconds(), 5);
    }

    #[test]
    fn test_sub_instant_from_std_instant_with_instant_subtraction() {
        let instant1 = Instant::now();
        let instant2 = instant1 + Duration::seconds(5);
        let duration_between = instant2 - instant1;
        let std_instant1 = StdInstant::from(instant1);
        let std_instant2 = StdInstant::from(instant2);

        // The duration between the two instants should be exactly 5 seconds
        assert_eq!(duration_between.whole_seconds(), 5);

        // Instant - StdInstant using std_instant2 should also be 5 seconds
        assert_eq!((instant2 - std_instant1).whole_seconds(), 5);

        // Instant - StdInstant using std_instant1 should result in -5 seconds
        let result = instant1 - std_instant2;
        assert_eq!(result.whole_seconds(), -5);
        assert!(result.is_negative());
    }

    #[test]
    #[should_panic]
    fn test_sub_std_instant_from_instant_with_overflow() {
        // If adding the maximum duration does not cause a panic on StdInstant, the test should not continue
        if let Some(distant_past_instant) = StdInstant::now().checked_sub(StdDuration::from_secs(u64::MAX)) {
            let instant_now = Instant::now();

            // This should panic because std_instant is before the Instant epoch
            let _duration = instant_now - distant_past_instant;
        }
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::{Duration as StdDuration, Instant as StdInstant};
    use crate::{Duration, Instant};
    use crate::ext::NumericalStdDuration;

    #[test]
    fn instant_subtraction_with_equal_instants() {
        let instant1 = Instant::now();
        let instant2 = instant1;
        assert_eq!(instant1 - instant2, Duration::ZERO);
    }

    #[test]
    fn instant_subtraction_with_greater_instants() {
        let instant1 = Instant::now();
        let instant2 = instant1 - StdDuration::from_secs(1);
        assert_eq!(instant1 - instant2, Duration::seconds(1));
    }

    #[test]
    fn instant_subtraction_with_less_instants() {
        let instant1 = Instant::now();
        let instant2 = instant1 - StdDuration::from_secs(1);
        assert_eq!(instant2 - instant1, Duration::seconds(-1));
    }

    #[test]
    #[should_panic(expected = "overflow converting `std::crate::Duration` to `crate::Duration`")]
    fn instant_subtraction_panic_on_overflow() {
        let instant1 = Instant(StdInstant::now());
        let instant2 = Instant(StdInstant::now() - StdDuration::from_secs(u64::MAX));
        let _ = instant1 - instant2;
    }

    #[test]
    fn instant_subtraction_stays_within_bounds() {
        let instant1 = Instant::now();
        let instant2 = instant1.checked_sub(Duration::seconds(1)).unwrap();
        assert!(instant2 <= instant1);
        assert_eq!(instant1 - instant2, Duration::seconds(1));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn sub_assign_positive_duration() {
        let mut instant = Instant::now();
        let earlier_instant = instant;
        let duration = Duration::seconds(5);
        instant -= duration;
        assert!(instant <= earlier_instant);
    }

    #[test]
    fn sub_assign_negative_duration() {
        let mut instant = Instant::now();
        let later_instant = instant;
        let duration = Duration::seconds(-5);
        instant -= duration;
        assert!(instant >= later_instant);
    }

    #[test]
    fn sub_assign_zero_duration() {
        let mut instant = Instant::now();
        let same_instant = instant;
        let duration = Duration::seconds(0);
        instant -= duration;
        assert_eq!(instant, same_instant);
    }

    #[test]
    fn sub_assign_std_duration() {
        let mut instant = Instant::now();
        let earlier_instant = instant;
        let duration = StdDuration::from_secs(5);
        instant -= duration;
        assert!(instant <= earlier_instant);
    }

    #[test]
    fn sub_assign_edge_cases() {
        let mut instant = Instant::from(StdDuration::from_secs(u64::MAX));
        let duration = Duration::seconds(1);
        instant -= duration;
        // Check for wrapping or potential panic
        assert!(instant.elapsed().is_positive() || instant.elapsed().is_zero());

        // Subtraction that results in a negative duration, which should be handled correctly
        let mut near_epoch_instant = Instant::from(StdDuration::new(0, 1));
        let large_duration = Duration::seconds(i64::MAX);
        near_epoch_instant -= large_duration;
        // Check for wrapping or potential panic
        assert!(near_epoch_instant.elapsed().is_positive() || near_epoch_instant.elapsed().is_zero());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::{Duration as StdDuration, Instant as StdInstant};

    #[test]
    fn sub_assign_std_duration() {
        let mut instant = Instant::now();
        let std_duration = StdDuration::from_secs(5);
        let expected = instant - std_duration;
        instant -= std_duration;
        assert_eq!(instant, expected);
    }

    #[test]
    #[should_panic(expected = "subtraction underflow")]
    fn sub_assign_std_duration_with_overflow() {
        let mut instant = Instant(StdInstant::now() - StdDuration::from_secs(5));
        let std_duration = StdDuration::from_secs(10);
        instant -= std_duration; // this should panic due to underflow
    }

    #[test]
    fn sub_assign_duration() {
        let mut instant = Instant::now();
        let duration = Duration::seconds(5);
        let expected = instant - duration;
        instant -= duration;
        assert_eq!(instant, expected);
    }

    #[test]
    #[should_panic(expected = "subtraction underflow")]
    fn sub_assign_duration_with_overflow() {
        let mut instant = Instant(StdInstant::now() - StdDuration::from_secs(5));
        let duration = Duration::seconds(-10);
        instant -= duration; // this should panic due to overflow
    }

    #[test]
    fn sub_assign_zero_duration() {
        let mut instant = Instant::now();
        let duration = Duration::zero();
        let expected = instant - duration;
        instant -= duration;
        assert_eq!(instant, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::TryFrom;

    #[test]
    fn test_try_from_valid_month() {
        for i in 1..=12 {
            assert!(Month::try_from(i).is_ok());
        }
    }

    #[test]
    fn test_try_from_invalid_month() {
        for i in 0..u8::MIN {
            assert!(Month::try_from(i).is_err());
        }
        for i in 13..u8::MAX {
            assert!(Month::try_from(i).is_err());
        }
    }
}
True
========================================
    use super::*; // Assume this imports Month and necessary dependencies from the same file

use crate::*;
    use std::str::FromStr;

    // Test successful parsing for each month
    #[test]
    fn test_from_str_valid() {
        assert_eq!(Month::from_str("January").unwrap(), Month::January);
        assert_eq!(Month::from_str("February").unwrap(), Month::February);
        assert_eq!(Month::from_str("March").unwrap(), Month::March);
        assert_eq!(Month::from_str("April").unwrap(), Month::April);
        assert_eq!(Month::from_str("May").unwrap(), Month::May);
        assert_eq!(Month::from_str("June").unwrap(), Month::June);
        assert_eq!(Month::from_str("July").unwrap(), Month::July);
        assert_eq!(Month::from_str("August").unwrap(), Month::August);
        assert_eq!(Month::from_str("September").unwrap(), Month::September);
        assert_eq!(Month::from_str("October").unwrap(), Month::October);
        assert_eq!(Month::from_str("November").unwrap(), Month::November);
        assert_eq!(Month::from_str("December").unwrap(), Month::December);
    }

    // Test unsuccessful parsing for an invalid month
    #[test]
    fn test_from_str_invalid() {
        assert!(Month::from_str("NotAMonth").is_err());
    }
}
True
========================================
#[cfg(test)]
mod offset_date_time_eq_system_time_tests {
    use crate::{OffsetDateTime, macros::datetime, offset, Date, PrimitiveDateTime, UtcOffset};
    use std::crate::SystemTime;

    #[test]
    fn eq_system_time() {
        // Construct an OffsetDateTime
        let odt = OffsetDateTime::from_unix_timestamp(1_609_459_200).unwrap(); // 2021-01-01 0:00 UTC

        // Convert OffsetDateTime to SystemTime
        let st: SystemTime = odt.into();

        // They should be equal
        assert_eq!(odt, st.into());
    }

    #[test]
    fn eq_system_time_with_offset() {
        // Construct an OffsetDateTime with a non-zero UTC offset
        let odt = PrimitiveDateTime::new(
            Date::from_calendar_date(2021, crate::Month::January, 1).unwrap(),
            crate::Time::from_hms(0, 0, 0).unwrap(),
        ).assume_offset(UtcOffset::from_hms(1, 0, 0).unwrap());

        // Convert OffsetDateTime to SystemTime
        let st: SystemTime = odt.into();

        // Convert SystemTime to OffsetDateTime at UTC to compare
        let odt_utc: OffsetDateTime = st.into();

        // The OffsetDateTime converted to UTC should equal the original with offset
        assert_eq!(odt_utc, odt);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::cmp::Ordering;
    use std::crate::SystemTime;
    use time_macros::datetime;
    use crate::ext::NumericalDuration;
    use crate::OffsetDateTime;

    #[test]
    fn partial_cmp_with_system_time() {
        let odt = OffsetDateTime::UNIX_EPOCH;
        let sys_time = SystemTime::UNIX_EPOCH;
        assert_eq!(odt.partial_cmp(&sys_time), Some(Ordering::Equal));

        let later_odt = odt + 1.seconds();
        let later_sys_time = sys_time + std::crate::Duration::from_secs(1);
        assert_eq!(later_odt.partial_cmp(&later_sys_time), Some(Ordering::Equal));

        let earlier_odt = odt - 1.seconds();
        let earlier_sys_time = SystemTime::UNIX_EPOCH
            .checked_sub(std::crate::Duration::from_secs(1))
            .unwrap();
        assert_eq!(earlier_odt.partial_cmp(&earlier_sys_time), Some(Ordering::Equal));

        assert_eq!(later_odt.partial_cmp(&sys_time), Some(Ordering::Greater));
        assert_eq!(odt.partial_cmp(&later_sys_time), Some(Ordering::Less));
        assert_eq!(odt.partial_cmp(&earlier_sys_time), Some(Ordering::Greater));
        assert_eq!(earlier_odt.partial_cmp(&sys_time), Some(Ordering::Less));
    }
}
False
========================================
#[cfg(test)]
mod offset_date_time_tests {
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalDuration;
    use crate::macros::{datetime, offset};

    #[test]
    fn offset_date_time_from_system_time() {
        // Define the SystemTime corresponding to the UNIX_EPOCH
        let system_time_epoch = std::crate::SystemTime::UNIX_EPOCH;
        // Define the corresponding OffsetDateTime
        let offset_date_time_epoch = OffsetDateTime::UNIX_EPOCH;
        // Assert that `OffsetDateTime::from` gives the expected result
        assert_eq!(
            OffsetDateTime::from(system_time_epoch), offset_date_time_epoch
        );

        // Define a SystemTime that is offset from the UNIX_EPOCH
        let system_time_offset = system_time_epoch
            .checked_add(StdDuration::from_secs(1))
            .unwrap();
        // Define the corresponding OffsetDateTime
        let offset_date_time_offset = offset_date_time_epoch + 1.seconds();
        // Assert that `OffsetDateTime::from` gives the expected result
        assert_eq!(
            OffsetDateTime::from(system_time_offset),
            offset_date_time_offset
        );

        // Define a SystemTime that is before the UNIX_EPOCH
        let system_time_before_epoch = system_time_epoch
            .checked_sub(StdDuration::from_secs(1))
            .unwrap();
        // Define the corresponding OffsetDateTime
        let offset_date_time_before_epoch = offset_date_time_epoch - 1.seconds();
        // Assert that `OffsetDateTime::from` gives the expected result
        assert_eq!(
            OffsetDateTime::from(system_time_before_epoch),
            offset_date_time_before_epoch
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;
    use crate::OffsetDateTime;
    use crate::Time;

    #[test]
    fn add_duration_to_offset_date_time() {
        let base_time = Time::from_hms(14, 30, 0).unwrap();
        let base_date = Date::from_calendar_date(2023, Month::April, 6).unwrap();
        let base_offset = UtcOffset::UTC;
        let base_offset_date_time = OffsetDateTime::from_utc_datetime(PrimitiveDateTime::new(base_date, base_time));
        let base_offset_date_time = base_offset_date_time.to_offset(base_offset);

        let duration = Duration::seconds(4500); // 1 hour, 15 minutes
        let added_offset_date_time = base_offset_date_time.add(duration);
        let expected_time = Time::from_hms(15, 45, 0).unwrap();
        let expected_date = Date::from_calendar_date(2023, Month::April, 6).unwrap();
        let expected_offset_date_time = OffsetDateTime::from_utc_datetime(PrimitiveDateTime::new(expected_date, expected_time));
        let expected_offset_date_time = expected_offset_date_time.to_offset(base_offset);

        assert_eq!(added_offset_date_time, expected_offset_date_time);
    }
}
False
========================================
    use crate::{Duration, OffsetDateTime};
    use std::crate::Duration as StdDuration;
    use time_macros::datetime;

    #[test]
    fn add_std_duration_to_offset_date_time() {
        // Construct an OffsetDateTime instance
        let odt = datetime!(2021-02-20 12:00:00 UTC);

        // StdDuration instances to be added
        let durations = &[
            StdDuration::from_secs(1), // 1 second
            StdDuration::from_secs(60), // 1 minute
            StdDuration::from_secs(60 * 60), // 1 hour
            StdDuration::from_secs(60 * 60 * 24), // 1 day
            StdDuration::from_secs(60 * 60 * 24 * 7), // 1 week
        ];

        // Expected OffsetDateTime instances after addition
        let expected = &[
            datetime!(2021-02-20 12:00:01 UTC),
            datetime!(2021-02-20 12:01:00 UTC),
            datetime!(2021-02-20 13:00:00 UTC),
            datetime!(2021-02-21 12:00:00 UTC),
            datetime!(2021-02-27 12:00:00 UTC),
        ];

        // Perform the addition and check the results
        for (duration, &expected) in durations.iter().zip(expected) {
            assert_eq!(odt + Duration::from_std(*duration).unwrap(), expected);
        }
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;
    use crate::OffsetDateTime;
    use crate::Time;
    use crate::Date;
    use crate::DateTime;
    use crate::date::Month;
    use crate::date_crate::offset_kind::Fixed;
    use crate::error;
    use crate::util::DateAdjustment;
    use std::ops::AddAssign;
    use std::convert::TryFrom;
    use std::crate::SystemTime;
    use crate::PrimitiveDateTime;

    #[test]
    fn add_assign_duration() {
        let mut odt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::seconds(1);
        odt.add_assign(duration);
        assert_eq!(odt, OffsetDateTime::UNIX_EPOCH + duration);
    }

    #[test]
    fn add_assign_negative_duration() {
        let mut odt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::seconds(-1);
        odt.add_assign(duration);
        assert_eq!(odt, OffsetDateTime::UNIX_EPOCH + duration);
    }

    #[test]
    fn add_assign_zero_duration() {
        let mut odt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::ZERO;
        odt.add_assign(duration);
        assert_eq!(odt, OffsetDateTime::UNIX_EPOCH);
    }

    #[test]
    fn add_assign_large_duration() {
        let mut odt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::days(36525); // 100 years
        odt.add_assign(duration);
        assert_eq!(odt, OffsetDateTime::UNIX_EPOCH + duration);
    }

    #[test]
    fn add_assign_duration_wrapping() {
        let mut odt = OffsetDateTime::UNIX_EPOCH;
        odt.add_assign(Duration::MAX);
        // This will wrap around as Duration::MAX is the largest representable duration
        assert_eq!(odt, OffsetDateTime::UNIX_EPOCH + Duration::MAX);
    }
}
False
========================================
    use crate::OffsetDateTime;
    use std::ops::AddAssign;
    use std::crate::Duration as StdDuration;
    use crate::Duration;

    #[test]
    fn add_assign_std_duration() {
        let mut odt = OffsetDateTime::UNIX_EPOCH;
        let duration = StdDuration::from_secs(60);
        odt.add_assign(StdDuration::from_secs(60));
        assert_eq!(odt, OffsetDateTime::UNIX_EPOCH + Duration::seconds(60));
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::Duration;
    use std::ops::Sub;

    #[test]
    fn sub_duration() {
        let dt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::seconds(5);
        let result = dt - duration;
        assert_eq!(
            result,
            OffsetDateTime::UNIX_EPOCH - Duration::seconds(5),
            "Subtracting Duration from OffsetDateTime should yield the correct result"
        );
    }

    #[test]
    fn sub_duration_zero() {
        let dt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::seconds(0);
        let result = dt - duration;
        assert_eq!(
            result,
            OffsetDateTime::UNIX_EPOCH,
            "Subtracting zero Duration should yield the original OffsetDateTime"
        );
    }

    #[test]
    fn sub_duration_negative() {
        let dt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::seconds(-5);
        let result = dt - duration;
        assert_eq!(
            result,
            OffsetDateTime::UNIX_EPOCH + Duration::seconds(5),
            "Subtracting negative Duration should yield the OffsetDateTime incremented by the magnitude"
        );
    }

    #[test]
    fn sub_duration_boundary() {
        let dt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::MIN;
        let result = dt - duration;
        assert_eq!(
            result,
            OffsetDateTime::UNIX_EPOCH + Duration::MAX,
            "Subtracting MIN Duration should not panic or overflow"
        );
    }
}
True
========================================
#[cfg(test)]
mod offset_date_time_sub_tests {
    use crate::OffsetDateTime; // Change crate:: to use the inner definition
    use crate::Duration; // Change crate:: to use the inner definition
    use std::crate::Duration as StdDuration; // Fix the path
    use crate::macros::datetime; // Change use path to crate::macros::

    #[test]
    fn test_sub_duration() {
        assert_eq!(
            // Use the macros correctly
            datetime!(2022 - 01 - 01 0:00 UTC) - Duration::days(1),
            datetime!(2021 - 12 - 31 0:00 UTC),
        );
        assert_eq!(
            // Use the macros correctly
            datetime!(2022 - 01 - 01 0:00 UTC) - Duration::seconds(60),
            datetime!(2021 - 12 - 31 23:59 UTC),
        );
    }

    #[test]
    fn test_sub_std_duration() {
        assert_eq!(
            // Use the macros correctly
            datetime!(2022 - 01 - 01 0:00 UTC) - StdDuration::from_secs(86_400),
            datetime!(2021 - 12 - 31 0:00 UTC),
        );
        assert_eq!(
            // Use the macros correctly
            datetime!(2022 - 01 - 01 0:00 UTC) - StdDuration::from_secs(60),
            datetime!(2021 - 12 - 31 23:59 UTC),
        );
    }
}
False
========================================
#[cfg(test)]
mod offset_date_time_sub_system_time_tests {
    use crate::PrimitiveDateTime;
    use crate::UtcOffset;
    use std::ops::Sub;
    use std::crate::Duration as StdDuration;
    use std::crate::SystemTime;
    use crate::OffsetDateTime;

    #[test]
    fn sub_system_time() {
        // Create an instance of `OffsetDateTime`.
        let dt = PrimitiveDateTime::new(
            crate::Date::from_calendar_date(2023, crate::Month::March, 19).unwrap(),
            crate::Time::from_hms(12, 0, 0).unwrap(),
        );
        let odt = dt.assume_utc();

        // Create an instance of `SystemTime`.
        let sys_time = SystemTime::UNIX_EPOCH + StdDuration::from_secs(3_600); // 1 hour after UNIX_EPOCH

        // Perform the subtraction.
        let result = odt - sys_time;

        // The result should be a `Duration`.
        let expected = crate::Duration::hours(10);
        assert_eq!(
            result, expected,
            "Subtracting SystemTime should yield the expected Duration"
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDuration;
    use crate::PrimitiveDateTime;
    use crate::UtcOffset;
    use std::crate::SystemTime;
    use std::convert::TryFrom;
    use std::crate::Duration as StdDuration;

    #[test]
    fn sub_offset_date_time() {
        let datetime1 = OffsetDateTime::from_unix_timestamp(1_546_300_800).unwrap(); // 2019-01-01 0:00 UTC
        let datetime2 = OffsetDateTime::from_unix_timestamp(1_546_307_199).unwrap(); // 2019-01-01 1:00 UTC
        let duration = datetime2 - datetime1;

        assert_eq!(duration, 1.hours());

        // Subtracting a duration
        let datetime3 = datetime2 - duration;
        assert_eq!(datetime3, datetime1);

        // Subtracting a StdDuration
        let std_duration = StdDuration::from_secs(60 * 60);
        let datetime4 = datetime2 - std_duration;
        assert_eq!(datetime4, datetime1);

        // Subtracting SystemTime
        let system_time: SystemTime = SystemTime::try_from(datetime2).unwrap();
        let duration2 = datetime2 - system_time;
        assert_eq!(duration2, StdDuration::from_secs(0));

        // Subtracting another OffsetDateTime
        let duration3 = datetime2 - datetime1;
        assert_eq!(duration3, 1.hours());
        let datetime5 = datetime1 + duration3;
        assert_eq!(datetime5, datetime2);
    }
}
False
========================================
#[cfg(test)]
mod offset_date_time_sub_assign_tests {
    use crate::{Duration, OffsetDateTime, ext::NumericalDuration};
    use time_macros::{datetime, offset};

    #[test]
    fn sub_assign_duration() {
        let mut ny_datetime = datetime!(2022-07-08 17:00 -5);
        ny_datetime -= 5.hours();
        assert_eq!(ny_datetime, datetime!(2022-07-08 12:00 -5));
    }

    #[test]
    fn sub_assign_std_duration() {
        use core::crate::Duration as StdDuration;
        let mut ny_datetime = datetime!(2022-07-08 17:00 -5);
        ny_datetime -= StdDuration::from_secs(5 * 60 * 60);
        assert_eq!(ny_datetime, datetime!(2022-07-08 12:00 -5));
    }

    #[test]
    fn sub_assign_negative_duration() {
        let mut ny_datetime = datetime!(2022-07-08 17:00 -5);
        ny_datetime -= (-2).hours();
        assert_eq!(ny_datetime, datetime!(2022-07-08 19:00 -5));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use crate::macros::datetime;
    use crate::OffsetDateTime;

    #[test]
    fn sub_assign_std_duration() {
        let mut odt = datetime!(2022-01-01 0:00 +0);
        let duration = StdDuration::from_secs(60 * 60); // 1 hour
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 23:00 +0));
    }

    #[test]
    fn sub_assign_duration() {
        let mut odt = datetime!(2022-01-01 0:00 +0);
        let duration = Duration::minutes(30);
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 23:30 +0));
    }

    #[test]
    fn sub_assign_negative_std_duration() {
        let mut odt = datetime!(2022-01-01 0:00 +0);
        let duration = StdDuration::from_secs(2 * 60 * 60); // 2 hours
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 22:00 +0));
    }

    #[test]
    fn sub_assign_negative_duration() {
        let mut odt = datetime!(2022-01-01 0:00 +0);
        let duration = Duration::hours(2);
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 22:00 +0));
    }

    #[test]
    fn sub_assign_std_duration_with_offset() {
        let mut odt = datetime!(2022-01-01 0:00 +1);
        let duration = StdDuration::from_secs(60 * 60); // 1 hour
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 23:00 +1));
    }

    #[test]
    fn sub_assign_duration_with_offset() {
        let mut odt = datetime!(2022-01-01 0:00 +1);
        let duration = Duration::minutes(30);
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 23:30 +1));
    }

    #[test]
    fn sub_assign_negative_std_duration_with_offset() {
        let mut odt = datetime!(2022-01-01 0:00 +1);
        let duration = StdDuration::from_secs(2 * 60 * 60); // 2 hours
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 22:00 +1));
    }

    #[test]
    fn sub_assign_negative_duration_with_offset() {
        let mut odt = datetime!(2022-01-01 0:00 +1);
        let duration = Duration::hours(2);
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 22:00 +1));
    }

    #[test]
    fn sub_assign_std_duration_positive_offset() {
        let mut odt = datetime!(2022-01-01 0:00 +1);
        let duration = StdDuration::from_secs(1 * 60 * 60); // 1 hour
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 23:00 +1));
    }

    #[test]
    fn sub_assign_duration_positive_offset() {
        let mut odt = datetime!(2022-01-01 0:00 +1);
        let duration = Duration::minutes(90);
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 22:30 +1));
    }

    #[test]
    fn sub_assign_std_duration_negative_offset() {
        let mut odt = datetime!(2022-01-01 0:00 -1);
        let duration = StdDuration::from_secs(1 * 60 * 60); // 1 hour
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 23:00 -1));
    }

    #[test]
    fn sub_assign_duration_negative_offset() {
        let mut odt = datetime!(2022-01-01 0:00 -1);
        let duration = Duration::minutes(90);
        odt.sub_assign(duration);
        assert_eq!(odt, datetime!(2021-12-31 22:30 -1));
    }
}
False
========================================
    use crate::primitive_date_crate::PrimitiveDateTime;
    use crate::Duration;
    use time_macros::{date, time};

    #[test]
    fn test_primitive_date_time_add_duration() {
        let date_time = PrimitiveDateTime::new(date!(2022-12-31), time!(12:34:56));
        let duration = Duration::seconds(3);
        let result = date_time + duration;
        assert_eq!(result, PrimitiveDateTime::new(date!(2022-12-31), time!(12:34:59)));
    }

    #[test]
    fn test_primitive_date_time_add_duration_with_overflow() {
        let date_time = PrimitiveDateTime::new(date!(2022-12-31), time!(23:59:59));
        let duration = Duration::seconds(2);
        let result = date_time + duration;
        assert_eq!(result, PrimitiveDateTime::new(date!(2023-01-01), time!(0:0:1)));
    }

    #[test]
    fn test_primitive_date_time_add_duration_with_underflow() {
        let date_time = PrimitiveDateTime::new(date!(2022-01-01), time!(0:0:0));
        let duration = Duration::seconds(-1);
        let result = date_time + duration;
        assert_eq!(result, PrimitiveDateTime::new(date!(2021-12-31), time!(23:59:59)));
    }

    #[test]
    fn test_primitive_date_time_add_negative_duration() {
        let date_time = PrimitiveDateTime::new(date!(2022-12-31), time!(12:34:56));
        let duration = Duration::seconds(-3);
        let result = date_time + duration;
        assert_eq!(result, PrimitiveDateTime::new(date!(2022-12-31), time!(12:34:53)));
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use time_macros::datetime;

    #[test]
    fn add_std_duration() {
        let datetime = datetime!(2020-01-01 0:00);
        let duration = StdDuration::new(3600, 0); // One hour
        let result = datetime.add(duration);
        assert_eq!(result, datetime!(2020-01-01 1:00));
    }

    #[test]
    fn add_duration() {
        let datetime = datetime!(2020-01-01 0:00);
        let duration = Duration::seconds(90 * 60); // An hour and 30 minutes
        let result = datetime.add(duration);
        assert_eq!(result, datetime!(2020-01-01 1:30));
    }

    #[test]
    fn add_std_duration_overflow() {
        let datetime = PrimitiveDateTime::MAX;
        let duration = StdDuration::new(1, 0); // One second
        let result = datetime.add(duration);
        assert_eq!(result, PrimitiveDateTime::MAX);
    }

    #[test]
    fn add_duration_overflow() {
        let datetime = PrimitiveDateTime::MAX;
        let duration = Duration::seconds(1); // One second
        let result = datetime.add(duration);
        assert_eq!(result, PrimitiveDateTime::MAX);
    }

    #[test]
    fn add_std_duration_underflow() {
        let datetime = PrimitiveDateTime::MIN;
        let duration = StdDuration::new(1, 0); // One second
        let result = datetime.add(duration);
        assert_eq!(result, PrimitiveDateTime::MIN);
    }

    #[test]
    fn add_duration_underflow() {
        let datetime = PrimitiveDateTime::MIN;
        let duration = Duration::seconds(1); // One second
        let result = datetime.add(duration);
        assert_eq!(result, PrimitiveDateTime::MIN);
    }
}
False
========================================
    use crate::{Date, Duration, PrimitiveDateTime, Time, UtcOffset};
    use crate::ext::NumericalDuration;

    #[test]
    fn add_assign_duration() {
        let mut ny_date = PrimitiveDateTime::new(
            Date::from_calendar_date(2023, crate::Month::April, 6).unwrap(),
            Time::from_hms(14, 30, 0).unwrap(),
        );

        let original = ny_date;

        ny_date += 5.minutes();
        assert_eq!(
            ny_date, 
            original
                .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
                .assume_utc()
                .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
                .replace_date_time(PrimitiveDateTime::new(
                    Date::from_calendar_date(2023, crate::Month::April, 6).unwrap(),
                    Time::from_hms(14, 35, 0).unwrap()
                ))
        );

        ny_date += (-15).seconds();
        assert_eq!(
            ny_date, 
            original
                .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
                .assume_utc()
                .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
                .replace_date_time(PrimitiveDateTime::new(
                    Date::from_calendar_date(2023, crate::Month::April, 6).unwrap(),
                    Time::from_hms(14, 34, 45).unwrap()
                ))
        );

        // Overflowing add
        ny_date += 10.hours();
        assert_eq!(
            ny_date, 
            original
                .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
                .assume_utc()
                .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
                .replace_date_time(PrimitiveDateTime::new(
                    Date::from_calendar_date(2023, crate::Month::April, 7).unwrap(),
                    Time::from_hms(0, 34, 45).unwrap()
                ))
        );

        // Overflowing sub
        ny_date += (-15).hours();
        assert_eq!(
            ny_date, 
            original
                .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
                .assume_utc()
                .assume_offset(UtcOffset::from_hms(-5, 0, 0).unwrap())
                .replace_date_time(PrimitiveDateTime::new(
                    Date::from_calendar_date(2023, crate::Month::April, 6).unwrap(),
                    Time::from_hms(9, 34, 45).unwrap()
                ))
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime; // Updated path
    use std::crate::Duration as StdDuration; // Adjusted path
    use crate::macros::{datetime, time}; // Updated path
    use crate::Duration; // Added import
    use crate::Time;

    // Adjusted test function names to avoid potential name collision
    #[test]
    fn add_assign_std_duration_test() {
        let mut dt = PrimitiveDateTime::new(datetime!(2022-02-15).date(), time!(12:00));
        dt += Duration::new(2 * 3600 + 30 * 60, 15); // Use Duration from `time`, adding seconds and nanoseconds
        assert_eq!(dt, PrimitiveDateTime::new(datetime!(2022-02-15).date(), time!(14:30:00.000_000_015)));
    }

    #[test]
    fn add_assign_std_duration_rollover_test() {
        let mut dt = PrimitiveDateTime::new(datetime!(2022-02-15).date(), time!(23:45));
        dt += Duration::new(3600, 0); // Use Duration from `time`, adding seconds
        assert_eq!(dt, PrimitiveDateTime::new(datetime!(2022-02-16).date(), time!(00:45)));
    }

    #[test]
    fn add_assign_std_duration_negative_test() {
        let mut dt = PrimitiveDateTime::new(datetime!(2022-02-15).date(), time!(02:30));
        dt += Duration::new(0, 0); // Use Duration from `time`, adding seconds and nanoseconds
        assert_eq!(dt, PrimitiveDateTime::new(datetime!(2022-02-15).date(), time!(02:30)));
    }

    #[test]
    fn add_assign_std_duration_end_of_month_test() {
        let mut dt = PrimitiveDateTime::new(datetime!(2022-02-28).date(), time!(23:00));
        dt += Duration::new(7200, 0); // Use Duration from `time`, adding seconds
        assert_eq!(dt, PrimitiveDateTime::new(datetime!(2022-03-01).date(), time!(01:00)));
    }

    #[test]
    fn add_assign_std_duration_large_test() {
        let mut dt = PrimitiveDateTime::new(datetime!(2022-02-15).date(), time!(23:45));
        dt += Duration::new(48 * 3600, 0); // Use Duration from `time`, adding seconds
        assert_eq!(dt, PrimitiveDateTime::new(datetime!(2022-02-17).date(), time!(23:45)));
    }

    #[test]
    fn add_assign_std_duration_leap_year_test() {
        let mut dt = PrimitiveDateTime::new(datetime!(2024-02-28).date(), time!(23:00));
        dt += Duration::new(3 * 3600, 0); // Use Duration from `time`, adding seconds
        assert_eq!(dt, PrimitiveDateTime::new(datetime!(2024-02-29).date(), time!(02:00)));
    }

    #[test]
    fn add_assign_std_duration_leap_second_test() {
        let mut dt = PrimitiveDateTime::new(datetime!(2022-06-30).date(), time!(23:59:59));
        dt += Duration::new(1, 0); // Use Duration from `time`, adding seconds
        assert_eq!(dt, PrimitiveDateTime::new(datetime!(2022-07-01).date(), time!(00:00:00)));
    }
}
False
========================================
#[cfg(test)]
mod primitive_date_time_sub_duration_tests {
    // Import the required items from the crate
    use crate::PrimitiveDateTime;
    use crate::{Duration, ext::NumericalDuration, macros::datetime, std::crate::Duration as StdDuration};

    #[test]
    fn sub_duration() {
        // Test with `Duration`
        assert_eq!(
            datetime!(2023-04-01 12:00) - 1.days(),
            datetime!(2023-03-31 12:00)
        );
        assert_eq!(
            datetime!(2023-04-01 00:00) - (-1).days(),
            datetime!(2023-04-02 00:00)
        );
        assert_eq!(
            datetime!(2023-04-01 12:00) - 1.5.days(),
            datetime!(2023-03-31 00:00)
        );
        assert_eq!(
            datetime!(2023-04-01 12:00) - (-1).minutes(),
            datetime!(2023-04-01 12:01)
        );
        
        // Test with `Duration` that cause wrapping
        assert_eq!(
            datetime!(2023-04-01 00:00) - 25.hours(),
            datetime!(2023-03-30 23:00)
        );
        assert_eq!(
            datetime!(2023-04-01 00:00) - (-23).hours(),
            datetime!(2023-04-01 23:00)
        );
        
        // Test with `std::crate::Duration`
        assert_eq!(
            datetime!(2023-04-01 12:00) - 1.std_days(),
            datetime!(2023-03-31 12:00)
        );
        assert_eq!(
            datetime!(2023-04-01 12:00) - StdDuration::from_secs(1 * 3600 + 30 * 60), // 1.5 hours
            datetime!(2023-04-01 10:30)
        );
        assert_eq!(
            datetime!(2023-04-01 00:00) - StdDuration::from_secs(90 * 60), // 1.5 hours
            datetime!(2023-03-31 22:30)
        );
    }
}
False
========================================
    use crate::{PrimitiveDateTime, Time};
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;
    use time_macros::{datetime, time};

    #[test]
    fn sub_std_duration() {
        // Subtract std::crate::Duration from PrimitiveDateTime
        assert_eq!(
            PrimitiveDateTime::new(date!(2022-01-01), time!(5:00)).sub(StdDuration::new(3600, 0)),
            PrimitiveDateTime::new(date!(2022-01-01), time!(4:00)),
            "Subtract 1 hour."
        );
        assert_eq!(
            PrimitiveDateTime::new(date!(2022-01-01), time!(0:30)).sub(StdDuration::new(5400, 0)),
            PrimitiveDateTime::new(date!(2021-12-31), time!(23:00)),
            "Subtract 90 minutes, wrapping to previous day."
        );
        assert_eq!(
            PrimitiveDateTime::new(date!(2022-01-01), time!(0:00)).sub(StdDuration::new(0, 1500_000_000)),
            PrimitiveDateTime::new(date!(2021-12-31), time!(23:59:58)).replace_nanosecond(500_000_000).unwrap(),
            "Subtract 1.5 seconds, wrapping to previous day."
        );
        assert_eq!(
            PrimitiveDateTime::new(date!(2022-01-01), time!(0:00)).sub(StdDuration::new(0, 0)),
            PrimitiveDateTime::new(date!(2022-01-01), time!(0:00)),
            "Subtract zero duration."
        );
    }
}
False
========================================
    use crate::{Date, PrimitiveDateTime, Time, Duration};
    use std::crate::Duration as StdDuration;

    #[test]
    fn sub_self() {
        let datetime1 = PrimitiveDateTime::new(
            Date::from_calendar_date(2023, crate::Month::March, 18).unwrap(),
            Time::from_hms(14, 30, 0).unwrap(),
        );
        let datetime2 = PrimitiveDateTime::new(
            Date::from_calendar_date(2023, crate::Month::March, 16).unwrap(),
            Time::from_hms(14, 30, 0).unwrap(),
        );
        let expected = Duration::new(2 * 86_400, 0); // 2 days
        assert_eq!(datetime1 - datetime2, expected);
    }

    #[test]
    fn sub_duration() {
        let datetime = PrimitiveDateTime::new(
            Date::from_calendar_date(2023, crate::Month::March, 18).unwrap(),
            Time::from_hms(14, 30, 0).unwrap(),
        );
        let duration = Duration::new(86_400, 0); // 1 day
        let expected = PrimitiveDateTime::new(
            Date::from_calendar_date(2023, crate::Month::March, 17).unwrap(),
            Time::from_hms(14, 30, 0).unwrap(),
        );
        assert_eq!(datetime - duration, expected);
    }

    #[test]
    fn sub_std_duration() {
        let datetime = PrimitiveDateTime::new(
            Date::from_calendar_date(2023, crate::Month::March, 18).unwrap(),
            Time::from_hms(14, 30, 0).unwrap(),
        );
        let duration = StdDuration::new(86_400, 0); // 1 day
        let expected = PrimitiveDateTime::new(
            Date::from_calendar_date(2023, crate::Month::March, 17).unwrap(),
            Time::from_hms(14, 30, 0).unwrap(),
        );
        assert_eq!(datetime - duration, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::primitive_date_crate::PrimitiveDateTime;
    use crate::OffsetDateTime;
    use crate::Duration;
    use crate::crate::Time;
    use crate::date::Date;
    use time_macros::time;
    use time_macros::date;

    #[test]
    fn sub_assign_duration() {
        let mut odt = PrimitiveDateTime::new(date!(2022-01-01), time!(12:00));
        odt -= 2.hours();
        assert_eq!(odt, PrimitiveDateTime::new(date!(2022-01-01), time!(10:00)));

        odt -= 10.hours();
        assert_eq!(odt, PrimitiveDateTime::new(date!(2021-12-31), time!(24:00)));

        odt -= 48.hours();
        assert_eq!(odt, PrimitiveDateTime::new(date!(2021-12-29), time!(24:00)));

        odt -= (-48).hours();
        assert_eq!(odt, PrimitiveDateTime::new(date!(2021-12-31), time!(24:00)));

        odt -= (-2).hours();
        assert_eq!(odt, PrimitiveDateTime::new(date!(2022-01-01), time!(2:00)));
    }
}
False
========================================
#[cfg(test)]
mod test_sub_assign {
    use core::ops::SubAssign;
    use std::crate::Duration as StdDuration;
    use crate::PrimitiveDateTime;
    use crate::Duration;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDuration;
    use time_macros::datetime;

    #[test]
    fn sub_assign_std() {
        let mut datetime = datetime!(2020-01-01 5:00);
        datetime.sub_assign(StdDuration::from_secs(2 * 3600)); // 2 hours
        assert_eq!(datetime, datetime!(2020-01-01 3:00));
    }

    #[test]
    fn sub_assign_duration() {
        let mut datetime = datetime!(2020-01-01 5:00);
        datetime.sub_assign(Duration::hours(2));
        assert_eq!(datetime, datetime!(2020-01-01 3:00));
    }

    #[test]
    fn sub_assign_duration_negative() {
        let mut datetime = datetime!(2020-01-01 0:00);
        datetime.sub_assign(Duration::hours(-2));
        assert_eq!(datetime, datetime!(2019-12-31 22:00));
    }

    #[test]
    fn sub_assign_std_negative() {
        let mut datetime = datetime!(2020-01-01 0:00);
        datetime.sub_assign(StdDuration::from_secs(2 * 3600)); // 2 hours
        assert_eq!(datetime, datetime!(2019-12-31 22:00));
    }
}
False
========================================
    use crate::{Duration, Time};
    use crate::macros::time;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_time_add_positive_duration_wraps() {
        assert_eq!(
            Time::MIDNIGHT + Duration::hours(24),
            Time::MIDNIGHT
        );
        assert_eq!(
            time!(23:59:59) + Duration::seconds(2),
            time!(0:00:01)
        );
    }

    #[test]
    fn test_time_add_negative_duration_wraps() {
        assert_eq!(
            Time::MIDNIGHT + Duration::hours(-1),
            time!(23:00)
        );
        assert_eq!(
            time!(0:00:01) + Duration::seconds(-2),
            time!(23:59:59)
        );
    }

    #[test]
    fn test_add_duration_to_time() {
        assert_eq!(
            time!(12:00) + Duration::hours(2),
            time!(14:00)
        );
        assert_eq!(
            time!(12:00) + Duration::minutes(30),
            time!(12:30)
        );
        assert_eq!(
            time!(12:00) + Duration::seconds(30),
            time!(12:00:30)
        );
        assert_eq!(
            time!(12:00) + Duration::milliseconds(500),
            time!(12:00:00.500)
        );
        assert_eq!(
            time!(12:00) + Duration::microseconds(500),
            time!(12:00:00.000_500)
        );
        assert_eq!(
            time!(12:00) + Duration::nanoseconds(500),
            time!(12:00:00.000_000_500)
        );
    }

    #[test]
    fn test_add_assign_duration_to_time() {
        let mut time = time!(12:00);
        time += Duration::minutes(30);
        assert_eq!(time, time!(12:30));
    }

    #[test]
    fn test_time_add_std_duration_wraps() {
        assert_eq!(
            Time::MIDNIGHT + StdDuration::from_secs(86_400),
            Time::MIDNIGHT
        );
        assert_eq!(
            time!(23:59:59) + StdDuration::from_secs(2),
            time!(0:00:01)
        );
    }

    #[test]
    fn test_time_sub_positive_duration_wraps() {
        assert_eq!(
            Time::MIDNIGHT - Duration::hours(1),
            time!(23:00)
        );
        assert_eq!(
            time!(0:00:01) - Duration::seconds(2),
            time!(23:59:59)
        );
    }

    #[test]
    fn test_time_sub_negative_duration_wraps() {
        assert_eq!(
            Time::MIDNIGHT - Duration::hours(-24),
            Time::MIDNIGHT
        );
        assert_eq!(
            time!(23:59:59) - Duration::seconds(-2),
            time!(0:00:01)
        );
    }

    #[test]
    fn test_sub_duration_from_time() {
        assert_eq!(
            time!(14:00) - Duration::hours(2),
            time!(12:00)
        );
        assert_eq!(
            time!(12:30) - Duration::minutes(30),
            time!(12:00)
        );
        assert_eq!(
            time!(12:00:30) - Duration::seconds(30),
            time!(12:00)
        );
        assert_eq!(
            time!(12:00:00.500) - Duration::milliseconds(500),
            time!(12:00)
        );
        assert_eq!(
            time!(12:00:00.000_500) - Duration::microseconds(500),
            time!(12:00)
        );
        assert_eq!(
            time!(12:00:00.000_000_500) - Duration::nanoseconds(500),
            time!(12:00)
        );
    }

    #[test]
    fn test_sub_assign_duration_from_time() {
        let mut time = time!(12:30);
        time -= Duration::minutes(30);
        assert_eq!(time, time!(12:00));
    }

    #[test]
    fn test_time_sub_std_duration_wraps() {
        assert_eq!(
            Time::MIDNIGHT - StdDuration::from_secs(1),
            time!(23:59:59)
        );
        assert_eq!(
            time!(0:00:01) - StdDuration::from_secs(2),
            time!(23:59:59)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use time_macros::time;

    #[test]
    fn add_std_duration_to_time_wraps_correctly() {
        assert_eq!(time!(23:30:00) + StdDuration::new(3600, 0), time!(00:30:00));
        assert_eq!(time!(23:30:00) + StdDuration::new(0, 500_000_000), time!(23:30:00.5));
        assert_eq!(time!(00:00:01) + StdDuration::new(1, 0), time!(00:00:02));
        assert_eq!(time!(23:59:59) + StdDuration::new(0, 1_000_000_000), time!(00:00:00));
        assert_eq!(time!(00:00:00) + StdDuration::new(2, 0), time!(00:00:02));
        assert_eq!(time!(23:59:59) + StdDuration::new(2, 0), time!(00:00:01));
        assert_eq!(time!(23:59:59) + StdDuration::new(0, 500_000_000), time!(23:59:59.5));
        assert_eq!(time!(12:00) + StdDuration::new(2 * 3600, 0), time!(14:00));
        assert_eq!(time!(23:59:59) + StdDuration::new(1, 1_000_000_000), time!(00:00:01));
    }

    #[test]
    fn add_std_duration_rollover() {
        assert_eq!(time!(23:59:59) + StdDuration::new(2, 0), time!(00:00:01));
    }

    #[test]
    fn add_std_duration_multiple_rollover() {
        assert_eq!(time!(23:59:59) + StdDuration::new(86400 + 2, 0), time!(00:00:01));
    }

    #[test]
    fn add_std_duration_subsecond_rollover() {
        assert_eq!(time!(23:59:59) + StdDuration::new(0, 2 * 1_000_000_000), time!(00:00:01));
    }

    #[test]
    fn add_std_duration_subsecond() {
        assert_eq!(time!(23:59:59.123_456_789) + StdDuration::new(0, 123_456_789), time!(23:59:59.246_913_578));
    }
}
False
========================================
    use crate::duration::Duration;
    use crate::Time;
    use std::ops::AddAssign;
    use time_macros::time;

    #[test]
    fn time_add_assign_duration() {
        let mut time = time!(12:00);
        time.add_assign(Duration::hours(2));
        assert_eq!(time, time!(14:00));

        let mut time = time!(23:30);
        time.add_assign(Duration::minutes(30));
        assert_eq!(time, time!(00:00));
    }
}
False
========================================
    use crate::*;
    use std::ops::AddAssign;
    use std::crate::Duration as StdDuration;

    #[test]
    fn time_add_assign_std_duration() {
        let mut time = Time::MIDNIGHT;

        // Add zero StdDuration to Time (shouldn't change)
        time.add_assign(StdDuration::from_secs(0));
        assert_eq!(time, Time::MIDNIGHT);

        // Add one second to Time (should increase second by 1)
        time.add_assign(StdDuration::from_secs(1));
        assert_eq!(time, Time::__from_hms_nanos_unchecked(0, 0, 1, 0));

        // Add one second and half a second as nanoseconds to Time (should increase second by 1 and nanoseconds by half a second)
        time.add_assign(StdDuration::new(1, 500_000_000));
        assert_eq!(time, Time::__from_hms_nanos_unchecked(0, 0, 2, 500_000_000));

        // Add enough seconds to wrap to next hour
        time.add_assign(StdDuration::new(3597, 500_000_000));
        assert_eq!(time, Time::__from_hms_nanos_unchecked(1, 0, 0, 0));

        // Add 24 hours and check for wrap around to midnight
        time.add_assign(StdDuration::from_secs(86400));
        assert_eq!(time, Time::MIDNIGHT);
    }

    #[test]
    fn time_add_assign_std_duration_overflow() {
        let mut time = Time::__from_hms_nanos_unchecked(23, 59, 59, 1_000_000_000 - 1);
        // Add one nanosecond should wrap to next day
        time.add_assign(StdDuration::from_nanos(1));
        assert_eq!(time, Time::MIDNIGHT);

        let mut time = Time::__from_hms_nanos_unchecked(23, 59, 59, 0);
        // Add more than one day should wrap around
        time.add_assign(StdDuration::from_secs(90000));
        assert_eq!(time, Time::__from_hms_nanos_unchecked(1, 0, 0, 0));
    }

    // Include more tests to cover edge cases, different time values, and StdDuration ranges
    // ...
}
False
========================================
    use crate::Time;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDuration;
    use time_macros::time;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_sub_duration() {
        assert_eq!(Time::from_hms(14, 0, 0).unwrap() - 2.hours(), Time::from_hms(12, 0, 0).unwrap());
        assert_eq!(Time::from_hms(23, 59, 59).unwrap() - (-2).seconds(), Time::from_hms(0, 0, 1).unwrap());
        assert_eq!(Time::from_hms(0, 0, 1).unwrap() - StdDuration::from_secs(2), Time::from_hms(23, 59, 59).unwrap());
        assert_eq!(Time::from_hms(0, 0, 0).unwrap() - StdDuration::from_secs(86_400), Time::from_hms(0, 0, 0).unwrap());
    }
}
False
========================================
    use crate::Time;
    use std::crate::Duration as StdDuration;
    use time_macros::time;

    #[test]
    fn sub_std_duration_from_time() {
        let time = time!(14:00);
        let std_duration = StdDuration::from_secs(2 * 3600); // 2 hours in seconds
        assert_eq!(time - std_duration, time!(12:00));

        let time = time!(0:00:01);
        let std_duration = StdDuration::from_secs(2); // 2 seconds
        assert_eq!(time - std_duration, time!(23:59:59));

        // Additional test case: subtraction leading to a date change
        let time = time!(0:00:00);
        let std_duration = StdDuration::from_secs(1); // 1 second
        assert_eq!(time - std_duration, time!(23:59:59));

        // Additional test case: subtraction with nanoseconds
        let time = time!(0:00:00.000_000_001);
        let std_duration = StdDuration::from_nanos(1); // 1 nanosecond
        assert_eq!(time - std_duration, time!(23:59:59.999_999_999));

        // Additional test case: subtraction with no change
        let time = time!(12:34:56.789_012_345);
        let std_duration = StdDuration::from_secs(0); // 0 seconds
        assert_eq!(time - std_duration, time);
    }
}
False
========================================
    use crate::{Duration, Time};
    use crate::ext::NumericalDuration;
    use std::ops::Sub;
    use time_macros::time;

    #[test]
    fn time_sub_same_times_results_in_zero_duration() {
        assert_eq!(
            Time::MIDNIGHT.sub(Time::MIDNIGHT),
            0.seconds()
        );
        assert_eq!(
            time!(12:00).sub(time!(12:00)),
            0.seconds()
        );
    }

    #[test]
    fn time_sub_different_times_results_in_correct_duration() {
        assert_eq!(
            time!(1:00).sub(time!(0:00)),
            1.hours()
        );
        assert_eq!(
            time!(0:00).sub(time!(1:00)),
            (-1).hours()
        );
        assert_eq!(
            time!(0:00).sub(time!(23:00)),
            (-23).hours()
        );
    }

    #[test]
    fn time_sub_with_minutes_and_seconds() {
        assert_eq!(
            time!(1:30).sub(time!(1:00)),
            30.minutes()
        );
        assert_eq!(
            time!(1:00:30).sub(time!(1:00)),
            30.seconds()
        );
    }

    #[test]
    fn time_sub_with_nanoseconds() {
        assert_eq!(
            Time::__from_hms_nanos_unchecked(0, 0, 0, 1_000_000_000).sub(Time::__from_hms_nanos_unchecked(23, 59, 59, 0)),
            1.seconds()
        );
    }

    #[test]
    fn time_sub_between_midnight_and_max_time() {
        assert_eq!(
            Time::MIDNIGHT.sub(Time::MAX),
            (-23).hours() - 59.minutes() - 59.seconds() - 999_999_999.nanoseconds()
        );
        assert_eq!(
            Time::MAX.sub(Time::MIDNIGHT),
            23.hours() + 59.minutes() + 59.seconds() + 999_999_999.nanoseconds()
        );
    }

    #[test]
    fn time_sub_with_date_adjustment() {
        let time1 = Time::__from_hms_nanos_unchecked(0, 0, 0, 0);
        let time2 = Time::__from_hms_nanos_unchecked(23, 59, 59, 999_999_999);
        let duration: Duration = time1.sub(time2);
        assert_eq!(duration, (-23).hours() - 59.minutes() - 59.seconds() - 999_999_999.nanoseconds());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;
    use std::ops::SubAssign;
    use time_macros::time;

    #[test]
    fn time_sub_assign_duration() {
        let mut time = time!(12:00);
        time.sub_assign(Duration::hours(1) + Duration::minutes(30) + Duration::seconds(45));
        assert_eq!(time, time!(10:29:15));
    }

    #[test]
    fn time_sub_assign_duration_wrapping() {
        let mut time = time!(0:00);
        time.sub_assign(Duration::hours(1));
        assert_eq!(time, time!(23:00));
    }

    #[test]
    fn time_sub_assign_duration_microseconds() {
        let mut time = time!(12:00:00.500);
        time.sub_assign(Duration::microseconds(500));
        assert_eq!(time, time!(12:00));
    }

    #[test]
    fn time_sub_assign_duration_nanos() {
        let mut time = time!(12:00:00.000_500_000);
        time.sub_assign(Duration::nanoseconds(500_000));
        assert_eq!(time, time!(12:00));
    }

    #[test]
    fn time_sub_assign_duration_zero() {
        let mut time = time!(12:00);
        time.sub_assign(Duration::ZERO);
        assert_eq!(time, time!(12:00));
    }

    #[test]
    #[should_panic]
    fn time_sub_assign_duration_overflow() {
        let mut time = time!(0:00);
        time.sub_assign(Duration::hours(24));
    }
}
False
========================================
    use std::ops::SubAssign;
    use std::crate::Duration as StdDuration;
    use crate::{Duration, Time};

    #[test]
    fn time_sub_assign_std_duration() {
        let mut time = Time::__from_hms_nanos_unchecked(10, 30, 0, 0);
        let duration = StdDuration::from_secs(60 * 60 + 30 * 60); // 1h 30m
        time.sub_assign(duration);
        assert_eq!(time, Time::__from_hms_nanos_unchecked(9, 0, 0, 0));
    }

    #[test]
    fn time_sub_assign_duration() {
        let mut time = Time::__from_hms_nanos_unchecked(5, 45, 10, 0);
        let duration = Duration::minutes(45) + Duration::seconds(10);
        time.sub_assign(duration);
        assert_eq!(time, Time::__from_hms_nanos_unchecked(5, 0, 0, 0));
    }

    #[test]
    fn time_sub_assign_std_duration_overflow() {
        let mut time = Time::__from_hms_nanos_unchecked(0, 0, 0, 0);
        let duration = StdDuration::from_secs(60 * 60 * 1); // 1 hour
        time.sub_assign(duration);
        assert_eq!(time, Time::__from_hms_nanos_unchecked(23, 0, 0, 0));
    }

    #[test]
    fn time_sub_assign_duration_overflow() {
        let mut time = Time::__from_hms_nanos_unchecked(0, 10, 0, 0);
        let duration = Duration::hours(1);
        time.sub_assign(duration);
        assert_eq!(time, Time::__from_hms_nanos_unchecked(23, 10, 0, 0));
    }
}
False
========================================
    use super::*; // Use the parent module to bring `NumericalStdDuration` into scope

use crate::*;
    use std::crate::Duration as StdDuration; // Correctly import `StdDuration` from `std::time`

    #[test]
    fn std_days_returns_correct_duration() {
        // One day in seconds
        const SECOND_PER_DAY: u64 = 86_400;

        // Test values
        let test_days = [1, 2, 5, 10, 100, 1000];

        for &days in &test_days {
            // Use `NumericalStdDuration` trait to get `std_days` method for `u64` type
            let std_duration = days.std_days();
            // Check the duration against the expected number of seconds
            assert_eq!(StdDuration::from_secs(days * SECOND_PER_DAY), std_duration);
        }
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_std_hours() {
        assert_eq!(<u64 as NumericalStdDuration>::std_hours(0), StdDuration::from_secs(0));
        assert_eq!(<u64 as NumericalStdDuration>::std_hours(1), StdDuration::from_secs(3600));
        assert_eq!(<u64 as NumericalStdDuration>::std_hours(2), StdDuration::from_secs(7200));
        assert_eq!(<u64 as NumericalStdDuration>::std_hours(24), StdDuration::from_secs(86400));
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn std_microseconds_test() {
        let micros = 123456789;
        let std_duration = micros.std_microseconds();
        let expected_std_duration = StdDuration::from_micros(micros);
        
        assert_eq!(std_duration, expected_std_duration);
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use std::convert::TryInto;

    #[test]
    fn test_std_milliseconds() {
        let milliseconds = 1234u64;
        let std_duration = milliseconds.std_milliseconds();

        assert_eq!(std_duration, StdDuration::from_millis(milliseconds));
    }

    #[test]
    fn test_std_milliseconds_with_add() {
        let milliseconds = 1234u64;
        let std_duration = milliseconds.std_milliseconds();
        let time_duration = Duration::milliseconds(milliseconds as i64);

        let added_std = StdDuration::from_millis(milliseconds) + time_duration;
        assert_eq!(added_std, StdDuration::from_millis(milliseconds * 2));
    }

    #[test]
    fn test_std_milliseconds_with_add_assign() {
        let milliseconds = 1234u64;
        let mut std_duration = milliseconds.std_milliseconds();
        let time_duration = Duration::milliseconds(milliseconds as i64);

        std_duration += time_duration;
        assert_eq!(std_duration, StdDuration::from_millis(milliseconds * 2));
    }

    #[test]
    fn test_std_milliseconds_with_div() {
        let milliseconds = 1234u64;
        let std_duration = milliseconds.std_milliseconds();
        let time_duration = Duration::milliseconds(milliseconds as i64);

        let ratio = std_duration.as_secs_f64() / time_duration.as_seconds_f64();
        assert_eq!(ratio, 1.);
    }

    #[test]
    fn test_std_milliseconds_with_partial_eq() {
        let milliseconds = 1234u64;
        let std_duration = milliseconds.std_milliseconds();
        let time_duration = Duration::milliseconds(milliseconds as i64);

        assert!(std_duration == time_duration.try_into().unwrap());
    }

    #[test]
    fn test_std_milliseconds_with_partial_ord() {
        let milliseconds = 1234u64;
        let std_duration = milliseconds.std_milliseconds();
        let time_duration_smaller = Duration::milliseconds((milliseconds - 1) as i64);
        let time_duration_larger = Duration::milliseconds((milliseconds + 1) as i64);

        assert!(std_duration > time_duration_smaller.try_into().unwrap());
        assert!(std_duration < time_duration_larger.try_into().unwrap());
    }

    #[test]
    fn test_std_milliseconds_with_sub() {
        let milliseconds = 1234u64;
        let std_duration = milliseconds.std_milliseconds();
        let time_duration = Duration::milliseconds(milliseconds as i64);

        let difference = std_duration - time_duration;
        assert_eq!(difference, StdDuration::from_millis(0));
    }

    #[test]
    fn test_std_milliseconds_with_sub_assign() {
        let milliseconds = 1234u64;
        let mut std_duration = milliseconds.std_milliseconds();
        let time_duration = Duration::milliseconds(milliseconds as i64);

        std_duration -= time_duration;
        assert_eq!(std_duration, StdDuration::from_millis(0));
    }

    #[test]
    fn test_std_milliseconds_with_try_from() {
        let milliseconds = 1234u64;
        let std_duration = milliseconds.std_milliseconds();
        let time_duration = Duration::milliseconds(milliseconds as i64);

        let converted_std_duration: Result<StdDuration, _> = time_duration.try_into();
        assert_eq!(std_duration, converted_std_duration.unwrap());
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_std_minutes() {
        let minute_in_seconds = 60;
        let one_minute = 1_u64;
        let five_minutes = 5_u64;
        let thirty_minutes = 30_u64;

        assert_eq!(
            one_minute.std_minutes(),
            StdDuration::from_secs(one_minute * minute_in_seconds)
        );
        assert_eq!(
            five_minutes.std_minutes(),
            StdDuration::from_secs(five_minutes * minute_in_seconds)
        );
        assert_eq!(
            thirty_minutes.std_minutes(),
            StdDuration::from_secs(thirty_minutes * minute_in_seconds)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;

    #[test]
    fn test_std_nanoseconds() {
        // Test with zero
        assert_eq!(
            StdDuration::from_nanos(0_u64.std_nanoseconds().as_nanos()),
            StdDuration::from_nanos(0)
        );

        // Test with typical value
        let typical_nanos = 123456789_u64;
        assert_eq!(
            StdDuration::from_nanos(typical_nanos.std_nanoseconds().as_nanos()),
            StdDuration::from_nanos(typical_nanos)
        );

        // Test with maximum value allowed by u64
        let max_nanos = u64::MAX;
        assert_eq!(
            StdDuration::from_nanos(max_nanos.std_nanoseconds().as_nanos()),
            StdDuration::from_nanos(max_nanos)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn std_seconds_zero() {
        assert_eq!(0u64.std_seconds(), StdDuration::from_secs(0));
    }

    #[test]
    fn std_seconds_non_zero() {
        assert_eq!(5u64.std_seconds(), StdDuration::from_secs(5));
    }

    // This test is not correct as the std_seconds function cannot panic given the u64::MAX is a valid input
    // for std::crate::Duration::from_secs, so the test is removed.
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::ext::NumericalStdDuration;

    const SECONDS_PER_MINUTE: u64 = 60;
    const MINUTES_PER_HOUR: u64 = 60;
    const HOURS_PER_DAY: u64 = 24;
    const DAYS_PER_WEEK: u64 = 7;
    const SECONDS_PER_WEEK: u64 = SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY * DAYS_PER_WEEK;

    #[test]
    fn std_weeks_correct_duration() {
        let weeks = 2u64;
        let expected_duration = StdDuration::from_secs(weeks * SECONDS_PER_WEEK);
        let actual_duration = weeks.std_weeks();
        assert_eq!(actual_duration, expected_duration);
    }

    #[test]
    fn std_weeks_zero_duration() {
        let weeks = 0u64;
        let expected_duration = StdDuration::from_secs(0);
        let actual_duration = weeks.std_weeks();
        assert_eq!(actual_duration, expected_duration);
    }

    #[test]
    fn std_weeks_large_duration() {
        let weeks = u64::MAX / SECONDS_PER_WEEK;
        let expected_duration = StdDuration::from_secs(weeks * SECONDS_PER_WEEK);
        let actual_duration = weeks.std_weeks();
        assert_eq!(actual_duration, expected_duration);
    }
    
    #[test]
    #[should_panic(expected = "overflow converting `std::crate::Duration` to `crate::Duration`")]
    fn std_weeks_overflow_duration() {
        let weeks = u64::MAX;
        let _ = weeks.std_weeks(); // This should panic due to overflow.
    }
}
False
========================================
#[cfg(test)]
mod utc_offset_neg_tests {
    use crate::UtcOffset;
    use time_macros::offset;

    #[test]
    fn neg_utc_offset() {
        assert_eq!(-offset!(+1:02:03), offset!(-1:02:03));
        assert_eq!(-offset!(-1:02:03), offset!(+1:02:03));
        assert_eq!(-UtcOffset::UTC, UtcOffset::UTC);
        assert_eq!(-offset!(+23:59:59), offset!(-23:59:59));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::str::FromStr;

    #[test]
    fn test_from_str_valid_days() {
        assert_eq!(Weekday::from_str("Monday"), Ok(Weekday::Monday));
        assert_eq!(Weekday::from_str("Tuesday"), Ok(Weekday::Tuesday));
        assert_eq!(Weekday::from_str("Wednesday"), Ok(Weekday::Wednesday));
        assert_eq!(Weekday::from_str("Thursday"), Ok(Weekday::Thursday));
        assert_eq!(Weekday::from_str("Friday"), Ok(Weekday::Friday));
        assert_eq!(Weekday::from_str("Saturday"), Ok(Weekday::Saturday));
        assert_eq!(Weekday::from_str("Sunday"), Ok(Weekday::Sunday));
    }

    #[test]
    fn test_from_str_invalid_day() {
        assert!(matches!(
            Weekday::from_str("Funday"), 
            Err(error::InvalidVariant)
        ));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;

    #[test]
    #[allow(unused_imports)]
    fn test_from_ordinal_date_unchecked() {
        // Use valid data to test successful creation
        let valid_date = Date::__from_ordinal_date_unchecked(2021, 1);
        assert_eq!(valid_date.year(), 2021);
        assert_eq!(valid_date.ordinal(), 1);

        // Use debug assertions to test the behavior (if enabled)
        let year = 2021;
        let ordinal = 365;
        let max_ordinal = days_in_year(year);
        if cfg!(debug_assertions) {
            let result = std::panic::catch_unwind(|| {
                Date::__from_ordinal_date_unchecked(year, ordinal)
            });
            assert!(result.is_ok());
            if ordinal <= max_ordinal {
                assert_eq!(result.unwrap().ordinal(), ordinal);
            }
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::ext::NumericalStdDuration;
    use crate::date::Date;
    use crate::duration::Duration;
    use time_macros::date;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_checked_add_with_overflow() {
        assert_eq!(Date::MAX.checked_add(1.days()), None);
        assert_eq!(Date::MIN.checked_add((-1).days()), None);
    }

    #[test]
    fn test_checked_add_without_overflow() {
        assert_eq!(
            date!(2020 - 12 - 31).checked_add(1.days()), 
            Some(date!(2021 - 01 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_large_duration() {
        assert_eq!(date!(2020 - 01 - 01).checked_add(1.weeks()), Some(date!(2020 - 01 - 08)));
    }

    #[test]
    fn test_checked_add_with_standard_duration() {
        assert_eq!(
            date!(2020 - 12 - 31).checked_add(StdDuration::new(86_400, 0)), 
            Some(date!(2021 - 01 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_negative_duration() {
        assert_eq!(
            date!(2020 - 01 - 02).checked_add((-1).days()), 
            Some(date!(2020 - 01 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_zero_duration() {
        assert_eq!(
            date!(2020 - 01 - 01).checked_add(Duration::ZERO), 
            Some(date!(2020 - 01 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_subsecond_duration() {
        assert_eq!(
            date!(2020 - 01 - 01).checked_add(1.seconds()), 
            Some(date!(2020 - 01 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_date_rollover() {
        assert_eq!(
            date!(2020 - 12 - 31).checked_add(1.days()), 
            Some(date!(2021 - 01 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_month_rollover() {
        assert_eq!(
            date!(2020 - 01 - 31).checked_add(1.days()), 
            Some(date!(2020 - 02 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_year_rollover() {
        assert_eq!(
            date!(2020 - 12 - 31).checked_add(1.days()), 
            Some(date!(2021 - 01 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_leap_year() {
        assert_eq!(
            date!(2020 - 02 - 29).checked_add(1.days()), 
            Some(date!(2020 - 03 - 01))
        );
    }

    #[test]
    fn test_checked_add_with_non_leap_year() {
        assert_eq!(
            date!(2021 - 02 - 28).checked_add(1.days()), 
            Some(date!(2021 - 03 - 01))
        );
    }
}
False
========================================
    use crate::date::Date;
    use crate::duration::Duration;
    use crate::ext::NumericalDuration;
    use time_macros::date;

    #[test]
    fn checked_sub_date_overflow() {
        assert_eq!(Date::MIN.checked_sub(1.days()), None);
        assert_eq!(Date::MIN.checked_sub(1_000_000_000.days()), None);
    }

    #[test]
    fn checked_sub_date_edge_case() {
        assert_eq!(Date::MIN.checked_sub(0.days()), Some(Date::MIN));
    }

    #[test]
    fn checked_sub_date_within_bounds() {
        assert_eq!(
            date!(2020 - 01 - 05).checked_sub(5.days()),
            Some(date!(2019 - 12 - 31))
        );
        assert_eq!(
            date!(2020 - 01 - 01).checked_sub((-1).days()),
            Some(date!(2020 - 01 - 02))
        );
    }

    #[test]
    fn checked_sub_sub_day_durations() {
        assert_eq!(
            date!(2020 - 01 - 01).checked_sub(1.hours()),
            Some(date!(2020 - 01 - 01))
        );
        assert_eq!(
            date!(2020 - 01 - 02).checked_sub(23.hours()),
            Some(date!(2020 - 01 - 02))
        );
    }

    #[test]
    fn checked_sub_date_multiple_overflow() {
        assert_eq!(Date::MAX.checked_sub((-1).days()), None);
        assert_eq!(Date::MAX.checked_sub((-1_000_000_000).days()), None);
    }

    #[test]
    fn checked_sub_date_exact() {
        assert_eq!(Date::MAX.checked_sub(Duration::MIN), Some(Date::MIN));
        assert_eq!(Date::MIN.checked_sub(Duration::MAX), Some(Date::MAX));
    }

    #[test]
    fn checked_sub_sub_day_durations_overflow() {
        assert_eq!(
            date!(2020 - 01 - 01).checked_sub((-1_000_000_000).hours()),
            None
        );
    }

    #[test]
    fn checked_sub_duration_negative_overflow() {
        assert_eq!(Date::MIN.checked_sub((-1).seconds()), None);
    }

    #[test]
    fn checked_sub_duration_positive_overflow() {
        assert_eq!(Date::MAX.checked_sub(1.seconds()), None);
    }
}
False
========================================
    use crate::date::Date;
    use crate::Month;
    use time_macros::date;

    #[test]
    fn test_day() {
        let test_cases = [
            (date!(2022 - 01 - 01), 1),
            (date!(2022 - 01 - 31), 31),
            (date!(2022 - 02 - 01), 1),
            (date!(2022 - 02 - 28), 28),
            (date!(2020 - 02 - 29), 29), // Leap year
            (date!(2022 - 03 - 01), 1),
            (date!(2022 - 03 - 31), 31),
            (date!(2022 - 04 - 01), 1),
            (date!(2022 - 04 - 30), 30),
            (date!(2022 - 12 - 01), 1),
            (date!(2022 - 12 - 31), 31),
        ];

        for (date, expected_day) in test_cases {
            assert_eq!(date.day(), expected_day, "Testing day for {:?}", date);
        }
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::Month;
    use crate::error::ComponentRange;

    #[test]
    fn from_calendar_date_valid_dates() {
        assert!(Date::from_calendar_date(2019, Month::January, 1).is_ok());
        assert!(Date::from_calendar_date(2019, Month::December, 31).is_ok());
        assert!(Date::from_calendar_date(2020, Month::February, 29).is_ok()); // 2020 is a leap year.
        assert!(Date::from_calendar_date(-1, Month::January, 1).is_ok()); // Test negative year
    }

    #[test]
    fn from_calendar_date_invalid_dates() {
        assert!(Date::from_calendar_date(2019, Month::February, 29).is_err()); // 2019 isn't a leap year.
        assert!(Date::from_calendar_date(2019, Month::April, 31).is_err()); // April doesn't have 31 days
        assert!(Date::from_calendar_date(2019, Month::December, 0).is_err()); // There is no 0th day
        assert!(matches!(Date::from_calendar_date(2019, Month::February, 29).unwrap_err(),
            ComponentRange { name, minimum:1, maximum: _, value: 29, conditional_range: true }));
    }

    #[test]
    fn from_calendar_date_edge_cases() {
        assert!(Date::from_calendar_date(i32::MIN, Month::January, 1).is_err()); // Test year at minimum
        assert!(Date::from_calendar_date(i32::MAX, Month::January, 1).is_err()); // Test year at maximum
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Weekday::{Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};

    #[test]
    fn test_from_iso_week_date() {
        assert!(Date::from_iso_week_date(2019, 1, Monday).is_ok());
        assert!(Date::from_iso_week_date(2019, 1, Tuesday).is_ok());
        assert!(Date::from_iso_week_date(2019, 1, Wednesday).is_ok());
        assert!(Date::from_iso_week_date(2019, 1, Thursday).is_ok());
        assert!(Date::from_iso_week_date(2019, 1, Friday).is_ok());
        assert!(Date::from_iso_week_date(2019, 1, Saturday).is_ok());
        assert!(Date::from_iso_week_date(2019, 1, Sunday).is_ok());
        
        assert!(Date::from_iso_week_date(2020, 53, Friday).is_ok());
        
        assert!(Date::from_iso_week_date(2019, 53, Monday).is_err());
        assert!(Date::from_iso_week_date(2019, 0, Monday).is_err());
        // Testing edge cases (bounds)
        assert!(Date::from_iso_week_date(crate::date::MIN_YEAR, 1, Monday).is_ok());
        assert!(Date::from_iso_week_date(crate::date::MIN_YEAR, 1, Sunday).is_ok());
        assert!(Date::from_iso_week_date(crate::date::MAX_YEAR, 1, Monday).is_ok());
        assert!(Date::from_iso_week_date(crate::date::MAX_YEAR, 1, Sunday).is_ok());
        assert!(Date::from_iso_week_date(crate::date::MIN_YEAR - 1, 1, Monday).is_err());
        assert!(Date::from_iso_week_date(crate::date::MAX_YEAR + 1, 1, Sunday).is_err());
    }
}
True
========================================
    use crate::{Date, error::ComponentRangeError};

    #[test]
    fn from_julian_day_min_boundary() {
        assert_eq!(
            Date::from_julian_day(Date::MIN.to_julian_day()),
            Ok(Date::MIN)
        );
    }

    #[test]
    fn from_julian_day_max_boundary() {
        assert_eq!(
            Date::from_julian_day(Date::MAX.to_julian_day()),
            Ok(Date::MAX)
        );
    }

    #[test]
    fn from_julian_day_known_dates() {
        assert_eq!(Date::from_julian_day(0), Ok(Date::from_ymd(-4713, 11, 24).unwrap()));
        assert_eq!(Date::from_julian_day(2_451_545), Ok(Date::from_ymd(2000, 1, 1).unwrap()));
        assert_eq!(Date::from_julian_day(2_458_485), Ok(Date::from_ymd(2019, 1, 1).unwrap()));
        assert_eq!(Date::from_julian_day(2_458_849), Ok(Date::from_ymd(2019, 12, 31).unwrap()));
    }

    #[test]
    fn from_julian_day_below_min() {
        assert!(matches!(
            Date::from_julian_day(Date::MIN.to_julian_day() - 1),
            Err(ComponentRangeError { .. })
        ));
    }

    #[test]
    fn from_julian_day_above_max() {
        assert!(matches!(
            Date::from_julian_day(Date::MAX.to_julian_day() + 1),
            Err(ComponentRangeError { .. })
        ));
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_julian_day_unchecked() {
        let date = Date::from_julian_day_unchecked(2_451_545); // This corresponds to 2000-01-01
        assert_eq!(date.to_calendar_date(), (2000, Month::January, 1));

        let date = Date::from_julian_day_unchecked(2_458_485); // This corresponds to 2019-01-01
        assert_eq!(date.to_calendar_date(), (2019, Month::January, 1));

        let date = Date::from_julian_day_unchecked(2_458_849); // This corresponds to 2019-12-31
        assert_eq!(date.to_calendar_date(), (2019, Month::December, 31));

        let date = Date::from_julian_day_unchecked(0); // This corresponds to -4713-11-24 in the proleptic Gregorian calendar
        assert_eq!(date.to_calendar_date(), (-4713, Month::November, 24));
    }
}
True
========================================
    use crate::Date;
    use crate::error::Error;

    #[test]
    fn test_from_ordinal_date_valid() {
        assert!(Date::from_ordinal_date(2019, 1).is_ok());
        assert!(Date::from_ordinal_date(2019, 365).is_ok());
        assert!(Date::from_ordinal_date(2020, 366).is_ok()); // 2020 is a leap year.
    }

    #[test]
    fn test_from_ordinal_date_invalid_ordinal() {
        assert!(matches!(Date::from_ordinal_date(2019, 366).unwrap_err(), Error::ComponentRange(_)));
        assert!(matches!(Date::from_ordinal_date(2019, 0).unwrap_err(), Error::ComponentRange(_)));
        assert!(matches!(Date::from_ordinal_date(2020, 367).unwrap_err(), Error::ComponentRange(_)));
    }

    #[test]
    fn test_from_ordinal_date_invalid_year() {
        assert!(matches!(Date::from_ordinal_date(9999, 1).unwrap_err(), Error::ComponentRange(_)));
        assert!(matches!(Date::from_ordinal_date(-10000, 1).unwrap_err(), Error::ComponentRange(_)));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::Date;
    use time_macros::date;

    #[test]
    fn iso_week_number() {
        assert_eq!(Date::from_calendar_date(2019, Month::January, 1).unwrap().iso_week(), 1);
        assert_eq!(Date::from_calendar_date(2019, Month::October, 4).unwrap().iso_week(), 40);
        assert_eq!(Date::from_calendar_date(2020, Month::January, 1).unwrap().iso_week(), 1);
        assert_eq!(Date::from_calendar_date(2020, Month::December, 31).unwrap().iso_week(), 53);
        assert_eq!(Date::from_calendar_date(2021, Month::January, 1).unwrap().iso_week(), 53);
    }
}
True
========================================
    use crate::{Date, Weekday};
    use crate::util::weeks_in_year;

    #[test]
    fn iso_year_week_in_common_year() {
        let d = Date::from_calendar_date(2019, Month::January, 1).unwrap();
        assert_eq!(d.iso_year_week(), (2019, 1));

        let d = Date::from_calendar_date(2019, Month::December, 31).unwrap();
        assert_eq!(d.iso_year_week(), (2020, 1));
    }

    #[test]
    fn iso_year_week_in_leap_year() {
        let d = Date::from_calendar_date(2020, Month::January, 1).unwrap();
        assert_eq!(d.iso_year_week(), (2020, 1));

        let d = Date::from_calendar_date(2020, Month::December, 31).unwrap();
        assert_eq!(d.iso_year_week(), (2020, 53));
    }

    #[test]
    fn iso_year_week_at_year_transition() {
        let d = Date::from_calendar_date(2018, Month::December, 31).unwrap();
        assert_eq!(d.iso_year_week(), (2019, 1));

        let d = Date::from_calendar_date(2020, Month::December, 28).unwrap();
        assert_eq!(d.iso_year_week(), (2021, 53));
    }

    #[test]
    fn iso_year_week_edge_cases() {
        let d = Date::from_calendar_date(2020, Month::December, 27).unwrap();
        assert_eq!(d.iso_year_week(), (2020, 52));

        let d = Date::from_calendar_date(2020, Month::December, 28).unwrap();
        assert_eq!(d.iso_year_week(), (2020, 53));
    }

    #[test]
    fn iso_year_week_edge_cases_at_week_start() {
        let d = Date::from_calendar_date(2018, Month::December, 30).unwrap();
        assert_eq!(d.iso_year_week(), (2018, 52));

        let d = Date::from_calendar_date(2018, Month::December, 31).unwrap();
        assert_eq!(d.iso_year_week(), (2019, 1));
    }
}
False
========================================
    use crate::date::Date;
    use crate::primitive_date_crate::PrimitiveDateTime;
    use time_macros::{date, datetime};

    #[test]
    fn midnight_test() {
        assert_eq!(date!(2022-03-15).midnight(), datetime!(2022-03-15 0:00));
        assert_eq!(date!(1970-01-01).midnight(), datetime!(1970-01-01 0:00));
        assert_eq!(date!(1999-12-31).midnight(), datetime!(1999-12-31 0:00));
        assert_eq!(date!(2020-02-29).midnight(), datetime!(2020-02-29 0:00)); // Leap day
        assert_eq!(date!(-4713-11-24).midnight(), datetime!(-4713-11-24 0:00)); // Julian day 0
    }
}
False
========================================
    use crate::Date;
    use time_macros::date;

    #[test]
    fn test_monday_based_week() {
        assert_eq!(date!(2019 - 01 - 01).monday_based_week(), 0);
        assert_eq!(date!(2019 - 01 - 07).monday_based_week(), 1);
        assert_eq!(date!(2019 - 01 - 14).monday_based_week(), 2);
        assert_eq!(date!(2019 - 12 - 30).monday_based_week(), 52);
        assert_eq!(date!(2020 - 01 - 01).monday_based_week(), 0);
        assert_eq!(date!(2020 - 01 - 06).monday_based_week(), 1);
        assert_eq!(date!(2020 - 12 - 28).monday_based_week(), 52);
        assert_eq!(date!(2021 - 01 - 01).monday_based_week(), 0);
        assert_eq!(date!(2021 - 01 - 04).monday_based_week(), 1);
        assert_eq!(date!(2021 - 12 - 27).monday_based_week(), 52);
        assert_eq!(date!(2022 - 01 - 01).monday_based_week(), 0);
        assert_eq!(date!(2022 - 12 - 26).monday_based_week(), 52);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Month::{January, February, March, April, May, June, July, August, September, October, November, December};
    use crate::Date;

    #[test]
    fn test_month() {
        assert_eq!(Date::from_calendar_date(2022, January, 15).unwrap().month(), January);
        assert_eq!(Date::from_calendar_date(2022, February, 15).unwrap().month(), February);
        assert_eq!(Date::from_calendar_date(2022, March, 15).unwrap().month(), March);
        assert_eq!(Date::from_calendar_date(2022, April, 15).unwrap().month(), April);
        assert_eq!(Date::from_calendar_date(2022, May, 15).unwrap().month(), May);
        assert_eq!(Date::from_calendar_date(2022, June, 15).unwrap().month(), June);
        assert_eq!(Date::from_calendar_date(2022, July, 15).unwrap().month(), July);
        assert_eq!(Date::from_calendar_date(2022, August, 15).unwrap().month(), August);
        assert_eq!(Date::from_calendar_date(2022, September, 15).unwrap().month(), September);
        assert_eq!(Date::from_calendar_date(2022, October, 15).unwrap().month(), October);
        assert_eq!(Date::from_calendar_date(2022, November, 15).unwrap().month(), November);
        assert_eq!(Date::from_calendar_date(2022, December, 15).unwrap().month(), December);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Month::*;

    #[test]
    fn test_month_day() {
        let common_year_date = Date::__from_ordinal_date_unchecked(2021, 59);
        let leap_year_date = Date::__from_ordinal_date_unchecked(2020, 60);
        let end_of_year_date = Date::__from_ordinal_date_unchecked(2021, 365);
        let start_of_year_date = Date::__from_ordinal_date_unchecked(2021, 1);

        assert_eq!(common_year_date.month_day(), (February, 28));
        assert_eq!(leap_year_date.month_day(), (February, 29));
        assert_eq!(end_of_year_date.month_day(), (December, 31));
        assert_eq!(start_of_year_date.month_day(), (January, 1));
    }
}
True
========================================
#[cfg(test)]
mod next_day_tests {
    use crate::Date;
    use time_macros::date;

    #[test]
    fn test_next_day_regular_days() {
        assert_eq!(
            Date::from_calendar_date(2019, crate::Month::January, 1).unwrap().next_day(),
            Some(date!(2019 - 01 - 02))
        );
        assert_eq!(
            Date::from_calendar_date(2019, crate::Month::January, 30).unwrap().next_day(),
            Some(date!(2019 - 01 - 31))
        );
    }

    #[test]
    fn test_next_day_end_of_month() {
        assert_eq!(
            Date::from_calendar_date(2019, crate::Month::January, 31).unwrap().next_day(),
            Some(date!(2019 - 02 - 01))
        );
        assert_eq!(
            Date::from_calendar_date(2019, crate::Month::April, 30).unwrap().next_day(),
            Some(date!(2019 - 05 - 01))
        );
    }

    #[test]
    fn test_next_day_end_of_year() {
        assert_eq!(
            Date::from_calendar_date(2019, crate::Month::December, 31).unwrap().next_day(),
            Some(date!(2020 - 01 - 01))
        );
    }

    #[test]
    fn test_next_day_leap_day() {
        assert_eq!(
            Date::from_calendar_date(2020, crate::Month::February, 29).unwrap().next_day(),
            Some(date!(2020 - 03 - 01))
        );
    }

    #[test]
    fn test_next_day_end_of_leap_year() {
        assert_eq!(
            Date::from_calendar_date(2020, crate::Month::December, 31).unwrap().next_day(),
            Some(date!(2021 - 01 - 01))
        );
    }

    #[test]
    fn test_next_day_max_date() {
        assert_eq!(Date::MAX.next_day(), None);
    }
}
False
========================================
    use super::*;

use crate::*;
    use time_macros::date;

    #[test]
    fn test_ordinal_common_year() {
        let d = date!(2019 - 01 - 01);
        assert_eq!(d.ordinal(), 1);

        let d = date!(2019 - 12 - 31);
        assert_eq!(d.ordinal(), 365);
    }

    #[test]
    fn test_ordinal_leap_year() {
        let d = date!(2020 - 01 - 01);
        assert_eq!(d.ordinal(), 1);

        let d = date!(2020 - 12 - 31);
        assert_eq!(d.ordinal(), 366);
    }

    #[test]
    fn test_ordinal_edge_cases() {
        let d = date!(2019 - 12 - 01);
        assert_eq!(d.ordinal(), 335);

        let d = date!(2020 - 02 - 29);
        assert_eq!(d.ordinal(), 60);
    }

    #[test]
    #[should_panic(expected = "overflow when creating date")]
    fn test_ordinal_with_invalid_date() {
        let d = Date::from_julian_day(i32::MAX)
            .unwrap_or_else(|_| panic!("overflow when creating date"));
        let _ = d.ordinal();
    }
}
False
========================================
    use crate::Date;
    use crate::util::days_in_year;
    use crate::macros::date;
    use crate::Month;

    #[test]
    fn previous_day_basic() {
        assert_eq!(
            date!(2019 - 01 - 02).previous_day(),
            Some(date!(2019 - 01 - 01))
        );
        assert_eq!(
            date!(2019 - 02 - 01).previous_day(),
            Some(date!(2019 - 01 - 31))
        );
        assert_eq!(
            date!(2020 - 01 - 01).previous_day(),
            Some(date!(2019 - 12 - 31))
        );
    }

    #[test]
    fn previous_day_min() {
        assert_eq!(Date::MIN.previous_day(), None);
    }

    #[test]
    fn previous_day_leap_year() {
        assert_eq!(
            date!(2020 - 03 - 01).previous_day(),
            Some(date!(2020 - 02 - 29))
        );
    }

    #[test]
    fn previous_day_year_boundary() {
        assert_eq!(
            date!(2021 - 01 - 01).previous_day(),
            Some(date!(2020 - 12 - 31))
        );
    }

    #[test]
    fn previous_day_month_boundary() {
        assert_eq!(
            date!(2021 - 11 - 01).previous_day(),
            Some(date!(2021 - 10 - 31))
        );
    }

    #[test]
    fn previous_day_nonexistent_date() {
        assert!(Date::from_calendar_date(2019, Month::February, 29).is_err());
        assert_eq!(
            date!(2019 - 03 - 01).previous_day(),
            Some(date!(2019 - 02 - 28))
        );
    }
}
False
========================================
    use crate::Date;
    use crate::error::ComponentRange;
    use crate::Month;
    use time_macros::date;

    #[test]
    fn replace_day_valid() {
        assert_eq!(
            Date::from_calendar_date(2022, Month::February, 18).unwrap().replace_day(1),
            Ok(Date::from_calendar_date(2022, Month::February, 1).unwrap())
        );
        assert_eq!(
            Date::from_calendar_date(2022, Month::February, 18).unwrap().replace_day(28),
            Ok(Date::from_calendar_date(2022, Month::February, 28).unwrap())
        );
        assert_eq!(
            Date::from_calendar_date(2022, Month::January, 18).unwrap().replace_day(31),
            Ok(Date::from_calendar_date(2022, Month::January, 31).unwrap())
        );
        assert_eq!(
            Date::from_calendar_date(2020, Month::February, 18).unwrap().replace_day(29),
            Ok(Date::from_calendar_date(2020, Month::February, 29).unwrap())
        );
    }

    #[test]
    fn replace_day_invalid() {
        assert_eq!(
            Date::from_calendar_date(2022, Month::February, 18)
                .unwrap()
                .replace_day(0)
                .unwrap_err(),
            ComponentRange {
                name: "day",
                value: 0,
                minimum: 1,
                maximum: 29,
                conditional_range: true,
            }
        );
        assert_eq!(
            Date::from_calendar_date(2022, Month::February, 18)
                .unwrap()
                .replace_day(30)
                .unwrap_err(),
            ComponentRange {
                name: "day",
                value: 30,
                minimum: 1,
                maximum: 29,
                conditional_range: true,
            }
        );
        assert_eq!(
            Date::from_calendar_date(2022, Month::April, 18)
                .unwrap()
                .replace_day(31)
                .unwrap_err(),
            ComponentRange {
                name: "day",
                value: 31,
                minimum: 1,
                maximum: 30,
                conditional_range: true,
            }
        );
        assert_eq!(
            Date::from_calendar_date(2022, Month::January, 18)
                .unwrap()
                .replace_day(32)
                .unwrap_err(),
            ComponentRange {
                name: "day",
                value: 32,
                minimum: 1,
                maximum: 31,
                conditional_range: true,
            }
        );
    }

    #[test]
    fn replace_day_edge_cases() {
        assert_eq!(
            Date::from_calendar_date(2022, Month::December, 31).unwrap().replace_day(1),
            Ok(Date::from_calendar_date(2022, Month::December, 1).unwrap())
        );
        assert_eq!(
            Date::from_calendar_date(2020, Month::February, 29)
                .unwrap()
                .replace_day(28),
            Ok(Date::from_calendar_date(2020, Month::February, 28).unwrap())
        );
        assert_eq!(
            Date::from_calendar_date(2021, Month::February, 28)
                .unwrap()
                .replace_day(29)
                .unwrap_err(),
            ComponentRange {
                name: "day",
                value: 29,
                minimum: 1,
                maximum: 28,
                conditional_range: true,
            }
        );
    }
}
True
========================================
    use crate::Date; // use the super keyword to access the parent module
    use crate::Month; // use crate to access the root of the current crate
    use time_macros::date;

    #[test]
    fn replace_month_valid() {
        assert_eq!(
            date!(2022 - 02 - 18).replace_month(Month::January),
            Ok(date!(2022 - 01 - 18))
        );
        assert_eq!(
            date!(2022 - 02 - 28).replace_month(Month::March),
            Ok(date!(2022 - 03 - 28))
        );
        assert_eq!(
            date!(2020 - 02 - 29).replace_month(Month::December),
            Ok(date!(2020 - 12 - 29))
        );
        assert_eq!(
            date!(2024 - 01 - 31).replace_month(Month::December),
            Ok(date!(2024 - 12 - 31))
        );
    }

    #[test]
    fn replace_month_in_leap_year() {
        assert_eq!(
            date!(2024 - 02 - 29).replace_month(Month::February),
            Ok(date!(2024 - 02 - 29))
        );
    }

    #[test]
    fn replace_month_invalid() {
        assert!(date!(2021 - 02 - 29).replace_month(Month::February).is_err());
        assert!(date!(2022 - 01 - 31).replace_month(Month::February).is_err());
        assert!(date!(2022 - 03 - 31).replace_month(Month::February).is_err());
        assert!(date!(2022 - 03 - 31).replace_month(Month::April).is_err());
    }

    #[test]
    fn replace_month_edge_cases() {
        assert_eq!(
            Date::MIN.replace_month(Month::January),
            Ok(Date::MIN)
        );
        assert_eq!(
            Date::MAX.replace_month(Month::December),
            Ok(Date::MAX)
        );
    }
}
False
========================================
    use crate::Date; // Use `Date` directly from the crate scope.
    use crate::error::ComponentRange;
    use time_macros::date; // Use `date` macro directly.

    #[test]
    fn replace_valid_year() {
        assert_eq!(
            Date::from_calendar_date(2022, crate::Month::February, 18).unwrap().replace_year(2019),
            Ok(Date::from_calendar_date(2019, crate::Month::February, 18).unwrap())
        );
    }

    #[test]
    fn replace_invalid_year() {
        assert!(Date::from_calendar_date(2022, crate::Month::February, 18).unwrap().replace_year(-1_000_000_000).is_err());
        assert!(Date::from_calendar_date(2022, crate::Month::February, 18).unwrap().replace_year(1_000_000_000).is_err());
    }

    #[test]
    fn replace_leap_year_to_common() {
        assert_eq!(
            Date::from_calendar_date(2020, crate::Month::February, 29).unwrap().replace_year(2021),
            Err(ComponentRange {
                name: "day",
                value: 29,
                minimum: 1,
                maximum: 28,
                conditional_range: true,
            })
        );
    }

    #[test]
    fn replace_common_year_to_leap() {
        assert_eq!(
            Date::from_calendar_date(2021, crate::Month::March, 1).unwrap().replace_year(2020),
            Ok(Date::from_calendar_date(2020, crate::Month::March, 1).unwrap())
        );
    }

    #[test]
    fn replace_leap_year_to_leap() {
        assert_eq!(
            Date::from_calendar_date(2020, crate::Month::February, 29).unwrap().replace_year(2016),
            Ok(Date::from_calendar_date(2016, crate::Month::February, 29).unwrap())
        );
    }

    #[test]
    fn replace_common_year_to_common() {
        assert_eq!(
            Date::from_calendar_date(2019, crate::Month::January, 15).unwrap().replace_year(2018),
            Ok(Date::from_calendar_date(2018, crate::Month::January, 15).unwrap())
        );
    }
}
True
========================================
    use crate::{ext::NumericalDuration, Date, Duration};

    #[test]
    fn saturating_add_positive_no_overflow() {
        let date = Date::from_calendar_date(2020, crate::Month::January, 1).unwrap();
        assert_eq!(date.saturating_add(1.days()), Date::from_calendar_date(2020, crate::Month::January, 2).unwrap());
    }

    #[test]
    fn saturating_add_positive_overflow() {
        let date = Date::MAX;
        assert_eq!(date.saturating_add(1.days()), Date::MAX);
    }

    #[test]
    fn saturating_add_negative_no_overflow() {
        let date = Date::from_calendar_date(2020, crate::Month::January, 2).unwrap();
        assert_eq!(date.saturating_add((-1).days()), Date::from_calendar_date(2020, crate::Month::January, 1).unwrap());
    }

    #[test]
    fn saturating_add_negative_overflow() {
        let date = Date::MIN;
        assert_eq!(date.saturating_add((-1).days()), Date::MIN);
    }

    #[test]
    fn saturating_add_large_duration() {
        let date = Date::from_calendar_date(2020, crate::Month::January, 1).unwrap();
        let duration = Duration::new(i64::MAX, 0);
        assert_eq!(date.saturating_add(duration), Date::MAX);
    }

    #[test]
    fn saturating_add_with_hours() {
        assert_eq!(
            Date::from_calendar_date(2020, crate::Month::December, 31).unwrap().saturating_add(23.hours()),
            Date::from_calendar_date(2020, crate::Month::December, 31).unwrap()
        );
        assert_eq!(
            Date::from_calendar_date(2020, crate::Month::December, 31).unwrap().saturating_add(47.hours()),
            Date::from_calendar_date(2021, crate::Month::January, 1).unwrap()
        );
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::Date;
    use crate::Duration;

    #[test]
    fn saturating_sub_underflow() {
        assert_eq!(Date::MIN.saturating_sub(1.days()), Date::MIN);
    }

    #[test]
    fn saturating_sub_no_underflow() {
        assert_eq!(
            Date::MIN.saturating_sub((-1).days()),
            Date::MIN.checked_add(1.days()).unwrap()
        );
    }

    #[test]
    fn saturating_sub_overflow() {
        assert_eq!(Date::MAX.saturating_sub((-1).days()), Date::MAX);
    }

    #[test]
    fn saturating_sub_no_overflow() {
        assert_eq!(
            Date::MAX.saturating_sub(1.days()),
            Date::MAX.checked_sub(1.days()).unwrap()
        );
    }

    #[test]
    fn saturating_sub_days() {
        assert_eq!(
            Date::from_calendar_date(2020, Month::January, 1).unwrap().saturating_sub(2.days()),
            Date::from_calendar_date(2019, Month::December, 30).unwrap()
        );
    }

    #[test]
    fn saturating_sub_hours_no_change() {
        assert_eq!(
            Date::from_calendar_date(2020, Month::January, 1).unwrap().saturating_sub(23.hours()),
            Date::from_calendar_date(2020, Month::January, 1).unwrap()
        );
    }

    #[test]
    fn saturating_sub_hours_change() {
        assert_eq!(
            Date::from_calendar_date(2020, Month::January, 1).unwrap().saturating_sub(25.hours()),
            Date::from_calendar_date(2019, Month::December, 31).unwrap()
        );
    }

    // Additional tests can be created to cover more cases, including
    // different units of time, edge cases, and standard behavior.
}
True
========================================
    use crate::Date;
    use time_macros::date;

    #[test]
    fn sunday_based_week_test() {
        assert_eq!(date!(2019 - 01 - 01).sunday_based_week(), 0);
        assert_eq!(date!(2019 - 01 - 06).sunday_based_week(), 1);
        assert_eq!(date!(2020 - 01 - 01).sunday_based_week(), 0);
        assert_eq!(date!(2020 - 01 - 05).sunday_based_week(), 1);
        assert_eq!(date!(2020 - 12 - 31).sunday_based_week(), 52);
        assert_eq!(date!(2021 - 01 - 01).sunday_based_week(), 0);
        assert_eq!(date!(2021 - 01 - 03).sunday_based_week(), 1);
        assert_eq!(date!(2021 - 12 - 31).sunday_based_week(), 52);
        assert_eq!(date!(2022 - 01 - 01).sunday_based_week(), 0);
        assert_eq!(date!(2022 - 01 - 02).sunday_based_week(), 1);
        assert_eq!(date!(2022 - 12 - 31).sunday_based_week(), 52);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Month::*;
    use crate::error::ComponentRange;

    #[test]
    fn to_calendar_date_works() {
        let cases = [
            // Year, Month, Day, Expected Year, Expected Month, Expected Day
            (2019, January, 1, 2019, January, 1),
            (2020, February, 29, 2020, February, 29),
            (2019, December, 31, 2019, December, 31),
            (2000, February, 29, 2000, February, 29),
            (1900, February, 28, 1900, February, 28),
            (1970, June, 1, 1970, June, 1),
            (-1, December, 31, -1, December, 31),
            (2021, May, 12, 2021, May, 12),
        ];

        for (year, month, day, expected_year, expected_month, expected_day) in cases {
            let date = Date::from_calendar_date(year, month, day).unwrap();
            let (year, month, day) = date.to_calendar_date();
            assert_eq!((year, month, day), (expected_year, expected_month, expected_day));
        }
    }

    #[test]
    fn to_calendar_date_failures() {
        let cases = [
            // Invalid Year, Month, Day, Expected Error
            (2019, January, 0),
            (10000, January, 1),
            (-10000, January, 1),
            (2020, February, 30),
            (2019, February, 29),
        ];

        for (year, month, day) in cases {
            let date = Date::from_calendar_date(year, month, day);
            assert!(matches!(date, Err(ComponentRange { .. })));
        }
    }
}
True
========================================
    use crate::Date;
    use crate::Weekday::*;
    use crate::macros::date;

    #[test]
    fn test_to_iso_week_date() {
        assert_eq!(date!(2019 - 01 - 01).to_iso_week_date(), (2019, 1, Tuesday));
        assert_eq!(date!(2019 - 10 - 04).to_iso_week_date(), (2019, 40, Friday));
        assert_eq!(date!(2020 - 01 - 01).to_iso_week_date(), (2020, 1, Wednesday));
        assert_eq!(date!(2020 - 12 - 31).to_iso_week_date(), (2020, 53, Thursday));
        assert_eq!(date!(2021 - 01 - 01).to_iso_week_date(), (2020, 53, Friday));
        assert_eq!(date!(2019 - 12 - 30).to_iso_week_date(), (2020, 1, Monday)); // Case where the week belongs to next year
        assert_eq!(date!(2021 - 12 - 26).to_iso_week_date(), (2021, 51, Sunday)); // Last week of the year
        assert_eq!(date!(2023 - 01 - 01).to_iso_week_date(), (2022, 52, Sunday)); // First day of the year
    }
}
False
========================================
    use crate::Date;
    use time_macros::date;

    #[test]
    fn test_to_julian_day() {
        assert_eq!(date!(-4713 - 11 - 24).to_julian_day(), 0);
        assert_eq!(date!(2000 - 01 - 01).to_julian_day(), 2_451_545);
        assert_eq!(date!(2019 - 01 - 01).to_julian_day(), 2_458_485);
        assert_eq!(date!(2019 - 12 - 31).to_julian_day(), 2_458_849);
    }
}
False
========================================
    use crate::Date;
    use time_macros::date;

    #[test]
    fn to_ordinal_date_for_leap_year() {
        assert_eq!(date!(2020 - 01 - 01).to_ordinal_date(), (2020, 1));
        assert_eq!(date!(2020 - 12 - 31).to_ordinal_date(), (2020, 366));
    }

    #[test]
    fn to_ordinal_date_for_common_year() {
        assert_eq!(date!(2021 - 01 - 01).to_ordinal_date(), (2021, 1));
        assert_eq!(date!(2021 - 12 - 31).to_ordinal_date(), (2021, 365));
    }

    #[test]
    fn to_ordinal_date_for_dates_with_different_ordinals() {
        assert_eq!(date!(2019 - 03 - 01).to_ordinal_date(), (2019, 60));
        assert_eq!(date!(2019 - 10 - 13).to_ordinal_date(), (2019, 286));
    }

    #[test]
    fn to_ordinal_date_on_leap_day() {
        assert_eq!(date!(2020 - 02 - 29).to_ordinal_date(), (2020, 60));
    }

    #[test]
    fn to_ordinal_date_for_dates_across_different_years() {
        assert_eq!(date!(2018 - 12 - 31).to_ordinal_date(), (2018, 365));
        assert_eq!(date!(2019 - 01 - 01).to_ordinal_date(), (2019, 1));
    }

    #[test]
    fn to_ordinal_date_for_dates_at_extremes() {
        assert_eq!(Date::MIN.to_ordinal_date(), (Date::MIN.year(), 1));
        assert_eq!(Date::MAX.to_ordinal_date(), (Date::MAX.year(), Date::MAX.ordinal()));
    }
}
False
========================================
    use crate::Weekday::*;
    use crate::Date;
    use time_macros::date;

    #[test]
    fn test_weekday() {
        assert_eq!(date!(2019 - 01 - 01).weekday(), Tuesday);
        assert_eq!(date!(2019 - 02 - 01).weekday(), Friday);
        assert_eq!(date!(2019 - 03 - 01).weekday(), Friday);
        assert_eq!(date!(2019 - 04 - 01).weekday(), Monday);
        assert_eq!(date!(2019 - 05 - 01).weekday(), Wednesday);
        assert_eq!(date!(2019 - 06 - 01).weekday(), Saturday);
        assert_eq!(date!(2019 - 07 - 01).weekday(), Monday);
        assert_eq!(date!(2019 - 08 - 01).weekday(), Thursday);
        assert_eq!(date!(2019 - 09 - 01).weekday(), Sunday);
        assert_eq!(date!(2019 - 10 - 01).weekday(), Tuesday);
        assert_eq!(date!(2019 - 11 - 01).weekday(), Friday);
        assert_eq!(date!(2019 - 12 - 01).weekday(), Sunday);
    }
}
False
========================================
    use crate::{Date, PrimitiveDateTime, error::ComponentRange, Time, macros::date};

    #[test]
    fn test_with_hms() {
        assert_eq!(
            date!(1999 - 12 - 31).with_hms(23, 59, 59),
            Ok(PrimitiveDateTime::new(date!(1999 - 12 - 31), Time::from_hms(23, 59, 59).unwrap()))
        );
        assert_eq!(
            date!(2020 - 2 - 29).with_hms(12, 0, 0),
            Ok(PrimitiveDateTime::new(date!(2020 - 2 - 29), Time::from_hms(12, 0, 0).unwrap()))
        );
        assert!(date!(2020 - 2 - 29).with_hms(24, 0, 0).is_err());
        assert!(date!(2020 - 2 - 29).with_hms(23, 60, 0).is_err());
        assert!(date!(2020 - 2 - 29).with_hms(23, 0, 60).is_err());
        assert_eq!(
            date!(2000 - 1 - 1).with_hms(0, 0, 0),
            Ok(PrimitiveDateTime::new(date!(2000 - 1 - 1), Time::from_hms(0, 0, 0).unwrap()))
        );
        assert_eq!(
            date!(2000 - 1 - 1).with_hms(0, 0, 0),
            date!(2000 - 1 - 1).midnight()
        );
    }
}
False
========================================
    use crate::Time;
    use crate::Date;
    use crate::error::ComponentRange;
    use crate::PrimitiveDateTime;
    use time_macros::date;

    #[test]
    fn with_hms_micro_valid() {
        let d = date!(2000 - 01 - 01);
        assert!(d.with_hms_micro(0, 0, 0, 0).is_ok());
        assert!(d.with_hms_micro(23, 59, 59, 999_999).is_ok());
    }

    #[test]
    fn with_hms_micro_invalid() {
        let d = date!(2000 - 01 - 01);
        assert!(d.with_hms_micro(24, 0, 0, 0).is_err());
        assert!(d.with_hms_micro(23, 60, 0, 0).is_err());
        assert!(d.with_hms_micro(23, 59, 60, 0).is_err());
        assert!(d.with_hms_micro(23, 59, 59, 1_000_000).is_err());
    }
}
False
========================================
    use crate::{
        error::{self, ComponentRange},
        Date, PrimitiveDateTime, Time,
        ext::NumericalDuration
    };

    #[test]
    fn with_hms_milli_valid_time() {
        let valid_date = Date::from_calendar_date(2023, crate::Month::March, 15).unwrap();
        let valid_time = valid_date.with_time(Time::from_hms_milli(23, 59, 59, 999).unwrap());
        assert_eq!(valid_date.with_hms_milli(23, 59, 59, 999), Ok(valid_time));
    }

    #[test]
    fn with_hms_milli_invalid_hour() {
        assert!(matches!(
            Date::from_calendar_date(2023, crate::Month::March, 15).unwrap().with_hms_milli(24, 0, 0, 0),
            Err(ComponentRange { .. })
        ));
    }

    #[test]
    fn with_hms_milli_invalid_minute() {
        assert!(matches!(
            Date::from_calendar_date(2023, crate::Month::March, 15).unwrap().with_hms_milli(23, 60, 0, 0),
            Err(ComponentRange { .. })
        ));
    }

    #[test]
    fn with_hms_milli_invalid_second() {
        assert!(matches!(
            Date::from_calendar_date(2023, crate::Month::March, 15).unwrap().with_hms_milli(23, 59, 60, 0),
            Err(ComponentRange { .. })
        ));
    }

    #[test]
    fn with_hms_milli_invalid_millisecond() {
        assert!(matches!(
            Date::from_calendar_date(2023, crate::Month::March, 15).unwrap().with_hms_milli(23, 59, 59, 1000),
            Err(ComponentRange { .. })
        ));
    }

    #[test]
    fn with_hms_milli_min_value() {
        let valid_date = Date::from_calendar_date(2023, crate::Month::March, 15).unwrap();
        let valid_time = valid_date.with_time(Time::from_hms_milli(0, 0, 0, 0).unwrap());
        assert_eq!(valid_date.with_hms_milli(0, 0, 0, 0), Ok(valid_time));
    }

    #[test]
    fn with_hms_milli_max_value() {
        let valid_date = Date::from_calendar_date(2023, crate::Month::March, 15).unwrap();
        let valid_time = valid_date.with_time(Time::from_hms_milli(23, 59, 59, 999).unwrap());
        assert_eq!(valid_date.with_hms_milli(23, 59, 59, 999), Ok(valid_time));
    }
}
True
========================================
    use crate::{Date, error, macros::date, PrimitiveDateTime, Time, Duration};

    #[test]
    fn test_with_hms_nano_valid_times() {
        assert_eq!(
            date!(2022-07-08).with_hms_nano(0, 0, 0, 0),
            Ok(PrimitiveDateTime::new(date!(2022-07-08), Time::from_hms_nano(0, 0, 0, 0).unwrap()))
        );
        assert_eq!(
            date!(2022-07-08).with_hms_nano(23, 59, 59, 999_999_999),
            Ok(PrimitiveDateTime::new(date!(2022-07-08), Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap()))
        );
    }

    #[test]
    fn test_with_hms_nano_invalid_hour() {
        assert!(date!(2022-07-08).with_hms_nano(24, 0, 0, 0).is_err());
    }

    #[test]
    fn test_with_hms_nano_invalid_minute() {
        assert!(date!(2022-07-08).with_hms_nano(23, 60, 0, 0).is_err());
    }

    #[test]
    fn test_with_hms_nano_invalid_second() {
        assert!(date!(2022-07-08).with_hms_nano(23, 59, 60, 0).is_err());
    }

    #[test]
    fn test_with_hms_nano_invalid_nanosecond() {
        assert!(date!(2022-07-08).with_hms_nano(23, 59, 59, 1_000_000_000).is_err());
    }
}
False
========================================
    use super::*;

use crate::*;
    use time_macros::datetime;
    use crate::util::DateAdjustment;
    use crate::Date;
    use crate::Month;
    use std::cmp::Ordering;
    use crate::Time;

    #[test]
    fn test_with_time() {
        // Test with the start of the day
        assert_eq!(
            Date::from_calendar_date(1970, Month::January, 1)
                .unwrap()
                .with_time(Time::MIDNIGHT),
            datetime!(1970-01-01 0:00),
        );

        // Test with the middle of the day
        assert_eq!(
            Date::from_calendar_date(2000, Month::February, 29)
                .unwrap()
                .with_time(Time::from_hms(12, 34, 56).unwrap()),
            datetime!(2000-02-29 12:34:56),
        );

        // Test with the end of the day
        assert_eq!(
            Date::from_calendar_date(2019, Month::December, 31)
                .unwrap()
                .with_time(Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap()),
            datetime!(2019-12-31 23:59:59.999_999_999),
        );

        // Test ordering
        assert_eq!(
            Date::from_calendar_date(2019, Month::December, 31)
                .unwrap()
                .with_time(Time::from_hms(0, 0, 0).unwrap())
                .cmp(&datetime!(2019-12-31 23:59:59.999_999_999)),
            Ordering::Less
        );
        assert_eq!(
            Date::from_calendar_date(2019, Month::January, 1)
                .unwrap()
                .with_time(Time::from_hms(0, 0, 1).unwrap())
                .cmp(&datetime!(2019-01-01 0:00)),
            Ordering::Greater
        );
    }
}
False
========================================
    use crate::Date;
    use crate::Month;
    use time_macros::date;

    #[test]
    fn test_year() {
        assert_eq!(date!(2019 - 01 - 01).year(), 2019);
        assert_eq!(date!(2019 - 12 - 31).year(), 2019);
        assert_eq!(date!(2020 - 01 - 01).year(), 2020);
        assert_eq!(date!(10000 - 01 - 01).year(), 10000);

        // Note: The time crate does not support dates before year 0 or after 9999
        // if the `large-dates` feature is not enabled. The following two tests
        // should not be used unless `large-dates` feature is enabled. Otherwise,
        // the creation of dates with the year less than 0 or greater than 9999
        // will result in compilation error.

        // Uncomment below tests if the `large-dates` feature is enabled.
        // assert_eq!(date!(-10000 - 01 - 01).year(), -10000);
    }
}
False
========================================
#[cfg(test)]
mod date_time_eq_tests {
    use crate::{ext::NumericalDuration, macros::{datetime, date, time}, Date, Time, UtcOffset, OffsetDateTime};
    use std::crate::SystemTime;

    #[test]
    fn eq_same_instant() {
        let system_time = SystemTime::now();
        let fixed_time = OffsetDateTime::now_utc();

        assert_eq!(system_time, fixed_time);
    }

    #[test]
    fn eq_different_instants_same_point() {
        let system_time = SystemTime::UNIX_EPOCH + 1.std_days();
        let fixed_time = datetime!(1970-01-02 0:00:00 UTC);

        assert_eq!(system_time, fixed_time);
    }

    #[test]
    fn eq_same_instant_different_offsets() {
        let system_time = SystemTime::UNIX_EPOCH + 1.std_days() + 1.std_hours();
        let fixed_time_utc = datetime!(1970-01-02 1:00 UTC);
        let fixed_time_plus1 = datetime!(1970-01-02 2:00 +1);

        assert_eq!(system_time, fixed_time_utc);
        assert_ne!(system_time, fixed_time_plus1);
    }

    #[test]
    fn eq_boundary() {
        let date = date!(1970 - 01 - 01);
        let time_utc = time!(0:00);
        let fixed_time_utc = datetime!(1970-01-01 0:00 UTC);
        let fixed_time_plus1 = OffsetDateTime::from_unix_timestamp(0).unwrap().to_offset(UtcOffset::hours(1));

        assert_eq!(SystemTime::UNIX_EPOCH, fixed_time_utc);
        assert_ne!(SystemTime::UNIX_EPOCH, fixed_time_plus1);
    }

    #[test]
    fn ne_different_dates() {
        let system_time = SystemTime::UNIX_EPOCH + 1.std_hours();
        let fixed_time = datetime!(1970-01-01 1:00 UTC);

        assert_ne!(system_time, fixed_time);
    }

    #[test]
    fn ne_different_times() {
        let system_time = SystemTime::UNIX_EPOCH + 1.std_hours() + 30.std_minutes();
        let fixed_time = datetime!(1970-01-01 1:00 UTC);

        assert_ne!(system_time, fixed_time);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::{macros::datetime, Date, Duration, OffsetDateTime, PrimitiveDateTime, Time, UtcOffset, Weekday};
    use core::cmp::Ordering;
    use std::crate::SystemTime;

    #[test]
    fn partial_cmp_with_system_time_before_epoch() {
        let system_time = SystemTime::UNIX_EPOCH - Duration::seconds(5);
        let datetime = PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms(0, 0, 1).unwrap());
        let datetime = datetime.assume_utc();
        assert_eq!(system_time.partial_cmp(&datetime), Some(Ordering::Less));
    }

    #[test]
    fn partial_cmp_with_system_time_after_epoch() {
        let system_time = SystemTime::UNIX_EPOCH + Duration::seconds(5);
        let datetime = PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms(0, 0, 1).unwrap());
        let datetime = datetime.assume_utc();
        assert_eq!(system_time.partial_cmp(&datetime), Some(Ordering::Greater));
    }

    #[test]
    fn partial_cmp_with_system_time_equal_epoch() {
        let system_time = SystemTime::UNIX_EPOCH + Duration::seconds(1);
        let datetime = PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms(0, 0, 1).unwrap());
        let datetime = datetime.assume_utc();
        assert_eq!(system_time.partial_cmp(&datetime), Some(Ordering::Equal));
    }

    #[test]
    fn partial_cmp_with_system_time_equal() {
        let system_time = SystemTime::UNIX_EPOCH + Duration::seconds(1);
        let datetime = PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms(0, 0, 1).unwrap());
        let datetime = datetime.assume_utc();
        assert_eq!(system_time.partial_cmp(&datetime), Some(Ordering::Equal));
    }

    #[test]
    fn partial_cmp_with_system_time_with_offset() {
        let system_time = SystemTime::UNIX_EPOCH + Duration::seconds(1);
        let datetime = OffsetDateTime::from_unix_timestamp(1).unwrap();
        assert_eq!(system_time.partial_cmp(&datetime), Some(Ordering::Equal));
    }
}
False
========================================
    use crate::offset_kind;
    use crate::date_crate::DateTime;
    use crate::{ext::NumericalDuration, macros::datetime};
    use std::crate::{Duration as StdDuration, SystemTime};

    #[test]
    fn from_datetime_to_system_time_at_unix_epoch() {
        let dt: DateTime<offset_kind::Fixed> = DateTime::UNIX_EPOCH;
        let st: SystemTime = SystemTime::UNIX_EPOCH;
        assert_eq!(SystemTime::from(dt), st);
    }

    #[test]
    fn from_datetime_to_system_time_before_unix_epoch() {
        let dt: DateTime<offset_kind::Fixed> = DateTime::UNIX_EPOCH - 1.seconds();
        let st: SystemTime = SystemTime::UNIX_EPOCH - StdDuration::from_secs(1);
        assert_eq!(SystemTime::from(dt), st);
    }

    #[test]
    fn from_datetime_to_system_time_after_unix_epoch() {
        let dt: DateTime<offset_kind::Fixed> = DateTime::UNIX_EPOCH + 1.seconds();
        let st: SystemTime = SystemTime::UNIX_EPOCH + StdDuration::from_secs(1);
        assert_eq!(SystemTime::from(dt), st);
    }

    #[test]
    fn from_datetime_to_system_time_far_future() {
        let dt: DateTime<offset_kind::Fixed> = datetime!(9999-12-31 23:59:59);
        let st = SystemTime::UNIX_EPOCH + dt.unix_timestamp().std_seconds();
        assert_eq!(SystemTime::from(dt), st);
    }

    #[test]
    fn from_datetime_to_system_time_far_past() {
        let dt: DateTime<offset_kind::Fixed> = datetime!(-9999-01-01 0:00:00);
        let st = SystemTime::UNIX_EPOCH - dt.unix_timestamp().unsigned_abs().std_seconds();
        assert_eq!(SystemTime::from(dt), st);
    }
}
False
========================================
    use super::*;

use crate::*;

    use std::crate::{Duration as StdDuration, SystemTime};
    use crate::Duration;

    #[test]
    fn test_add_zero_duration() {
        let sys_time = SystemTime::now();
        let zero_duration = Duration::ZERO;
        assert_eq!(sys_time.add(zero_duration), sys_time);
    }

    #[test]
    fn test_add_positive_duration() {
        let sys_time = SystemTime::now();
        let positive_duration = Duration::seconds(10); // 10 seconds
        let expected = sys_time + StdDuration::from_secs(10);
        assert_eq!(sys_time.add(positive_duration), expected);
    }

    #[test]
    fn test_add_negative_duration() {
        let sys_time = SystemTime::now();
        let negative_duration = Duration::seconds(-10); // -10 seconds
        let expected = sys_time - StdDuration::from_secs(10);
        assert_eq!(sys_time.add(negative_duration), expected);
    }

    #[test]
    fn test_add_positive_duration_with_nanoseconds() {
        let sys_time = SystemTime::now();
        let positive_duration = Duration::new(10, 500_000_000); // 10 seconds and 500 milliseconds
        let expected = sys_time + StdDuration::new(10, 500_000_000);
        assert_eq!(sys_time.add(positive_duration), expected);
    }

    #[test]
    fn test_add_negative_duration_with_nanoseconds() {
        let sys_time = SystemTime::now();
        let negative_duration = Duration::new(-10, -500_000_000); // -10 seconds and -500 milliseconds
        let expected = sys_time - StdDuration::new(10, 500_000_000);
        assert_eq!(sys_time.add(negative_duration), expected);
    }
}
False
========================================
    use std::crate::SystemTime;
    use crate::Duration;

    #[test]
    fn add_assign_duration_to_system_time() {
        let mut system_time = SystemTime::now();
        let duration = Duration::seconds(10);
        let expected = system_time + duration;
        system_time += duration;
        assert_eq!(system_time, expected);
    }

    #[test]
    fn add_assign_negative_duration_to_system_time() {
        let mut system_time = SystemTime::now();
        let duration = Duration::seconds(-10);
        let expected = system_time + duration;
        system_time += duration;
        assert_eq!(system_time, expected);
    }

    #[test]
    fn add_assign_zero_duration_to_system_time() {
        let mut system_time = SystemTime::now();
        let duration = Duration::ZERO;
        let expected = system_time.clone();
        system_time += duration;
        assert_eq!(system_time, expected);
    }

    #[test]
    fn add_assign_max_duration_to_system_time() {
        let mut system_time = SystemTime::UNIX_EPOCH;
        let duration = Duration::MAX;
        let expected = system_time + duration;
        system_time += duration;
        assert_eq!(system_time, expected);
    }

    #[test]
    fn add_assign_min_duration_to_system_time() {
        let mut system_time = SystemTime::UNIX_EPOCH;
        let duration = Duration::MIN;
        // Note: Duration::MIN cannot be added to SystemTime::UNIX_EPOCH.
        // The SystemTime representation in Rust does not allow it to go before the UNIX_EPOCH.
        // The following code is incorrect and needs to be addressed.
        let expected = system_time + duration;
        system_time += duration;
        assert_eq!(system_time, expected);
    }
}
False
========================================
    use std::crate::SystemTime;
    use crate::{Duration, OffsetDateTime};
    use crate::macros::{datetime, offset};

    #[test]
    fn sub_assign_system_time() {
        let system_time_now = SystemTime::now();
        let fixed_offset = offset!(UTC);

        let date_time = datetime!(2023-04-04 12:34:56).assume_offset(fixed_offset);

        let duration = date_time - system_time_now;
        let mut system_time = system_time_now;
        system_time -= date_time;

        let expected = OffsetDateTime::now_utc() - duration;
        let result: OffsetDateTime = system_time.into();

        assert_eq!(result, expected);
    }

    #[test]
    fn sub_system_time() {
        let system_time_now = SystemTime::now();
        let fixed_offset = offset!(UTC);

        let date_time = datetime!(2023-04-04 12:34:56).assume_offset(fixed_offset);

        let duration = system_time_now - date_time;
        let expected = OffsetDateTime::now_utc() - crate::Duration::try_from(duration).unwrap();

        assert_eq!(expected, OffsetDateTime::from(system_time_now));
    }

    #[test]
    fn system_time_sub_assign() {
        let system_time_now = SystemTime::now();

        let date_time = OffsetDateTime::now_utc();
        let mut system_time = system_time_now;
        system_time -= date_time;

        let result: OffsetDateTime = system_time.into();

        // This test is not deterministic because we cannot freeze time for both system_now and date_time.
        // Thus, comparing date_time and what's obtained from `system_time.into()` is not reliable.
        // What we can ensure is obtaining OffsetDateTime constructors do not fail.
        assert!(result.year() >= 2023);
    }

    #[test]
    fn system_time_sub() {
        let system_time_now = SystemTime::now();

        let date_time = OffsetDateTime::now_utc();
        let duration = system_time_now - date_time;

        // Similarly, this test is not deterministic.
        // Instead, we verify that the duration we obtain is non-negative.
        assert!(crate::Duration::try_from(duration).unwrap() >= Duration::ZERO);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;
    use std::crate::SystemTime;

    #[test]
    fn sub_positive_duration() {
        let system_time = SystemTime::now();
        let duration = Duration::seconds(5);
        let result = system_time.sub(duration);
        assert!(result < system_time);
    }

    #[test]
    fn sub_zero_duration() {
        let system_time = SystemTime::now();
        let duration = Duration::seconds(0);
        let result = system_time.sub(duration);
        assert_eq!(result, system_time);
    }

    #[test]
    fn sub_negative_duration() {
        let system_time = SystemTime::now();
        let duration = Duration::seconds(-5);
        let result = system_time.sub(duration);
        assert!(result > system_time);
    }

    #[test]
    fn sub_max_duration() {
        let system_time = SystemTime::now();
        let duration = Duration::MAX;
        let result = system_time.sub(duration);
        // Assumes the system time is not so early that it underflows the SystemTime
        // This could happen if the current SystemTime is too close to the UNIX_EPOCH.
        assert!(result < system_time);
    }

    #[test]
    fn sub_min_duration() {
        let system_time = SystemTime::now();
        let duration = Duration::MIN;
        let result = system_time.sub(duration);
        // Assumes the system time is not so late that it overflows the SystemTime
        // This could happen if the current SystemTime is too close to the SystemTime max value.
        assert!(result > system_time);
    }
}
False
========================================
    use std::crate::{Duration as StdDuration, SystemTime};
    use crate::Duration;
    use crate::ext::NumericalDuration;

    #[test]
    fn sub_assign_positive_duration() {
        let mut system_time = SystemTime::now();
        let original_time = system_time;
        let duration = 5.seconds();
        system_time -= duration;
        assert!(system_time < original_time);
    }

    #[test]
    fn sub_assign_zero_duration() {
        let mut system_time = SystemTime::now();
        let original_time = system_time;
        let duration = Duration::ZERO;
        system_time -= duration;
        assert_eq!(system_time, original_time);
    }

    #[test]
    fn sub_assign_negative_duration() {
        let mut system_time = SystemTime::now();
        let original_time = system_time;
        let duration = (-5).seconds();
        system_time -= duration;
        assert!(system_time > original_time);
    }

    #[test]
    fn sub_assign_std_duration() {
        let mut system_time = SystemTime::now();
        let original_time = system_time;
        let std_duration = StdDuration::from_secs(5);
        let duration = Duration::try_from(std_duration).unwrap();
        system_time -= duration;
        assert!(system_time < original_time);
    }

    #[test]
    #[should_panic]
    fn sub_assign_overflow() {
        let mut system_time = SystemTime::UNIX_EPOCH;
        let duration = Duration::MIN;
        system_time -= duration;
    }
}
False
========================================
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::date::Date;
    use crate::crate::Time;
    use time_macros::{datetime};

    #[test]
    fn as_hms_midnight() {
        let dt: DateTime<Fixed> = DateTime::new(date!(2023-04-01), Time::MIDNIGHT).assume_utc();
        assert_eq!(dt.as_hms(), (0, 0, 0));
    }

    #[test]
    fn as_hms_noon() {
        let dt: DateTime<Fixed> = DateTime::new(date!(2023-04-01), Time::from_hms(12, 0, 0).unwrap()).assume_utc();
        assert_eq!(dt.as_hms(), (12, 0, 0));
    }

    #[test]
    fn as_hms_before_midnight() {
        let dt: DateTime<Fixed> = DateTime::new(date!(2023-04-01), Time::from_hms(23, 59, 59).unwrap()).assume_utc();
        assert_eq!(dt.as_hms(), (23, 59, 59));
    }

    #[test]
    fn as_hms_arbitrary() {
        let dt: DateTime<Fixed> = DateTime::new(date!(2023-04-01), Time::from_hms(14, 15, 36).unwrap()).assume_utc();
        assert_eq!(dt.as_hms(), (14, 15, 36));
    }

    #[test]
    fn as_hms_maximum() {
        let dt: DateTime<Fixed> = DateTime::new(
            Date::from_ordinal_date(9999, 365).unwrap(),
            Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap()
        ).assume_utc();
        assert_eq!(dt.as_hms(), (23, 59, 59));
    }

    #[test]
    #[should_panic]
    fn as_hms_date_time_out_of_range() {
        let dt: DateTime<Fixed> = DateTime::new(
            Date::from_ordinal_date(10000, 1).unwrap_err(), // This should panic
            Time::MIDNIGHT
        ).assume_utc();
        let _ = dt.as_hms(); // This should panic
    }
}
False
========================================
    use crate::{ext::NumericalDuration, Date, Month, PrimitiveDateTime, Time};
    use time_macros::datetime;

    #[test]
    fn as_hms_micro() {
        let time = Time::from_hms_micro(14, 15, 16, 123_456).unwrap();
        let date = Date::from_calendar_date(2023, Month::March, 16).unwrap();
        let datetime = PrimitiveDateTime::new(date, time);

        assert_eq!(datetime.as_hms_micro(), (14, 15, 16, 123_456));
    }

    #[test]
    fn as_hms_micro_midnight() {
        let datetime = datetime!(2023-03-16 0:00);
        assert_eq!(datetime.as_hms_micro(), (0, 0, 0, 0));
    }

    #[test]
    fn as_hms_micro_just_before_midnight() {
        let datetime = datetime!(2023-03-16 23:59:59.999_999);
        assert_eq!(datetime.as_hms_micro(), (23, 59, 59, 999_999));
    }

    #[test]
    fn as_hms_micro_leap_second() {
        let time = Time::from_hms_micro(23, 59, 59, 1_000_000).unwrap();
        let date = Date::from_calendar_date(2023, Month::December, 31).unwrap();
        let datetime = PrimitiveDateTime::new(date, time);

        // Leap seconds are not supported; they will roll over to the next day.
        assert_eq!(datetime.as_hms_micro(), (0, 0, 0, 0));
    }

    #[test]
    fn as_hms_micro_large_time() {
        let time = Time::from_hms_micro(48, 0, 0, 0).unwrap_or_else(|_| Time::MIDNIGHT);
        let date = Date::MIN;
        let datetime = PrimitiveDateTime::new(date, time);

        // Large hours value (such as 48) will be wrapped or corrected to a valid value.
        assert_eq!(datetime.as_hms_micro(), (0, 0, 0, 0));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::date_crate::offset_kind::None;
    use crate::crate::Padding;
    use crate::crate::Time;
    use crate::Duration;
    use crate::Month;
    use crate::Weekday;
    use std::cmp::Ordering;
    use std::crate::Duration as StdDuration;

    #[test]
    fn as_hms_milli_returns_correct_values() {
        let time = Time::from_hms_milli(12, 34, 56, 789).unwrap();

        let datetime = DateTime::new(
            Date::from_calendar_date(2021, Month::January, 1).unwrap(),
            time,
        );

        assert_eq!(datetime.as_hms_milli(), (12, 34, 56, 789));
    }

    #[test]
    fn partial_eq_is_correct() {
        let time = Time::from_hms(12, 34, 56).unwrap();
        let date = Date::from_calendar_date(2021, Month::January, 1).unwrap();

        let datetime_1 = DateTime::new(date, time);

        let time = Time::from_hms(12, 34, 56).unwrap();
        let datetime_2 = DateTime::new(date, time);

        let time = Time::from_hms(11, 34, 56).unwrap();
        let datetime_3 = DateTime::new(date, time);

        assert_eq!(datetime_1, datetime_2);
        assert_ne!(datetime_1, datetime_3);
    }
    
    #[test]
    fn partial_ord_is_correct() {
        let time = Time::from_hms(12, 34, 56).unwrap();
        let date = Date::from_calendar_date(2021, Month::January, 1).unwrap();
        let datetime_1 = DateTime::new(date, time);

        let time = Time::from_hms(12, 34, 56).unwrap();
        let datetime_2 = DateTime::new(date, time);

        let time = Time::from_hms(11, 34, 56).unwrap();
        let datetime_3 = DateTime::new(date, time);

        assert_eq!(datetime_1.partial_cmp(&datetime_2), Some(Ordering::Equal));
        assert_eq!(datetime_1.partial_cmp(&datetime_3), Some(Ordering::Greater));
        assert_eq!(datetime_3.partial_cmp(&datetime_1), Some(Ordering::Less));
    }

    #[test]
    fn time_subtraction_is_correct() {
        let time_1 = Time::from_hms(12, 34, 56).unwrap();
        let time_2 = Time::from_hms(14, 34, 56).unwrap();
        let duration = time_2 - time_1;

        assert_eq!(duration, StdDuration::from_secs(2 * 60 * 60));
    }

    #[test]
    fn add_duration_to_time_wraps_correctly() {
        let time = Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap();
        let added_time = time + Duration::milliseconds(2);
        assert_eq!(added_time.hour(), 0);
        assert_eq!(added_time.minute(), 0);
        assert_eq!(added_time.second(), 0);
        assert_eq!(added_time.nanosecond(), 1_999_999);
    }

    #[test]
    fn date_time_is_correct_for_leap_year() {
        let datetime = DateTime::<None>::from_iso_week_date(2020, 9, Weekday::Monday).unwrap();
        assert_eq!(datetime.to_calendar_date(), (2020, Month::February, 24));
    }
}
False
========================================
    use crate::Date;
    use crate::OffsetDateTime;
    use crate::Time;
    use crate::UtcOffset;
    use crate::macros::datetime;
    
    #[test]
    fn test_as_hms_nano() {
        let utc_offset = UtcOffset::UTC;
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(0).unwrap().as_hms_nano(),
            (0, 0, 0, 0)
        );
        assert_eq!(
            datetime!(2022-12-31 23:59:59).assume_offset(utc_offset).as_hms_nano(),
            (23, 59, 59, 0)
        );
        assert_eq!(
            datetime!(2022-12-31 12:00).assume_offset(utc_offset).as_hms_nano(),
            (12, 0, 0, 0)
        );
        assert_eq!(
            datetime!(2022-12-31 12:00:00.000_000_001).assume_offset(utc_offset).as_hms_nano(),
            (12, 0, 0, 1)
        );
    }
}
False
========================================
     use crate::offset::UtcOffset;
     use crate::util::DateAdjustment;
     use crate::Date;
     use crate::Time;
     use crate::PrimitiveDateTime;
     use crate::Month;
     use crate::Weekday;
     use crate::util;
     use crate::Padding;
     use crate::Duration;
     use crate::error;
     use core::hash::Hash;
     use core::fmt;
     use core::ops::Add;
     use core::ops::Sub;
     use core::ops::AddAssign;
     use core::ops::SubAssign;
     use core::cmp::Ord;
     use core::cmp::PartialOrd;
     use core::cmp::PartialEq;
     use core::cmp::Eq;
     use core::hash::Hasher;
     use core::cmp::Ordering;
     use std::io;
     use crate::error::ComponentRange;
     use crate::format_description::FormatItem;
     use std::error::Error;
     use crate::parsing::Parsable;
     use crate::format_description::modifier::Padding;
     use std::fmt::Write;
     use crate::format_description::modifier::SubsecondDigits;
     use crate::format_description::modifier::WeekNumber;
     use crate::format_description::modifier::Component;
     use crate::format_description::modifier::WeekdayRepr;
     use crate::format_description::modifier::MonthRepr;
     use crate::format_description::modifier::Day;
     use crate::format_description::modifier::OffsetHour;
     use crate::format_description::modifier::OffsetMinute;
     use crate::format_description::modifier::OffsetSecond;
     use crate::format_description::modifier::Period;
     use crate::format_description::modifier::Hour;
     use crate::format_description::modifier::Minute;
     use crate::format_description::modifier::Second;
     use crate::format_description::modifier::Subsecond;
     use std::crate::SystemTime;
     use crate::parsing::Parsed;
     use crate::util::days_in_year;
     use crate::util::days_in_year_month;
     use crate::util::is_leap_year;
     use crate::util::weeks_in_year;
     use crate::util::div_floor;
     use std::marker::Copy;
     use crate::offset::offset::UtcOffset;
     use crate::date_crate::DateTime;
     use crate::date_crate::offset_kind::Fixed;
     use std::crate::Duration as StdDuration;
     use crate::date_crate::PrimitiveDateTime as PrimitiveDateTimeTrait;
     use crate::date_crate::DateTime as DateTimeTrait;
     use crate::parsing::Parsable as ParsableTrait;
     use crate::format_description::FormatItem as FormatItemTrait;
     use crate::format_description::modifier::Modifier as ModifierTrait;
     use crate::parsing::combinator::Combinator as CombinatorTrait;

    #[test]
    fn assume_offset_east() {
        let datetime = PrimitiveDateTime::new(Date::from_calendar_date(2020, Month::January, 1).unwrap(), Time::from_hms(5, 0, 0).unwrap());
        let offset = UtcOffset::from_hms(2, 30, 0).unwrap();
        let fixed_offset_datetime = datetime.assume_offset(offset);
        assert_eq!(fixed_offset_datetime.offset, offset);
        assert_eq!(fixed_offset_datetime.date(), datetime.date());
        assert_eq!(fixed_offset_datetime.time(), datetime.time());
    }

    #[test]
    fn assume_offset_utc() {
        let datetime = PrimitiveDateTime::new(Date::from_calendar_date(2020, Month::January, 1).unwrap(), Time::from_hms(5, 0, 0).unwrap());
        let offset = UtcOffset::UTC;
        let fixed_offset_datetime = datetime.assume_offset(offset);
        assert_eq!(fixed_offset_datetime.offset, offset);
        assert_eq!(fixed_offset_datetime.date(), datetime.date());
        assert_eq!(fixed_offset_datetime.time(), datetime.time());
    }

    #[test]
    fn assume_offset_west() {
        let datetime = PrimitiveDateTime::new(Date::from_calendar_date(2020, Month::January, 1).unwrap(), Time::from_hms(5, 0, 0).unwrap());
        let offset = UtcOffset::from_hms(-7, 0, 0).unwrap();
        let fixed_offset_datetime = datetime.assume_offset(offset);
        assert_eq!(fixed_offset_datetime.offset, offset);
        assert_eq!(fixed_offset_datetime.date(), datetime.date());
        assert_eq!(fixed_offset_datetime.time(), datetime.time());
    }

    #[test]
    fn assume_offset_invalid_datetime() {
        // `assume_offset` should be infallible since it does not validate the datetime itself
        let datetime = PrimitiveDateTime::new(Date::MIN, Time::MIN);
        let offset = UtcOffset::from_hms(2, 30, 0).unwrap();
        let fixed_offset_datetime = datetime.assume_offset(offset);
        assert_eq!(fixed_offset_datetime.offset, offset);
        assert_eq!(fixed_offset_datetime.date(), datetime.date());
        assert_eq!(fixed_offset_datetime.time(), datetime.time());
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::macros::{date, datetime, time, offset};

    #[test]
    fn assume_utc() {
        let primitive = PrimitiveDateTime::new(date!(2022-01-27), time!(12:34:56));
        let fixed_offset = primitive.assume_utc();
        assert_eq!(fixed_offset, datetime!(2022-01-27 12:34:56 UTC));
    }

    #[test]
    fn assume_utc_min_max() {
        // MIN
        let primitive_min = PrimitiveDateTime::new(date!(MIN), time!(MIDNIGHT));
        let fixed_min = primitive_min.assume_utc();
        assert_eq!(fixed_min, datetime!(MIN MIDNIGHT UTC));

        // MAX
        let primitive_max = PrimitiveDateTime::new(date!(MAX), time!(MIDNIGHT));
        let fixed_max = primitive_max.assume_utc();
        assert_eq!(fixed_max, datetime!(MAX MIDNIGHT UTC));
    }

    #[test]
    fn assume_utc_with_offset() {
        let primitive = PrimitiveDateTime::new(date!(MIN), time!(MIDNIGHT));
        let offset_dt = primitive.assume_offset(offset!(+1));
        let fixed_offset = offset_dt.assume_utc();
        assert_eq!(fixed_offset, datetime!(MIN MIDNIGHT UTC));
    }
}
False
========================================
    use crate::date::Date;
    use crate::duration::Duration;
    use crate::crate::Time;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;

    #[test]
    fn checked_add_positive_duration() {
        let datetime = DateTime::<Fixed>::new(Date::from_ordinal_date(2020, 60).unwrap(), Time::MIDNIGHT);
        let duration = Duration::seconds(60);
        let result = datetime.checked_add(duration);
        assert_eq!(
            result,
            Some(DateTime::<Fixed>::new(
                Date::from_ordinal_date(2020, 60).unwrap(),
                Time::from_hms(0, 1, 0).unwrap()
            ))
        );
    }

    #[test]
    fn checked_add_negative_duration() {
        let datetime = DateTime::<Fixed>::new(Date::from_ordinal_date(2020, 60).unwrap(), Time::MIDNIGHT);
        let duration = Duration::seconds(-60);
        let result = datetime.checked_add(duration);
        assert_eq!(
            result,
            Some(DateTime::<Fixed>::new(
                Date::from_ordinal_date(2020, 59).unwrap(),
                Time::from_hms(23, 59, 0).unwrap()
            ))
        );
    }

    #[test]
    fn checked_add_duration_overflow() {
        let datetime = DateTime::<Fixed>::new(Date::MAX, Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap());
        let duration = Duration::seconds(1);
        let result = datetime.checked_add(duration);
        assert_eq!(result, None);
    }

    #[test]
    fn checked_add_duration_underflow() {
        let datetime = DateTime::<Fixed>::new(Date::MIN, Time::MIDNIGHT);
        let duration = Duration::seconds(-1);
        let result = datetime.checked_add(duration);
        assert_eq!(result, None);
    }

    // Add additional test cases as needed
}
False
========================================
    use crate::date::{Date, Month, Weekday};
    use crate::date_crate::DateTime;
    use crate::duration::Duration;
    use crate::crate::Time;
    use crate::utc_offset::UtcOffset;
    use crate::PrimitiveDateTime;
    use crate::OffsetDateTime;

    #[test]
    fn checked_sub() {
        let datetime = OffsetDateTime::new(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2020, Month::January, 6).unwrap(),
                Time::from_hms_milli(0, 0, 0, 0).unwrap(),
            ),
            UtcOffset::UTC,
        );
        let duration = Duration::seconds(1);

        // Case 1: No wrapping required
        let datetime_expected = OffsetDateTime::new(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2020, Month::January, 5).unwrap(),
                Time::from_hms_milli(23, 59, 59, 0).unwrap(),
            ),
            UtcOffset::UTC,
        );
        assert_eq!(
            datetime.checked_sub(duration),
            Some(datetime_expected),
        );

        // Case 2: Wrapping into previous year
        let datetime = OffsetDateTime::new(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2020, Month::January, 1).unwrap(),
                Time::from_hms_milli(0, 0, 0, 0).unwrap(),
            ),
            UtcOffset::UTC,
        );
        let datetime_expected = OffsetDateTime::new(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2019, Month::December, 31).unwrap(),
                Time::from_hms_milli(23, 59, 59, 0).unwrap(),
            ),
            UtcOffset::UTC,
        );
        assert_eq!(
            datetime.checked_sub(duration),
            Some(datetime_expected),
        );

        // Case 3: No time wrapping, change in date only
        let duration = Duration::seconds(86_400);
        let datetime_expected = OffsetDateTime::new(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2020, Month::January, 5).unwrap(),
                Time::from_hms_milli(0, 0, 0, 0).unwrap(),
            ),
            UtcOffset::UTC,
        );
        assert_eq!(
            datetime.checked_sub(duration),
            Some(datetime_expected),
        );

        // Case 4: Wrapping into previous year with time wrapping as well
        let duration = Duration::seconds(86_400 * 2);
        let datetime_expected = OffsetDateTime::new(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2019, Month::December, 31).unwrap(),
                Time::from_hms_milli(0, 0, 0, 0).unwrap(),
            ),
            UtcOffset::UTC,
        );
        assert_eq!(
            datetime.checked_sub(duration),
            Some(datetime_expected),
        );

        // Case 5: Wrapping to the previous leap year
        let duration = Duration::seconds(86_400 * 367);
        let datetime_expected = OffsetDateTime::new(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2019, Month::January, 1).unwrap(),
                Time::from_hms_milli(0, 0, 0, 0).unwrap(),
            ),
            UtcOffset::UTC,
        );
        assert_eq!(
            datetime.checked_sub(duration),
            Some(datetime_expected),
        );
    }
}
False
========================================
    use crate::DateTime;
    use crate::date::Date;
    use crate::crate::Time;
    use crate::utc_offset::UtcOffset;
    use crate::offset::Offset;
    use crate::date_crate::offset_kind::Fixed;
    use crate::date_crate::offset_kind::OffsetKind;
    use crate::date_crate::PrimitiveDateTime;
    use time_macros::{date, datetime, offset, time};

    #[test]
    fn test_checked_to_offset_same_offset() {
        let dt: DateTime<Fixed> = datetime!(2023-04-02 12:34:56 +02:00);
        let target_offset = offset!(+02:00);
        assert_eq!(
            dt.checked_to_offset(target_offset),
            Some(dt)
        );
    }

    #[test]
    fn test_checked_to_offset_different_offset() {
        let dt: DateTime<Fixed> = datetime!(2023-04-02 12:34:56 +02:00);
        let target_offset = offset!(-03:00);
        let expected: DateTime<Fixed> = datetime!(2023-04-02 07:34:56 -03:00);
        assert_eq!(
            dt.checked_to_offset(target_offset),
            Some(expected)
        );
    }

    #[test]
    fn test_checked_to_offset_out_of_bounds() {
        let dt: DateTime<Fixed> = datetime!(+9999-12-31 23:00:00 +00:00);
        let target_offset = offset!(+02:00);
        assert_eq!(
            dt.checked_to_offset(target_offset),
            None
        );
    }

    #[test]
    fn test_checked_to_offset_same_negative_offset() {
        let dt: DateTime<Fixed> = datetime!(2023-04-02 12:34:56 -02:00);
        let target_offset = offset!(-02:00);
        assert_eq!(
            dt.checked_to_offset(target_offset),
            Some(dt)
        );
    }

    #[test]
    fn test_checked_to_offset_negative_to_positive() {
        let dt: DateTime<Fixed> = datetime!(2023-04-02 12:34:56 -02:00);
        let target_offset = offset!(+02:00);
        let expected: DateTime<Fixed> = datetime!(2023-04-02 16:34:56 +02:00);
        assert_eq!(
            dt.checked_to_offset(target_offset),
            Some(expected)
        );
    }
}
False
========================================
    use crate::{DateTime, FixedOffset, Date, Time, Padding};
    use time_macros::{date, datetime, time};
    use core::cmp::Ordering;

    #[test]
    fn test_date() {
        let dt: DateTime<FixedOffset> = DateTime::new(date!(2023 - 04 - 10), time!(12:34:56));
        assert_eq!(dt.date(), date!(2023 - 04 - 10));
    }

    #[test]
    fn test_date_with_offset() {
        let dt = DateTime {
            date: date!(2023 - 04 - 10),
            time: time!(12:34:56),
            offset: FixedOffset::UTC,  // Assuming UTC offset for Fixed
        };
        assert_eq!(dt.date(), date!(2023 - 04 - 10));
    }

    #[test]
    fn test_date_min_max() {
        let dt_min: DateTime<FixedOffset> = DateTime::new(Date::MIN, Time::MIDNIGHT);
        let dt_max: DateTime<FixedOffset> = DateTime::new(Date::MAX, Time::MIDNIGHT);
        assert_eq!(dt_min.date(), Date::MIN);
        assert_eq!(dt_max.date(), Date::MAX);
    }

    #[test]
    fn test_date_unix_epoch() {
        let dt_epoch: DateTime<FixedOffset> = DateTime::UNIX_EPOCH;
        assert_eq!(dt_epoch.date(), date!(1970 - 01 - 01));
    }

    #[test]
    fn test_date_round_trip() {
        let dt: DateTime<FixedOffset> = DateTime::new(date!(2023 - 04 - 10), time!(12:34:56));
        let dt = DateTime::new(dt.date(), Time::MIDNIGHT);
        assert_eq!(dt, datetime!(2023 - 04 - 10 0:00));
    }
}
False
========================================
    use crate::date::Date;
    use crate::date::Month;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::crate::Time;
    use crate::util::days_in_year_month;
    use crate::Duration;
    use std::cmp::Ordering;

    #[test]
    fn day_within_month() {
        let time = Time::MIDNIGHT;
        for &(year, month, day) in &[
            (2020, Month::January, 3),
            (2020, Month::February, 29),
            (2020, Month::March, 15),
            (2020, Month::April, 1),
            (2020, Month::December, 31),
            (2019, Month::February, 28),
        ] {
            let date = Date::from_calendar_date(year, month, day).unwrap();
            let datetime = DateTime::new(date, time);
            assert_eq!(datetime.day(), day);
        }
    }

    #[test]
    fn day_across_months() {
        let time = Time::MIDNIGHT;

        let initial_date = Date::from_calendar_date(2020, Month::January, 31).unwrap();
        let datetime = DateTime::new(initial_date, time);
        assert_eq!(datetime.day(), 31);

        let next_day = datetime + Duration::days(1);
        assert_eq!(next_day.day(), 1);
    }

    #[test]
    fn day_across_years() {
        let time = Time::MIDNIGHT;
        let initial_date = Date::from_calendar_date(2019, Month::December, 31).unwrap();
        let datetime = DateTime::new(initial_date, time);
        assert_eq!(datetime.day(), 31);

        let next_day = datetime + Duration::days(1);
        assert_eq!(next_day.day(), 1);
        assert_eq!(next_day.year(), 2020);
    }

    #[test]
    fn day_on_leap_year() {
        let time = Time::MIDNIGHT;
        let initial_date = Date::from_calendar_date(2020, Month::February, 28).unwrap();
        let datetime = DateTime::new(initial_date, time);
        assert_eq!(datetime.day(), 28);

        let next_day = datetime + Duration::days(1);
        assert_eq!(next_day.day(), 29);

        let day_after = next_day + Duration::days(1);
        assert_eq!(day_after.day(), 1);
        assert_eq!(day_after.month(), Month::March);
    }

    #[test]
    fn day_on_non_leap_year() {
        let time = Time::MIDNIGHT;
        let initial_date = Date::from_calendar_date(2019, Month::February, 28).unwrap();
        let datetime = DateTime::new(initial_date, time);
        assert_eq!(datetime.day(), 28);

        let next_day = datetime + Duration::days(1);
        assert_eq!(next_day.day(), 1);
        assert_eq!(next_day.month(), Month::March);
    }

    #[test]
    fn day_on_invalid_date() {
        let result = Date::from_calendar_date(2020, Month::February, 30);
        if let Ok(date) = result {
            assert!(date.day() != 30);
        } else {
            assert!(result.is_err());
        }
    }
}
False
========================================
    use crate::DateTime;
    use crate::error::ComponentRange;
    use crate::OffsetDateTime;
    use crate::UtcOffset;
    use crate::Date;
    use crate::Time;

    // Dummy struct to represent a type with a logical UTC offset
    struct Utc;

    // Implement `MaybeOffset` for `Utc`
    impl crate::MaybeOffset for Utc {
        type LogicalOffsetType = UtcOffset;

        fn maybe_offset(&self) -> Option<Self::LogicalOffsetType> {
            Some(UtcOffset::UTC)
        }
    }

    // Implement `HasLogicalOffset` for `Utc`
    impl crate::sealed::HasLogicalOffset for Utc {}

    #[test]
    fn test_from_unix_timestamp_within_range() {
        let timestamp = 1_578_454_000; // Some valid timestamp
        let result = DateTime::<Utc>::from_unix_timestamp(timestamp);
        assert!(result.is_ok());
    }

    #[test]
    fn test_from_unix_timestamp_below_min_range() {
        let timestamp = i64::MIN; // Minimum possible i64 value, definitely below the supported unix timestamp range
        let result = DateTime::<Utc>::from_unix_timestamp(timestamp);
        assert!(matches!(result, Err(ComponentRange)));
    }

    #[test]
    fn test_from_unix_timestamp_above_max_range() {
        let timestamp = i64::MAX; // Maximum possible i64 value, definitely above the supported unix timestamp range
        let result = DateTime::<Utc>::from_unix_timestamp(timestamp);
        assert!(matches!(result, Err(ComponentRange)));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Date;
    use crate::Time;
    use crate::UtcOffset;
    use crate::error::ComponentRange;
    use crate::util::NumericalDuration;
    use crate::util::NumericalStdDuration;
    use crate::util::NumericalStdDurationShort;
    use crate::util::NumericalDurationShort;
    use crate::prelude::*;

    struct MockUtc;

    impl MaybeOffset for MockUtc {
        fn maybe_utc_offset(&self) -> Option<UtcOffset> {
            Some(UtcOffset::UTC)
        }
    }

    impl crate::offset::HasUtcOffset for MockUtc {
        fn offset(&self) -> UtcOffset {
            UtcOffset::UTC
        }
    }
    
    impl crate::offset::HasLocalOffset for MockUtc {
        fn offset(&self) -> UtcOffset {
            UtcOffset::UTC
        }
    }

    #[test]
    fn test_from_unix_timestamp_nanos_at_epoch() {
        let timestamp_nanos_at_epoch = 0_i128;
        let result = DateTime::<MockUtc>::from_unix_timestamp_nanos(timestamp_nanos_at_epoch);
        assert!(result.is_ok());
        let datetime = result.unwrap();
        assert_eq!(datetime.date(), Date::from_calendar_date(1970, 1, 1).unwrap());
        assert_eq!(datetime.time(), Time::from_hms_nano(0, 0, 0, 0).unwrap());
    }

    #[test]
    fn test_from_unix_timestamp_nanos_positive() {
        let timestamp_nanos_positive = 1_000_000_000_i128;
        let result = DateTime::<MockUtc>::from_unix_timestamp_nanos(timestamp_nanos_positive);
        assert!(result.is_ok());
        let datetime = result.unwrap();
        assert_eq!(datetime.time().nanosecond(), 0);
    }

    #[test]
    fn test_from_unix_timestamp_nanos_negative() {
        let timestamp_nanos_negative = -1_000_000_000_i128;
        let result = DateTime::<MockUtc>::from_unix_timestamp_nanos(timestamp_nanos_negative);
        assert!(result.is_ok());
        let datetime = result.unwrap();
        assert_eq!(datetime.time().nanosecond(), 0);
    }

    #[test]
    fn test_from_unix_timestamp_nanos_out_of_range() {
        let timestamp_nanos_out_of_range = i128::MAX;
        let result = DateTime::<MockUtc>::from_unix_timestamp_nanos(timestamp_nanos_out_of_range);
        assert!(result.is_err());
        let error = result.unwrap_err();
        match error {
            ComponentRange { .. } => (),
            _ => panic!("Expected ComponentRange error"),
        }
    }
}
False
========================================
    use crate::PrimitiveDateTime; // Import the structure that the datetime macro corresponds to
    use crate::offset::UtcOffset; // Import the UtcOffset structure that the offset macro corresponds to
    use crate::UtcOffsetKind; // Import the UtcOffsetKind trait for the offset macro to use

    use crate::DateTime; // Import the DateTime structure in use in this file
    use time_macros::datetime; // Use datetime macro from time_macros crate

    #[test]
    fn hour() {
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 00:00:00), UtcOffset::UTC).hour(), 0);
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 23:59:59), UtcOffset::UTC).hour(), 23);
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 12:00:00), UtcOffset::UTC).hour(), 12);
    }

    #[test]
    fn hour_with_offset() {
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 00:00:00), UtcOffset::hours(1)).hour(), 0);
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 23:59:59), UtcOffset::hours(-2) + UtcOffset::minutes(-30)).hour(), 23);
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 12:00:00), UtcOffset::hours(5) + UtcOffset::minutes(45)).hour(), 12);
    }

    #[test]
    fn hour_on_offset_boundaries() {
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 23:59:59.999_999_999), UtcOffset::UTC).hour(), 23);
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 00:00:00), UtcOffset::hours(-1)).hour(), 0);
        assert_eq!(PrimitiveDateTime::new(datetime!(2022-01-01 23:00:00), UtcOffset::hours(1)).hour(), 23);
    }
}
False
========================================
    use super::*; // Make all items under the current module available.

use crate::*;
    use crate::OffsetDateTime; // Assuming the current module is `date_time`.

    #[test]
    fn test_iso_week() {
        let tests = &[
            (OffsetDateTime::UNIX_EPOCH, 1),
            (date!(2005-12-31).midnight().assume_utc(), 52),
            (date!(2007-01-01).midnight().assume_utc(), 1),
            // Add more test cases as needed
        ];

        for &(datetime, expected) in tests {
            assert_eq!(datetime.iso_week(), expected);
        }
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::offset::UtcOffset;
    use crate::PrimitiveDateTime as DateTime;
    use crate::util::days_in_year;
    use core::crate::Duration as StdDuration;

    #[test]
    fn microsecond_none_offset() {
        let date = Date::from_ordinal_date(2023, 1).unwrap();
        let time = Time::from_hms_micro(12, 30, 15, 678_901).unwrap();
        let datetime = DateTime::new(date.with_hms_micro(12, 30, 15, 678_901).unwrap());

        assert_eq!(datetime.microsecond(), 678_901);
    }

    #[test]
    fn microsecond_fixed_offset() {
        let date = Date::from_ordinal_date(2023, 1).unwrap();
        let time = Time::from_hms_micro(12, 30, 15, 123_456).unwrap();
        let datetime = DateTime::new(date.with_hms_micro(12, 30, 15, 123_456).unwrap());

        assert_eq!(datetime.microsecond(), 123_456);
    }

    #[test]
    fn microsecond_midnight() {
        let date = Date::from_ordinal_date(2023, 1).unwrap();
        let datetime = DateTime::new(date.midnight());

        assert_eq!(datetime.microsecond(), 0);
    }

    #[test]
    fn microsecond_max_time() {
        let date = Date::from_ordinal_date(2023, days_in_year(2023)).unwrap();
        let time = Time::from_hms_micro(23, 59, 59, 999_999).unwrap();
        let datetime = DateTime::new(date.with_hms_micro(23, 59, 59, 999_999).unwrap());

        assert_eq!(datetime.microsecond(), 999_999);
    }

    #[test]
    fn microsecond_min_time() {
        let date = Date::from_ordinal_date(2023, 1).unwrap();
        let time = Time::from_hms_micro(0, 0, 0, 0).unwrap();
        let datetime = DateTime::new(date.with_hms_micro(0, 0, 0, 0).unwrap());

        assert_eq!(datetime.microsecond(), 0);
    }

    #[test]
    fn microsecond_wrap_around() {
        let date = Date::from_ordinal_date(2023, 1).unwrap();
        let time = Time::from_hms_micro(23, 59, 59, 999_999).unwrap();
        let mut datetime = DateTime::new(date.with_hms_micro(23, 59, 59, 999_999).unwrap());
        datetime = datetime + StdDuration::new(1, 0);

        assert_eq!(datetime.microsecond(), 999_999);
        assert_eq!(datetime.time().hour(), 0);
    }

    #[test]
    fn microsecond_leap_year() {
        let date = Date::from_ordinal_date(2024, 60).unwrap(); // Feb 29, 2024
        let time = Time::from_hms_micro(12, 0, 0, 500_000).unwrap();
        let datetime = DateTime::new(date.with_hms_micro(12, 0, 0, 500_000).unwrap());

        assert_eq!(datetime.microsecond(), 500_000);
    }

    #[test]
    #[should_panic(expected = "provided value is out of range")]
    fn microsecond_invalid() {
        let date = Date::from_ordinal_date(2023, 1).unwrap();
        // Exceed the maximum microsecond value, expect panic
        let _ = DateTime::new(date.with_hms_micro(12, 30, 15, 1_000_000).unwrap());
    }
}
False
========================================
    use crate::{Date, Month, Time};
    use crate::util::DateAdjustment;
    use crate::PrimitiveDateTime as DateTime;

    #[test]
    fn millisecond() {
        // Test with a fixed millisecond
        let dt = DateTime {
            date: Date::from_calendar_date(2023, Month::January, 1).unwrap(),
            time: Time::from_hms_milli(12, 0, 0, 500).unwrap(),
            offset: DateAdjustment::None,
        };
        assert_eq!(dt.millisecond(), 500);

        // Test with 0 milliseconds
        let dt = DateTime {
            date: Date::from_calendar_date(2023, Month::January, 1).unwrap(),
            time: Time::MIDNIGHT,
            offset: DateAdjustment::None,
        };
        assert_eq!(dt.millisecond(), 0);

        // Test with max milliseconds (999)
        let dt = DateTime {
            date: Date::from_calendar_date(2023, Month::January, 1).unwrap(),
            time: Time::from_hms_milli(23, 59, 59, 999).unwrap(),
            offset: DateAdjustment::None,
        };
        assert_eq!(dt.millisecond(), 999);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Date;
    use crate::OffsetDateTime;
    use crate::Time;

    #[test]
    fn minute_return_correct_value() {
        let date = Date::from_calendar_date(2023, Month::March, 16).unwrap();
        let time = Time::from_hms(14, 26, 38).unwrap();
        let date_time = OffsetDateTime::new(date, time, crate::UtcOffset::UTC);

        assert_eq!(date_time.minute(), 26);
    }
}
False
========================================
    use crate::Date;
    use crate::macros::date;

    #[test]
    fn monday_based_week_first_week_january() {
        // January 1, 2019 is a Tuesday, so January 1 is part of the 1st week
        // based on Monday as the first day of the week.
        let dt = Date::from_calendar_date(2019, crate::Month::January, 1).unwrap();
        assert_eq!(dt.monday_based_week(), 1);
    }

    #[test]
    fn monday_based_week_last_week_december() {
        // December 31, 2018 is a Monday, so December 31 is part of the 53rd week
        // based on Monday as the first day of the week.
        let dt = Date::from_calendar_date(2018, crate::Month::December, 31).unwrap();
        assert_eq!(dt.monday_based_week(), 53);
    }

    #[test]
    fn monday_based_week_first_week_monday() {
        // January 7, 2019 is a Monday, so January 7 is part of the 2nd week
        // based on Monday as the first day of the week.
        let dt = Date::from_calendar_date(2019, crate::Month::January, 7).unwrap();
        assert_eq!(dt.monday_based_week(), 2);
    }

    #[test]
    fn monday_based_week_middle_of_year() {
        // July 1, 2019 is a Monday, so July 1 is part of the 27th week
        // based on Monday as the first day of the week.
        let dt = Date::from_calendar_date(2019, crate::Month::July, 1).unwrap();
        assert_eq!(dt.monday_based_week(), 27);
    }

    #[test]
    fn monday_based_week_end_of_year() {
        // December 30, 2019 is a Monday, so December 30 is part of the 53rd week
        // based on Monday as the first day of the week.
        let dt = Date::from_calendar_date(2019, crate::Month::December, 30).unwrap();
        assert_eq!(dt.monday_based_week(), 53);
    }

    #[test]
    fn monday_based_week_leap_year() {
        // January 1, 2020 is a Wednesday, the first Monday is January 6, so January 1 is part of the 1st week.
        let dt = Date::from_calendar_date(2020, crate::Month::January, 1).unwrap();
        assert_eq!(dt.monday_based_week(), 1);
    }

    #[test]
    fn monday_based_week_non_leap_year() {
        // January 1, 2019 is a Tuesday, the first Monday is January 7, so January 1 is part of the 1st week.
        let dt = Date::from_calendar_date(2019, crate::Month::January, 1).unwrap();
        assert_eq!(dt.monday_based_week(), 1);
    }

    #[test]
    fn monday_based_week_last_day_of_leap_year() {
        // December 31, 2020 is a Thursday, the first Monday was January 6, so December 31 is part of the 53rd week.
        let dt = Date::from_calendar_date(2020, crate::Month::December, 31).unwrap();
        assert_eq!(dt.monday_based_week(), 53);
    }
}
False
========================================
    use crate::{Date, Month, offset::OffsetDateTime, Time};

    #[test]
    fn test_month() {
        let date = Date::from_calendar_date(2023, Month::January, 1).unwrap();
        let time = Time::from_hms(12, 0, 0).unwrap();
        let datetime = OffsetDateTime::from_unix_timestamp(0).unwrap();
        let datetime = datetime.replace_date(date).replace_time(time);
        assert_eq!(datetime.month(), Month::January);
    }
}
False
========================================
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::Date;
    use crate::Time;
    use crate::UtcOffset;

    #[test]
    fn nanosecond() {
        let date = DateTime::<Fixed>::new(
            Date::from_calendar_date(2022, crate::Month::January, 1).unwrap(),
            Time::from_hms_nano(1, 2, 3, 4).unwrap(),
        )
        .assume_offset(UtcOffset::UTC);
        assert_eq!(date.nanosecond(), 4);
    }
}
False
========================================
    use crate::date::Date;
    use crate::crate::Time;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::None;
    use crate::Month;

    /// Ensure that the `DateTime::new` method correctly constructs a `DateTime` with the provided
    /// `Date` and `Time` components.
    #[test]
    fn test_date_time_new() {
        let date = Date::from_calendar_date(2023, Month::March, 15)
            .expect("date should be valid");
        let time = Time::from_hms(12, 30, 45).expect("time should be valid");
        let datetime = DateTime::<None>::new(date, time);

        assert_eq!(datetime.date(), date, "Date component should match");
        assert_eq!(datetime.time(), time, "Time component should match");
    }
}
False
========================================
    use crate::DateTime;
    use std::crate::SystemTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::date_crate::sealed::{IsOffsetKindFixed, MaybeOffset};

    #[test]
    fn now_utc_returns_system_time() {
        let utc_now = DateTime::<Fixed>::now_utc();
        let sys_now = SystemTime::now();
        assert_eq!(utc_now, DateTime::<Fixed>::from(sys_now));
    }
}
False
========================================
    use crate::date::Date;
    use crate::date_crate::DateTime;
    use crate::crate::Time;
    use crate::utc_offset::UtcOffset;
    use time_macros::{date, time, offset};

    #[test]
    fn offset_returns_correct_offset() {
        let datetime = DateTime::<UtcOffset> {
            date: date!(2022 - 01 - 01),
            time: time!(12:00),
            offset: offset!(+2:00),
        };
        assert_eq!(datetime.offset(), offset!(+2:00));
    }

    #[test]
    fn offset_returns_correct_offset_utc() {
        let datetime = DateTime::<UtcOffset> {
            date: date!(2022 - 01 - 01),
            time: time!(00:00),
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime.offset(), UtcOffset::UTC);
    }

    #[test]
    fn offset_returns_correct_offset_negative() {
        let datetime = DateTime::<UtcOffset> {
            date: date!(2022 - 01 - 01),
            time: time!(12:00),
            offset: offset!(-5:00),
        };
        assert_eq!(datetime.offset(), offset!(-5:00));
    }

    #[test]
    fn offset_with_max_time() {
        let datetime = DateTime::<UtcOffset> {
            date: date!(2022 - 01 - 01),
            time: Time::MAX,
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime.offset(), UtcOffset::UTC);
    }

    #[test]
    fn offset_with_min_time() {
        let datetime = DateTime::<UtcOffset> {
            date: date!(2022 - 01 - 01),
            time: Time::MIN,
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime.offset(), UtcOffset::UTC);
    }

    #[test]
    fn offset_with_max_date() {
        let datetime = DateTime::<UtcOffset> {
            date: Date::MAX,
            time: time!(12:00),
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime.offset(), UtcOffset::UTC);
    }

    #[test]
    fn offset_with_min_date() {
        let datetime = DateTime::<UtcOffset> {
            date: Date::MIN,
            time: time!(12:00),
            offset: UtcOffset::UTC,
        };
        assert_eq!(datetime.offset(), UtcOffset::UTC);
    }
}
False
========================================
    use crate::macros::datetime;
    use crate::ext::NumericalDuration;
    use crate::date::Date;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::None;
    use crate::date_crate::offset_kind::Fixed;

    #[test]
    fn ordinal() {
        assert_eq!(datetime!(2020-01-01 0:00).ordinal(), 1);
        assert_eq!(datetime!(2020-02-01 0:00).ordinal(), 32);
        assert_eq!(datetime!(2020-12-31 0:00).ordinal(), 366);
        assert_eq!(datetime!(2019-01-01 0:00).ordinal(), 1);
        assert_eq!(datetime!(2019-12-31 0:00).ordinal(), 365);
    }

    #[test]
    fn ordinal_with_time() {
        assert_eq!(datetime!(2020-01-01 12:00).ordinal(), 1);
        assert_eq!(datetime!(2020-02-01 23:59:59).ordinal(), 32);
        assert_eq!(datetime!(2020-12-31 1:01:01).ordinal(), 366);
        assert_eq!(datetime!(2019-01-01 3:02:02).ordinal(), 1);
        assert_eq!(datetime!(2019-12-31 4:03:03).ordinal(), 365);
    }

    #[test]
    fn ordinal_with_offset() {
        assert_eq!(DateTime::<None>::from(datetime!(2020-01-01 0:00)).ordinal(), 1);
        assert_eq!(DateTime::<None>::from(datetime!(2020-02-01 0:00)).ordinal(), 32);
        assert_eq!(DateTime::<None>::from(datetime!(2020-12-31 0:00)).ordinal(), 366);
        assert_eq!(DateTime::<None>::from(datetime!(2019-01-01 0:00)).ordinal(), 1);
        assert_eq!(DateTime::<None>::from(datetime!(2019-12-31 0:00)).ordinal(), 365);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::date_crate::{DateTime, fixed_offset::None}; // Correct path for `None`
    use crate::util::days_in_year_month;
    use crate::Month; // Correct use of `Month`
    use crate::Time; // Correct use of `Time`

    #[test]
    fn replace_date_valid() {
        let original_dt = DateTime::<None>::new(
            Date::from_calendar_date(2023, Month::January, 1).unwrap(),
            Time::MIDNIGHT,
        );
        let new_date = Date::from_calendar_date(2023, Month::October, 3).unwrap();
        let new_dt = original_dt.replace_date(new_date);

        assert_eq!(new_dt.date().year(), 2023);
        assert_eq!(new_dt.date().month(), Month::October);
        assert_eq!(new_dt.date().day(), 3);
        assert_eq!(new_dt.time().hour(), original_dt.time().hour());
        assert_eq!(new_dt.time().minute(), original_dt.time().minute());
        assert_eq!(new_dt.time().second(), original_dt.time().second());
        assert_eq!(new_dt.time().nanosecond(), original_dt.time().nanosecond());
    }
}
False
========================================
    use crate::{util::DateAdjustment, Date, OffsetDateTime, Time, UtcOffset};

    #[test]
    fn replace_date_time() {
        let original = OffsetDateTime::from_unix_timestamp(0).unwrap(); // 1970-01-01 00:00:00 UTC
        let new = OffsetDateTime::from_unix_timestamp(86_400).unwrap(); // 1970-01-02 00:00:00 UTC
        let replaced = original.replace_date_time(new.date_time());
        assert_eq!(replaced, new);
    }

    #[test]
    fn replace_date_time_with_offset() {
        let original = OffsetDateTime::from_unix_timestamp(0).unwrap()
            .to_offset(UtcOffset::from_hms(1, 0, 0).unwrap()); // 1970-01-01 01:00:00 +01:00
        let new = OffsetDateTime::from_unix_timestamp(86_400).unwrap(); // 1970-01-02 00:00:00 UTC
        let replaced = original.replace_date_time(new.date_time());
        assert_eq!(replaced, new);
    }

    #[test]
    fn replace_date_time_preserves_offset() {
        let original = OffsetDateTime::from_unix_timestamp(0).unwrap()
            .to_offset(UtcOffset::from_hms(-5, 0, 0).unwrap()); // 1969-12-31 19:00:00 -05:00
        let new = OffsetDateTime::from_unix_timestamp(86_400).unwrap(); // 1970-01-02 00:00:00 UTC
        let replaced = original.replace_date_time(new.date_time());
        assert_eq!(replaced, new);
    }

    #[test]
    #[should_panic]
    fn replace_date_time_panics_on_overflow() {
        let original = OffsetDateTime::from_unix_timestamp(86_400 * 40_000).unwrap()
            .to_offset(UtcOffset::from_hms(0, 0, 0).unwrap()); // far in the future
        let new = OffsetDateTime::from_unix_timestamp(-86_400 * 40_000).unwrap(); // far in the past
        original.replace_date_time(new.date_time()); // should panic
    }

    #[test]
    fn replace_date_time_no_offset() {
        let original = OffsetDateTime::from_unix_timestamp(0).unwrap()
            .to_offset(UtcOffset::from_hms(0, 0, 0).unwrap()); // 1970-01-01 00:00:00 +00:00
        let date = Date::from_ordinal_date(2020, 1).unwrap();
        let time = Time::from_hms(12, 0, 0).unwrap();
        let new = OffsetDateTime::new(date, time, UtcOffset::from_hms(0, 0, 0).unwrap());
        let replaced = original.replace_date_time(new.date_time());
        assert_eq!(replaced, new);
    }

    #[test]
    fn replace_date_time_changes_date_time() {
        let original = OffsetDateTime::from_unix_timestamp(0).unwrap()
            .to_offset(UtcOffset::from_hms(0, 0, 0).unwrap()); // 1970-01-01 00:00:00 +00:00
        let new_date = Date::from_ordinal_date(1970, 2).unwrap();
        let new_time = Time::from_hms(12, 34, 56).unwrap();
        let replaced = original.replace_date_time(
            OffsetDateTime::new(new_date, new_time, UtcOffset::from_hms(0, 0, 0).unwrap())
                .date_time(),
        );
        assert_eq!(replaced.year(), 1970);
        assert_eq!(replaced.ordinal(), 2);
        assert_eq!(replaced.hour(), 12);
        assert_eq!(replaced.minute(), 34);
        assert_eq!(replaced.second(), 56);
    }

    fn date_time(self) -> OffsetDateTime {
        // Helper function to mimic the .date_time() method.
        // This will need to be adjusted according to the actual API in use.
        OffsetDateTime::new(self.date, self.time, self.offset)
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::offset::UtcOffset;
    use crate::Time;
    use crate::PrimitiveDateTime;
    use crate::Date;
    use crate::Month;
    use crate::error;
    use crate::DateTime;

    #[test]
    fn replace_day_valid() {
        let datetime = DateTime::<UtcOffset> {
            date: Date::from_calendar_date(2020, Month::January, 15).unwrap(),
            time: Time::from_hms(12, 30, 45).unwrap(),
            offset: UtcOffset::UTC,
        };
        
        let new_day = 20;
        let expected_date = Date::from_calendar_date(2020, Month::January, new_day).unwrap();

        assert_eq!(datetime.replace_day(new_day).unwrap().date, expected_date);
    }

    #[test]
    fn replace_day_invalid() {
        let datetime = DateTime::<UtcOffset> {
            date: Date::from_calendar_date(2020, Month::February, 15).unwrap(),
            time: Time::from_hms(12, 30, 45).unwrap(),
            offset: UtcOffset::UTC,
        };
        
        let new_day = 30;
        assert!(datetime.replace_day(new_day).is_err());
    }

    #[test]
    fn replace_day_february_leap_year() {
        let datetime = DateTime::<UtcOffset> {
            date: Date::from_calendar_date(2020, Month::February, 15).unwrap(),
            time: Time::from_hms(12, 30, 45).unwrap(),
            offset: UtcOffset::UTC,
        };
        
        let new_day = 29;
        let expected_date = Date::from_calendar_date(2020, Month::February, new_day).unwrap();

        assert_eq!(datetime.replace_day(new_day).unwrap().date, expected_date);
    }

    #[test]
    fn replace_day_february_non_leap_year() {
        let datetime = DateTime::<UtcOffset> {
            date: Date::from_calendar_date(2021, Month::February, 15).unwrap(),
            time: Time::from_hms(12, 30, 45).unwrap(),
            offset: UtcOffset::UTC,
        };
        
        let new_day = 29;
        assert!(datetime.replace_day(new_day).is_err());
    }
}
False
========================================
    use crate::date::Date;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::error::ComponentRange;
    use crate::Duration;
    use time_macros::{date, time};

    #[test]
    fn test_replace_hour() {
        // You can initialize specific dates and times for testing using the `date!` and `time!` macros if available
        // Assuming you have the macros `date!` and `time!` available in your scope.

        // Successful replacements
        let dt = DateTime::new(date!(2021-01-01), time!(12:34:56));
        assert_eq!(dt.replace_hour(0), Ok(DateTime::new(date!(2021-01-01), time!(0:34:56))));
        assert_eq!(dt.replace_hour(23), Ok(DateTime::new(date!(2021-01-01), time!(23:34:56))));

        // Out of range
        let out_of_range = dt.replace_hour(24);
        assert!(matches!(out_of_range, Err(ComponentRange { .. })));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::{error, Date, PrimitiveDateTime, Time, UtcOffset};
    use crate::error::ComponentRange;
    use time_macros::datetime;

    #[test]
    fn replace_microsecond_valid() {
        let dt = datetime!(2021-01-01 12:34:56.123456);
        let new_microsecond = 789_000;
        assert_eq!(
            dt.replace_microsecond(new_microsecond),
            Ok(datetime!(2021-01-01 12:34:56.789))
        );
    }

    #[test]
    fn replace_microsecond_invalid() {
        let dt = datetime!(2021-01-01 12:34:56.123456);
        let new_microsecond = 1_000_000;
        assert!(matches!(
            dt.replace_microsecond(new_microsecond),
            Err(ComponentRange { .. })
        ));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::Date;
    use crate::Time;
    use crate::PrimitiveDateTime as DateTime;
    use crate::UtcOffset;

    #[test]
    fn replace_millisecond_valid() {
        // `DateTime` with a millisecond that can be replaced without error.
        let date_time = DateTime::new(
            Date::from_calendar_date(2023, crate::Month::January, 1).unwrap(),
            Time::from_hms_milli(12, 30, 45, 500).unwrap(),
        );

        let millisecond = 123;
        let expected_time = Time::from_hms_milli(12, 30, 45, millisecond).unwrap();
        let replaced = date_time.replace_millisecond(millisecond);
        assert_eq!(
            replaced,
            Ok(DateTime::new(date_time.date(), expected_time))
        );
    }

    #[test]
    fn replace_millisecond_invalid() {
        // `DateTime` with a millisecond that, when replaced, causes an error.
        let date_time = DateTime::new(
            Date::from_calendar_date(2023, crate::Month::January, 1).unwrap(),
            Time::from_hms_milli(12, 30, 45, 500).unwrap(),
        );

        let millisecond = 1_000; // Invalid millisecond
        let err = date_time.replace_millisecond(millisecond);
        assert_eq!(
            err,
            Err(ComponentRange {
                name: "millisecond",
                minimum: 0,
                maximum: 999,
                value: millisecond as _,
                conditional_range: false
            })
        );
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::offset::UtcOffset;
    use crate::Month;

    /// Helper function to create a `DateTime` with fixed offset for testing.
    /// For simplicity, it doesn't handle errors and expects all inputs to be valid.
    fn fixed_offset_date_time(
        year: i32, 
        month: Month, 
        day: u8, 
        hour: u8, 
        minute: u8, 
        second: u8, 
        nanosecond: u32, 
        offset_seconds: i32
    ) -> DateTime<Fixed> {
        let date = Date::from_calendar_date(year, month, day).unwrap();
        let time = Time::from_hms_nano(hour, minute, second, nanosecond).unwrap();
        let offset = UtcOffset::from_whole_seconds(offset_seconds).unwrap();
        DateTime {
            date,
            time,
            offset,
        }
    }

    #[test]
    fn test_replace_minute() {
        let initial = fixed_offset_date_time(2023, Month::January, 30, 12, 30, 45, 123_456_789, 0);
        let expected_ok = fixed_offset_date_time(2023, Month::January, 30, 12, 45, 45, 123_456_789, 0);
        let result_ok = initial.replace_minute(45);
        match result_ok {
            Ok(result) => assert_eq!(result, expected_ok, "The minute should have been successfully replaced."),
            Err(e) => panic!("Test failed with error: {:?}", e),
        }

        let result_err = initial.replace_minute(60);
        let expected_err = Err(ComponentRange {
            name: "minute",
            value: 60,
            minimum: 0,
            maximum: 59,
            conditional_range: false,
        });
        assert_eq!(result_err, expected_err, "Replacing minute with invalid value should fail with ComponentRange error");

    }
}
False
========================================
    use super::*; // Assuming all relevant structs and enums are in the same file

use crate::*;
    use crate::date::Date;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::error::ComponentRange;
    use crate::month::Month;
    use crate::crate::Time;
    use std::convert::TryFrom;

    #[test]
    fn replace_month_valid() {
        let dt = DateTime::<Fixed>::from_unix_timestamp(0).unwrap(); // Assuming 1970-01-01 00:00:00 UTC
        let new_month = Month::April;
        let replaced_dt = dt.replace_month(new_month).unwrap();
        assert_eq!(replaced_dt.month(), new_month);
    }

    #[test]
    fn replace_month_invalid() {
        let dt = DateTime::<Fixed>::from_unix_timestamp(0).unwrap(); // Assuming 1970-01-01 00:00:00 UTC
        let new_month = Month::February; // An invalid replacement for a leap day
        let leap_day_dt = dt.replace_day(29).unwrap();
        let replaced_dt = leap_day_dt.replace_month(new_month);
        assert!(replaced_dt.is_err());
        assert_eq!(replaced_dt.unwrap_err(), ComponentRange {
            name: "day",
            minimum: 1,
            maximum: 29,  // 28 in this case, but the maximum reported is based on the day in `Time` (which is not part of this task)
            value: 29,
            conditional_range: true,
        });
    }

    #[test]
    fn replace_month_preserve_time() {
        let dt = DateTime::<Fixed>::from_unix_timestamp(0).unwrap(); // Assuming 1970-01-01 00:00:00 UTC
        let initial_time = dt.time();
        let new_month = Month::March;
        let replaced_dt = dt.replace_month(new_month).unwrap();
        assert_eq!(replaced_dt.time(), initial_time);
    }

    #[test]
    fn replace_month_preserve_year() {
        let dt = DateTime::<Fixed>::from_unix_timestamp(0).unwrap(); // Assuming 1970-01-01 00:00:00 UTC
        let initial_year = dt.year();
        let new_month = Month::March;
        let replaced_dt = dt.replace_month(new_month).unwrap();
        assert_eq!(replaced_dt.year(), initial_year);
    }

    #[test]
    fn replace_month_preserve_day() {
        let dt = DateTime::<Fixed>::from_unix_timestamp(0).unwrap(); // Assuming 1970-01-01 00:00:00 UTC
        let new_month = Month::March;
        let replaced_dt = dt.replace_month(new_month).unwrap();
        assert_eq!(replaced_dt.day(), dt.day());
    }

    #[test]
    fn replace_month_same_month() {
        let dt = DateTime::<Fixed>::from_unix_timestamp(0).unwrap(); // Assuming 1970-01-01 00:00:00 UTC
        let new_month = Month::January; // Same as initial month
        let replaced_dt = dt.replace_month(new_month).unwrap();
        assert_eq!(replaced_dt.month(), new_month);
    }
}
False
========================================
    use crate::util::DateAdjustment;
    use crate::{
        error::ComponentRange, Date, Duration, PrimitiveDateTime, Time,
        offset_kind::Fixed, DateTime,
    };
    use crate::crate::macros::datetime;

    #[test]
    fn replace_nanosecond_valid() {
        let dt = datetime!(2023-04-01 12:00:00 UTC);
        let expected = datetime!(2023-04-01 12:00:00.123_456_789 UTC);
        assert_eq!(dt.replace_nanosecond(123_456_789), Ok(expected));
    }

    #[test]
    fn replace_nanosecond_invalid() {
        let dt = datetime!(2023-04-01 12:00:00 UTC);
        assert!(matches!(
            dt.replace_nanosecond(1_000_000_000),
            Err(ComponentRange { .. })
        ));
    }

    #[test]
    fn replace_nanosecond_min_max() {
        let dt_min = DateTime::<Fixed>::MIN;
        let dt_max = DateTime::<Fixed>::MAX;
        let expected_min = PrimitiveDateTime::new(
            Date::MIN,
            Time::from_hms_nano(0, 0, 0, 123_456_789).unwrap()
        )
        .assume_utc();
        let expected_max = PrimitiveDateTime::new(
            Date::MAX,
            Time::from_hms_nano(23, 59, 59, 123_456_789).unwrap()
        )
        .assume_utc();
        assert_eq!(dt_min.replace_nanosecond(123_456_789), Ok(expected_min));
        assert_eq!(dt_max.replace_nanosecond(123_456_789), Ok(expected_max));
    }
}
False
========================================
    use crate::{Date, Time, UtcOffset, offset, PrimitiveDateTime};

    #[test]
    fn test_replace_offset() {
        let original_date = Date::from_ordinal_date(2021, 200).unwrap();
        let original_time = Time::from_hms(12, 30, 45).unwrap();
        let original_offset = UtcOffset::from_hms(1, 0, 0).unwrap();
        let new_offset = UtcOffset::from_hms(2, 0, 0).unwrap();
        let original_date_time = PrimitiveDateTime::new(original_date, original_time).assume_offset(original_offset);
        let new_date_time = original_date_time.replace_offset(new_offset);

        assert_eq!(new_date_time.offset(), new_offset);
        assert_eq!(new_date_time.year(), original_date_time.year());
        assert_eq!(new_date_time.ordinal(), original_date_time.ordinal());
        assert_eq!(new_date_time.hour(), original_date_time.hour());
        assert_eq!(new_date_time.minute(), original_date_time.minute());
        assert_eq!(new_date_time.second(), original_date_time.second());
        assert_eq!(new_date_time.nanosecond(), original_date_time.nanosecond());
    }
}
False
========================================
#[cfg(test)]
mod replace_second_tests {
    use crate::{macros::datetime, Date, Month, OffsetDateTime, Time, UtcOffset};

    #[test]
    fn replace_second_in_bounds() {
        let initial = datetime!(2023-03-15 13:45:30 UTC);
        let expected = datetime!(2023-03-15 13:45:45 UTC);
        assert_eq!(initial.replace_second(45).unwrap(), expected);
    }

    #[test]
    #[should_panic]
    fn replace_second_out_of_bounds() {
        let initial = datetime!(2023-03-15 13:45:30 UTC);
        initial.replace_second(60).unwrap();
    }

    #[test]
    fn replace_second_at_bounds() {
        // Test lower bound
        let initial_lower = datetime!(2023-03-15 13:45:30 UTC);
        let expected_lower = datetime!(2023-03-15 13:45:00 UTC);
        assert_eq!(initial_lower.replace_second(0).unwrap(), expected_lower);

        // Test upper bound
        let initial_upper = datetime!(2023-03-15 13:45:30 UTC);
        let expected_upper = datetime!(2023-03-15 13:45:59 UTC);
        assert_eq!(initial_upper.replace_second(59).unwrap(), expected_upper);
    }
}
False
========================================
    use crate::{OffsetDateTime, PrimitiveDateTime as DateTime, Time};
    use time_macros::{date, time};
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_replace_time_midnight() {
        let initial = OffsetDateTime::now_utc();
        let replacement = time!(0:00);
        let result = initial.replace_time(replacement);
        assert_eq!(result.time(), replacement);
    }

    #[test]
    fn test_replace_time_noon() {
        let initial = OffsetDateTime::now_utc();
        let replacement = time!(12:00);
        let result = initial.replace_time(replacement);
        assert_eq!(result.time(), replacement);
    }

    #[test]
    fn test_replace_time_specific() {
        let initial = DateTime::new(date!(2020 - 01 - 01), time!(12:00));
        let replacement = time!(9:30);
        let result = initial.replace_time(replacement);
        assert_eq!(result.time(), replacement);
    }

    #[test]
    fn test_replace_time_with_std_duration() {
        let initial = OffsetDateTime::now_utc();
        let replacement = time!(23:45:19);
        let result = initial.replace_time(replacement);
        assert_eq!(result.time(), replacement);
    }

    #[test]
    fn test_replace_time_in_past() {
        let initial = DateTime::new(date!(2020 - 01 - 01), time!(23:59:59));
        let replacement = time!(0:00);
        let result = initial.replace_time(replacement);
        assert_eq!(result.time(), replacement);
    }

    #[test]
    fn test_replace_time_in_future() {
        let initial = DateTime::new(date!(2020 - 01 - 01), time!(0:00));
        let replacement = time!(23:59:59);
        let result = initial.replace_time(replacement);
        assert_eq!(result.time(), replacement);
    }
}
False
========================================
    use crate::date::Date;
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::None;
    use crate::error::ComponentRange;
    use crate::crate::Time;
    use crate::Month;
    use crate::PrimitiveDateTime;
    use crate::UtcOffset;  
 
    #[test]
    fn test_replace_year_valid() {
        let original = DateTime::UNIX_EPOCH;
        let expected = DateTime {
            date: Date::from_ordinal_date(2023, 1).unwrap(),
            time: original.time(),
            offset: original.offset,
        };
        assert_eq!(original.replace_year(2023).unwrap(), expected);
    }

    #[test]
    fn test_replace_year_invalid() {
        let original = DateTime::UNIX_EPOCH;
        assert!(matches!(
            original.replace_year(i32::MAX),
            Err(ComponentRange { .. })
        ));
    }

    #[test]
    fn test_replace_year_leap_year() {
        let original = DateTime {
            date: Date::from_calendar_date(2020, Month::February, 29).unwrap(),
            time: Time::MIDNIGHT,
            offset: UtcOffset::UTC,
        };
        let expected = DateTime {
            date: Date::from_calendar_date(2024, Month::February, 29).unwrap(),
            time: Time::MIDNIGHT,
            offset: UtcOffset::UTC,
        };
        assert_eq!(original.replace_year(2024).unwrap(), expected);
    }

    #[test]
    fn test_replace_year_non_leap_year() {
        let original = DateTime {
            date: Date::from_calendar_date(2020, Month::February, 29).unwrap(),
            time: Time::MIDNIGHT,
            offset: UtcOffset::UTC,
        };
        assert!(matches!(
            original.replace_year(2021),
            Err(ComponentRange { .. })
        ));
    }
}
False
========================================
    use crate::{Date, DateTime, Duration, OffsetDateTime, Time, UtcOffset};
    use crate::offset::FixedOffset;

    #[test]
    fn saturating_add_with_positive_duration() {
        let dt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::seconds(10);
        let result = dt.saturating_add(duration);
        let expected = OffsetDateTime {
            date_time: DateTime {
                date: Date::from_calendar_date(1970, 1, 1).unwrap(),
                time: Time::from_hms_milli(0, 0, 10, 0).unwrap(),
            },
            offset: FixedOffset::UTC,
        };
        assert_eq!(result, expected);
    }

    #[test]
    fn saturating_add_with_large_positive_duration() {
        let dt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::new(i64::MAX, 0);
        let result = dt.saturating_add(duration);
        let expected = OffsetDateTime {
            date_time: DateTime {
                date: Date::MAX,
                time: Time::MAX,
            },
            offset: FixedOffset::UTC,
        };
        assert_eq!(result, expected);
    }

    #[test]
    fn saturating_add_with_negative_duration() {
        let dt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::seconds(-10);
        let result = dt.saturating_add(duration);
        let expected = OffsetDateTime {
            date_time: DateTime {
                date: Date::from_calendar_date(1969, 12, 31).unwrap(),
                time: Time::from_hms_milli(23, 59, 50, 0).unwrap(),
            },
            offset: FixedOffset::UTC,
        };
        assert_eq!(result, expected);
    }

    #[test]
    fn saturating_add_with_large_negative_duration() {
        let dt = OffsetDateTime::UNIX_EPOCH;
        let duration = Duration::new(i64::MIN, 0);
        let result = dt.saturating_add(duration);
        let expected = OffsetDateTime {
            date_time: DateTime {
                date: Date::MIN,
                time: Time::MIN,
            },
            offset: FixedOffset::UTC,
        };
        assert_eq!(result, expected);
    }

    #[test]
    fn saturating_add_at_max_datetime() {
        let dt = OffsetDateTime {
            date_time: DateTime {
                date: Date::MAX,
                time: Time::MAX,
            },
            offset: FixedOffset::UTC,
        };
        let duration = Duration::seconds(1);
        let result = dt.saturating_add(duration);
        assert_eq!(result, dt);
    }

    #[test]
    fn saturating_add_at_min_datetime() {
        let dt = OffsetDateTime {
            date_time: DateTime {
                date: Date::MIN,
                time: Time::MIN,
            },
            offset: FixedOffset::UTC,
        };
        let duration = Duration::seconds(-1);
        let result = dt.saturating_add(duration);
        assert_eq!(result, dt);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::duration::Duration;
    use crate::date_crate::DateTime;
    use crate::offset_kind::Fixed;
    use crate::date::Date;
    use crate::crate::Time;
    use crate::offset::UtcOffset;
    use std::crate::SystemTime;
    use std::convert::TryInto;

    #[test]
    fn saturating_sub_positive_duration() {
        let datetime = DateTime::<Fixed>::from_unix_timestamp(0).unwrap();
        let duration = 5.seconds();
        let result = datetime.saturating_sub(duration);
        assert_eq!(
            result,
            DateTime::<Fixed>::MIN
        );
    }

    #[test]
    fn saturating_sub_negative_duration() {
        let datetime = DateTime::<Fixed>::from_unix_timestamp(0).unwrap();
        let duration = (-5).seconds();
        let result = datetime.saturating_sub(duration);
        assert_eq!(
            result,
            DateTime::<Fixed> {
                date: Date::MIN,
                time: Time::MIN,
                offset: UtcOffset::UTC,
            }.saturating_add(duration)
        );
    }

    #[test]
    fn saturating_sub_zero_duration() {
        let datetime = DateTime::<Fixed>::from_unix_timestamp(0).unwrap();
        let duration = Duration::ZERO;
        let result = datetime.saturating_sub(duration);
        assert_eq!(
            result,
            datetime,
            "Subtracting zero duration should return the original datetime"
        );
    }
}
False
========================================
    use crate::date::Date;
    use crate::offset::UtcOffset;
    use crate::crate::Time;
    use crate::DateAdjustment;
    use crate::Duration;
    use crate::OffsetDateTime;

    #[test]
    fn second() {
        let base_date = Date::from_ordinal_date(2023, 91).unwrap();
        let base_time = Time::from_hms(12, 30, 30).unwrap();
        let base_fixed_offset = UtcOffset::from_hms(0, 0, 0).unwrap();
        let base_date_time = OffsetDateTime::new(base_date, base_time, base_fixed_offset);

        // Test second
        assert_eq!(30, base_date_time.second());

        // Test with other values
        let other_time = Time::from_hms(23, 59, 45).unwrap();
        let other_date_time = OffsetDateTime::new(base_date, other_time, base_fixed_offset);

        assert_eq!(45, other_date_time.second());
    }
}
False
========================================
    use crate::{Date, Month, Time, PrimitiveDateTime as DateTime};

    #[test]
    fn sunday_based_week() {
        // Lower bound
        let dt = DateTime::new(Date::from_calendar_date(2023, Month::January, 1).unwrap(), Time::MIDNIGHT);
        assert_eq!(dt.sunday_based_week(), 0);

        // Middle of the year
        let dt = DateTime::new(Date::from_calendar_date(2023, Month::June, 15).unwrap(), Time::MIDNIGHT);
        assert_eq!(dt.sunday_based_week(), 23);

        // End of the year
        let dt = DateTime::new(Date::from_calendar_date(2023, Month::December, 31).unwrap(), Time::MIDNIGHT);
        assert_eq!(dt.sunday_based_week(), 52);

        // Leap year beginning
        let dt = DateTime::new(Date::from_calendar_date(2024, Month::January, 1).unwrap(), Time::MIDNIGHT);
        assert_eq!(dt.sunday_based_week(), 0);

        // Leap year end
        let dt = DateTime::new(Date::from_calendar_date(2024, Month::December, 31).unwrap(), Time::MIDNIGHT);
        assert_eq!(dt.sunday_based_week(), 52);
    }
}
True
========================================
#[cfg(test)]
mod date_time_tests {
    use crate::DateTime;
    use crate::date::Date;
    use crate::crate::Time;
    use crate::date::Month;
    use crate::timezone::UtcOffset;
    use crate::date_crate::PrimitiveDateTime;
    use crate::date_crate::OffsetDateTime;
    use crate::date_crate::offset::FixedOffset;
    use crate::date_crate::offset::Utc;

    #[test]
    fn test_time() {
        // Construct a date
        let date = Date::from_calendar_date(2023, Month::March, 15).unwrap();
        let time = Time::from_hms(12, 30, 45).unwrap();
        // Combine date and time into a `PrimitiveDateTime`
        let primitive_date_time = PrimitiveDateTime::new(date, time);
        // Create a `DateTime<Utc>` from a `PrimitiveDateTime`
        let date_time = OffsetDateTime::new(primitive_date_time, UtcOffset::UTC);

        assert_eq!(date_time.date(), date);
        assert_eq!(date_time.time(), time);

        // Create a `DateTime<FixedOffset>` from a `PrimitiveDateTime`
        let fixed_offset = FixedOffset::east(0);
        let date_time_fixed = OffsetDateTime::new(primitive_date_time, fixed_offset);

        assert_eq!(date_time_fixed.date(), date);
        assert_eq!(date_time_fixed.time(), time);
    }
}
False
========================================
    use crate::date::Date;
    use crate::date_crate::{DateTime, offset_kind::Fixed};
    use crate::month::Month::*;
    use crate::crate::Time;

    #[test]
    fn test_to_calendar_date() {
        let test_cases = &[
            (2023, January, 1, 0, 0, 0, 2023, January, 1),
            (2023, January, 1, 23, 59, 59, 2023, January, 1),
            (2023, February, 28, 0, 0, 0, 2023, February, 28),
            (2023, February, 28, 23, 59, 59, 2023, February, 28),
            (2020, February, 29, 0, 0, 0, 2020, February, 29),
            (2020, February, 29, 23, 59, 59, 2020, February, 29),
            (1999, December, 31, 0, 0, 0, 1999, December, 31),
            (1999, December, 31, 23, 59, 59, 1999, December, 31),
        ];

        for &(year, month, day, h, min, sec, expected_y, expected_m, expected_d) in test_cases {
            let date = Date::from_calendar_date(year, month, day).unwrap();
            let time = Time::from_hms(h, min, sec).unwrap();
            let date_time = DateTime::new(date, time);
            let (result_y, result_m, result_d) = date_time.to_calendar_date();
            assert_eq!(expected_y, result_y);
            assert_eq!(&expected_m, &result_m);
            assert_eq!(expected_d, result_d);
        }
    }
}
False
========================================
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::crate::Time;
    use crate::date::Date;

    #[test]
    fn test_to_hms_deprecated() {
        let dt = DateTime::<Fixed> {
            date: Date::from_ordinal_date(1970, 1).unwrap(),
            time: Time::MIDNIGHT,
            offset: crate::date_crate::UtcOffset::UTC,
        };

        let expected = dt.time.as_hms();
        let actual = dt.to_hms();

        assert_eq!(
            expected, actual,
            "DateTime::<Fixed>::to_hms should return the same result as Time::as_hms"
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::OffsetDateTime;
    use crate::util::DateAdjustment;
    use crate::Date;
    use crate::OffsetKind::Fixed;
    use crate::PrimitiveDateTime;
    use crate::Time;
    use crate::UtcOffset;

    #[test]
    fn test_to_hms_micro() {
        // Typical use case
        let dt = PrimitiveDateTime::new(
            Date::from_ordinal_date(2023, 100).unwrap(),
            Time::from_hms_micro(14, 30, 45, 123456).unwrap(),
        )
        .assume_offset(UtcOffset::UTC);
        assert_eq!(dt.to_hms_micro(), (14, 30, 45, 123456));

        // Edge case: end of day
        let dt = PrimitiveDateTime::new(
            Date::from_ordinal_date(2023, 100).unwrap(),
            Time::from_hms_micro(23, 59, 59, 999999).unwrap(),
        )
        .assume_offset(UtcOffset::UTC);
        assert_eq!(dt.to_hms_micro(), (23, 59, 59, 999999));

        // Edge case: start of day
        let dt = PrimitiveDateTime::new(
            Date::from_ordinal_date(2023, 100).unwrap(),
            Time::from_hms_micro(0, 0, 0, 0).unwrap(),
        )
        .assume_offset(UtcOffset::UTC);
        assert_eq!(dt.to_hms_micro(), (0, 0, 0, 0));

        // Edge case: leap second (not actually supported, but can test boundary)
        let dt = PrimitiveDateTime::new(
            Date::from_ordinal_date(2023, 100).unwrap(),
            Time::from_hms_micro(23, 59, 60, 0).unwrap_err(),
        )
        .assume_offset(UtcOffset::UTC);
        assert!(matches!(dt, Err(crate::error::ComponentRange { .. })));

        // Edge case: negative leap second (not actually supported, but can test boundary)
        let dt = PrimitiveDateTime::new(
            Date::from_ordinal_date(2023, 100).unwrap(),
            Time::from_hms_micro(23, 59, 58, 0).unwrap(),
        )
        .assume_offset(UtcOffset::UTC);
        assert_eq!(dt.to_hms_micro(), (23, 59, 58, 0));
    }
}
False
========================================
    use crate::{OffsetDateTime, UtcOffset, time, macros::datetime};

    #[test]
    fn to_hms_milli_deprecated() {
        // 0 milliseconds
        let dt = datetime!(2023-01-01 0:00);
        let (hour, min, sec, milli) = dt.to_hms_milli();
        assert_eq!(0, hour);
        assert_eq!(0, min);
        assert_eq!(0, sec);
        assert_eq!(0, milli);

        // Check transition from 23:59:59.999 to 00:00:00.000
        let dt = datetime!(2023-01-01 23:59:59.999);
        let (hour, min, sec, milli) = dt.to_hms_milli();
        assert_eq!(23, hour);
        assert_eq!(59, min);
        assert_eq!(59, sec);
        assert_eq!(999, milli);

        // Test with added offset of 1 hour
        let dt = datetime!(2023-01-01 23:59:59.999).to_offset(UtcOffset::hours(1));
        let (hour, min, sec, milli) = dt.to_hms_milli();
        assert_eq!(0, hour);
        assert_eq!(0, min);
        assert_eq!(0, sec);
        assert_eq!(0, milli);

        // Test with subtracted offset of 1 hour
        let dt = datetime!(2023-01-01 23:59:59.999).to_offset(UtcOffset::hours(-1));
        let (hour, min, sec, milli) = dt.to_hms_milli();
        assert_eq!(22, hour);
        assert_eq!(59, min);
        assert_eq!(59, sec);
        assert_eq!(999, milli);

        // Leap-second related, though hypothetical since time 0.3 does not support leap seconds
        let dt = datetime!(2023-06-30 23:59:60);
        let (hour, min, sec, milli) = dt.to_hms_milli();
        assert_eq!(23, hour);
        assert_eq!(59, min);
        assert_eq!(60, sec);
        assert_eq!(0, milli);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::macros::datetime;
    use crate::UtcOffset;
    use crate::Date;
    use crate::Month;
    use crate::PrimitiveDateTime as DateTime;

    #[test]
    fn test_to_hms_nano() {
        // Create a test for crate::PrimitiveDateTime::to_hms_nano(), where time represents a fixed offset
        // The method `to_hms_nano` is called on DateTime types where the offset is fixed (which
        // means the offset is known at compile time and doesn't change).
        
        // Create a DateTime and use to_hms_nano
        let datetime = datetime!(2020-01-01 12:34:56.789_012_345);

        // The `to_hms_nano` method returns the hour, minute, second, and nanosecond.
        // Since to_hms_nano is deprecated, we should use the `Time::as_hms_nano` method directly
        // from the `time` component of `DateTime`.
        let (hour, minute, second, nanosecond) = datetime.time().as_hms_nano();
        
        assert_eq!(hour, 12);
        assert_eq!(minute, 34);
        assert_eq!(second, 56);
        assert_eq!(nanosecond, 789_012_345);
    }
}
False
========================================
    use crate::DateTime;
    use crate::Date;
    use crate::Time;
    use crate::Weekday;
    use crate::UtcOffset;
    use std::convert::TryFrom;

    #[test]
    fn test_to_iso_week_date() {
        // Use some representative test cases that highlight different parts of the year
        let test_cases = [
            // Date, Expected ISO year, Expected ISO week, Expected ISO weekday
            (Date::try_from_calendar_date(2023, crate::Month::January, 1).unwrap(), 2022, 52, Weekday::Sunday), // Beginning of the year (belongs to the last week of the previous year)
            (Date::try_from_calendar_date(2023, crate::Month::August, 4).unwrap(), 2023, 31, Weekday::Friday), // Middle of the year
            (Date::try_from_calendar_date(2023, crate::Month::December, 31).unwrap(), 2023, 52, Weekday::Sunday), // End of the year
        ];

        for (date, expected_iso_year, expected_iso_week, expected_iso_weekday) in test_cases {
            let datetime = DateTime::new(date, Time::MIDNIGHT);
            let (iso_year, iso_week, iso_weekday) = datetime.to_iso_week_date();
            assert_eq!(iso_year, expected_iso_year);
            assert_eq!(iso_week, expected_iso_week);
            assert_eq!(iso_weekday, expected_iso_weekday);
        }
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::{util, Date, Month, PrimitiveDateTime as DateTime, Time};

    #[test]
    fn test_to_julian_day() {
        fn make_date_time(year: i32, month: Month, day: u8, hour: u8, minute: u8, second: u8) -> DateTime {
            DateTime::new(
                Date::from_calendar_date(year, month, day).expect("date construction should be valid"),
                Time::from_hms(hour, minute, second).expect("time construction should be valid"),
            )
        }

        let date_times = [
            make_date_time(2000, Month::January, 1, 0, 0, 0),
            make_date_time(2000, Month::January, 1, 12, 0, 0),
            make_date_time(2020, Month::March, 1, 0, 0, 0),
            make_date_time(2020, Month::March, 1, 6, 12, 24),
            make_date_time(1969, Month::December, 31, 0, 0, 0),
            make_date_time(1969, Month::December, 31, 23, 59, 59),
        ];
        let expected_julian_days = [2_451_545, 2_451_545, 2_458_948, 2_458_948, 2_440_582, 2_440_582];

        for (date_time, &expected) in date_times.iter().zip(&expected_julian_days) {
            assert_eq!(date_time.to_julian_day(), expected, "{}", date_time);
        }

        let just_before_midnight = make_date_time(2000, Month::January, 1, 23, 59, 59);
        let just_after_midnight = make_date_time(2000, Month::January, 2, 0, 0, 1);
        assert_eq!(just_before_midnight.to_julian_day(), 2_451_545);
        assert_eq!(just_after_midnight.to_julian_day(), 2_451_546);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::crate::Time;
    use crate::utc_offset::UtcOffset;
    use crate::date_crate::offset_kind::Fixed;
    use crate::date_crate::DateTime;

    #[test]
    fn to_offset_same_offset_no_change() {
        let date = Date::from_calendar_date(2023, crate::Month::January, 1).unwrap();
        let time = Time::from_hms(0, 0, 0).unwrap();
        let offset = UtcOffset::from_hms(0, 0, 0).unwrap();
        let datetime = DateTime::from_utc(date, time, offset);

        let new_offset = UtcOffset::from_hms(0, 0, 0).unwrap();
        let new_datetime = datetime.to_offset(new_offset);

        assert_eq!(new_datetime, datetime);
    }

    #[test]
    fn to_offset_different_offset() {
        let offset = UtcOffset::from_hms(0, 0, 0).unwrap();
        let new_offset = UtcOffset::from_hms(1, 0, 0).unwrap();
        let datetime = DateTime::from_utc(Date::from_calendar_date(2023, crate::Month::January, 1).unwrap(), Time::from_hms(0, 0, 0).unwrap(), offset);

        let new_datetime = datetime.to_offset(new_offset);

        assert_eq!(new_datetime.offset(), new_offset);
        // Since `to_offset` does not change the moment in time, only how it's represented, the
        // datetime with the new offset should have different date and time components if the offset
        // change indeed occurred.
        if offset.whole_hours() != new_offset.whole_hours() {
            assert_ne!(new_datetime.date(), datetime.date());
            assert_ne!(new_datetime.time(), datetime.time());
        } else {
            assert_eq!(new_datetime.date(), datetime.date());
            assert_eq!(new_datetime.time(), datetime.time());
        }
    }

    #[test]
    #[should_panic]
    fn to_offset_out_of_range_panic() {
        let offset = UtcOffset::from_hms(0, 0, 0).unwrap();
        let datetime = DateTime::from_utc(Date::MAX, Time::MAX, offset);
        let new_offset = UtcOffset::from_hms(1, 0, 0).unwrap();

        // This should panic because the offset is outside the valid range
        let _new_datetime = datetime.to_offset(new_offset);
    }

    #[test]
    #[should_panic]
    fn to_offset_negative_out_of_range_panic() {
        let offset = UtcOffset::from_hms(0, 0, 0).unwrap();
        let datetime = DateTime::from_utc(Date::MIN, Time::MIDNIGHT, offset);
        let new_offset = UtcOffset::from_hms(-1, 0, 0).unwrap();

        // This should panic because the offset is outside the valid range
        let _new_datetime = datetime.to_offset(new_offset);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::offset::UtcOffset;
    use crate::crate::Time;
    use crate::PrimitiveDateTime as DateTime;

    #[test]
    pub fn test_to_offset_raw() {
        // You need to use the `PrimitiveDateTime` type since the test is based on `crate::OffsetDateTime`. 
        // Consider using the `DateTime` type name to refer to `PrimitiveDateTime` within the `time` crate.
        let fixed_datetime = DateTime::new(
            Date::from_calendar_date(2023, Month::January, 1).unwrap(),
            Time::from_hms(4, 0, 0).unwrap(),
        ).assume_offset(UtcOffset::from_hms(1, 0, 0).unwrap());

        // Convert it to an offset of 0 and verify the result
        let to_offset = UtcOffset::UTC;
        let (year, ordinal, time) = fixed_datetime.to_offset_raw(to_offset);
        assert_eq!(year, 2023);
        assert_eq!(ordinal, 1);
        assert_eq!(time, Time::from_hms(3, 0, 0).unwrap());

        // Convert it to the same non-UTC offset (should result in same date_time)
        let (year, ordinal, time) = fixed_datetime.to_offset_raw(UtcOffset::from_hms(1, 0, 0).unwrap());
        assert_eq!(year, 2023);
        assert_eq!(ordinal, 1);
        assert_eq!(time, Time::from_hms(4, 0, 0).unwrap());

        // Convert it to another non-UTC offset (-3 hours)
        let (year, ordinal, time) = fixed_datetime.to_offset_raw(UtcOffset::from_hms(-3, 0, 0).unwrap());
        assert_eq!(year, 2022);
        assert_eq!(ordinal, 365); // This should be the last ordinal of the previous year
        assert_eq!(time, Time::from_hms(23, 0, 0).unwrap());
    }
}
False
========================================
    use crate::date_crate::{DateTime, offset_kind::Fixed, offset_kind::OffsetKind};
    use crate::Time;
    use crate::date::Date;
    use time_macros::{date, datetime};

    #[test]
    fn test_to_ordinal_date() {
        // Define dates
        let no_offset_1: DateTime<Fixed> = DateTime::from_unix_timestamp(946_684_800).unwrap(); // 2000-01-01 0:00:00 UTC
        let no_offset_2: DateTime<Fixed> = DateTime::from_unix_timestamp(989_548_800).unwrap(); // 2001-05-03 0:00:00 UTC
        let no_offset_3: DateTime<Fixed> = DateTime::from_unix_timestamp(1_640_822_400).unwrap(); // 2022-01-01 0:00:00 UTC

        let fixed_offset_1: DateTime<Fixed> = DateTime::UNIX_EPOCH;
        let fixed_offset_2: DateTime<Fixed> = DateTime::UNIX_EPOCH + 1_000_000_000;
        let fixed_offset_3: DateTime<Fixed> = DateTime::UNIX_EPOCH - 1_000_000_000;

        // Assert no_offset
        assert_eq!(no_offset_1.to_ordinal_date(), (2000, 1));
        assert_eq!(no_offset_2.to_ordinal_date(), (2001, 123));
        assert_eq!(no_offset_3.to_ordinal_date(), (2021, 365));

        // Assert fixed_offset
        assert_eq!(fixed_offset_1.to_ordinal_date(), (1970, 1));
        assert_eq!(fixed_offset_2.to_ordinal_date(), DateTime::from_unix_timestamp(1_000_000_000).unwrap().to_ordinal_date());
        assert_eq!(fixed_offset_3.to_ordinal_date(), DateTime::from_unix_timestamp(-1_000_000_000).unwrap().to_ordinal_date());
    }
}
False
========================================
    use crate::{macros::datetime, Date, Month, PrimitiveDateTime, Time, UtcOffset};

    #[test]
    fn test_unix_timestamp() {
        let fixed_offset = UtcOffset::UTC;
        let unix_epoch = Date::from_calendar_date(1970, Month::January, 1).unwrap();
        let epoch_datetime = PrimitiveDateTime::new(unix_epoch, Time::MIDNIGHT).assume_utc();

        // Epoch
        assert_eq!(epoch_datetime.unix_timestamp(), 0);
        // Post Epoch
        assert_eq!(
            epoch_datetime
                .replace_time(Time::from_hms(1, 0, 0).unwrap())
                .unix_timestamp(),
            3600
        );
        // Pre Epoch
        assert_eq!(
            PrimitiveDateTime::new(unix_epoch.previous_day().unwrap(), Time::from_hms(23, 0, 0).unwrap())
                .assume_utc()
                .unix_timestamp(),
            -3600
        );
        // Random date
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2001, Month::September, 9).unwrap(),
                Time::from_hms(1, 46, 40).unwrap()
            )
            .assume_utc()
            .unix_timestamp(),
            1000000000
        );
    }
}
False
========================================
    use crate::date_crate::DateTime;
    use crate::date_crate::offset_kind::Fixed;
    use crate::date::Date;
    use crate::crate::Time;
    use crate::crate::ext::NumericalDuration;
    use crate::date_crate::PrimitiveDateTime;
    use crate::date_crate::sealed::HasLogicalOffset;

    #[test]
    fn unix_timestamp_nanos() {
        let datetime_0 = Date::from_calendar_date(1970, crate::Month::January, 1)
            .unwrap()
            .with_hms_nano(0, 0, 0, 0)
            .unwrap()
            .assume_utc();
        let datetime_1 = Date::from_calendar_date(1970, crate::Month::January, 2)
            .unwrap()
            .with_hms_nano(0, 0, 1, 0)
            .unwrap()
            .assume_utc();
        let datetime_2 = Date::from_calendar_date(2000, crate::Month::February, 29)
            .unwrap()
            .with_hms_nano(1, 46, 40, 0)
            .unwrap()
            .assume_utc();
        let datetime_3 = Date::from_calendar_date(2023, crate::Month::March, 18)
            .unwrap()
            .with_hms_nano(22, 14, 33, 823_746_129)
            .unwrap()
            .assume_utc();
        
        assert_eq!(DateTime::<Fixed>::unix_timestamp_nanos(datetime_0), 0);
        assert_eq!(DateTime::<Fixed>::unix_timestamp_nanos(datetime_1), 1_000_000_000);
        assert_eq!(DateTime::<Fixed>::unix_timestamp_nanos(datetime_2), 951_782_800_000_000_000);
        assert_eq!(DateTime::<Fixed>::unix_timestamp_nanos(datetime_3), 1_679_799_073_823_746_129);
    }
}
False
========================================
    use crate::{Date, DateTime, Time, Weekday, util::days_in_year};
    use crate::date_crate::offset_kind::Fixed;
    use std::convert::TryInto;

    #[test]
    fn weekday_test() {
        // Helper function to create a new UTC DateTime with a fixed offset
        fn new_datetime(year: i32, ordinal: u16, hour: u8, minute: u8, second: u8, nanosecond: u32) -> DateTime<Fixed> {
            let date = Date::__from_ordinal_date_unchecked(year, ordinal);
            let time = Time::__from_hms_nanos_unchecked(hour, minute, second, nanosecond);
            DateTime {
                date,
                time,
                offset: Fixed::UTC,
            }
        }

        // Tests for known weekdays
        assert_eq!(new_datetime(2023, 1, 0, 0, 0, 0).weekday(), Weekday::Sunday);
        assert_eq!(new_datetime(2023, days_in_year(2023), 23, 59, 59, 999_999_999).weekday(), Weekday::Sunday);
        assert_eq!(new_datetime(2019, 1, 0, 0, 0, 0).weekday(), Weekday::Tuesday);
        assert_eq!(new_datetime(2019, 365, 23, 59, 59, 999_999_999).weekday(), Weekday::Tuesday);
        assert_eq!(new_datetime(2020, 1, 0, 0, 0, 0).weekday(), Weekday::Wednesday);
        assert_eq!(new_datetime(2020, 366, 23, 59, 59, 999_999_999).weekday(), Weekday::Thursday);

        // Tests for weekdays after adding days
        assert_eq!(new_datetime(2023, 1, 0, 0, 0, 0).date.next_day().unwrap().weekday(), Weekday::Monday);
        assert_eq!(new_datetime(2023, 1, 0, 0, 0, 0).date.next_day().unwrap().next_day().unwrap().weekday(), Weekday::Tuesday);

        // Tests for weekdays before a date
        assert_eq!(new_datetime(2023, days_in_year(2023), 23, 59, 59, 999_999_999).date.previous_day().unwrap().weekday(), Weekday::Saturday);
        assert_eq!(new_datetime(2023, days_in_year(2023) - 1, 23, 59, 59, 999_999_999).date.previous_day().unwrap().weekday(), Weekday::Friday);

        // Boundary tests for weekday transitions
        for day in 1..=days_in_year(2021) {
            let date = new_datetime(2021, day.try_into().unwrap(), 0, 0, 0, 0).date;
            let weekday = date.weekday();
            let next_day = date.next_day();
            let next_weekday = next_day.map(|d| d.weekday());
            assert_eq!(next_weekday, Some(weekday.next()), "Date: {}, Weekday: {}, Next weekday: {:?}", date, weekday, next_weekday);
        }

        // Tests with leap years
        let last_day_of_feb_nonleap = new_datetime(2023, 59, 23, 59, 59, 999_999_999);
        let last_day_of_feb_leap = new_datetime(2024, 60, 23, 59, 59, 999_999_999);

        assert_eq!(last_day_of_feb_nonleap.weekday(), Weekday::Tuesday);
        assert_eq!(last_day_of_feb_leap.weekday(), Weekday::Thursday);
        assert_eq!(last_day_of_feb_nonleap.date.next_day().unwrap().weekday(), Weekday::Wednesday);
        assert_eq!(last_day_of_feb_leap.date.next_day().unwrap().weekday(), Weekday::Friday);
    }
}
False
========================================
    use crate::{DateTime, Date};
    use crate::{util::days_in_year, Month, Time, UtcOffset, offset_kind::Fixed};

    #[test]
    fn test_year() {
        let dt = DateTime {
            date: Date::from_calendar_date(2020, Month::January, 1).unwrap(),
            time: Time::MIDNIGHT,
            offset: Fixed::UTC,
        };
        assert_eq!(dt.year(), 2020);

        let dt = DateTime {
            date: Date::from_calendar_date(-500, Month::January, 1).unwrap(),
            time: Time::MIDNIGHT,
            offset: Fixed::UTC,
        };
        assert_eq!(dt.year(), -500);

        let dt = DateTime {
            date: Date::from_calendar_date(10_000, Month::January, 1).unwrap(),
            time: Time::MIDNIGHT,
            offset: Fixed::UTC,
        };
        assert_eq!(dt.year(), 10_000);

        let dt = DateTime {
            date: Date::from_ordinal_date(2020, 1).unwrap() - 400 * days_in_year(2020),
            time: Time::MIDNIGHT,
            offset: Fixed::UTC,
        };
        assert_eq!(dt.year(), 1620);

        let dt = DateTime {
            date: Date::from_ordinal_date(2020, 1).unwrap() + 250 * days_in_year(2020),
            time: Time::MIDNIGHT,
            offset: Fixed::UTC,
        };
        assert_eq!(dt.year(), 2270);
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::offset_kind::Fixed;
    use crate::sealed::MaybeOffset;
    use crate::sealed::HasLogicalOffset;
    use crate::UtcOffset;

    #[test]
    fn test_maybe_offset_as_offset_for_fixed() {
        let fixed_offset = UtcOffset::__from_hms_unchecked(1, 2, 3);
        let offset = super::maybe_offset_as_offset::<Fixed>(fixed_offset);
        assert_eq!(offset, fixed_offset);
    }
    
    #[test]
    #[should_panic(expected = "`MaybeOffset::as_offset` called on a type without an offset in memory")]
    fn test_maybe_offset_as_offset_without_offset() {
        let no_offset_type = UtcOffset::__from_hms_unchecked(0, 0, 0);
        let _ = super::maybe_offset_as_offset::<Fixed>(no_offset_type);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::sealed::MaybeOffset;
    use crate::UtcOffset;
    use crate::offset::Offset;
    use crate::offset::FixedOffset;
    use std::mem::size_of;
    
    #[test]
    fn maybe_offset_as_offset_opt_with_fixed() {
        // FixedOffset has STATIC_OFFSET set to None and HAS_MEMORY_OFFSET set to true
        struct Fixed;
        impl MaybeOffset for Fixed {
            type MemoryOffsetType = UtcOffset;
            type LogicalOffsetType = UtcOffset;
            type Self_ = Self;
            const STATIC_OFFSET: Option<UtcOffset> = None;
            const HAS_LOGICAL_OFFSET: bool = true;
            const HAS_MEMORY_OFFSET: bool = true;
        }
        
        let utc_offset = UtcOffset::from_hms(5, 30, 0).unwrap();
        let offset_option = maybe_offset_as_offset_opt::<Fixed>(utc_offset);

        assert_eq!(offset_option, Some(utc_offset));
    }

    #[test]
    fn maybe_offset_as_offset_opt_with_none() {
        // FixedOffset has STATIC_OFFSET set to None and HAS_MEMORY_OFFSET set to false
        struct None;
        impl MaybeOffset for None {
            type MemoryOffsetType = UtcOffset;
            type LogicalOffsetType = ();
            type Self_ = Self;
            const STATIC_OFFSET: Option<UtcOffset> = None;
            const HAS_LOGICAL_OFFSET: bool = size_of::<()>() == size_of::<UtcOffset>();
            const HAS_MEMORY_OFFSET: bool = false;
        }
        
        let utc_offset = UtcOffset::from_hms(0, 0, 0).unwrap();
        let offset_option = maybe_offset_as_offset_opt::<None>(utc_offset);

        assert!(offset_option.is_none());
    }
}
False
========================================
    use crate::maybe_offset_from_offset;
    use crate::{date_crate::{self, sealed::MaybeOffset, offset_kind::Fixed}, utc_offset::UtcOffset};

    #[test]
    fn maybe_offset_from_offset_fixed() {
        let offset = UtcOffset::from_hms(1, 30, 0).unwrap();
        let fixed_offset: UtcOffset = maybe_offset_from_offset::<Fixed>(offset);
        assert_eq!(fixed_offset, offset);
    }
}
False
========================================
    use crate::Duration;
    use std::crate::Duration as StdDuration;
    
    #[test]
    fn eq_with_std_duration() {
        // Duration is zero
        assert!(StdDuration::new(0, 0).eq(&Duration::new(0, 0)));
        
        // Duration is positive
        assert!(StdDuration::new(5, 0).eq(&Duration::new(5, 0)));
        
        // Duration is negative
        // `std::crate::Duration` cannot represent negative durations, so the comparison is always false
        assert!(!StdDuration::new(5, 0).eq(&Duration::new(-5, 0)));
        
        // Duration is positive with nanoseconds
        assert!(StdDuration::new(5, 100).eq(&Duration::new(5, 100)));
        
        // Duration is negative with nanoseconds
        // `std::crate::Duration` cannot represent negative durations, so the comparison is always false
        assert!(!StdDuration::new(5, 100).eq(&Duration::new(-5, -100)));
        
        // StdDuration larger than i64::MAX as seconds
        // Cannot construct a `crate::Duration` with more seconds than `i64::MAX`
        assert!(!StdDuration::new(i64::MAX as u64 + 1, 0).eq(&Duration::MAX));
        
        // StdDuration with nanoseconds larger than i32::MAX
        // Cannot construct a `crate::Duration` with more nanoseconds than `i32::MAX`
        assert!(!StdDuration::new(0, i32::MAX as u32 + 1).eq(&Duration::new(0, i32::MAX)));
        
        // Check with Duration consts
        assert!(StdDuration::new(0, 0).eq(&Duration::ZERO));
        assert!(StdDuration::new(1, 0).eq(&Duration::SECOND));
        assert!(StdDuration::new(60, 0).eq(&Duration::MINUTE));
        assert!(StdDuration::new(3_600, 0).eq(&Duration::HOUR));
        assert!(StdDuration::new(86_400, 0).eq(&Duration::DAY));
        
        // Check Duration::MAX
        // `Duration::MAX` cannot be represented as `std::crate::Duration`
        assert!(!StdDuration::new(i64::MAX as u64, 1_000_000_000 - 1).eq(&Duration::MAX));
        
        // Check Duration::MIN
        // `Duration::MIN` is negative, which `std::crate::Duration` cannot represent
        assert!(!Duration::MIN.eq(&StdDuration::new(0, 0)));
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use std::cmp::Ordering;

    #[test]
    fn partial_cmp_equal() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::seconds(5);
        assert_eq!(std_duration.partial_cmp(&time_duration), Some(Ordering::Equal));
    }

    #[test]
    fn partial_cmp_less() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::seconds(6);
        assert_eq!(std_duration.partial_cmp(&time_duration), Some(Ordering::Less));
    }

    #[test]
    fn partial_cmp_greater() {
        let std_duration = StdDuration::from_secs(6);
        let time_duration = Duration::seconds(5);
        assert_eq!(std_duration.partial_cmp(&time_duration), Some(Ordering::Greater));
    }

    #[test]
    fn partial_cmp_with_nanosecond_precision() {
        let std_duration = StdDuration::new(5, 1_000_000);
        let time_duration = Duration::new(5, 1_000_000);
        assert_eq!(std_duration.partial_cmp(&time_duration), Some(Ordering::Equal));

        let std_duration = StdDuration::new(5, 1_000_000);
        let time_duration = Duration::new(5, 1_000_001);
        assert_eq!(std_duration.partial_cmp(&time_duration), Some(Ordering::Less));

        let std_duration = StdDuration::new(5, 1_000_001);
        let time_duration = Duration::new(5, 1_000_000);
        assert_eq!(std_duration.partial_cmp(&time_duration), Some(Ordering::Greater));
    }

    #[test]
    fn partial_cmp_with_negative_duration() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::seconds(-5);
        assert!(std_duration.partial_cmp(&time_duration).is_none());
    }
}
False
========================================
    use crate::duration::Duration;
    use std::crate::Duration as StdDuration;
    use crate::error::ConversionRange;
    use std::convert::TryFrom;

    #[test]
    fn test_try_from_duration() {
        let duration = Duration::new(5, 0); // 5 seconds
        let std_duration = match StdDuration::try_from(duration) {
            Ok(duration) => duration,
            Err(_) => panic!("Conversion failed when it should not."),
        };
        assert_eq!(std_duration, StdDuration::new(5, 0));

        let duration = Duration::new(-5, 0); // -5 seconds, should fail
        assert!(matches!(
            StdDuration::try_from(duration),
            Err(ConversionRange)
        ));

        let duration = Duration::new(i64::MAX, 1_000_000_000 - 1);
        assert!(matches!(
            StdDuration::try_from(duration),
            Err(ConversionRange)
        ));

        let duration = Duration::new(i64::MIN, -1_000_000_000 + 1);
        assert!(matches!(
            StdDuration::try_from(duration),
            Err(ConversionRange)
        ));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn add_duration_to_std_duration() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::seconds(10);
        let result = std_duration.add(time_duration);
        assert_eq!(result.whole_seconds(), 15);
    }

    #[test]
    fn add_std_duration_to_duration() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::seconds(10);
        let result = time_duration.add(std_duration);
        assert_eq!(result.whole_seconds(), 15);
    }

    #[test]
    fn add_zero_to_std_duration() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::seconds(0);
        let result = std_duration.add(time_duration);
        assert_eq!(result.whole_seconds(), 5);
    }

    #[test]
    fn add_std_duration_to_zero() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::ZERO;
        let result = time_duration.add(std_duration);
        assert_eq!(result.whole_seconds(), 5);
    }

    #[test]
    fn add_std_duration_to_negative_duration() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::seconds(-3);
        let result = time_duration.add(std_duration);
        assert_eq!(result.whole_seconds(), 2);
    }

    #[test]
    fn add_negative_duration_to_std_duration() {
        let std_duration = StdDuration::from_secs(5);
        let time_duration = Duration::seconds(-3);
        let result = std_duration.add(time_duration);
        assert_eq!(result.whole_seconds(), 2);
    }

    #[test]
    fn add_large_durations() {
        let std_duration = StdDuration::new(u64::MAX, 999_999_999);
        let time_duration = Duration::seconds(i64::MAX);
        let result = std_duration.add(time_duration);
        assert_eq!(result.whole_seconds(), (u64::MAX as i64) + i64::MAX);
        assert_eq!(result.subsec_nanoseconds(), 999_999_999);
    }

    #[test]
    fn add_std_duration_to_max_duration() {
        let std_duration = StdDuration::new(1, 0);
        let time_duration = Duration::MAX;
        let result = time_duration.add(std_duration);
        assert_eq!(result, Duration::MAX);
    }

    #[test]
    fn add_max_std_duration_to_duration() {
        let std_duration = StdDuration::new(u64::MAX, 999_999_999);
        let time_duration = Duration::seconds(1);
        let result = std_duration.add(time_duration);
        assert_eq!(result, Duration::try_from(std_duration)
            .map(|duration| duration + time_duration)
            .unwrap_or(Duration::MAX)
        );
    }
}
False
========================================
    use std::crate::Duration as StdDuration;
    use crate::Duration as TimeDuration;

    #[test]
    fn add_assign_non_overflowing() {
        let mut std_duration = StdDuration::new(5, 0);
        let mut time_duration = TimeDuration::seconds(5);
        std_duration.add_assign(time_duration);
        assert_eq!(std_duration, StdDuration::new(10, 0));
    }

    #[test]
    #[should_panic(expected = "Cannot represent a resulting duration in std")]
    fn add_assign_overflowing() {
        let mut std_duration = StdDuration::new(u64::MAX, 1_000_000_000 - 1);
        let time_duration = TimeDuration::seconds(1);
        std_duration.add_assign(time_duration);
    }

    #[test]
    fn add_assign_with_nanoseconds() {
        let mut std_duration = StdDuration::new(5, 500_000_000);
        let time_duration = TimeDuration::nanoseconds(1_000_000_000);
        std_duration.add_assign(time_duration);
        assert_eq!(std_duration, StdDuration::new(6, 500_000_000));
    }

    #[test]
    fn add_assign_with_negative_duration() {
        let mut std_duration = StdDuration::new(5, 0);
        let time_duration = TimeDuration::seconds(-3);
        std_duration.add_assign(time_duration);
        assert_eq!(std_duration, StdDuration::new(2, 0));
    }

    #[test]
    #[should_panic(expected = "Cannot represent a resulting duration in std")]
    fn add_assign_with_negative_overflow() {
        let mut std_duration = StdDuration::new(0, 0);
        let time_duration = TimeDuration::seconds(-1);
        std_duration.add_assign(time_duration);
    }
}
False
========================================
    // `super::*` imports from the parent module, which contains the `Duration` type
    use super::*;

use crate::*;

    // `std::crate::Duration` is from the standard library, no `crate` prefix is needed
    use std::crate::Duration as StdDuration;

    #[test]
    fn div_by_std_duration() {
        let std_duration = StdDuration::new(10, 0); // 10 seconds
        let time_duration = Duration::seconds(5); // 5 seconds

        // We use `as_seconds_f64` from the `Duration` type to perform the division
        let result = std_duration.as_secs_f64() / time_duration.as_seconds_f64();
        assert_eq!(result, 2.0);
    }

    #[test]
    fn div_by_zero_std_duration() {
        let std_duration = StdDuration::new(10, 0); // 10 seconds
        let time_duration = Duration::seconds(0); // 0 seconds

        // We use `as_seconds_f64` from the `Duration` type to perform the division
        let result = std_duration.as_secs_f64() / time_duration.as_seconds_f64();
        assert!(result.is_infinite());
    }

    #[test]
    fn div_by_negative_std_duration() {
        let std_duration = StdDuration::new(10, 0); // 10 seconds
        let time_duration = Duration::seconds(-5); // -5 seconds

        // We use `as_seconds_f64` from the `Duration` type to perform the division
        let result = std_duration.as_secs_f64() / time_duration.as_seconds_f64();
        assert_eq!(result, -2.0);
    }

    #[test]
    fn div_by_std_duration_with_nanoseconds() {
        let std_duration = StdDuration::new(10, 500_000_000); // 10.5 seconds
        let time_duration = Duration::new(5, 250_000_000); // 5.25 seconds

        // We use `as_seconds_f64` from the `Duration` type to perform the division
        let result = std_duration.as_secs_f64() / time_duration.as_seconds_f64();
        let expected = 2.0;
        let epsilon = expected * f64::EPSILON;
        assert!(approx_eq(result, expected, epsilon));
    }

    // Helper function to compare floating-point numbers within a tolerance
    fn approx_eq(lhs: f64, rhs: f64, epsilon: f64) -> bool {
        (lhs - rhs).abs() < epsilon
    }
}
False
========================================
    use super::*;

use crate::*;
    use core::crate::Duration as StdDuration; // Correct the import path

    #[test]
    fn mul_f32_with_duration() {
        let duration = Duration::new(5, 0); // 5 seconds
        let multiplier: f32 = 2.5;
        let expected = Duration::new(12, 500_000_000); // 12.5 seconds
        assert_eq!(multiplier.mul(duration), expected);
    }

    #[test]
    fn mul_f32_with_negative_duration() {
        let duration = Duration::new(-5, 0); // -5 seconds
        let multiplier: f32 = 2.5;
        let expected = Duration::new(-12, -500_000_000); // -12.5 seconds
        assert_eq!(multiplier.mul(duration), expected);
    }

    #[test]
    fn mul_f32_with_zero_duration() {
        let duration = Duration::ZERO; // 0 seconds
        let multiplier: f32 = 2.5;
        let expected = Duration::ZERO; // 0 seconds
        assert_eq!(multiplier.mul(duration), expected);
    }

    #[test]
    fn mul_f32_with_one_duration() {
        let duration = Duration::SECOND; // 1 second
        let multiplier: f32 = 2.5;
        let expected = Duration::new(2, 500_000_000); // 2.5 seconds
        assert_eq!(multiplier.mul(duration), expected);
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn mul_f32_with_max_duration() {
        let duration = Duration::MAX; // maximum duration
        let multiplier: f32 = 2.5;
        let _ = multiplier.mul(duration); // should panic due to overflow
    }

    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn mul_f32_with_min_duration() {
        let duration = Duration::MIN; // minimum duration
        let multiplier: f32 = 2.5;
        let _ = multiplier.mul(duration); // should panic due to overflow
    }
}
False
========================================
    use crate::Duration;
    use std::ops::Mul;

    #[test]
    fn mul_by_positive_float() {
        let duration = Duration::seconds(5);
        let multiplier = 2.5_f64;
        let result = multiplier.mul(duration);
        assert_eq!(result, Duration::seconds(12) + Duration::milliseconds(500));
    }

    #[test]
    fn mul_by_negative_float() {
        let duration = Duration::seconds(5);
        let multiplier = -2.0_f64;
        let result = multiplier.mul(duration);
        assert_eq!(result, Duration::seconds(-10));
    }

    #[test]
    fn mul_by_zero() {
        let duration = Duration::seconds(5);
        let multiplier = 0.0_f64;
        let result = multiplier.mul(duration);
        assert_eq!(result, Duration::seconds(0));
    }

    #[test]
    fn mul_by_one() {
        let duration = Duration::seconds(5);
        let multiplier = 1.0_f64;
        let result = multiplier.mul(duration);
        assert_eq!(result, duration);
    }

    #[test]
    fn mul_with_fraction_result() {
        let duration = Duration::milliseconds(1000);
        let multiplier = 0.5_f64;
        let result = multiplier.mul(duration);
        assert_eq!(result, Duration::milliseconds(500));
    }

    #[test]
    fn mul_with_large_multiplier() {
        let duration = Duration::seconds(1);
        let multiplier = 1e9_f64;
        let result = multiplier.mul(duration);
        assert_eq!(result, Duration::seconds(1_000_000_000));
    }

    #[test]
    fn mul_with_large_duration() {
        let duration = Duration::seconds(i64::MAX);
        let multiplier = 0.000000001_f64;
        let result = multiplier.mul(duration);
        assert_eq!(result, Duration::seconds(1));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn mul_duration_by_i16() {
        let dur = Duration::seconds(2);
        let multiplier: i16 = 3;
        let expected = Duration::seconds(6);
        assert_eq!(multiplier.mul(dur), expected);
    }

    #[test]
    fn mul_duration_by_i16_with_overflow() {
        let dur = Duration::seconds(i64::MAX / 2 + 1);
        let multiplier: i16 = 2;
        let expected = Duration::MAX;
        assert_eq!(multiplier.mul(dur), expected);
    }

    #[test]
    fn mul_duration_by_i16_with_negative() {
        let dur = Duration::seconds(3);
        let multiplier: i16 = -2;
        let expected = Duration::seconds(-6);
        assert_eq!(multiplier.mul(dur), expected);
    }

    #[test]
    fn mul_duration_by_i16_with_zero() {
        let dur = Duration::seconds(5);
        let multiplier: i16 = 0;
        let expected = Duration::seconds(0);
        assert_eq!(multiplier.mul(dur), expected);
    }

    #[test]
    fn mul_duration_by_i16_with_negative_duration() {
        let dur = Duration::seconds(-4);
        let multiplier: i16 = 3;
        let expected = Duration::seconds(-12);
        assert_eq!(multiplier.mul(dur), expected);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::ops::Mul;

    #[test]
    fn test_mul_zero() {
        assert_eq!(0.mul(Duration::ZERO), Duration::ZERO);
    }

    #[test]
    fn test_mul_positive() {
        assert_eq!(2.mul(Duration::SECOND), Duration::seconds(2));
    }

    #[test]
    fn test_mul_negative() {
        assert_eq!((-2).mul(Duration::SECOND), Duration::seconds(-2));
    }

    #[test]
    fn test_mul_max() {
        assert_eq!(i32::MAX.mul(Duration::SECOND), Duration::seconds(i32::MAX as i64));
    }

    #[test]
    fn test_mul_min() {
        assert_eq!(
            i32::MIN.mul(Duration::SECOND),
            Duration::seconds(i32::MIN as i64)
        );
    }

    #[test]
    fn test_mul_overflow() {
        assert!((i32::MAX).mul(Duration::MAX).is_positive());
        assert!((i32::MIN).mul(Duration::MIN).is_positive());
    }
}
True
========================================
    use crate::Duration;
    use std::ops::Mul;

    #[test]
    fn mul_duration_by_i8() {
        let duration = Duration::seconds(5);
        let multiplier: i8 = 2;
        let expected = Duration::seconds(10);
        assert_eq!(multiplier.mul(duration), expected);

        let duration = Duration::seconds(5);
        let multiplier: i8 = 0;
        let expected = Duration::seconds(0);
        assert_eq!(multiplier.mul(duration), expected);

        let duration = Duration::seconds(5);
        let multiplier: i8 = -2;
        let expected = Duration::seconds(-10);
        assert_eq!(multiplier.mul(duration), expected);
    }
}
True
========================================
    use crate::Duration;
    use std::ops::Mul;

    #[test]
    fn mul_duration_by_u16() {
        let duration = Duration::seconds(2);
        let multiplier: u16 = 5;
        let result = multiplier.mul(duration);
        assert_eq!(Duration::seconds(10), result);
    }

    #[test]
    fn mul_duration_by_u16_with_nanoseconds() {
        let duration = Duration::new(2, 500_000_000); // 2.5 seconds
        let multiplier: u16 = 2;
        let result = multiplier.mul(duration);
        assert_eq!(Duration::new(5, 0), result);
    }

    #[test]
    fn mul_duration_by_u16_with_negative_duration() {
        let duration = Duration::new(-2, 0);
        let multiplier: u16 = 3;
        let result = multiplier.mul(duration);
        assert_eq!(Duration::new(-6, 0), result);
    }

    #[test]
    fn mul_duration_by_u16_with_overflow() {
        let duration = Duration::new(i64::MAX, 0);
        let multiplier: u16 = 2;
        let result = multiplier.mul(duration);
        assert!(result.is_negative());
        assert_eq!(Duration::new(i64::MAX, 0), result);
    }

    #[test]
    fn mul_duration_by_u16_with_underflow() {
        let duration = Duration::new(i64::MIN, 0);
        let multiplier: u16 = 2;
        let result = multiplier.mul(duration);
        assert!(result.is_negative());
        assert_eq!(Duration::new(i64::MIN, 0), result);
    }
}
True
========================================
    use crate::Duration;
    use std::ops::Mul;

    #[test]
    fn test_u32_mul_duration() {
        let duration = Duration::seconds(5);
        let scalar = 2u32;
        let expected = Duration::seconds(10);
        assert_eq!(scalar.mul(duration), expected);
    }

    #[test]
    fn test_u32_mul_duration_with_nanoseconds() {
        let duration = Duration::new(5, 123_456_789);
        let scalar = 2u32;
        let expected = Duration::new(10, 123_456_789 * 2);
        assert_eq!(scalar.mul(duration), expected);
    }

    #[test]
    fn test_u32_mul_duration_overflow() {
        let duration = Duration::new(i64::MAX, 999_999_999);
        let scalar = 2u32;
        assert!(scalar.mul(duration).is_positive());
    }

    #[test]
    fn test_u32_mul_duration_underflow() {
        let duration = Duration::new(i64::MIN, -999_999_999);
        let scalar = 2u32;
        assert!(scalar.mul(duration).is_negative());
    }

    #[test]
    fn test_u32_mul_zero_duration() {
        let duration = Duration::ZERO;
        let scalar = 2u32;
        let expected = Duration::ZERO;
        assert_eq!(scalar.mul(duration), expected);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn mul_duration_by_u8() {
        assert_eq!((5u8).mul(Duration::seconds(1)), Duration::seconds(5));
        assert_eq!((0u8).mul(Duration::seconds(1)), Duration::ZERO);
        assert_eq!((1u8).mul(Duration::MIN), Duration::MIN);
        assert_eq!((1u8).mul(Duration::MAX), Duration::MAX);
        assert_eq!((2u8).mul(Duration::MIN), Duration::MIN.saturating_mul(2));
        assert_eq!((u8::MAX).mul(Duration::NANOSECOND), Duration::nanoseconds(u8::MAX as i64));
    }
}
True
========================================
    use std::crate::Duration as StdDuration;
    use crate::Duration;
    use crate::ext::NumericalDuration;

    #[test]
    fn sub_std_duration() {
        let std_duration_a = StdDuration::from_secs(5);
        let time_duration_b = 2.seconds();
        let std_duration_a_time_b = std_duration_a - time_duration_b;
        assert_eq!(
            crate::Duration::try_from(std_duration_a).unwrap() - time_duration_b,
            std_duration_a_time_b
        );
    }

    #[test]
    #[should_panic(expected = "overflow converting `std::crate::Duration` to `crate::Duration`")]
    fn sub_std_duration_overflow() {
        let std_duration_a = StdDuration::from_secs(u64::MAX);
        let time_duration_b = 1.seconds();
        let _ = std_duration_a - time_duration_b; // Should panic
    }

    #[test]
    fn sub_time_duration() {
        let std_duration_a = StdDuration::from_secs(5);
        let time_duration_b = 2.seconds();
        let resultant_time_duration = crate::Duration::try_from(std_duration_a).unwrap() - time_duration_b;
        assert_eq!(resultant_time_duration, 3.seconds());
    }

    #[test]
    fn sub_time_duration_neg() {
        let std_duration_a = StdDuration::from_secs(2);
        let time_duration_b = 5.seconds();
        let resultant_time_duration = crate::Duration::try_from(std_duration_a).unwrap() - time_duration_b;
        assert_eq!(resultant_time_duration, (-3).seconds());
    }

    #[test]
    fn sub_zero() {
        let std_duration_a = StdDuration::from_secs(0);
        let time_duration_b = 0.seconds();
        let std_duration_a_time_b = std_duration_a - time_duration_b;
        assert_eq!(
            crate::Duration::try_from(std_duration_a).unwrap() - time_duration_b,
            std_duration_a_time_b
        );
    }

    #[test]
    fn sub_associativity() {
        let std_duration_a = StdDuration::from_secs(8);
        let time_duration_b = 3.seconds();
        let time_duration_c = 2.seconds();
        assert_eq!(
            (std_duration_a - time_duration_b) - time_duration_c,
            std_duration_a - (time_duration_b + time_duration_c)
        );
    }
}
False
========================================
    use std::crate::Duration as StdDuration; // Fixed path
    use std::ops::SubAssign;
    use crate::Duration; // Correct path for the inner duration

    #[test]
    fn sub_assign_positive_durations() {
        let mut std_duration = StdDuration::new(2, 0);
        let time_duration = Duration::new(1, 0);
        std_duration.sub_assign(time_duration);
        assert_eq!(std_duration, StdDuration::new(1, 0));
    }

    #[test]
    fn sub_assign_negative_result() {
        let mut std_duration = StdDuration::new(1, 0);
        let time_duration = Duration::new(2, 0);
        std_duration.sub_assign(time_duration);
        // Overflow subtraction should fall back to the `crate::Duration` type as it allows negative.
        assert!(matches!(StdDuration::try_from(time_duration), Err(_))); // Correct try_from usage
    }

    #[test]
    fn sub_assign_zero_subtracts_to_zero() {
        let mut std_duration = StdDuration::new(0, 0);
        let time_duration = Duration::new(0, 0);
        std_duration.sub_assign(time_duration);
        assert_eq!(std_duration, StdDuration::new(0, 0));
    }

    #[test]
    fn sub_assign_subseconds() {
        let mut std_duration = StdDuration::new(2, 500_000_000);
        let time_duration = Duration::new(1, 250_000_000);
        std_duration.sub_assign(time_duration);
        assert_eq!(std_duration, StdDuration::new(1, 250_000_000));
    }

    #[test]
    fn sub_assign_different_nanosecond_values() {
        let mut std_duration = StdDuration::new(1, 750_000_000);
        let time_duration = Duration::new(0, 500_000_000);
        std_duration.sub_assign(time_duration);
        assert_eq!(std_duration, StdDuration::new(1, 250_000_000));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration; // Ensure the trait is in scope for the methods.

    #[test]
    fn test_abs_positive() {
        assert_eq!(1.seconds().abs(), 1.seconds());
    }

    #[test]
    fn test_abs_zero() {
        assert_eq!(0.seconds().abs(), 0.seconds());
    }

    #[test]
    fn test_abs_negative() {
        assert_eq!((-1).seconds().abs(), 1.seconds());
    }

    #[test]
    fn test_abs_edge_case() {
        assert_eq!(Duration::MIN.abs(), Duration::MAX);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_as_seconds_f32() {
        assert_eq!(Duration::ZERO.as_seconds_f32(), 0.0);
        assert_eq!(Duration::new(0, 500_000_000).as_seconds_f32(), 0.5);
        assert_eq!(Duration::new(1, 0).as_seconds_f32(), 1.0);
        assert_eq!(Duration::new(1, 250_000_000).as_seconds_f32(), 1.25);
        assert_eq!(Duration::new(-1, 0).as_seconds_f32(), -1.0);
        assert_eq!(Duration::new(-1, -250_000_000).as_seconds_f32(), -1.25);
        assert_eq!(Duration::new(0, 1_000_000_001).as_seconds_f32(), 1.0);
        assert_eq!(Duration::new(0, -1_000_000_001).as_seconds_f32(), -1.0);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_as_seconds_f64() {
        let duration_positive = Duration::new(5, 500_000_000); // 5.5 seconds
        let duration_negative = Duration::new(-5, -500_000_000); // -5.5 seconds
        let duration_zero = Duration::ZERO;

        assert_eq!(duration_positive.as_seconds_f64(), 5.5);
        assert_eq!(duration_negative.as_seconds_f64(), -5.5);
        assert_eq!(duration_zero.as_seconds_f64(), 0.0);
    }

    #[test]
    fn test_as_seconds_f64_with_extreme_values() {
        let duration_max = Duration::new(i64::MAX, 999_999_999); // Maximum possible Duration
        let duration_min = Duration::new(i64::MIN, -999_999_999); // Minimum possible Duration

        assert_eq!(duration_max.as_seconds_f64(), i64::MAX as f64 + 999_999_999 as f64 / 1_000_000_000 as f64);
        assert_eq!(duration_min.as_seconds_f64(), i64::MIN as f64 - 999_999_999 as f64 / 1_000_000_000 as f64);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{Duration, ext::NumericalDuration};

    #[test]
    fn checked_add_with_no_overflow() {
        assert_eq!(
            Duration::new(1, 500_000_000).checked_add(Duration::new(2, 250_000_000)),
            Some(Duration::new(3, 750_000_000))
        );
        assert_eq!(
            Duration::new(-1, -500_000_000).checked_add(Duration::new(2, 250_000_000)),
            Some(Duration::new(0, -250_000_000))
        );
        assert_eq!(
            Duration::new(1, 750_000_000).checked_add(Duration::new(0, 250_000_000)),
            Some(Duration::new(2, 0))
        );
        assert_eq!(
            Duration::new(i64::MAX, 999_999_999).checked_add(Duration::new(0, 0)),
            Some(Duration::new(i64::MAX, 999_999_999))
        );
        assert_eq!(
            Duration::new(i64::MIN, -999_999_999).checked_add(Duration::new(0, 0)),
            Some(Duration::new(i64::MIN, -999_999_999))
        );
    }

    #[test]
    fn checked_add_with_overflow() {
        assert_eq!(
            Duration::new(i64::MAX, 999_999_999).checked_add(Duration::new(0, 1)),
            None
        );
        assert_eq!(
            Duration::new(i64::MIN, -999_999_999).checked_add(Duration::new(0, -1)),
            None
        );
    }

    #[test]
    fn checked_add_with_underflow() {
        assert_eq!(
            Duration::new(i64::MIN, 0).checked_add(Duration::new(-1, 0)),
            None
        );
        assert_eq!(
            Duration::new(i64::MAX, 0).checked_add(Duration::new(1, 0)),
            None
        );
    }

    #[test]
    fn checked_add_with_edges() {
        assert_eq!(
            Duration::new(i64::MAX, 0).checked_add(Duration::new(0, 999_999_999)),
            Some(Duration::new(i64::MAX, 999_999_999))
        );
        assert_eq!(
            Duration::new(i64::MIN, 0).checked_add(Duration::new(0, -999_999_999)),
            Some(Duration::new(i64::MIN, -999_999_999))
        );
    }

    #[test]
    fn checked_add_with_cross_zero() {
        assert_eq!(
            Duration::new(-1, 500_000_000).checked_add(Duration::new(0, 500_000_000)),
            Some(Duration::new(0, 0))
        );
        assert_eq!(
            Duration::new(1, -500_000_000).checked_add(Duration::new(0, -500_000_000)),
            Some(Duration::new(0, 0))
        );
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn checked_div_positive() {
        assert_eq!(
            Duration::new(10, 0).checked_div(2),
            Some(Duration::new(5, 0))
        );
    }

    #[test]
    fn checked_div_negative() {
        assert_eq!(
            Duration::new(-10, 0).checked_div(2),
            Some(Duration::new(-5, 0))
        );
    }

    #[test]
    fn checked_div_zero_divisor() {
        assert_eq!(Duration::new(1, 0).checked_div(0), None);
    }

    #[test]
    fn checked_div_fractional() {
        assert_eq!(
            Duration::new(10, 500_000_000).checked_div(2),
            Some(Duration::new(5, 250_000_000))
        );
    }

    #[test]
    fn checked_div_overflow() {
        assert_eq!(Duration::new(i64::MAX, 0).checked_div(1), Some(Duration::new(i64::MAX, 0)));
        assert_eq!(Duration::new(i64::MAX, 999_999_999).checked_div(1), Some(Duration::new(i64::MAX, 999_999_999)));
        assert_eq!(Duration::new(i64::MIN, 0).checked_div(-1), None);
        assert_eq!(Duration::new(i64::MIN + 1, 0).checked_div(-1), Some(Duration::new(i64::MAX, 0)));
        assert_eq!(Duration::new(1, 0).checked_div(i32::MIN), None);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn checked_mul_with_overflow() {
        assert_eq!(Duration::MAX.checked_mul(2), None);
        assert_eq!(Duration::MIN.checked_mul(2), None);
    }

    #[test]
    fn checked_mul_without_overflow() {
        assert_eq!(5.seconds().checked_mul(2), Some(10.seconds()));
        assert_eq!(5.seconds().checked_mul(-2), Some((-10).seconds()));
        assert_eq!(5.seconds().checked_mul(0), Some(0.seconds()));
        assert_eq!(Duration::new(1, 0).checked_mul(2), Some(Duration::new(2, 0)));
        assert_eq!(Duration::new(-1, 0).checked_mul(2), Some(Duration::new(-2, 0)));
    }
}
True
========================================
    use crate::Duration;
    use crate::ext::NumericalDuration;

    #[test]
    fn test_checked_seconds_f32() {
        assert_eq!(
            Duration::checked_seconds_f32(0.5),
            Some(Duration::seconds(0) + Duration::milliseconds(500))
        );
        assert_eq!(
            Duration::checked_seconds_f32(-0.5),
            Some(Duration::seconds(0) - Duration::milliseconds(500))
        );
        assert_eq!(Duration::checked_seconds_f32(f32::NAN), None);
        assert_eq!(Duration::checked_seconds_f32(f32::NEG_INFINITY), None);
        assert_eq!(Duration::checked_seconds_f32(f32::INFINITY), None);
        assert_eq!(
            Duration::checked_seconds_f32(f32::MAX),
            Some(Duration::seconds(f32::MAX as i64))
        );
        assert_eq!(
            Duration::checked_seconds_f32(f32::MIN),
            Some(Duration::seconds(f32::MIN as i64))
        );
    }
}
True
========================================
    use crate::Duration;
    use crate::ext::NumericalDuration;

    #[test]
    fn checked_seconds_f64_valid() {
        assert_eq!(
            Duration::checked_seconds_f64(0.5),
            Some(0.5.seconds())
        );
        assert_eq!(
            Duration::checked_seconds_f64(-0.5),
            Some(-0.5.seconds())
        );
        assert_eq!(
            Duration::checked_seconds_f64(1.0e7),
            Some(1.0e7.seconds())
        );
        assert_eq!(
            Duration::checked_seconds_f64(-1.0e7),
            Some(-1.0e7.seconds())
        );
    }

    #[test]
    fn checked_seconds_f64_invalid() {
        assert_eq!(
            Duration::checked_seconds_f64(f64::NAN),
            None
        );
        assert_eq!(
            Duration::checked_seconds_f64(f64::NEG_INFINITY),
            None
        );
        assert_eq!(
            Duration::checked_seconds_f64(f64::INFINITY),
            None
        );
        assert_eq!(
            Duration::checked_seconds_f64(f64::MAX),
            None
        );
        assert_eq!(
            Duration::checked_seconds_f64(f64::MIN),
            None
        );
    }

    #[test]
    fn checked_seconds_f64_edge_cases() {
        assert_eq!(
            Duration::checked_seconds_f64(f64::EPSILON),
            Some(f64::EPSILON.seconds())
        );
        assert_eq!(
            Duration::checked_seconds_f64(-f64::EPSILON),
            Some((-f64::EPSILON).seconds())
        );
    }
}
True
========================================
#[cfg(test)]
mod checked_sub_tests {
    use super::*;

use crate::*;
    use crate::{Duration, ext::NumericalDuration};

    #[test]
    fn zero_duration() {
        assert_eq!(Duration::ZERO.checked_sub(Duration::ZERO), Some(Duration::ZERO));
    }

    #[test]
    fn positive_duration() {
        assert_eq!(5.seconds().checked_sub(5.seconds()), Some(Duration::ZERO));
        assert_eq!(5.seconds().checked_sub(1.seconds()), Some(4.seconds()));
        assert_eq!(1.seconds().checked_sub(5.seconds()), Some((-4).seconds()));
    }

    #[test]
    fn negative_duration() {
        assert_eq!((-5).seconds().checked_sub((-5).seconds()), Some(Duration::ZERO));
        assert_eq!((-5).seconds().checked_sub((-1).seconds()), Some((-4).seconds()));
        assert_eq!((-1).seconds().checked_sub((-5).seconds()), Some(4.seconds()));
    }

    #[test]
    fn mixed_duration() {
        assert_eq!(5.seconds().checked_sub((-5).seconds()), Some(10.seconds()));
        assert_eq!((-5).seconds().checked_sub(5.seconds()), Some((-10).seconds()));
    }

    #[test]
    fn overflow_duration() {
        assert_eq!(Duration::MIN.checked_sub(1.nanoseconds()), None);
        assert_eq!(Duration::MIN.checked_sub((-1).seconds()), None);
        assert_eq!(Duration::MAX.checked_sub((-1).nanoseconds()), None);
        assert_eq!(Duration::MAX.checked_sub(1.seconds()), None);
    }
}
True
========================================
    use super::*;

use crate::*;
    use duration::Duration;

    #[test]
    fn days_zero() {
        assert_eq!(Duration::days(0), Duration::ZERO);
    }

    #[test]
    fn days_single() {
        assert_eq!(Duration::days(1), Duration::DAY);
    }

    #[test]
    fn days_multiple() {
        assert_eq!(Duration::days(10), Duration::days(1) * 10);
    }

    #[test]
    fn days_negative() {
        assert_eq!(Duration::days(-1), -Duration::DAY);
    }

    #[test]
    fn days_arbitrary() {
        assert_eq!(
            Duration::days(365),
            Duration::seconds(365 * 86_400)
        );
    }

    #[test]
    fn days_min() {
        assert_eq!(Duration::days(i64::MIN), Duration::MIN);
    }

    #[test]
    fn days_max() {
        assert_eq!(Duration::days(i64::MAX), Duration::MAX);
    }

    #[test]
    fn days_overflow() {
        assert!(Duration::days(i64::MAX / 86_400 + 1).is_negative());
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn days_overflow_panic() {
        let _ = Duration::days(i64::MAX / 86_400 + 1);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn hours_zero() {
        assert_eq!(Duration::hours(0), Duration::seconds(0));
    }

    #[test]
    fn hours_pos() {
        assert_eq!(Duration::hours(1), Duration::seconds(3600));
        assert_eq!(Duration::hours(2), Duration::seconds(7200));
        assert_eq!(Duration::hours(24), Duration::seconds(86400));
    }

    #[test]
    fn hours_neg() {
        assert_eq!(Duration::hours(-1), Duration::seconds(-3600));
        assert_eq!(Duration::hours(-2), Duration::seconds(-7200));
        assert_eq!(Duration::hours(-24), Duration::seconds(-86400));
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn hours_overflow() {
        let _ = Duration::hours(i64::MAX);
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn hours_underflow() {
        let _ = Duration::hours(i64::MIN);
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn test_is_negative() {
        assert!(Duration::new(-1, 0).is_negative());
        assert!(Duration::new(-1, -500_000_000).is_negative());
        assert!(Duration::new(0, -500_000_000).is_negative());
        assert!(Duration::new(-1, 500_000_000).is_negative());
        assert!(!Duration::new(0, 0).is_negative());
        assert!(!Duration::new(1, 0).is_negative());
        assert!(!Duration::new(1, -500_000_000).is_negative());
        assert!(!Duration::new(1, 500_000_000).is_negative());
        assert!(!Duration::new(0, 500_000_000).is_negative());
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn test_is_positive() {
        assert!(Duration::seconds(1).is_positive());
        assert!(Duration::milliseconds(1).is_positive());
        assert!(Duration::nanoseconds(1).is_positive());
        assert!(!Duration::seconds(0).is_positive());
        assert!(!Duration::milliseconds(0).is_positive());
        assert!(!Duration::nanoseconds(0).is_positive());
        assert!(!Duration::seconds(-1).is_positive());
        assert!(!Duration::milliseconds(-1).is_positive());
        assert!(!Duration::nanoseconds(-1).is_positive());
        assert!(Duration::new(1, 1).is_positive());
        assert!(Duration::new(0, 1).is_positive());
        assert!(Duration::new(-1, 1).is_positive());
        assert!(!Duration::new(0, -1).is_positive());
        assert!(!Duration::new(1, -1).is_positive());
        assert!(!Duration::new(-1, -1).is_positive());
    }
}
True
========================================
    use super::*; // import the `Duration` struct and its associated methods

use crate::*;
    
    #[test]
    fn is_zero_with_zero_duration() {
        assert!(Duration::ZERO.is_zero());
    }

    #[test]
    fn is_zero_with_nonzero_duration() {
        assert!(!Duration::nanoseconds(1).is_zero());
        assert!(!Duration::seconds(1).is_zero());
    }

    #[test]
    fn is_zero_with_negative_duration() {
        assert!(!Duration::seconds(-1).is_zero());
    }

    #[test]
    fn is_zero_with_complex_duration() {
        assert!(Duration::new(0, 0).is_zero());
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn microseconds_new() {
        assert_eq!(Duration::microseconds(1), Duration::nanoseconds(1000));
        assert_eq!(Duration::microseconds(1000), Duration::milliseconds(1));
        assert_eq!(Duration::microseconds(1_000_000), Duration::seconds(1));
        assert_eq!(Duration::microseconds(-1), Duration::nanoseconds(-1000));
        assert_eq!(Duration::microseconds(-1000), Duration::milliseconds(-1));
        assert_eq!(Duration::microseconds(-1_000_000), Duration::seconds(-1));
    }

    #[test]
    fn microseconds_bounds() {
        assert_eq!(Duration::microseconds(i64::MAX), Duration::MAX);
        assert_eq!(Duration::microseconds(i64::MIN), Duration::MIN);
    }

    #[test]
    fn microseconds_properties() {
        let pos_duration = Duration::microseconds(1_000_000);
        let neg_duration = Duration::microseconds(-1_000_000);
        assert!(pos_duration.is_positive());
        assert!(neg_duration.is_negative());
        assert!(!pos_duration.is_negative());
        assert!(!neg_duration.is_positive());
    }

    #[test]
    fn microseconds_arithmetic() {
        assert_eq!(Duration::microseconds(500) + Duration::microseconds(500), Duration::milliseconds(1));
        assert_eq!(Duration::microseconds(500) - Duration::microseconds(300), Duration::microseconds(200));
        assert_eq!(Duration::microseconds(100) * 5, Duration::microseconds(500));
        assert_eq!(Duration::microseconds(1000) / 2, Duration::microseconds(500));
    }

    #[test]
    fn microseconds_zero() {
        assert_eq!(Duration::microseconds(-0), Duration::ZERO);
        assert_eq!(Duration::microseconds(0), Duration::ZERO);
        assert!(Duration::microseconds(0).is_zero());
    }

    // Additional tests can be defined as needed
}
True
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;

    #[test]
    fn milliseconds_positive() {
        assert_eq!(
            Duration::milliseconds(1500),
            Duration::new(1, 500_000_000),
            "1500 milliseconds should be 1 second and 500 million nanoseconds"
        );
    }

    #[test]
    fn milliseconds_negative() {
        assert_eq!(
            Duration::milliseconds(-1500),
            Duration::new(-1, -500_000_000),
            "Negative 1500 milliseconds should be -1 second and -500 million nanoseconds"
        );
    }

    #[test]
    fn milliseconds_zero() {
        assert_eq!(
            Duration::milliseconds(0),
            Duration::new(0, 0),
            "0 milliseconds should be 0 seconds and 0 nanoseconds"
        );
    }

    #[test]
    fn milliseconds_one() {
        assert_eq!(
            Duration::milliseconds(1),
            Duration::new(0, 1_000_000),
            "1 millisecond should be 0 seconds and 1 million nanoseconds"
        );
    }

    #[test]
    fn milliseconds_max() {
        assert_eq!(
            Duration::milliseconds(i64::MAX),
            Duration::new(i64::MAX / 1_000, ((i64::MAX % 1_000) * 1_000_000) as i32),
            "Maximum i64 milliseconds should be calculated correctly"
        );
    }

    #[test]
    fn milliseconds_min() {
        assert_eq!(
            Duration::milliseconds(i64::MIN),
            Duration::new(i64::MIN / 1_000, ((i64::MIN % 1_000) * 1_000_000) as i32),
            "Minimum i64 milliseconds should be calculated correctly"
        );
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn duration_minutes() {
        assert_eq!(Duration::minutes(0), Duration::ZERO);
        assert_eq!(Duration::minutes(1), Duration::SECOND * 60);
        assert_eq!(Duration::minutes(60), Duration::HOUR);
        assert_eq!(Duration::minutes(1_440), Duration::DAY);
        assert_eq!(Duration::minutes(-1), Duration::SECOND * -60);
        assert_eq!(Duration::minutes(-60), Duration::HOUR * -1);
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn duration_minutes_overflow_positive() {
        let _ = Duration::minutes(i64::MAX / 60 + 1);
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn duration_minutes_overflow_negative() {
        let _ = Duration::minutes(i64::MIN / 60 - 1);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_nanoseconds_positive() {
        let nanos = 1_234_567_890;
        let duration = Duration::nanoseconds(nanos);
        assert_eq!(duration.whole_seconds(), 1);
        assert_eq!(duration.subsec_nanoseconds(), 234_567_890);
    }

    #[test]
    fn test_nanoseconds_negative() {
        let nanos = -1_234_567_890;
        let duration = Duration::nanoseconds(nanos);
        assert_eq!(duration.whole_seconds(), -2);
        assert_eq!(duration.subsec_nanoseconds(), 765_432_110);
    }

    #[test]
    fn test_nanoseconds_zero() {
        let nanos = 0;
        let duration = Duration::nanoseconds(nanos);
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.subsec_nanoseconds(), 0);
    }

    #[test]
    fn test_nanoseconds_one() {
        let nanos = 1;
        let duration = Duration::nanoseconds(nanos);
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.subsec_nanoseconds(), 1);
    }

    #[test]
    fn test_nanoseconds_one_negative() {
        let nanos = -1;
        let duration = Duration::nanoseconds(nanos);
        assert_eq!(duration.whole_seconds(), 0);
        assert_eq!(duration.subsec_nanoseconds(), -1);
    }

    #[test]
    fn test_nanoseconds_max() {
        let nanos = i64::MAX;
        let duration = Duration::nanoseconds(nanos);
        assert_eq!(duration.whole_seconds(), i64::MAX / 1_000_000_000);
        assert_eq!(duration.subsec_nanoseconds(), (i64::MAX % 1_000_000_000) as i32);
    }

    #[test]
    fn test_nanoseconds_min() {
        let nanos = i64::MIN;
        let duration = Duration::nanoseconds(nanos);
        assert_eq!(duration.whole_seconds(), i64::MIN / 1_000_000_000);
        assert_eq!(duration.subsec_nanoseconds(), (i64::MIN % 1_000_000_000) as i32);
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn nanoseconds_i128_within_bounds() {
        assert_eq!(
            Duration::nanoseconds_i128(1_000_000_000),
            Duration::seconds(1)
        );
        assert_eq!(
            Duration::nanoseconds_i128(-1_000_000_000),
            Duration::seconds(-1)
        );
        assert_eq!(
            Duration::nanoseconds_i128(i64::MAX as i128 * 1_000_000_000),
            Duration::MAX
        );
        assert_eq!(
            Duration::nanoseconds_i128(i64::MIN as i128 * 1_000_000_000),
            Duration::MIN
        );
    }

    #[test]
    #[should_panic]
    fn nanoseconds_i128_overflow() {
        Duration::nanoseconds_i128(i128::MAX);
    }

    #[test]
    #[should_panic]
    fn nanoseconds_i128_underflow() {
        Duration::nanoseconds_i128(i128::MIN);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn new_with_no_wrap() {
        assert_eq!(Duration::new(1, 0), Duration::seconds(1));
        assert_eq!(Duration::new(-1, 0), Duration::seconds(-1));
        assert_eq!(Duration::new(0, 500_000_000), Duration::milliseconds(500));
        assert_eq!(Duration::new(-2, -1_000_000_000), Duration::seconds(-3));
    }

    #[test]
    fn new_with_nanosecond_wrapping() {
        assert_eq!(Duration::new(1, 1_000_000_000), Duration::seconds(2));
        assert_eq!(Duration::new(2, -2_000_000_000), Duration::seconds(0));
        assert_eq!(Duration::new(-1, 2_000_000_000), Duration::seconds(1));
        assert_eq!(Duration::new(-2, -2_000_000_000), Duration::seconds(-4));
    }

    #[test]
    fn new_with_nanosecond_carry() {
        assert_eq!(Duration::new(1, 1_500_000_000), Duration::seconds(2) + Duration::milliseconds(500));
        assert_eq!(Duration::new(-1, -1_500_000_000), Duration::seconds(-2) - Duration::milliseconds(500));
    }

    #[test]
    fn new_with_maximum_values() {
        assert_eq!(Duration::new(i64::MAX, 999_999_999), Duration::MAX);
        assert_eq!(Duration::new(i64::MIN, -999_999_999), Duration::MIN);
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn new_with_overflow() {
        let _ = Duration::new(i64::MAX, 1_000_000_000);
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn new_with_underflow() {
        let _ = Duration::new(i64::MIN, -1_000_000_000);
    }
}
True
========================================
    use crate::Duration;
    use crate::duration::Padding;

    #[test]
    fn test_new_unchecked_positive() {
        let duration = Duration::new_unchecked(5, 100);
        assert_eq!(duration.seconds, 5);
        assert_eq!(duration.nanoseconds, 100);
        assert_eq!(duration.padding, Padding::Optimize);
    }

    #[test]
    fn test_new_unchecked_negative() {
        let duration = Duration::new_unchecked(-5, -100);
        assert_eq!(duration.seconds, -5);
        assert_eq!(duration.nanoseconds, -100);
        assert_eq!(duration.padding, Padding::Optimize);
    }

    #[test]
    fn test_new_unchecked_zero_positive() {
        let duration = Duration::new_unchecked(0, 100);
        assert_eq!(duration.seconds, 0);
        assert_eq!(duration.nanoseconds, 100);
        assert_eq!(duration.padding, Padding::Optimize);
    }

    #[test]
    fn test_new_unchecked_zero_negative() {
        let duration = Duration::new_unchecked(0, -100);
        assert_eq!(duration.seconds, 0);
        assert_eq!(duration.nanoseconds, -100);
        assert_eq!(duration.padding, Padding::Optimize);
    }

    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_new_unchecked_panic_positive_nanoseconds() {
        let _duration = Duration::new_unchecked(5, 1_000_000_000);
    }

    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_new_unchecked_panic_negative_nanoseconds() {
        let _duration = Duration::new_unchecked(-5, -1_000_000_000);
    }

    #[test]
    fn test_new_unchecked_edge_positive_nanoseconds() {
        let duration = Duration::new_unchecked(5, 999_999_999);
        assert_eq!(duration.seconds, 5);
        assert_eq!(duration.nanoseconds, 999_999_999);
        assert_eq!(duration.padding, Padding::Optimize);
    }

    #[test]
    fn test_new_unchecked_edge_negative_nanoseconds() {
        let duration = Duration::new_unchecked(-5, -999_999_999);
        assert_eq!(duration.seconds, -5);
        assert_eq!(duration.nanoseconds, -999_999_999);
        assert_eq!(duration.padding, Padding::Optimize);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn saturating_add_with_no_overflow() {
        assert_eq!(
            Duration::seconds(30).saturating_add(Duration::seconds(30)),
            Duration::seconds(60)
        );
        assert_eq!(
            Duration::nanoseconds(500).saturating_add(Duration::nanoseconds(500)),
            Duration::nanoseconds(1000)
        );
        assert_eq!(
            Duration::seconds(-30).saturating_add(Duration::seconds(30)),
            Duration::seconds(0)
        );
    }

    #[test]
    fn saturating_add_with_overflow() {
        assert_eq!(
            Duration::MAX.saturating_add(Duration::seconds(1)),
            Duration::MAX
        );
        assert_eq!(
            Duration::MAX.saturating_add(Duration::MAX),
            Duration::MAX
        );
    }

    #[test]
    fn saturating_add_with_underflow() {
        assert_eq!(
            Duration::MIN.saturating_add(Duration::seconds(-1)),
            Duration::MIN
        );
        assert_eq!(
            Duration::MIN.saturating_add(Duration::MIN),
            Duration::MIN
        );
    }
}
True
========================================
    use super::*;

use crate::*;
    use core::crate::Duration as StdDuration;
    use crate::Duration;

    #[test]
    fn saturating_mul_basic() {
        assert_eq!(
            Duration::seconds(5).saturating_mul(2),
            Duration::seconds(10)
        );
        assert_eq!(
            Duration::seconds(5).saturating_mul(-2),
            Duration::seconds(-10)
        );
        assert_eq!(
            Duration::seconds(5).saturating_mul(0),
            Duration::ZERO
        );
    }

    #[test]
    fn saturating_mul_overflow() {
        assert_eq!(
            Duration::new(i64::MAX, 999_999_999).saturating_mul(2),
            Duration::MAX
        );
    }

    #[test]
    fn saturating_mul_underflow() {
        assert_eq!(
            Duration::new(i64::MIN, -999_999_999).saturating_mul(2),
            Duration::MIN
        );
    }

    #[test]
    fn saturating_mul_overflow_with_negative() {
        assert_eq!(
            Duration::new(i64::MAX, 999_999_999).saturating_mul(-2),
            Duration::MIN
        );
    }

    #[test]
    fn saturating_mul_underflow_with_negative() {
        assert_eq!(
            Duration::new(i64::MIN, -999_999_999).saturating_mul(-2),
            Duration::MAX
        );
    }

    #[test]
    fn saturating_mul_with_std_duration() {
        let std_duration = StdDuration::new(5, 0);
        let time_duration = Duration::seconds(5);
        assert_eq!(
            time_duration.saturating_mul(2),
            Duration::try_from(std_duration).unwrap() * 2
        );
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn saturating_seconds_f32_returns_zero_for_nan() {
        let duration = Duration::saturating_seconds_f32(f32::NAN);
        assert_eq!(duration, Duration::ZERO);
    }

    #[test]
    fn saturating_seconds_f32_returns_max_for_infinity() {
        let duration = Duration::saturating_seconds_f32(f32::INFINITY);
        assert_eq!(duration, Duration::MAX);
    }

    #[test]
    fn saturating_seconds_f32_returns_min_for_negative_infinity() {
        let duration = Duration::saturating_seconds_f32(f32::NEG_INFINITY);
        assert_eq!(duration, Duration::MIN);
    }

    #[test]
    fn saturating_seconds_f32_handles_positive_values() {
        let duration = Duration::saturating_seconds_f32(0.5);
        assert_eq!(duration, Duration::seconds_f32(0.5));
    }

    #[test]
    fn saturating_seconds_f32_handles_negative_values() {
        let duration = Duration::saturating_seconds_f32(-0.5);
        assert_eq!(duration, Duration::seconds_f32(-0.5));
    }

    #[test]
    fn saturating_seconds_f32_saturates_positive_overflow() {
        let large_positive = f32::MAX;
        let duration = Duration::saturating_seconds_f32(large_positive);
        assert_eq!(duration, Duration::MAX);
    }

    #[test]
    fn saturating_seconds_f32_saturates_negative_overflow() {
        let large_negative = f32::MIN;
        let duration = Duration::saturating_seconds_f32(large_negative);
        assert_eq!(duration, Duration::MIN);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::f64;

    #[test]
    fn test_saturating_seconds_f64_zero() {
        assert_eq!(Duration::saturating_seconds_f64(0.0), Duration::ZERO);
    }

    #[test]
    fn test_saturating_seconds_f64_half() {
        assert_eq!(
            Duration::saturating_seconds_f64(0.5),
            Duration::seconds_f64(0.5)
        );
    }

    #[test]
    fn test_saturating_seconds_f64_negative_half() {
        assert_eq!(
            Duration::saturating_seconds_f64(-0.5),
            Duration::seconds_f64(-0.5)
        );
    }

    #[test]
    fn test_saturating_seconds_f64_nan() {
        assert_eq!(
            Duration::saturating_seconds_f64(f64::NAN),
            Duration::ZERO
        );
    }

    #[test]
    fn test_saturating_seconds_f64_infinity() {
        assert_eq!(
            Duration::saturating_seconds_f64(f64::INFINITY),
            Duration::MAX
        );
    }

    #[test]
    fn test_saturating_seconds_f64_negative_infinity() {
        assert_eq!(
            Duration::saturating_seconds_f64(f64::NEG_INFINITY),
            Duration::MIN
        );
    }

    #[test]
    fn test_saturating_seconds_f64_max() {
        assert_eq!(
            Duration::saturating_seconds_f64(i64::MAX as f64),
            Duration::seconds(i64::MAX)
        );
    }

    #[test]
    fn test_saturating_seconds_f64_min() {
        assert_eq!(
            Duration::saturating_seconds_f64(i64::MIN as f64),
            Duration::seconds(i64::MIN)
        );
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn saturating_sub_with_zero() {
        assert_eq!(Duration::seconds(5).saturating_sub(Duration::seconds(5)), Duration::ZERO);
        assert_eq!(Duration::ZERO.saturating_sub(Duration::seconds(5)), Duration::seconds(-5));
    }

    #[test]
    fn saturating_sub_with_min() {
        assert_eq!(Duration::MIN.saturating_sub(Duration::seconds(1)), Duration::MIN);
        assert_eq!(Duration::MIN.saturating_sub(Duration::MIN), Duration::ZERO);
    }

    #[test]
    fn saturating_sub_with_max() {
        assert_eq!(Duration::MAX.saturating_sub(Duration::seconds(-1)), Duration::MAX);
        assert_eq!(Duration::MAX.saturating_sub(Duration::MAX), Duration::ZERO);
    }

    #[test]
    fn saturating_sub_with_positive_negative() {
        assert_eq!(Duration::seconds(10).saturating_sub(Duration::seconds(-5)), Duration::seconds(15));
        assert_eq!(Duration::seconds(-10).saturating_sub(Duration::seconds(5)), Duration::seconds(-15));
    }

    #[test]
    fn saturating_sub_with_overflow() {
        assert_eq!(Duration::seconds(i64::MAX).saturating_sub(Duration::seconds(-1)), Duration::MAX);
        assert_eq!(Duration::seconds(i64::MIN).saturating_sub(Duration::seconds(1)), Duration::MIN);
    }

    #[test]
    fn saturating_sub_with_underflow() {
        assert_eq!(Duration::seconds(-5).saturating_sub(Duration::seconds(10)), Duration::seconds(-15));
        assert_eq!(Duration::seconds(5).saturating_sub(Duration::seconds(10)), Duration::seconds(-5));
    }

    #[test]
    fn saturating_sub_with_nanoseconds() {
        assert_eq!(Duration::nanoseconds(500).saturating_sub(Duration::nanoseconds(1000)), Duration::nanoseconds(-500));
        assert_eq!(Duration::nanoseconds(-500).saturating_sub(Duration::nanoseconds(-1000)), Duration::nanoseconds(500));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn seconds_positive() {
        assert_eq!(Duration::seconds(1), Duration::new(1, 0));
        assert_eq!(Duration::seconds(5), Duration::new(5, 0));
    }

    #[test]
    fn seconds_negative() {
        assert_eq!(Duration::seconds(-1), Duration::new(-1, 0));
        assert_eq!(Duration::seconds(-5), Duration::new(-5, 0));
    }

    #[test]
    fn seconds_zero() {
        assert_eq!(Duration::seconds(0), Duration::new(0, 0));
    }

    #[test]
    fn seconds_boundary() {
        assert_eq!(Duration::seconds(i64::MAX), Duration::new(i64::MAX, 0));
        assert_eq!(Duration::seconds(i64::MIN), Duration::new(i64::MIN, 0));
    }
}
True
========================================
    use crate::duration::Duration;
    use std::crate::Duration as StdDuration;

    #[test]
    fn zero_seconds() {
        assert_eq!(Duration::seconds_f32(0.0), Duration::ZERO);
    }

    #[test]
    fn half_seconds() {
        assert_eq!(Duration::seconds_f32(0.5), Duration::milliseconds(500));
    }

    #[test]
    fn one_second() {
        assert_eq!(Duration::seconds_f32(1.0), Duration::SECOND);
    }

    #[test]
    fn negative_half_second() {
        assert_eq!(Duration::seconds_f32(-0.5), Duration::milliseconds(-500));
    }

    #[test]
    fn from_std_duration() {
        assert_eq!(Duration::seconds_f32(1.5), Duration::try_from(StdDuration::new(1, 500_000_000)).unwrap());
    }

    #[test]
    fn add_duration() {
        assert_eq!(Duration::seconds_f32(0.5) + Duration::milliseconds(250), Duration::milliseconds(750));
    }

    #[test]
    fn sub_duration() {
        assert_eq!(Duration::seconds_f32(1.0) - Duration::milliseconds(250), Duration::milliseconds(750));
    }

    #[test]
    fn mul_duration() {
        assert_eq!(Duration::seconds_f32(1.0) * 2.0, Duration::seconds(2));
    }

    #[test]
    fn div_duration() {
        assert_eq!(Duration::seconds_f32(1.0) / 2.0, Duration::milliseconds(500));
    }

    #[test]
    fn neg_duration() {
        assert_eq!(-Duration::seconds_f32(1.0), Duration::seconds(-1));
    }

    #[test]
    fn saturating_add_max() {
        assert_eq!(Duration::seconds_f32(1.0).saturating_add(Duration::MAX), Duration::MAX);
    }

    #[test]
    fn saturating_sub_min() {
        assert_eq!(Duration::seconds_f32(1.0).saturating_sub(Duration::MIN), Duration::MIN.saturating_add(Duration::seconds(1)));
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_zero_seconds_f64() {
        assert_eq!(
            Duration::seconds_f64(0.0),
            Duration {
                seconds: 0,
                nanoseconds: 0,
                padding: Padding::Optimize,
            }
        );
    }

    #[test]
    fn test_positive_seconds_f64() {
        assert_eq!(
            Duration::seconds_f64(2.7),
            Duration {
                seconds: 2,
                nanoseconds: 700_000_000,
                padding: Padding::Optimize,
            }
        );
    }

    #[test]
    fn test_negative_seconds_f64() {
        assert_eq!(
            Duration::seconds_f64(-2.7),
            Duration {
                seconds: -2,
                nanoseconds: -700_000_000,
                padding: Padding::Optimize,
            }
        );
    }

    #[test]
    fn test_subsecond_positive_seconds_f64() {
        assert_eq!(
            Duration::seconds_f64(0.000_000_123),
            Duration {
                seconds: 0,
                nanoseconds: 123,
                padding: Padding::Optimize,
            }
        );
    }

    #[test]
    fn test_subsecond_negative_seconds_f64() {
        assert_eq!(
            Duration::seconds_f64(-0.000_000_123),
            Duration {
                seconds: 0,
                nanoseconds: -123,
                padding: Padding::Optimize,
            }
        );
    }

    #[test]
    fn test_large_number_seconds_f64() {
        assert_eq!(
            Duration::seconds_f64(1e10),
            Duration {
                seconds: 10_000_000_000,
                nanoseconds: 0,
                padding: Padding::Optimize,
            }
        );
    }

    #[test]
    fn test_small_number_seconds_f64() {
        assert_eq!(
            Duration::seconds_f64(1e-10),
            Duration {
                seconds: 0,
                nanoseconds: 0,
                padding: Padding::Optimize,
            }
        );
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn test_overflow_seconds_f64() {
        let _ = Duration::seconds_f64(f64::MAX);
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn test_underflow_seconds_f64() {
        let _ = Duration::seconds_f64(f64::MIN);
    }

    #[test]
    #[should_panic(expected = "passed NaN to `crate::Duration::seconds_f64`")]
    fn test_nan_seconds_f64() {
        let _ = Duration::seconds_f64(f64::NAN);
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn subsec_microseconds() {
        // Using constructors explicitly to provide seconds and nanoseconds for the tests

        // Edge case with 0 microseconds
        assert_eq!(Duration::seconds(5).subsec_microseconds(), 0);

        // Edge case with just 1 nanosecond more than a full second
        assert_eq!(
            Duration::new(5, 1).subsec_microseconds(),
            0 // since 1 nanosecond is less than 1 microsecond
        );

        // Normal case, more than 1 microsecond
        assert_eq!(
            Duration::new(5, 1_500).subsec_microseconds(),
            1 // 1_500 nanoseconds is 1 microsecond
        );
        
        // Normal case, negative duration
        assert_eq!(
            Duration::new(-5, -1_500).subsec_microseconds(),
            -1 // -1_500 nanoseconds is -1 microsecond
        );

        // Edge case with exactly -1_000_000 nanoseconds
        assert_eq!(
            Duration::new(-1, 0).subsec_microseconds(),
            0 // since we subtract full seconds, the microseconds part is 0
        );

        // Normal case, microseconds without full second
        assert_eq!(
            Duration::new(0, 1_000_000).subsec_microseconds(),
            1_000 // 1_000_000 nanoseconds is 1_000 microseconds
        );

        // Normal case, negative microseconds without full second
        assert_eq!(
            Duration::new(0, -1_000_000).subsec_microseconds(),
            -1_000 // -1_000_000 nanoseconds is -1_000 microseconds
        );

        // Checks for overflow (none should happen here)
        assert_eq!(
            Duration::new(i64::MIN, 0).subsec_microseconds(),
            0 // since we're at the min number of seconds, microsecond part is 0
        );
        assert_eq!(
            Duration::new(i64::MAX, 999_999_999).subsec_microseconds(),
            999_999 // 999_999_999 nanoseconds is 999_999 microseconds
        );
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn test_subsec_milliseconds() {
        assert_eq!(Duration::milliseconds(1500).subsec_milliseconds(), 500);
        assert_eq!(Duration::milliseconds(1000).subsec_milliseconds(), 0);
        assert_eq!(Duration::milliseconds(-1500).subsec_milliseconds(), -500);
        assert_eq!(Duration::milliseconds(-1000).subsec_milliseconds(), 0);
        assert_eq!(Duration::seconds(1).subsec_milliseconds(), 0);
        assert_eq!(Duration::seconds(-1).subsec_milliseconds(), 0);
        assert_eq!(Duration::milliseconds(500).subsec_milliseconds(), 500);
        assert_eq!(Duration::milliseconds(-500).subsec_milliseconds(), -500);
        assert_eq!(Duration::nanoseconds(1_500_000).subsec_milliseconds(), 500);
        assert_eq!(Duration::nanoseconds(-1_500_000).subsec_milliseconds(), -500);
    }
}
True
========================================
    use crate::Duration;
    use core::crate::Duration as StdDuration;

    #[test]
    fn subsec_nanoseconds_positive_duration() {
        let duration = Duration::new(5, 300);
        assert_eq!(duration.subsec_nanoseconds(), 300);
    }

    #[test]
    fn subsec_nanoseconds_negative_duration() {
        let duration = Duration::new(-5, -300);
        assert_eq!(duration.subsec_nanoseconds(), -300);
    }

    #[test]
    fn subsec_nanoseconds_zero_duration() {
        let duration = Duration::new(0, 0);
        assert_eq!(duration.subsec_nanoseconds(), 0);
    }

    #[test]
    fn subsec_nanoseconds_positive_duration_exceeding_nanos() {
        let duration = Duration::new(5, 1_500_000_000);
        assert_eq!(duration.subsec_nanoseconds(), 500_000_000);
    }

    #[test]
    fn subsec_nanoseconds_negative_duration_exceeding_nanos() {
        let duration = Duration::new(-5, -1_500_000_000);
        assert_eq!(duration.subsec_nanoseconds(), -500_000_000);
    }

    #[test]
    fn subsec_nanoseconds_std_duration() {
        let duration = Duration::new(5, 1);
        let std_duration = StdDuration::new(5, 1);
        assert_eq!(duration.subsec_nanoseconds() as u32, std_duration.subsec_nanos());
    }

    #[test]
    fn subsec_nanoseconds_maximum_nanos() {
        let duration = Duration::new(0, 999_999_999);
        assert_eq!(duration.subsec_nanoseconds(), 999_999_999);
    }

    #[test]
    fn subsec_nanoseconds_negative_maximum_nanos() {
        let duration = Duration::new(0, -999_999_999);
        assert_eq!(duration.subsec_nanoseconds(), -999_999_999);
    }

    #[test]
    fn subsec_nanoseconds_rollover() {
        let duration = Duration::new(5, 1_000_000_000);
        assert_eq!(duration.subsec_nanoseconds(), 0);
    }

    #[test]
    fn subsec_nanoseconds_negative_rollover() {
        let duration = Duration::new(-5, -1_000_000_000);
        assert_eq!(duration.subsec_nanoseconds(), 0);
    }
}
False
========================================
    use crate::Duration;
    use std::thread;
    use std::crate::{Duration as StdDuration, Instant};

    #[test]
    #[cfg(feature = "std")]
    fn test_time_fn() {
        // Test with an empty closure; should have minimal execution time
        let (duration, ()) = Duration::time_fn(|| {});
        assert!(duration.is_positive());

        // Test with an actual delay
        let delay = StdDuration::from_millis(100);
        let (duration, ()) = Duration::time_fn(|| {
            thread::sleep(delay);
        });
        assert!(duration.is_positive());
        // Due to OS scheduling, the actual time slept may be longer than the delay
        assert!(Duration::from(delay) <= duration);
    }

    // Helper function to convert std::crate::Duration to crate::Duration
    impl From<StdDuration> for Duration {
        fn from(duration: StdDuration) -> Self {
            Duration::new(duration.as_secs() as i64, duration.subsec_nanos() as i32)
        }
    }
}
False
========================================
    use crate::Duration;
    use std::crate::Duration as StdDuration;
    use std::convert::TryInto;

    #[test]
    fn unsigned_abs_positive() {
        let duration = Duration::new(5, 0);
        let expected = StdDuration::new(5, 0);
        assert_eq!(duration.unsigned_abs(), expected);
    }

    #[test]
    fn unsigned_abs_negative() {
        let duration = Duration::new(-5, 0);
        let expected = StdDuration::new(5, 0);
        assert_eq!(duration.unsigned_abs(), expected);
    }

    #[test]
    fn unsigned_abs_positive_with_nanos() {
        let duration = Duration::new(0, 500_000_000);
        let expected = StdDuration::new(0, 500_000_000);
        assert_eq!(duration.unsigned_abs(), expected);
    }

    #[test]
    fn unsigned_abs_negative_with_nanos() {
        let duration = Duration::new(0, -500_000_000);
        let expected = StdDuration::new(0, 500_000_000);
        assert_eq!(duration.unsigned_abs(), expected);
    }

    #[test]
    fn unsigned_abs_edge_case() {
        let duration = Duration::new(i64::MIN, -999_999_999);
        let expected = StdDuration::new(i64::MAX as u64 + 1, 999_999_999);
        assert_eq!(duration.unsigned_abs(), expected);
    }

    #[test]
    fn unsigned_abs_edge_case_nanos_overflow() {
        let duration = Duration::new(-1, -1_000_000_000);
        let expected = StdDuration::new(1, 0);
        assert_eq!(duration.unsigned_abs(), expected);
    }

    #[test]
    fn unsigned_abs_zero() {
        let duration = Duration::new(0, 0);
        let expected = StdDuration::new(0, 0);
        assert_eq!(duration.unsigned_abs(), expected);
    }

    #[test]
    #[should_panic] // this is expected to panic due to overflow
    fn unsigned_abs_conversion_overflow() {
        let duration = Duration::new(i64::MAX, 999_999_999);
        let std_duration: StdDuration = duration.unsigned_abs();
        // This assertion is expected to panic, as converting Duration::MAX to std::crate::Duration is not possible
        assert_eq!(StdDuration::try_from(duration).unwrap(), std_duration);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_weeks_positive() {
        assert_eq!(Duration::weeks(1), Duration::seconds(604_800));
        assert_eq!(Duration::weeks(2), Duration::seconds(2 * 604_800));
        assert_eq!(Duration::weeks(52), Duration::seconds(52 * 604_800));
    }

    #[test]
    fn test_weeks_zero() {
        assert_eq!(Duration::weeks(0), Duration::seconds(0));
    }

    #[test]
    fn test_weeks_negative() {
        assert_eq!(Duration::weeks(-1), Duration::seconds(-604_800));
        assert_eq!(Duration::weeks(-2), Duration::seconds(-2 * 604_800));
        assert_eq!(Duration::weeks(-52), Duration::seconds(-52 * 604_800));
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn test_weeks_overflow_positive() {
        let _ = Duration::weeks(i64::MAX);
    }

    #[test]
    #[should_panic(expected = "overflow constructing `crate::Duration`")]
    fn test_weeks_overflow_negative() {
        let _ = Duration::weeks(i64::MIN);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn test_whole_days() {
        // Test positive durations
        assert_eq!(Duration::days(1).whole_days(), 1);
        assert_eq!(Duration::hours(24).whole_days(), 1);
        assert_eq!(Duration::hours(48).whole_days(), 2);
        assert_eq!(Duration::hours(25).whole_days(), 1);
        assert_eq!(Duration::hours(23).whole_days(), 0);
        assert_eq!(Duration::minutes(1440).whole_days(), 1);
        assert_eq!(Duration::minutes(2880).whole_days(), 2);
        assert_eq!(Duration::minutes(1500).whole_days(), 1);
        assert_eq!(Duration::minutes(1439).whole_days(), 0);
        assert_eq!(Duration::seconds(86400).whole_days(), 1);
        assert_eq!(Duration::seconds(172800).whole_days(), 2);
        assert_eq!(Duration::seconds(86500).whole_days(), 1);
        assert_eq!(Duration::seconds(86399).whole_days(), 0);

        // Test negative durations
        assert_eq!(Duration::days(-1).whole_days(), -1);
        assert_eq!(Duration::hours(-24).whole_days(), -1);
        assert_eq!(Duration::hours(-48).whole_days(), -2);
        assert_eq!(Duration::hours(-25).whole_days(), -1);
        assert_eq!(Duration::hours(-23).whole_days(), 0);
        assert_eq!(Duration::minutes(-1440).whole_days(), -1);
        assert_eq!(Duration::minutes(-2880).whole_days(), -2);
        assert_eq!(Duration::minutes(-1500).whole_days(), -1);
        assert_eq!(Duration::minutes(-1439).whole_days(), 0);
        assert_eq!(Duration::seconds(-86400).whole_days(), -1);
        assert_eq!(Duration::seconds(-172800).whole_days(), -2);
        assert_eq!(Duration::seconds(-86500).whole_days(), -1);
        assert_eq!(Duration::seconds(-86399).whole_days(), 0);

        // Test edge cases
        assert_eq!(Duration::MIN.whole_days(), i64::MIN);
        assert_eq!(Duration::MAX.whole_days(), i64::MAX);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn whole_hours_zero() {
        assert_eq!(Duration::ZERO.whole_hours(), 0);
    }

    #[test]
    fn whole_hours_single() {
        assert_eq!(Duration::HOUR.whole_hours(), 1);
        assert_eq!((-Duration::HOUR).whole_hours(), -1);
    }

    #[test]
    fn whole_hours_multiple() {
        assert_eq!(Duration::hours(24).whole_hours(), 24);
        assert_eq!(Duration::hours(-24).whole_hours(), -24);
    }

    #[test]
    fn whole_hours_partially() {
        assert_eq!(Duration::minutes(90).whole_hours(), 1);
        assert_eq!(Duration::minutes(-90).whole_hours(), -1);
        assert_eq!(Duration::minutes(150).whole_hours(), 2);
        assert_eq!(Duration::minutes(-150).whole_hours(), -2);
    }

    #[test]
    fn whole_hours_limits() {
        assert_eq!(Duration::MIN.whole_hours(), i64::MIN);
        assert_eq!(Duration::MAX.whole_hours(), i64::MAX);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn whole_microseconds_zero() {
        assert_eq!(Duration::ZERO.whole_microseconds(), 0);
    }

    #[test]
    fn whole_microseconds_one_second() {
        assert_eq!(Duration::SECOND.whole_microseconds(), 1_000_000);
    }

    #[test]
    fn whole_microseconds_minus_one_second() {
        assert_eq!(Duration::seconds(-1).whole_microseconds(), -1_000_000);
    }

    #[test]
    fn whole_microseconds_one_microsecond() {
        assert_eq!(Duration::MICROSECOND.whole_microseconds(), 1);
    }

    #[test]
    fn whole_microseconds_minus_one_microsecond() {
        assert_eq!(Duration::microseconds(-1).whole_microseconds(), -1);
    }

    #[test]
    fn whole_microseconds_max_value() {
        assert_eq!(Duration::MAX.whole_microseconds(), i128::MAX);
    }

    #[test]
    fn whole_microseconds_min_value() {
        assert_eq!(Duration::MIN.whole_microseconds(), i128::MIN + 1);
    }
}
True
========================================
    use crate::duration::Duration;

    #[test]
    fn whole_milliseconds_zero_duration() {
        assert_eq!(Duration::ZERO.whole_milliseconds(), 0);
    }

    #[test]
    fn whole_milliseconds_one_second() {
        assert_eq!(Duration::seconds(1).whole_milliseconds(), 1_000);
    }

    #[test]
    fn whole_milliseconds_minus_one_second() {
        assert_eq!(Duration::seconds(-1).whole_milliseconds(), -1_000);
    }

    #[test]
    fn whole_milliseconds_one_millisecond() {
        assert_eq!(Duration::milliseconds(1).whole_milliseconds(), 1);
    }

    #[test]
    fn whole_milliseconds_minus_one_millisecond() {
        assert_eq!(Duration::milliseconds(-1).whole_milliseconds(), -1);
    }

    #[test]
    fn whole_milliseconds_one_hour() {
        assert_eq!(Duration::hours(1).whole_milliseconds(), 3_600_000);
    }

    #[test]
    fn whole_milliseconds_one_nano() {
        assert_eq!(Duration::nanoseconds(1_000_000).whole_milliseconds(), 1);
    }

    #[test]
    fn whole_milliseconds_complex() {
        let duration = Duration::new(5, 750_000_000); // 5.75 seconds
        assert_eq!(duration.whole_milliseconds(), 5_750);
    }

    #[test]
    fn whole_milliseconds_max() {
        assert_eq!(Duration::MAX.whole_milliseconds(), i128::MAX);
    }

    #[test]
    fn whole_milliseconds_min() {
        assert_eq!(Duration::MIN.whole_milliseconds(), i128::MIN);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_whole_minutes() {
        use crate::duration::Duration;

        assert_eq!(Duration::minutes(1).whole_minutes(), 1);
        assert_eq!(Duration::minutes(-1).whole_minutes(), -1);
        assert_eq!(Duration::seconds(59).whole_minutes(), 0);
        assert_eq!(Duration::seconds(-59).whole_minutes(), 0);
        assert_eq!(Duration::hours(1).whole_minutes(), 60);
        assert_eq!(Duration::hours(-1).whole_minutes(), -60);
        assert_eq!(Duration::seconds(120).whole_minutes(), 2);
        assert_eq!(Duration::milliseconds(60_000).whole_minutes(), 1);
        assert_eq!(Duration::milliseconds(-60_000).whole_minutes(), -1);
        assert_eq!(Duration::ZERO.whole_minutes(), 0);
    }
}
True
========================================
    use crate::Duration; // Make sure this path is correct according to the module hierarchy

    #[test]
    fn whole_nanoseconds() {
        // Given a Duration of 1 second + 500 milliseconds (1_500_000_000 nanoseconds)
        let duration = Duration::new(1, 500_000_000);
        // When getting the whole nanoseconds
        let nanoseconds = duration.whole_nanoseconds();
        // Then the nanoseconds should be 1_500_000_000
        assert_eq!(nanoseconds, 1_500_000_000);

        // Given a Duration of -1 second - 500 milliseconds (-1_500_000_000 nanoseconds)
        let duration = Duration::new(-1, -500_000_000);
        // When getting the whole nanoseconds
        let nanoseconds = duration.whole_nanoseconds();
        // Then the nanoseconds should be -1_500_000_000
        assert_eq!(nanoseconds, -1_500_000_000);

        // Given a Duration of 0 seconds + 1 nanosecond (1 nanoseconds)
        let duration = Duration::new(0, 1);
        // When getting the whole nanoseconds
        let nanoseconds = duration.whole_nanoseconds();
        // Then the nanoseconds should be 1
        assert_eq!(nanoseconds, 1);

        // Given a Duration of 0 seconds - 1 nanosecond (-1 nanoseconds)
        let duration = Duration::new(0, -1);
        // When getting the whole nanoseconds
        let nanoseconds = duration.whole_nanoseconds();
        // Then the nanoseconds should be -1
        assert_eq!(nanoseconds, -1);

        // Given a Duration of 2 seconds + 0 nanoseconds (2_000_000_000 nanoseconds)
        let duration = Duration::new(2, 0);
        // When getting the whole nanoseconds
        let nanoseconds = duration.whole_nanoseconds();
        // Then the nanoseconds should be 2_000_000_000
        assert_eq!(nanoseconds, 2_000_000_000);

        // Given a Duration of 2 seconds - 1_000_000_000 nanoseconds (1_000_000_000 nanoseconds)
        let duration = Duration::new(2, -1_000_000_000);
        // When getting the whole nanoseconds
        let nanoseconds = duration.whole_nanoseconds();
        // Then the nanoseconds should be 1_000_000_000
        assert_eq!(nanoseconds, 1_000_000_000);

        // Given a Duration of i64::MAX seconds + 0 nanoseconds
        let duration = Duration::new(i64::MAX, 0);
        // When getting the whole nanoseconds
        let nanoseconds = duration.whole_nanoseconds();
        // Then the nanoseconds should be i64::MAX * 1_000_000_000
        assert_eq!(nanoseconds, i64::MAX as i128 * 1_000_000_000);

        // Given a Duration of i64::MIN seconds - 0 nanoseconds
        let duration = Duration::new(i64::MIN, 0);
        // When getting the whole nanoseconds
        let nanoseconds = duration.whole_nanoseconds();
        // Then the nanoseconds should be i64::MIN * 1_000_000_000
        assert_eq!(nanoseconds, i64::MIN as i128 * 1_000_000_000);
    }
}
True
========================================
    use crate::Duration;

    #[test]
    fn test_whole_seconds() {
        assert_eq!(Duration::seconds(1).whole_seconds(), 1);
        assert_eq!(Duration::seconds(-1).whole_seconds(), -1);
        assert_eq!(Duration::minutes(1).whole_seconds(), 60);
        assert_eq!(Duration::minutes(-1).whole_seconds(), -60);
        assert_eq!(Duration::hours(1).whole_seconds(), 3_600);
        assert_eq!(Duration::hours(-1).whole_seconds(), -3_600);
        assert_eq!(Duration::days(1).whole_seconds(), 86_400);
        assert_eq!(Duration::days(-1).whole_seconds(), -86_400);
        assert_eq!(Duration::weeks(1).whole_seconds(), 604_800);
        assert_eq!(Duration::weeks(-1).whole_seconds(), -604_800);
        assert_eq!(Duration::new(1, 500_000_000).whole_seconds(), 1);
        assert_eq!(Duration::new(-1, -500_000_000).whole_seconds(), -1);
        assert_eq!(Duration::new(1, 1_000_000_000).whole_seconds(), 2);
        assert_eq!(Duration::new(-1, -1_000_000_000).whole_seconds(), -2);
        assert_eq!(Duration::new(1, -500_000_000).whole_seconds(), 0);
        assert_eq!(Duration::new(-1, 500_000_000).whole_seconds(), 0);
        assert_eq!(Duration::ZERO.whole_seconds(), 0);
        assert_eq!(Duration::MIN.whole_seconds(), i64::MIN);
        assert_eq!(Duration::MAX.whole_seconds(), i64::MAX);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;

    #[test]
    fn whole_weeks_zero() {
        assert_eq!(Duration::ZERO.whole_weeks(), 0);
    }

    #[test]
    fn whole_weeks_single_week() {
        assert_eq!(Duration::WEEK.whole_weeks(), 1);
        assert_eq!((-Duration::WEEK).whole_weeks(), -1);
    }

    #[test]
    fn whole_weeks_multiple_weeks() {
        assert_eq!(Duration::WEEK.whole_weeks() * 7, 7);
        assert_eq!((-Duration::WEEK).whole_weeks() * 7, -7);
    }

    #[test]
    fn whole_weeks_days() {
        assert_eq!(Duration::DAY.whole_weeks(), 0);
        assert_eq!((-Duration::DAY).whole_weeks(), 0);
    }

    #[test]
    fn whole_weeks_days_multiple() {
        assert_eq!(Duration::DAY.whole_weeks() * 6, 0);
        assert_eq!((-Duration::DAY).whole_weeks() * 6, 0);
    }

    #[test]
    fn whole_weeks_less_than_week() {
        assert_eq!(6.days().whole_weeks(), 0);
        assert_eq!((-6).days().whole_weeks(), 0);
    }

    #[test]
    fn whole_weeks_more_than_week() {
        assert_eq!(8.days().whole_weeks(), 1);
        assert_eq!((-8).days().whole_weeks(), -1);
    }

    #[test]
    fn whole_weeks_mixed() {
        assert_eq!((1.weeks() + 6.days()).whole_weeks(), 1);
        assert_eq!((1.weeks() - 6.days()).whole_weeks(), 0);
    }

    #[test]
    fn whole_weeks_extremes() {
        assert_eq!(Duration::MIN.whole_weeks(), Duration::MIN.whole_seconds() / 604800);
        assert_eq!(Duration::MAX.whole_weeks(), Duration::MAX.whole_seconds() / 604800);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_component_range_from() {
        let component_range = ComponentRange {
            name: "test_component",
            minimum: 0,
            maximum: 10,
            value: 11,
            conditional_range: false,
        };

        let error = Error::from(component_range);

        match error {
            Error::ComponentRange(cr) => {
                assert_eq!(cr.name(), "test_component");
                assert_eq!(cr.is_conditional(), false);
            }
            _ => panic!("Error converted to incorrect variant"),
        }
    }
}
True
========================================
    use crate::ComponentRange;

    #[test]
    fn test_is_conditional_true() {
        let component = ComponentRange {
            name: "test_component",
            minimum: 1,
            maximum: 10,
            value: 5,
            conditional_range: true,
        };
        assert!(component.is_conditional());
    }

    #[test]
    fn test_is_conditional_false() {
        let component = ComponentRange {
            name: "test_component",
            minimum: 1,
            maximum: 10,
            value: 5,
            conditional_range: false,
        };
        assert!(!component.is_conditional());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::component_range::ComponentRange;

    #[test]
    fn test_component_range_name() {
        let component_range = ComponentRange {
            name: "year",
            minimum: 1,
            maximum: 9999,
            value: 2023,
            conditional_range: false,
        };

        assert_eq!(component_range.name(), "year");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::conversion_range::ConversionRange;
    use crate::error::Error;

    #[test]
    fn test_conversion_range_from() {
        let conversion_range_error = ConversionRange;
        let error: Error = conversion_range_error.into();
        match error {
            Error::ConversionRange(_) => (),
            _ => panic!("Error::from did not convert to Error::ConversionRange"),
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::{DifferentVariant, Error};

    #[test]
    fn from_different_variant() {
        let different_variant_err = DifferentVariant;
        let error: Error = Error::from(different_variant_err);

        match error {
            Error::DifferentVariant(dv) => assert!(true, "Correct variant wrapped in Error"),
            _ => assert!(false, "Incorrect variant wrapped in Error"),
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::Error;
    use crate::error::invalid_variant::InvalidVariant;

    #[test]
    fn test_from_invalid_variant() {
        let invalid_variant = InvalidVariant;
        let error: Error = Error::from(invalid_variant);
        match error {
            Error::InvalidVariant(_) => {}
            _ => panic!("Error::from did not convert to Error::InvalidVariant variant"),
        }
    }
}
True
========================================
    use crate::expect_failed;

    #[test]
    #[should_panic(expected = "Expected panic message")]
    fn test_expect_failed_with_specific_message() {
        expect_failed("Expected panic message");
    }

    #[test]
    #[should_panic]
    fn test_expect_failed_with_any_message() {
        expect_failed("This will panic");
    }
}
True
========================================
    use crate::Instant;
    use std::crate::{Duration as StdDuration, Instant as StdInstant};

    #[test]
    fn eq_with_std_instant() {
        let std_instant_now = StdInstant::now();
        let my_instant_now = Instant::from(std_instant_now);

        assert!(my_instant_now.eq(&std_instant_now));
    }

    #[test]
    fn eq_with_instant() {
        let std_instant_now = StdInstant::now();
        let my_instant_now = Instant::from(std_instant_now);
        let std_instant_later = std_instant_now + StdDuration::from_secs(1);
        let my_instant_later = Instant::from(std_instant_later);

        assert!(my_instant_now.eq(&my_instant_now));
        assert!(!my_instant_now.eq(&my_instant_later));
    }

    #[test]
    fn eq_with_instant_elapsed() {
        let my_instant_now = Instant::now();
        std::thread::sleep(StdDuration::from_millis(1));
        let my_instant_later = Instant::now();

        assert!(my_instant_now.eq(&my_instant_now));
        assert!(!my_instant_now.eq(&my_instant_later));
    }
}
False
========================================
    use std::crate::Instant as StdInstant;
    use std::cmp::Ordering;
    use crate::Instant;
    use crate::Duration;

    #[test]
    fn partial_cmp_equal() {
        let t1 = StdInstant::now();
        let t2 = Instant::from(t1);
        assert_eq!(t1.partial_cmp(&t2), Some(Ordering::Equal));
        assert_eq!(t2.partial_cmp(&t1), Some(Ordering::Equal));
    }

    #[test]
    fn partial_cmp_less() {
        let t1 = StdInstant::now();
        let t2 = Instant::from(t1) + Duration::seconds(1); // 1 second
        assert_eq!(t1.partial_cmp(&t2), Some(Ordering::Less));
    }

    #[test]
    fn partial_cmp_greater() {
        let t1 = StdInstant::now();
        let t2 = Instant::from(t1) + Duration::seconds(1); // 1 second
        let t3 = StdInstant::from(t2);
        assert_eq!(t3.partial_cmp(&t1), Some(Ordering::Greater));
    }
}
False
========================================
    use crate::Instant;
    use std::crate::{Duration as StdDuration, Instant as StdInstant};

    #[test]
    fn test_instant_from() {
        let std_instant = StdInstant::now();
        let custom_instant = Instant::from(std_instant);
        
        // Custom instant should equal std instant when converted back
        let converted_std_instant: StdInstant = std_instant.into();
        assert_eq!(std_instant, converted_std_instant);
        
        // It should also be equal when compared as references
        assert_eq!(custom_instant.as_ref(), &std_instant);
        
        // Adding a StdDuration should be same for both instants
        let std_duration = StdDuration::from_millis(100);
        let added_std_instant = std_instant + std_duration;
        let added_custom_instant = custom_instant + std_duration;
        let converted_added_std_instant: StdInstant = added_custom_instant.into();
        assert_eq!(added_std_instant, converted_added_std_instant);
        
        // Subtracting a StdDuration should be same for both instants
        let sub_std_instant = std_instant - std_duration;
        let sub_custom_instant = custom_instant - std_duration;
        let converted_sub_std_instant: StdInstant = sub_custom_instant.into();
        assert_eq!(sub_std_instant, converted_sub_std_instant);
    }
}
False
========================================
    use std::crate::{Duration as StdDuration, Instant as StdInstant};
    use crate::{Duration, ext::NumericalDuration, Instant};

    #[test]
    fn test_add_duration() {
        let std_instant = StdInstant::now();
        let duration = 5.seconds();

        let result = Instant(std_instant) + duration;

        // Convert back to StdInstant to compare
        let std_result = StdInstant::from(result);
        let expected = std_instant + StdDuration::from(duration);

        assert!(std_result.duration_since(std_instant) >= StdDuration::from(duration));
        assert_eq!(std_result, expected);
    }

    #[test]
    fn test_add_zero_duration() {
        let std_instant = StdInstant::now();
        let result = Instant(std_instant) + Duration::ZERO;

        let std_result = StdInstant::from(result);
        assert_eq!(std_result, std_instant);
    }

    #[test]
    fn test_add_negative_duration() {
        let std_instant = StdInstant::now();
        let duration = (-5).seconds();

        let result = Instant(std_instant) + duration;

        let std_result = StdInstant::from(result);
        let expected = std_instant + StdDuration::from(duration);

        assert!(std_result.duration_since(std_instant) >= StdDuration::from(duration));
        assert_eq!(std_result, expected);
    }
    
    #[test]
    #[should_panic(expected = "overflow when adding durations")]
    fn test_add_duration_overflow() {
        let std_instant = StdInstant::now();

        // Create a duration that would overflow when added to the instant
        let duration = Duration::new(i64::MAX, 0) + 1.seconds();

        // This should panic due to overflow
        let _ = Instant(std_instant) + duration;
    }
}
False
========================================
    use std::crate::{Duration as StdDuration, Instant as StdInstant};
    use crate::Duration; // Assuming the crate is named `time`

    #[test]
    fn add_assign_duration_to_instant() {
        let mut instant = StdInstant::now();
        let original_instant = instant;
        let duration = Duration::seconds(5);
        // Convert `crate::Duration` to `std::crate::Duration` for the `add_assign`
        let std_duration = StdDuration::new(5, 0);
        instant += std_duration;
        let elapsed = instant.duration_since(original_instant);
        assert_eq!(elapsed, std_duration);
    }
}
False
========================================
    use crate::Instant;
    use crate::Duration;
    use std::crate::Instant as StdInstant;

    #[test]
    fn subtract_duration_from_instant() {
        let duration = Duration::new(5, 0); // 5 seconds
        let std_instant = StdInstant::now();
        let wrapped_instant = Instant(std_instant);
        let new_instant = wrapped_instant - duration;

        // new_instant should represent a point in time 5 seconds earlier than std_instant
        let expected_std_instant = std_instant - std::crate::Duration::new(5, 0);
        assert_eq!(new_instant.0, expected_std_instant);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::{Instant as StdInstant, Duration as StdDuration};
    use crate::Duration;

    #[test]
    fn std_instant_sub_instant() {
        let std_instant1 = StdInstant::now();
        let std_instant2 = std_instant1 + StdDuration::from_secs(5);
        let instant1 = Instant::from(std_instant1);
        let instant2 = Instant::from(std_instant2);

        let duration = std_instant2 - instant1;
        assert_eq!(duration, Duration::seconds(5));

        let std_instant_result = std_instant1 - instant2;
        assert_eq!(std_instant_result, Duration::seconds(-5));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::{Duration as StdDuration, Instant as StdInstant};

    #[test]
    fn sub_assign_duration_from_instant() {
        let mut instant = StdInstant::now();
        let earlier_instant = instant - StdDuration::from_secs(5);
        let duration_to_sub = Duration::new(5, 0);
        instant -= duration_to_sub;
        assert_eq!(instant, earlier_instant);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Duration;
    use std::crate::Duration as StdDuration;

    #[test]
    fn checked_add_with_positive_duration() {
        let instant = Instant::now();
        let duration = Duration::seconds(5);
        assert_eq!(instant.checked_add(duration), Some(instant + duration));
    }

    #[test]
    fn checked_add_with_zero_duration() {
        let instant = Instant::now();
        let duration = Duration::ZERO;
        assert_eq!(instant.checked_add(duration), Some(instant));
    }

    #[test]
    fn checked_add_with_negative_duration() {
        let instant = Instant::now();
        let duration = Duration::seconds(-5);
        assert_eq!(instant.checked_add(duration), Some(instant + duration));
    }

    #[test]
    #[should_panic]
    fn checked_add_with_duration_exceeding_bounds() {
        let instant = Instant::now();
        let duration = Duration::new(i64::MAX, 0);
        let _ = instant.checked_add(duration).unwrap();
    }

    #[test]
    fn checked_add_with_max_duration() {
        let instant = Instant::now();
        let duration = Duration::MAX;
        assert_eq!(instant.checked_add(duration), None);
    }

    #[test]
    fn checked_add_with_min_duration() {
        let instant = Instant::now();
        let duration = Duration::MIN;
        assert_eq!(instant.checked_add(duration), None);
    }

    #[test]
    fn checked_add_with_std_duration() {
        let instant = Instant::now();
        let std_duration = StdDuration::from_secs(5);
        let duration = Duration::try_from(std_duration).unwrap();
        assert_eq!(instant.checked_add(duration), Some(instant + duration));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::duration::Duration;
    use crate::Instant;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_checked_sub_with_positive_duration() {
        let instant = Instant::now();
        let duration = Duration::new(5, 0); // 5 seconds
        assert_eq!(instant.checked_sub(duration), Some(instant - duration));
    }

    #[test]
    fn test_checked_sub_with_negative_duration() {
        let instant = Instant::now();
        let duration = Duration::new(-5, 0); // -5 seconds
        assert_eq!(instant.checked_sub(duration), Some(instant - duration));
    }

    #[test]
    fn test_checked_sub_with_zero_duration() {
        let instant = Instant::now();
        let duration = Duration::new(0, 0); // 0 seconds
        assert_eq!(instant.checked_sub(duration), Some(instant));
    }

    #[test]
    fn test_checked_sub_with_duration_just_outside_bounds() {
        let instant = Instant::from_std(StdDuration::new(0, 0)); // Use from_std instead
        let duration = Duration::MAX;
        assert_eq!(instant.checked_sub(duration), None);
    }

    #[test]
    fn test_checked_sub_with_duration_just_inside_bounds() {
        let instant = Instant::from_std(StdDuration::new(0, 0)); // Use from_std instead
        let one_second = Duration::new(1, 0); // 1 second
        let duration = Duration::MAX - one_second;
        assert_ne!(instant.checked_sub(duration), None);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Instant;
    use std::thread;
    use std::time as std_time;
    use crate::Duration;

    #[test]
    fn test_elapsed_positive_duration() {
        let instant = Instant::now();
        let duration = std_crate::Duration::from_millis(200);
        thread::sleep(duration);
        let elapsed = instant.elapsed();
        assert!(elapsed >= Duration::milliseconds(200));
    }

    #[test]
    fn test_elapsed_zero_duration() {
        let instant = Instant::now();
        let elapsed = instant.elapsed();
        assert!(elapsed >= Duration::ZERO);
    }

    #[test]
    fn test_elapsed_with_old_instant() {
        let instant = Instant(std_crate::Instant::now() - std_crate::Duration::from_secs(5));
        let elapsed = instant.elapsed();
        assert!(elapsed >= Duration::seconds(5));
    }
}
False
========================================
    use crate::Instant;
    use std::crate::Instant as StdInstant;

    #[test]
    fn test_instant_into_inner() {
        let instant = Instant::now();
        let std_instant: StdInstant = instant.into_inner();
        assert_eq!(std_instant, StdInstant::from(instant));
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::thread;
    use std::crate::{Duration as StdDuration, Instant as StdInstant};

    #[test]
    fn test_instant_now_elapsing() {
        let now = Instant::now();
        let std_now = StdInstant::now();
        thread::sleep(StdDuration::from_millis(100));
        let later = Instant::now();
        let std_later = StdInstant::now();

        // Ensure that the time has advanced
        assert!(later > now);
        assert!(std_later > std_now);

        // Check that the duration elapsed is at least the sleep duration
        assert!(later - now >= StdDuration::from_millis(100));
        assert!(std_later - std_now >= StdDuration::from_millis(100));
    }

    #[test]
    fn test_instant_now_consistency() {
        let now = Instant::now();
        let std_now = StdInstant::now();
        // The crate::Instant::now() should be close to StdInstant::now()
        assert!(now.into_inner().duration_since(std_now).as_micros() < 1000);
        assert!(std_now.duration_since(now.into_inner()).as_micros() < 1000);
    }
}
False
========================================
    use crate::Month;
    use std::convert::From;

    #[test]
    fn from_january() {
        let month_u8 = u8::from(Month::January);
        assert_eq!(month_u8, 1);
    }

    #[test]
    fn from_february() {
        let month_u8 = u8::from(Month::February);
        assert_eq!(month_u8, 2);
    }

    #[test]
    fn from_march() {
        let month_u8 = u8::from(Month::March);
        assert_eq!(month_u8, 3);
    }

    #[test]
    fn from_april() {
        let month_u8 = u8::from(Month::April);
        assert_eq!(month_u8, 4);
    }

    #[test]
    fn from_may() {
        let month_u8 = u8::from(Month::May);
        assert_eq!(month_u8, 5);
    }

    #[test]
    fn from_june() {
        let month_u8 = u8::from(Month::June);
        assert_eq!(month_u8, 6);
    }

    #[test]
    fn from_july() {
        let month_u8 = u8::from(Month::July);
        assert_eq!(month_u8, 7);
    }

    #[test]
    fn from_august() {
        let month_u8 = u8::from(Month::August);
        assert_eq!(month_u8, 8);
    }

    #[test]
    fn from_september() {
        let month_u8 = u8::from(Month::September);
        assert_eq!(month_u8, 9);
    }

    #[test]
    fn from_october() {
        let month_u8 = u8::from(Month::October);
        assert_eq!(month_u8, 10);
    }

    #[test]
    fn from_november() {
        let month_u8 = u8::from(Month::November);
        assert_eq!(month_u8, 11);
    }

    #[test]
    fn from_december() {
        let month_u8 = u8::from(Month::December);
        assert_eq!(month_u8, 12);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use core::num::NonZeroU8;
    use crate::Month::*;
    use crate::month;

    #[test]
    fn test_from_number_valid() {
        assert_eq!(month::Month::from_number(NonZeroU8::new(1).unwrap()), Ok(January));
        assert_eq!(month::Month::from_number(NonZeroU8::new(2).unwrap()), Ok(February));
        assert_eq!(month::Month::from_number(NonZeroU8::new(3).unwrap()), Ok(March));
        assert_eq!(month::Month::from_number(NonZeroU8::new(4).unwrap()), Ok(April));
        assert_eq!(month::Month::from_number(NonZeroU8::new(5).unwrap()), Ok(May));
        assert_eq!(month::Month::from_number(NonZeroU8::new(6).unwrap()), Ok(June));
        assert_eq!(month::Month::from_number(NonZeroU8::new(7).unwrap()), Ok(July));
        assert_eq!(month::Month::from_number(NonZeroU8::new(8).unwrap()), Ok(August));
        assert_eq!(month::Month::from_number(NonZeroU8::new(9).unwrap()), Ok(September));
        assert_eq!(month::Month::from_number(NonZeroU8::new(10).unwrap()), Ok(October));
        assert_eq!(month::Month::from_number(NonZeroU8::new(11).unwrap()), Ok(November));
        assert_eq!(month::Month::from_number(NonZeroU8::new(12).unwrap()), Ok(December));
    }

    #[test]
    fn test_from_number_invalid() {
        for value in [0_u8, 13, 255] {
            match NonZeroU8::new(value) {
                Some(non_zero_value) => {
                    assert!(matches!(
                        month::Month::from_number(non_zero_value),
                        Err(ComponentRange { name, minimum, maximum, value: _, conditional_range: false }) 
                        if name == "month" && minimum == 1 && maximum == 12
                    ));
                }
                None => assert!(value == 0, "Invalid test value: {}", value),
            }
        }
    }
}
True
========================================
    use crate::Month::*;
    use crate::month::Month;

    #[test]
    fn test_next_month() {
        assert_eq!(January.next(), February);
        assert_eq!(February.next(), March);
        assert_eq!(March.next(), April);
        assert_eq!(April.next(), May);
        assert_eq!(May.next(), June);
        assert_eq!(June.next(), July);
        assert_eq!(July.next(), August);
        assert_eq!(August.next(), September);
        assert_eq!(September.next(), October);
        assert_eq!(October.next(), November);
        assert_eq!(November.next(), December);
        assert_eq!(December.next(), January);
    }
}
True
========================================
    use crate::Month;

    #[test]
    fn previous_month() {
        assert_eq!(Month::January.previous(), Month::December);
        assert_eq!(Month::February.previous(), Month::January);
        assert_eq!(Month::March.previous(), Month::February);
        assert_eq!(Month::April.previous(), Month::March);
        assert_eq!(Month::May.previous(), Month::April);
        assert_eq!(Month::June.previous(), Month::May);
        assert_eq!(Month::July.previous(), Month::June);
        assert_eq!(Month::August.previous(), Month::July);
        assert_eq!(Month::September.previous(), Month::August);
        assert_eq!(Month::October.previous(), Month::September);
        assert_eq!(Month::November.previous(), Month::October);
        assert_eq!(Month::December.previous(), Month::November);
    }
}
True
========================================
    use crate::OffsetDateTime;
    use crate::macros::datetime;
    use std::crate::SystemTime;

    #[test]
    fn eq_with_offset_date_time() {
        let system_time = SystemTime::now();
        let offset_date_time = OffsetDateTime::from(system_time);
        assert!(system_time.eq(&offset_date_time));
    }

    #[test]
    fn eq_with_exact_offset_date_time() {
        let system_time = SystemTime::UNIX_EPOCH;
        let offset_date_time = datetime!(1970-01-01 0:00 UTC);
        assert!(system_time.eq(&offset_date_time));
    }

    #[test]
    fn neq_with_offset_date_time() {
        let system_time = SystemTime::UNIX_EPOCH;
        let offset_date_time = datetime!(1970-01-01 0:00:01 UTC);
        assert!(!system_time.eq(&offset_date_time));
    }

    #[test]
    fn eq_with_system_time() {
        let system_time = SystemTime::UNIX_EPOCH;
        let offset_date_time = OffsetDateTime::UNIX_EPOCH;
        assert!(offset_date_time.eq(&system_time));
    }

    #[test]
    fn neq_with_system_time() {
        let system_time = SystemTime::UNIX_EPOCH;
        let offset_date_time = OffsetDateTime::UNIX_EPOCH + crate::Duration::nanoseconds(1);
        assert!(!offset_date_time.eq(&system_time));
    }
}
False
========================================
    use crate::{Duration, OffsetDateTime, Time, UtcOffset};
    use std::cmp::Ordering;
    use std::crate::SystemTime;
    use crate::ext::NumericalDuration;

    #[test]
    fn partial_cmp_with_system_time() {
        assert_eq!(
            SystemTime::UNIX_EPOCH
                .partial_cmp(&OffsetDateTime::UNIX_EPOCH),
            Some(Ordering::Equal)
        );
        assert_eq!(
            SystemTime::UNIX_EPOCH
                .partial_cmp(&(OffsetDateTime::UNIX_EPOCH + 1.seconds())),
            Some(Ordering::Less)
        );
        assert_eq!(
            (SystemTime::UNIX_EPOCH + 1.seconds())
                .partial_cmp(&OffsetDateTime::UNIX_EPOCH),
            Some(Ordering::Greater)
        );

        let odt1 = OffsetDateTime::UNIX_EPOCH + 978_307_200.seconds(); // 2001-01-01 0:00 UTC
        let odt2 = OffsetDateTime::UNIX_EPOCH
            + 978_307_200.seconds()
            + 1.hours(); // 2001-01-01 0:00 +1

        assert_eq!(
            SystemTime::from(odt1)
                .partial_cmp(&odt2),
            Some(Ordering::Less)
        );
        assert_eq!(
            SystemTime::from(odt2)
                .partial_cmp(&odt1),
            Some(Ordering::Greater)
        );
    }
}
False
========================================
    use crate::OffsetDateTime;
    use std::crate::SystemTime;
    use crate::Duration;

    #[test]
    fn from_offset_date_time_to_system_time() {
        // Create a known `OffsetDateTime` instance.
        let odt = OffsetDateTime::UNIX_EPOCH + Duration::days(1) + Duration::hours(6) + Duration::minutes(30);

        // Convert it to a `SystemTime`.
        let system_time: SystemTime = odt.into();

        // Convert the `SystemTime` back to a `OffsetDateTime`.
        let odt_converted = OffsetDateTime::from(system_time);

        // Ensure the two `OffsetDateTime` objects are equal.
        assert_eq!(odt, odt_converted, "Conversion from `OffsetDateTime` to `SystemTime` and back should result in the original `OffsetDateTime`.");
    }
}
False
========================================
#[cfg(test)]
mod test_offset_date_time_sub_system_time {
    use crate::{OffsetDateTime, Duration};
    use std::crate::SystemTime;

    #[test]
    fn test_sub_system_time() {
        // Convert OffsetDateTime to SystemTime and vice versa
        let odt1 = OffsetDateTime::UNIX_EPOCH;
        let st1: SystemTime = odt1.into();
        let odt2 = OffsetDateTime::from(st1);

        // Subtract SystemTime from OffsetDateTime
        let duration = odt1 - OffsetDateTime::from(st1);

        assert_eq!(odt2, odt1, "Conversion between OffsetDateTime and SystemTime should be lossless");
        assert_eq!(duration, Duration::ZERO, "Subtracting the SystemTime from the equivalent OffsetDateTime should yield zero duration");
    }

    #[test]
    fn test_sub_system_time_with_offset() {
        use crate::macros::offset;

        // OffsetDateTime with non-zero offset
        let odt1 = OffsetDateTime::UNIX_EPOCH
            .to_offset(offset!(+1));
        
        // SystemTime equivalent to OffsetDateTime with non-zero offset
        let st1: SystemTime = odt1.into();
        
        // Subtract SystemTime from OffsetDateTime
        let duration = odt1 - OffsetDateTime::from(st1);

        assert_eq!(duration, Duration::ZERO, "Subtracting a SystemTime from an equivalent OffsetDateTime with a non-zero offset should yield zero duration");
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::{ext::NumericalDuration, Date, PrimitiveDateTime, UtcOffset};
    use time_macros::{datetime, offset};

    #[test]
    fn test_overflow_past_max() {
        let datetime = PrimitiveDateTime::new(Date::MAX, Time::MIDNIGHT).assume_offset(offset!(UTC));
        assert_eq!(datetime.checked_add(2.days()), None);
    }

    #[test]
    fn test_overflow_past_min() {
        let datetime = PrimitiveDateTime::new(Date::MIN, Time::MIDNIGHT).assume_offset(offset!(UTC));
        assert_eq!(datetime.checked_add((-2).days()), None);
    }

    #[test]
    fn test_valid_addition() {
        assert_eq!(
            datetime!(2019 - 11 - 25 15:30 UTC).checked_add(27.hours()),
            Some(datetime!(2019 - 11 - 26 18:30 UTC))
        );
    }
}
False
========================================
    use crate::{Duration, OffsetDateTime};
    use crate::ext::NumericalDuration;
    use crate::macros::{datetime, offset};

    #[test]
    fn checked_sub_duration_overflow_past_min() {
        let datetime = OffsetDateTime::MIN_UTC_DATETIME;
        assert_eq!(datetime.checked_sub(1.nanoseconds()), None);
    }

    #[test]
    fn checked_sub_duration_overflow_past_max() {
        let datetime = OffsetDateTime::MAX_UTC_DATETIME;
        assert_eq!(datetime.checked_sub((-1).nanoseconds()), None);
    }

    #[test]
    fn checked_sub_duration_no_overflow() {
        let datetime = datetime!(2019-11-25 15:30 +10);
        let duration = Duration::hours(27);
        assert_eq!(
            datetime.checked_sub(duration),
            Some(datetime!(2019-11-24 12:30 +10))
        );
    }
}
False
========================================
    use crate::offset_date_crate::OffsetDateTime;
    use crate::UtcOffset;
    use time_macros::{datetime, offset};

    #[test]
    fn utc_to_offset() {
        assert_eq!(
            datetime!(2000-01-01 0:00 UTC)
                .checked_to_offset(offset!(-1))
                .unwrap()
                .year(),
            1999,
        );
    }

    #[test]
    fn max_to_offset_none() {
        assert_eq!(
            OffsetDateTime::MAX.checked_to_offset(offset!(+1)),
            None
        );
    }

    #[test]
    fn utc_to_utc_no_change() {
        let utc_datetime = datetime!(2000-01-01 0:00 UTC);
        assert_eq!(utc_datetime.checked_to_offset(UtcOffset::UTC), Some(utc_datetime));
    }

    #[test]
    fn offset_to_offset_no_change() {
        let dt = datetime!(2000-01-01 0:00 -1);
        let offset = dt.offset();
        assert_eq!(dt.checked_to_offset(offset), Some(dt));
    }

    #[test]
    fn offset_to_offset_change() {
        let dt = datetime!(2000-01-01 0:00 -1);
        let new_dt = datetime!(2000-01-01 1:00 UTC);
        assert_eq!(dt.checked_to_offset(UtcOffset::UTC), Some(new_dt));
    }

    #[test]
    fn add_duration_utc() {
        let dt = datetime!(2000-01-01 0:00 UTC);
        let new_dt = dt - crate::Duration::hours(1);
        assert_eq!(dt.checked_to_offset(offset!(+1)), Some(new_dt));
    }

    #[test]
    fn sub_duration_offset() {
        let dt = datetime!(2000-01-01 1:00 UTC);
        let new_dt = dt + crate::Duration::hours(1);
        assert_eq!(dt.checked_to_offset(offset!(-1)), Some(new_dt));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::util;
    use crate::Date;
    use time_macros::{date, datetime, offset};

    #[test]
    fn date_utc() {
        assert_eq!(datetime!(2019-01-01 0:00 UTC).date(), date!(2019-01-01));
    }

    #[test]
    fn date_with_offset() {
        assert_eq!(
            datetime!(2019-01-01 0:00 UTC)
                .to_offset(offset!(-1))
                .date(),
            date!(2018-12-31)
        );
    }

    #[test]
    fn date_with_positive_offset() {
        assert_eq!(
            datetime!(2019-01-01 0:00 UTC)
                .to_offset(offset!(+3))
                .date(),
            date!(2019-01-01)
        );
    }

    #[test]
    fn date_with_large_offset() {
        assert_eq!(
            datetime!(2019-01-01 0:00 UTC)
                .to_offset(offset!(+12:45))
                .date(),
            date!(2019-01-01)
        );
    }
}
False
========================================
    // Assuming the `OffsetDateTime` and `PrimitiveDateTime` are re-exported publicly
    use crate::OffsetDateTime;
    use time_macros::datetime;

    #[test]
    fn test_day() {
        assert_eq!(datetime!(2019-01-01 0:00 UTC).day(), 1);
        assert_eq!(datetime!(2019-12-31 0:00 UTC).day(), 31);
        assert_eq!(datetime!(2020-02-29 0:00 UTC).day(), 29);
        assert_eq!(datetime!(2020-02-29 23:59:59 UTC).day(), 29);
    }
}
False
========================================
    use crate::error::{Error, ComponentRange};
    use crate::ext::NumericalDuration;
    use crate::{Duration, OffsetDateTime};
    use time_macros::{datetime};

    #[test]
    fn test_from_unix_timestamp_at_epoch() {
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(0),
            Ok(OffsetDateTime::UNIX_EPOCH)
        );
    }

    #[test]
    fn test_from_unix_timestamp_post_epoch() {
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1_546_300_800),
            Ok(datetime!(2019-01-01 0:00 UTC))
        );
    }

    #[test]
    fn test_from_unix_timestamp_nanoseconds() {
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1).unwrap() + Duration::nanoseconds(500_000_000),
            OffsetDateTime::UNIX_EPOCH + 1.5.seconds()
        );
    }

    #[test]
    fn test_from_unix_timestamp_pre_epoch() {
        assert!(OffsetDateTime::from_unix_timestamp(-1).is_ok());
    }

    #[test]
    fn test_from_unix_timestamp_out_of_range() {
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(i64::MAX),
            Err(Error::ComponentRange(ComponentRange::new()))
        );
    }
}
False
========================================
    use crate::{OffsetDateTime, error, Month};

    #[test]
    fn from_unix_timestamp_nanos_unix_epoch() {
        let epoch = OffsetDateTime::from_unix_timestamp_nanos(0);
        assert_eq!(epoch, Ok(OffsetDateTime::UNIX_EPOCH));
    }

    #[test]
    fn from_unix_timestamp_nanos_post_epoch() {
        let timestamp = 1_546_300_800_000_000_000i128;
        let datetime = OffsetDateTime::from_unix_timestamp_nanos(timestamp);
        assert!(datetime.is_ok());
        let datetime = datetime.unwrap();
        assert_eq!(datetime.year(), 2019);
        assert_eq!(datetime.month(), Month::January);
        assert_eq!(datetime.day(), 1);
        assert_eq!(datetime.hour(), 0);
        assert_eq!(datetime.minute(), 0);
        assert_eq!(datetime.second(), 0);
        assert_eq!(datetime.nanosecond(), 0);
        assert_eq!(datetime.offset().whole_hours(), 0);
    }

    #[test]
    fn from_unix_timestamp_nanos_pre_epoch() {
        let timestamp = -217_740_480_000_000_000i128;
        let datetime = OffsetDateTime::from_unix_timestamp_nanos(timestamp);
        assert!(datetime.is_ok());
        let datetime = datetime.unwrap();
        assert_eq!(datetime.year(), 1963);
        assert_eq!(datetime.month(), Month::November);
        assert_eq!(datetime.day(), 22);
        assert_eq!(datetime.hour(), 18);
        assert_eq!(datetime.minute(), 30);
        assert_eq!(datetime.second(), 0);
        assert_eq!(datetime.nanosecond(), 0);
        assert_eq!(datetime.offset().whole_hours(), 0);
    }

    #[test]
    fn from_unix_timestamp_nanos_invalid_date() {
        let timestamp = i128::MAX;
        let datetime = OffsetDateTime::from_unix_timestamp_nanos(timestamp);
        assert!(datetime.is_err());
        assert!(matches!(datetime, Err(error::ComponentRange { .. })));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::crate::Time;
    use crate::offset_date_crate::OffsetDateTime;
    use crate::UtcOffset;
    use time_macros::{date, time, datetime, offset};

    #[test]
    fn hour_getter() {
        // Check hour in UTC
        assert_eq!(OffsetDateTime::from_date_time(datetime!(2019-01-01 0:00), UtcOffset::UTC).hour(), 0);
        assert_eq!(OffsetDateTime::from_date_time(datetime!(2019-01-01 5:00), UtcOffset::UTC).hour(), 5);
        assert_eq!(OffsetDateTime::from_date_time(datetime!(2019-01-01 23:59:59), UtcOffset::UTC).hour(), 23);

        // Check hour in other offsets
        assert_eq!(
            OffsetDateTime::from_date_time(datetime!(2019-01-01 23:59:59), offset!(-2)).hour(),
            21
        );
        assert_eq!(
            OffsetDateTime::from_date_time(datetime!(2019-01-01 0:00), offset!(+2)).hour(),
            2
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::UtcOffset;
    use crate::OffsetDateTime;
    use crate::Date;
    use crate::Weekday;
    use crate::Month;
    use crate::Time;

    #[test]
    fn iso_week() {
        assert_eq!(OffsetDateTime::UNIX_EPOCH.iso_week(), 1);
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1_546_300_800).unwrap().iso_week(),
            1
        );
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1_577_836_799).unwrap().iso_week(),
            1
        );
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1_609_459_199).unwrap().iso_week(),
            53
        );
        assert_eq!(
            PrimitiveDateTime::new(Date::from_iso_week_date(2019, 1, Weekday::Monday).unwrap(), Time::MIDNIGHT)
                .assume_utc()
                .iso_week(),
            1
        );
        assert_eq!(
            PrimitiveDateTime::new(Date::from_iso_week_date(2019, 52, Weekday::Sunday).unwrap(), Time::MIDNIGHT)
                .assume_utc()
                .iso_week(),
            52
        );
        assert_eq!(
            PrimitiveDateTime::new(Date::from_iso_week_date(2020, 53, Weekday::Friday).unwrap(), Time::MIDNIGHT)
                .assume_utc()
                .iso_week(),
            53
        );
        assert_eq!(
            PrimitiveDateTime::new(Date::from_iso_week_date(2021, 53, Weekday::Friday).unwrap(), Time::MIDNIGHT)
                .assume_utc()
                .iso_week(),
            53
        );
    }

    // Additional test case: Check edge case of a date in December resulting in week 1 of the next year
    #[test]
    fn iso_week_in_december() {
        assert_eq!(
            PrimitiveDateTime::new(Date::from_calendar_date(2019, Month::December, 31).unwrap(), Time::MIDNIGHT)
                .assume_utc()
                .iso_week(),
            1
        );
    }
}
True
========================================
    use crate::OffsetDateTime; // Adjust the import path based on the actual crate structure.

    #[test]
    fn microsecond() {
        // Here, `datetime!` macro creates `OffsetDateTime` instances, and you can call `.microsecond()` on them.
        assert_eq!(OffsetDateTime::from_unix_timestamp(1_546_301_600).unwrap().microsecond(), 0); // 2019-01-01 0:00 UTC
        assert_eq!(OffsetDateTime::from_unix_timestamp(1_546_301_600).unwrap().microsecond(), 1); // 2019-01-01 0:00:00.000_001 UTC
        assert_eq!(OffsetDateTime::from_unix_timestamp(1_546_337_999_000_001_000).unwrap().microsecond(), 1); // 2019-01-01 23:59:59.000_001 UTC
        assert_eq!(OffsetDateTime::from_unix_timestamp(1_546_337_999_123_456_000).unwrap().microsecond(), 123_456); // 2019-01-01 23:59:59.123_456 UTC
        assert_eq!(OffsetDateTime::from_unix_timestamp(1_546_337_999_999_999_000).unwrap().microsecond(), 999_999); // 2019-01-01 23:59:59.999_999 UTC
    }
}
True
========================================
    use crate::OffsetDateTime;
    use crate::UtcOffset;
    use time_macros::datetime;

    #[test]
    fn millisecond() {
        assert_eq!(datetime!(2019-01-01 0:00:00.000 UTC).millisecond(), 0);
        assert_eq!(datetime!(2019-01-01 0:00:00.001 UTC).millisecond(), 1);
        assert_eq!(datetime!(2019-01-01 0:00:00.500 UTC).millisecond(), 500);
        assert_eq!(datetime!(2019-01-01 0:00:00.999 UTC).millisecond(), 999);
        assert_eq!(datetime!(2019-01-01 23:59:59.001 UTC).millisecond(), 1);
        assert_eq!(datetime!(2019-01-01 23:59:59.999 UTC).millisecond(), 999);
        assert_eq!(datetime!(2019-01-01 0:00 UTC).to_offset(UtcOffset::hours(-1)).millisecond(), 0);
        assert_eq!(datetime!(2019-01-01 23:59:59.999 UTC).to_offset(UtcOffset::hours(1)).millisecond(), 999);
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::macros::datetime;
    use crate::UtcOffset;

    #[test]
    fn minute_returns_correct_value() {
        assert_eq!(datetime!(2023-04-01 0:00 UTC).minute(), 0);
        assert_eq!(datetime!(2023-04-01 23:59:59 UTC).minute(), 59);
        assert_eq!(datetime!(2023-04-01 12:34:56 UTC).minute(), 34);
        assert_eq!(datetime!(2023-04-01 23:00 UTC).minute(), 0);
        assert_eq!(datetime!(2023-04-01 23:45 UTC).minute(), 45);
        assert_eq!(datetime!(2023-04-01 00:30 UTC).minute(), 30);
        assert_eq!(datetime!(2023-04-01 12:15:30 UTC).minute(), 15);
    }

    #[test]
    fn minute_adjusts_for_offset() {
        assert_eq!(datetime!(2023-04-01 0:00 UTC).to_offset(UtcOffset::hours(1)).minute(), 0);
        assert_eq!(datetime!(2023-04-01 0:00 UTC).to_offset(UtcOffset::hours(-1)).minute(), 0);
        assert_eq!(datetime!(2023-04-01 0:45 UTC).to_offset(UtcOffset::hours(-1)).minute(), 45);
        assert_eq!(datetime!(2023-04-01 0:15 UTC).to_offset(UtcOffset::hours(1)).minute(), 15);
    }

    #[test]
    fn minute_adjusts_for_date_changes() {
        assert_eq!(datetime!(2023-04-01 0:00 UTC).to_offset(UtcOffset::hours(-1)).minute(), 0);
        assert_eq!(datetime!(2023-04-01 23:59 UTC).to_offset(UtcOffset::hours(1)).minute(), 59);
        assert_eq!(datetime!(2023-04-01 23:59 UTC).to_offset(UtcOffset::hours(-1)).minute(), 59);
        assert_eq!(datetime!(2023-04-01 0:01 UTC).to_offset(UtcOffset::hours(1)).minute(), 1);
    }
}
False
========================================
    use crate::{OffsetDateTime, UtcOffset};
    use crate::util::DateAdjustment;
    use time_macros::datetime;
    use crate::format::{parse, Parsed};

    #[test]
    fn monday_based_week() {
        // Since the `monday_based_week` function relies on `date.monday_based_week()`,
        // the tests should focus on different edge cases of the year, month, days, and time.
        // We should also test the behavior around year boundaries and leap years.
        // `monday_based_week` returns the week number where Monday is the first day of the week
        // and week 1 is the week containing the first Monday of the year.

        // Construct test cases for different dates and expected week numbers
        let test_cases = &[
            // Start of the year, week number should be 0 (not containing a Monday)
            (datetime!(2021-01-01 0:00 UTC), 0),
            // First Monday of 2021
            (datetime!(2021-01-04 0:00 UTC), 1),
            // Sunday before first Monday
            (datetime!(2021-01-03 0:00 UTC), 0),
            // Last day of 2021, should still be in the 52nd week
            (datetime!(2021-12-31 0:00 UTC), 52),
            // First day of 2022, should be week number 0 (part of the first week of 2022)
            (datetime!(2022-01-01 0:00 UTC), 0),
            // First Monday of 2022
            (datetime!(2022-01-03 0:00 UTC), 1),
            // Leap year, end of year should still be week 52
            (datetime!(2020-12-31 0:00 UTC), 52),
            // Leap year first day, should be week number 0
            (datetime!(2020-01-01 0:00 UTC), 0),
            // With an offset (shouldn't matter for the week number)
            (datetime!(2021-01-01 0:00 +02:00), 0),
            (datetime!(2021-01-04 0:00 +02:00), 1),
        ];

        for &(test_datetime, expected_week) in test_cases {
            assert_eq!(test_datetime.monday_based_week(), expected_week, "datetime: {test_datetime} should be in week {expected_week}");
        }

        // Random date within the year 2021
        assert_eq!(datetime!(2021-05-21 12:34 UTC).monday_based_week(), 20);
        // Random date within the year 2023, specifying an offset
        assert_eq!(
            datetime!(2023-07-08 12:34 +02:00).monday_based_week(),
            27
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::date::Date;
    use crate::offset_date_crate::OffsetDateTime;
    use crate::crate::Time;
    use crate::month::Month::*;
    use crate::utc_offset::UtcOffset;
    use time_macros::{datetime, offset};

    #[test]
    fn month_returns_correct_value() {
        assert_eq!(
            datetime!(2020-01-01 0:00 UTC).month(),
            January,
            "January should be returned for January dates",
        );
        assert_eq!(
            datetime!(2020-02-01 0:00 UTC).month(),
            February,
            "February should be returned for February dates",
        );
        assert_eq!(
            datetime!(2020-03-01 0:00 UTC).month(),
            March,
            "March should be returned for March dates",
        );
        assert_eq!(
            datetime!(2020-04-01 0:00 UTC).month(),
            April,
            "April should be returned for April dates",
        );
        assert_eq!(
            datetime!(2020-05-01 0:00 UTC).month(),
            May,
            "May should be returned for May dates",
        );
        assert_eq!(
            datetime!(2020-06-01 0:00 UTC).month(),
            June,
            "June should be returned for June dates",
        );
        assert_eq!(
            datetime!(2020-07-01 0:00 UTC).month(),
            July,
            "July should be returned for July dates",
        );
        assert_eq!(
            datetime!(2020-08-01 0:00 UTC).month(),
            August,
            "August should be returned for August dates",
        );
        assert_eq!(
            datetime!(2020-09-01 0:00 UTC).month(),
            September,
            "September should be returned for September dates",
        );
        assert_eq!(
            datetime!(2020-10-01 0:00 UTC).month(),
            October,
            "October should be returned for October dates",
        );
        assert_eq!(
            datetime!(2020-11-01 0:00 UTC).month(),
            November,
            "November should be returned for November dates",
        );
        assert_eq!(
            datetime!(2020-12-01 0:00 UTC).month(),
            December,
            "December should be returned for December dates",
        );

        // Check month changes at offset boundary
        let new_york_offset = offset!(-5);
        assert_eq!(
            datetime!(2020-12-31 23:00 UTC)
                .to_offset(new_york_offset)
                .month(),
            December,
            "December should be returned when UTC date is at year end but local is not",
        );
        assert_eq!(
            datetime!(2020-01-01 00:00 UTC)
                .to_offset(new_york_offset)
                .month(),
            December,
            "December should be returned when UTC date is at year start but local is not",
        );
        let sydney_offset = offset!(+11);
        assert_eq!(
            datetime!(2020-12-31 13:00 UTC)
                .to_offset(sydney_offset)
                .month(),
            January,
            "January should be returned when UTC date is at year end but local is not",
        );
    }
}
False
========================================
    use crate::{OffsetDateTime, UtcOffset, Date, Time, duration::Duration};
    use time_macros::date;

    /// Create an `OffsetDateTime` with the provided time, while the date is set to 1970-01-01 
    /// and the offset is set to UTC.
    fn create_odt_with_time(time: Time) -> OffsetDateTime {
        OffsetDateTime::from_unix_timestamp_nanos(
            Date::from_ordinal_date(1970, 1).unwrap().midnight().assume_utc().unix_timestamp_nanos()
            + time.as_hms_nano().2 as i128 * 1_000_000_000 + time.as_hms_nano().3 as i128
        ).unwrap()
    }

    #[test]
    fn test_nanosecond() {
        // Test with the start of the day
        let time = Time::from_hms_nano(0, 0, 0, 0).unwrap();
        let odt = create_odt_with_time(time);
        assert_eq!(odt.nanosecond(), 0);

        // Test with a time with non-zero nanoseconds
        let time = Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap();
        let odt = create_odt_with_time(time);
        assert_eq!(odt.nanosecond(), 999_999_999);
    }

    #[test]
    fn test_date_boundary() {
        // Test with a time just before midnight (end of the day)
        let time = Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap();
        let date = Date::from_calendar_date(1970, crate::Month::January, 1).unwrap();
        let odt = create_odt_with_time(time);
        assert_eq!(odt.nanosecond(), 999_999_999);

        // Test with a time just at midnight (start of the day)
        let time = Time::MIDNIGHT;
        let date = Date::from_calendar_date(1970, crate::Month::January, 2).unwrap();
        let odt = create_odt_with_time(time);
        assert_eq!(odt.nanosecond(), 0);
    }

    #[test]
    fn test_offset_change() {
        // Test with offset of 1 hour ahead of UTC
        let time = Time::from_hms_nano(1, 0, 0, 0).unwrap();
        let odt = create_odt_with_time(time).to_offset(UtcOffset::hours(1));
        assert_eq!(odt.nanosecond(), 0);

        // Test with offset of 1 hour behind UTC
        let time = Time::from_hms_nano(23, 0, 0, 0).unwrap();
        let odt = create_odt_with_time(time).to_offset(UtcOffset::hours(-1));
        assert_eq!(odt.nanosecond(), 0);
    }

    #[test]
    fn test_arithmetic() {
        // Test time arithmetic that rolls over to the next day
        let time = Time::from_hms_nano(23, 59, 59, 0).unwrap();
        let odt = create_odt_with_time(time) + Duration::SECOND * 2;
        assert_eq!(odt.nanosecond(), 1_000_000_999);

        // Test time arithmetic that rolls over to the previous day
        let time = Time::MIDNIGHT;
        let odt = create_odt_with_time(time) - Duration::SECOND;
        assert_eq!(odt.nanosecond(), 999_999_999);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::OffsetDateTime;
    use time_macros::offset;

    #[test]
    fn now_utc_returns_correct_year() {
        assert!(OffsetDateTime::now_utc().year() >= 2023);
    }

    #[test]
    fn now_utc_returns_utc_offset() {
        assert_eq!(OffsetDateTime::now_utc().offset(), offset!(UTC));
    }
}
False
========================================
#[cfg(test)]
mod offset_tests {
    use crate::OffsetDateTime;
    use crate::PrimitiveDateTime;
    use crate::UtcOffset;
    use crate::Date;
    use crate::Time;
    use time_macros::datetime;
    use time_macros::offset;

    #[test]
    fn get_offset() {
        let dt = datetime!(2019-01-01 0:00);
        let offset = dt.offset();
        assert_eq!(offset, UtcOffset::UTC);

        let dt = datetime!(2019-01-01 0:00 +1);
        let offset = dt.offset();
        assert_eq!(offset, offset!(+1));

        let dt = datetime!(2019-01-01 0:00 +2);
        let offset = dt.offset();
        assert_eq!(offset, offset!(+2));

        let dt = datetime!(2019-01-01 0:00 -1);
        let offset = dt.offset();
        assert_eq!(offset, offset!(-1));

        let dt = OffsetDateTime::new(
            Date::from_ordinal_date(2019, 1).unwrap(),
            Time::from_hms(0, 0, 0).unwrap(),
            UtcOffset::UTC,
        );
        let offset = dt.offset();
        assert_eq!(offset, UtcOffset::UTC);
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::offset_date_crate::OffsetDateTime as OffsetDateTimeInner;
    use crate::UtcOffset;
    use time_macros::{datetime, offset};

    #[test]
    fn ordinal() {
        // New Year's Day in UTC is the first ordinal
        assert_eq!(datetime!(2019-01-01 0:00 UTC).ordinal(), 1);
        // New Year's Eve in UTC is the last ordinal in a non-leap year
        assert_eq!(datetime!(2019-12-31 0:00 UTC).ordinal(), 365);
        // New Year's Eve in UTC is the last ordinal in a leap year
        assert_eq!(datetime!(2020-12-31 0:00 UTC).ordinal(), 366);
        // Day after New Year's Eve in a +1 offset is still the last ordinal
        assert_eq!(datetime!(2019-12-31 23:00 UTC).to_offset(offset!(+1)).ordinal(), 365);
        // Day after New Year's Eve in a +1 offset in a leap year is still the last ordinal
        assert_eq!(datetime!(2020-12-31 23:00 UTC).to_offset(offset!(+1)).ordinal(), 366);
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::macros::{datetime, date};

    #[test]
    fn replace_date() {
        assert_eq!(
            datetime!(2020-01-01 12:00 UTC).replace_date(date!(2020-01-30)),
            datetime!(2020-01-30 12:00 UTC),
            "Replace date while keeping time and offset unchanged"
        );
    }

    #[test]
    fn replace_date_retain_time_offset() {
        assert_eq!(
            datetime!(2020-01-01 0:00 +1).replace_date(date!(2020-01-30)),
            datetime!(2020-01-30 0:00 +1),
            "Replace date while keeping time and offset unchanged"
        );
    }

    #[test]
    fn replace_date_retain_time_negative_offset() {
        assert_eq!(
            datetime!(2020-01-01 0:00 -1).replace_date(date!(2020-01-30)),
            datetime!(2020-01-30 0:00 -1),
            "Replace date while keeping time and negative offset unchanged"
        );
    }

    #[test]
    fn replace_date_no_offset() {
        assert_eq!(
            datetime!(2020-01-01 12:00).replace_date(date!(2020-01-30)),
            datetime!(2020-01-30 12:00),
            "Replace date while keeping time and no offset unchanged"
        );
    }

    #[test]
    #[should_panic(expected = "overflow when adding duration to date")]
    fn replace_date_overflow() {
        let _ = datetime!(2020-01-01 12:00 UTC).replace_date(date!(+999999-01-30));
    }

    #[test]
    #[should_panic(expected = "underflow when adding duration to date")]
    fn replace_date_underflow() {
        let _ = datetime!(2020-01-01 12:00 UTC).replace_date(date!(-999999-01-30));
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::PrimitiveDateTime;
    use time_macros::{datetime, offset};

    #[test]
    fn replace_date_time() {
        let initial = datetime!(2020-01-01 0:00).assume_offset(offset!(UTC));
        let new_date_time = PrimitiveDateTime::new(datetime!(2020-01-30 12:00).date(), datetime!(2020-01-30 12:00).time());
        assert_eq!(
            initial.replace_date_time(new_date_time),
            datetime!(2020-01-30 12:00 UTC),
            "Offset should remain unchanged"
        );

        let initial = datetime!(2020-01-01 12:00 -1).assume_offset(offset!(-1));
        let new_date_time = PrimitiveDateTime::new(datetime!(2020-01-30 0:00).date(), datetime!(2020-01-30 0:00).time());
        assert_eq!(
            initial.replace_date_time(new_date_time),
            datetime!(2020-01-30 0:00 -1),
            "Offset should remain unchanged"
        );

        let initial = datetime!(2020-01-01 6:00 +1:30).assume_offset(offset!(+1:30));
        let new_date_time = PrimitiveDateTime::new(datetime!(2020-01-15 18:30).date(), datetime!(2020-01-15 18:30).time());
        assert_eq!(
            initial.replace_date_time(new_date_time),
            datetime!(2020-01-15 18:30 +1:30),
            "Offset should remain unchanged"
        );
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::error;
    use time_macros::datetime;

    #[test]
    fn replace_day_valid() {
        let odt = datetime!(2022-02-18 12:00 +01);
        let replaced = odt.replace_day(1);
        assert_eq!(replaced, Ok(datetime!(2022-02-01 12:00 +01)));
    }

    #[test]
    fn replace_day_invalid_zero() {
        let odt = datetime!(2022-02-18 12:00 +01);
        let replaced = odt.replace_day(0);
        assert!(matches!(replaced, Err(error::ComponentRange { .. })));
    }

    #[test]
    fn replace_day_invalid_overflow() {
        let odt = datetime!(2022-02-18 12:00 +01);
        let replaced = odt.replace_day(30);
        assert!(matches!(replaced, Err(error::ComponentRange { .. })));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::PrimitiveDateTime;
    use crate::UtcOffset;
    use time_macros::{datetime, time};

    #[test]
    fn replace_hour_valid() {
        let original = datetime!(2022 - 02 - 18 01:02:03.004_005_006 +01);
        let expected = datetime!(2022 - 02 - 18 07:02:03.004_005_006 +01);
        assert_eq!(original.replace_hour(7), Ok(expected));
    }

    #[test]
    fn replace_hour_invalid() {
        let original = datetime!(2022 - 02 - 18 01:02:03.004_005_006 +01);
        assert!(matches!(
            original.replace_hour(24),
            Err(ComponentRange {
                name: "hour",
                minimum: 0,
                maximum: 23,
                value: 24,
                ..
            })
        ));
    }

    #[test]
    fn replace_hour_23() {
        let date = PrimitiveDateTime::new(
            Date::from_calendar_date(2022, Month::February, 18).unwrap(),
            time!(1:02:03),
        );
        let offset = UtcOffset::from_hms(1, 0, 0).unwrap();
        let original = OffsetDateTime::from_unix_timestamp(0)
            .unwrap()
            .replace_date_time(date)
            .replace_offset(offset);
        let expected = date.replace_time(time!(23:00)).assume_utc();
        assert_eq!(original.replace_hour(23), Ok(expected));
    }

    #[test]
    fn replace_hour_0() {
        let date = PrimitiveDateTime::new(
            Date::from_calendar_date(2022, Month::February, 18).unwrap(),
            time!(23:02:03),
        );
        let offset = UtcOffset::from_hms(1, 0, 0).unwrap();
        let original = OffsetDateTime::from_unix_timestamp(0)
            .unwrap()
            .replace_date_time(date)
            .replace_offset(offset);
        let expected = date.replace_time(time!(0:00)).assume_utc();
        assert_eq!(original.replace_hour(0), Ok(expected));
    }
}
False
========================================
    use crate::{OffsetDateTime, Time};

    #[test]
    fn replace_microsecond() {
        let initial = OffsetDateTime::UNIX_EPOCH;
        assert_eq!(
            initial.replace_microsecond(0),
            Ok(initial.replace_time(Time::MIDNIGHT))
        );
        assert_eq!(
            initial.replace_microsecond(1),
            Ok(initial.replace_time(Time::from_hms_micro(0, 0, 0, 1).unwrap()))
        );
        assert_eq!(
            initial.replace_microsecond(999_999),
            Ok(initial.replace_time(Time::from_hms_micro(0, 0, 0, 999_999).unwrap()))
        );
        assert_eq!(
            initial.replace_microsecond(1_234_567),
            Ok(initial.replace_time(Time::from_hms_micro(0, 0, 1, 234_567).unwrap()))
        );
        assert_eq!(
            initial.replace_microsecond(59_999_999),
            Ok(initial.replace_time(Time::from_hms_micro(0, 0, 59, 999_999).unwrap()))
        );
        assert_eq!(
            initial.replace_microsecond(3_600_999_999),
            Ok(initial.replace_time(Time::from_hms_micro(1, 0, 0, 999_999).unwrap()))
        );
        assert_eq!(
            initial.replace_microsecond(59 * 60 * 1_000_000 + 999_999),
            Ok(initial
                .replace_time(Time::from_hms_micro(0, 59, 59, 999_999).unwrap()))
        );
        assert_eq!(
            initial.replace_microsecond(86_399 * 1_000_000 + 999_999),
            Ok(initial
                .replace_time(Time::from_hms_micro(23, 59, 59, 999_999).unwrap()))
        );
        assert!(initial.replace_microsecond(86_400_u64 * 1_000_000).is_err());
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::error;
    use crate::macros::datetime;
    
    #[test]
    fn replace_millisecond_valid() {
        let initial = datetime!(2022-02-18 1:02:3.004_005_006 +1);
        let expected = datetime!(2022-02-18 1:02:3.007 +1);
        assert_eq!(initial.replace_millisecond(7), Ok(expected));
    }

    #[test]
    fn replace_millisecond_invalid() {
        let initial = datetime!(2022-02-18 1:02:3.004_005_006 +1);
        let err = initial.replace_millisecond(1_000).unwrap_err();
        assert!(matches!(err, error::ComponentRange { .. }));
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::error::ComponentRange;
    use time_macros::datetime;

    #[test]
    fn replace_minute_valid() {
        assert_eq!(
            OffsetDateTime::from_datetime(datetime!(
                2022 - 02 - 18 01:02:03.004_005_006 +01
            ))
            .replace_minute(7)
            .unwrap(),
            OffsetDateTime::from_datetime(datetime!(
                2022 - 02 - 18 01:07:03.004_005_006 +01
            ))
        );
    }

    #[test]
    fn replace_minute_invalid() {
        assert_eq!(
            OffsetDateTime::from_datetime(datetime!(
                2022 - 02 - 18 01:02:03.004_005_006 +01
            ))
            .replace_minute(60)
            .unwrap_err(),
            ComponentRange {
                name: "minute",
                minimum: 0,
                maximum: 59,
                value: 60,
                conditional_range: false
            }
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::month::Month;
    use crate::util::DateAdjustment;
    use crate::Date;
    use crate::Duration;
    use crate::OffsetDateTime;
    use crate::PrimitiveDateTime;
    use crate::Time;
    use crate::UtcOffset;

    #[test]
    fn replace_month_valid() {
        let odt = PrimitiveDateTime::new(Date::from_calendar_date(2022, Month::April, 18).unwrap(), Time::MIDNIGHT)
            .assume_utc();
        assert_eq!(
            odt.replace_month(Month::January),
            Ok(PrimitiveDateTime::new(Date::from_calendar_date(2022, Month::January, 18).unwrap(), Time::MIDNIGHT)
                .assume_utc())
        );
    }

    #[test]
    fn replace_month_invalid() {
        let odt = PrimitiveDateTime::new(Date::from_calendar_date(2022, Month::January, 30).unwrap(), Time::MIDNIGHT)
            .assume_utc();
        assert!(odt.replace_month(Month::February).is_err());
    }

    #[test]
    fn replace_month_leap_year() {
        let odt = PrimitiveDateTime::new(Date::from_calendar_date(2020, Month::February, 29).unwrap(), Time::MIDNIGHT)
            .assume_utc();
        assert_eq!(
            odt.replace_month(Month::March),
            Ok(PrimitiveDateTime::new(Date::from_calendar_date(2020, Month::March, 29).unwrap(), Time::MIDNIGHT)
                .assume_utc())
        );
    }

    #[test]
    fn replace_month_non_leap_year() {
        let odt = PrimitiveDateTime::new(Date::from_calendar_date(2021, Month::March, 29).unwrap(), Time::MIDNIGHT)
            .assume_utc();
        assert_eq!(
            odt.replace_month(Month::February),
            Ok(PrimitiveDateTime::new(Date::from_calendar_date(2021, Month::February, 28).unwrap(), Time::MIDNIGHT)
                .assume_utc())
        );
    }
}
True
========================================
    use crate::error::ComponentRange;
    use crate::OffsetDateTime;
    use time_macros::datetime;

    #[test]
    fn replace_nanosecond_valid() {
        assert_eq!(
            datetime!(2022-02-18 01:02:03.004005006 +01)
                .replace_nanosecond(7008009)
                .unwrap(),
            datetime!(2022-02-18 01:02:03.007008009 +01),
        );
    }

    #[test]
    fn replace_nanosecond_invalid_nanosecond() {
        assert!(matches!(
            datetime!(2022-02-18 01:02:03.004005006 +01)
                .replace_nanosecond(1_000_000_000),
            Err(ComponentRange { .. })
        ));
    }
}
False
========================================
    use crate::offset_date_crate::OffsetDateTime;
    use crate::utc_offset::UtcOffset;
    use crate::PrimitiveDateTime;
    use time_macros::{datetime, offset};

    #[test]
    fn replace_offset() {
        // Ensure `replace_offset` does not alter date and time components
        let initial = datetime!(2020-01-01 0:00 -5);
        let new_offset = offset!(UTC); // UTC
        let result = initial.replace_offset(new_offset);
        assert_eq!(result, datetime!(2020-01-01 0:00 UTC));
        
        // Checking for different date, time, and offset
        let initial = datetime!(2020-01-01 5:00 -5);
        let new_offset = offset!(+2); // UTC+2
        let result = initial.replace_offset(new_offset);
        assert_eq!(result, datetime!(2020-01-01 5:00 +2));

        // Edge cases: minimum and maximum
        let initial = datetime!(9999-12-31 23:59:59.999_999_999 -23:59:59);
        let new_offset = offset!(+23:59:59); // UTC+23:59:59
        let result = initial.replace_offset(new_offset);
        assert_eq!(
            result,
            datetime!(9999-12-31 23:59:59.999_999_999 +23:59:59)
        );

        let initial = datetime!(-9999-01-01 0:00:00 +23:59:59);
        let new_offset = offset!(-23:59:59); // UTC-23:59:59
        let result = initial.replace_offset(new_offset);
        assert_eq!(
            result,
            datetime!(-9999-01-01 0:00:00 -23:59:59)
        );
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::error::ComponentRange;
    use crate::Duration;
    use time_macros::datetime;

    #[test]
    fn replace_second_valid() {
        assert_eq!(
            datetime!(2022 - 02 - 18 01:02:03.004_005_006 +01)
                .replace_second(7)
                .unwrap(),
            datetime!(2022 - 02 - 18 01:02:07.004_005_006 +01)
        );
    }

    #[test]
    fn replace_second_invalid() {
        assert!(matches!(
            datetime!(2022 - 02 - 18 01:02:03.004_005_006 +01).replace_second(60),
            Err(ComponentRange { name, .. }) if name == "second"
        ));
    }

    #[test]
    fn replace_second_boundary() {
        assert_eq!(
            datetime!(2022 - 02 - 18 01:02:03.004_005_006 +01)
                .replace_second(59)
                .unwrap(),
            datetime!(2022 - 02 - 18 01:02:59.004_005_006 +01)
        );
    }

    #[test]
    fn replace_second_wrapping() {
        assert_eq!(
            datetime!(2022 - 02 - 18 01:02:59.004_005_006 +01)
                .replace_second(0)
                .unwrap(),
            datetime!(2022 - 02 - 18 01:02:00.004_005_006 +01)
        );
    }

    #[test]
    fn replace_second_rollback() {
        let datetime = datetime!(2022 - 02 - 18 01:02:59.004_005_006 +01);
        let timestamp = datetime.unix_timestamp();
        assert_eq!(
            datetime
                .replace_second(0)
                .unwrap()
                .unix_timestamp(),
            timestamp - 59
        );
    }

    #[test]
    fn replace_second_edge_case() {
        assert_eq!(
            datetime!(2022 - 02 - 18 01:02:03.004_005_006 +01)
                .replace_second(2)
                .unwrap(),
            datetime!(2022 - 02 - 18 01:02:02.004_005_006 +01)
        );
    }
}
False
========================================
#[cfg(test)]
mod test_replace_time {
    use crate::{macros::{datetime, time}, OffsetDateTime, Time};

    #[test]
    fn replace_time_same_offset() {
        let original = datetime!(2020-01-01 5:00 UTC);
        let expected = datetime!(2020-01-01 12:00 UTC);
        let replacement_time = time!(12:00);
        let result = original.replace_time(replacement_time);
        assert_eq!(result, expected);
    }

    #[test]
    fn replace_time_different_offset() {
        let original = datetime!(2020-01-01 12:00 -5);
        let expected = datetime!(2020-01-01 7:00 -5);
        let replacement_time = time!(7:00);
        let result = original.replace_time(replacement_time);
        assert_eq!(result, expected);
    }

    #[test]
    fn replace_time_with_change_over_midnight() {
        let original = datetime!(2020-01-01 0:00 +1);
        let expected = datetime!(2020-01-01 12:00 +1);
        let replacement_time = time!(12:00);
        let result = original.replace_time(replacement_time);
        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::util::{days_in_year, is_leap_year};
    use crate::{error, Date, Duration, Month, OffsetDateTime, Time, UtcOffset, Weekday};
    use time_macros::{date, datetime, offset, time};

    #[test]
    fn replace_year_valid() {
        assert_eq!(
            datetime!(2022 - 02 - 18 12:00 +01).replace_year(2019),
            Ok(datetime!(2019 - 02 - 18 12:00 +01))
        );
    }

    #[test]
    fn replace_year_invalid_before_epoch() {
        assert!(datetime!(2022 - 02 - 18 12:00 +01)
            .replace_year(Date::MIN.year() - 1)
            .is_err());
    }

    #[test]
    fn replace_year_invalid_after_epoch() {
        assert!(datetime!(2022 - 02 - 18 12:00 +01)
            .replace_year(Date::MAX.year() + 1)
            .is_err());
    }

    #[test]
    fn replace_year_leap_year() {
        assert_eq!(
            datetime!(2020 - 02 - 29 12:00 +01).replace_year(2016),
            Ok(datetime!(2016 - 02 - 29 12:00 +01))
        );
    }

    #[test]
    fn replace_year_to_non_leap_year() {
        assert!(datetime!(2020 - 02 - 29 12:00 +01)
            .replace_year(2019)
            .is_err());
    }

    #[test]
    fn replace_year_to_leap_year() {
        assert_eq!(
            datetime!(2019 - 02 - 28 12:00 +01).replace_year(2020),
            Ok(datetime!(2020 - 02 - 28 12:00 +01))
        );
    }

    #[test]
    fn replace_year_retains_ymd_order() {
        assert!(datetime!(2020 - 01 - 31 12:00 +01)
            .replace_year(2019)
            .is_err());
    }
}
False
========================================
    use crate::{Duration, OffsetDateTime, UtcOffset, Date, Time, time_macros::{datetime, offset, days, hours}};

    #[test]
    fn saturating_add() {
        #[cfg(feature = "large-dates")]
        {
            assert_eq!(
                OffsetDateTime::from_unix_timestamp(0).to_offset(UtcOffset::from_hms(10, 0, 0).unwrap())
                    .saturating_add((-2).days()),
                OffsetDateTime::from_unix_timestamp(0).to_offset(UtcOffset::from_hms(10, 0, 0).unwrap())
            );

            assert_eq!(
                OffsetDateTime::from_unix_timestamp(i64::MAX)
                    .to_offset(UtcOffset::from_hms(10, 0, 0).unwrap())
                    .saturating_add(2.days()),
                OffsetDateTime::from_unix_timestamp(i64::MAX)
                    .to_offset(UtcOffset::from_hms(10, 0, 0).unwrap())
            );
        }

        #[cfg(not(feature = "large-dates"))]
        {
            assert_eq!(
                OffsetDateTime::from_unix_timestamp(i64::MIN)
                    .to_offset(UtcOffset::from_hms(10, 0, 0).unwrap())
                    .saturating_add((-2).days()),
                OffsetDateTime::from_unix_timestamp(i64::MIN)
                    .to_offset(UtcOffset::from_hms(10, 0, 0).unwrap())
            );

            assert_eq!(
                OffsetDateTime::from_unix_timestamp(i64::MAX)
                    .to_offset(UtcOffset::from_hms(10, 0, 0).unwrap())
                    .saturating_add(2.days()),
                OffsetDateTime::from_unix_timestamp(i64::MAX)
                    .to_offset(UtcOffset::from_hms(10, 0, 0).unwrap())
            );
        }

        assert_eq!(
            datetime!(2019 - 11 - 25 15:30 +10).saturating_add(27.hours()),
            datetime!(2019 - 11 - 26 18:30 +10)
        );
    }
}
False
========================================
    use crate::Duration;
    use crate::ext::NumericalDuration;
    use crate::offset_date_crate::OffsetDateTime;
    use time_macros::datetime;

    #[test]
    fn saturating_sub_underflow() {
        // Test saturation to minimum value on underflow.
        let dt = datetime!(-9999-01-01 0:00 +10);
        assert_eq!(dt.saturating_sub(2.days()), dt);
    }

    #[test]
    fn saturating_sub_overflow() {
        // Test saturation to maximum value on overflow.
        let dt = datetime!(+9999-12-31 23:59:59.999_999_999 +10);
        assert_eq!(dt.saturating_sub((-2).days()), dt);
    }

    #[test]
    fn saturating_sub_normal() {
        // Test normal subtraction without overflow.
        let dt = datetime!(2019-11-25 15:30 +10);
        let expected = datetime!(2019-11-24 12:30 +10);
        assert_eq!(dt.saturating_sub(27.hours()), expected);
    }
}
False
========================================
    use crate::{offset::UtcOffset, crate::Time, Date, OffsetDateTime, PrimitiveDateTime};
    use time_macros::{datetime, offset, time};

    #[test]
    fn test_second() {
        // Test with UTC
        assert_eq!(datetime!(2019-01-01 0:00 UTC).second(), 0);
        assert_eq!(datetime!(2019-01-01 23:59:59 UTC).second(), 59);

        // Test with non-UTC offset
        assert_eq!(
            PrimitiveDateTime::new(Date::from_calendar_date(2019, crate::Month::January, 1).unwrap(), Time::from_hms(0, 0, 0).unwrap())
                .assume_offset(offset!(+3:45:30))
                .second(),
            30
        );

        assert_eq!(
            PrimitiveDateTime::new(Date::from_calendar_date(2019, crate::Month::December, 31).unwrap(), Time::from_hms(23, 59, 59).unwrap())
                .assume_offset(offset!(-4:30:45))
                .second(),
            14
        );
    }
}
False
========================================
    use crate::OffsetDateTime;

    #[test]
    fn sunday_based_week() {
        // Test with the first Sunday of 2019, 2020, 2021, and 2022
        assert_eq!(OffsetDateTime::unix_epoch() + 1_546_865_600.seconds(), 1);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_577_765_600.seconds(), 1);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_609_363_200.seconds(), 1);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_640_995_200.seconds(), 1);

        // Test with the last Sunday of 2019, 2020, 2021, and 2022
        assert_eq!(OffsetDateTime::unix_epoch() + 1_577_427_200.seconds(), 52);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_609_235_200.seconds(), 52);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_640_867_200.seconds(), 52);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_672_499_200.seconds(), 52);

        // Test with the first day of 2019, 2020, 2021, and 2022
        assert_eq!(OffsetDateTime::unix_epoch() + 1_546_300_800.seconds(), 0);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_577_836_800.seconds(), 0);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_609_459_200.seconds(), 0);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_640_099_200.seconds(), 0);

        // Test with the last day of 2019, 2020, 2021, and 2022
        assert_eq!(OffsetDateTime::unix_epoch() + 1_577_689_600.seconds(), 52);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_609_497_600.seconds(), 52);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_641_129_600.seconds(), 52);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_672_761_600.seconds(), 52);

        // Test with a date that should be the first week of the next year
        assert_eq!(OffsetDateTime::unix_epoch() + 1_577_600_000.seconds(), 0);
        assert_eq!(OffsetDateTime::unix_epoch() + 1_609_459_200.seconds(), 0);
    }
}
False
========================================
#[cfg(test)]
mod offset_date_time_tests {
    use crate::Date;
    use crate::OffsetDateTime;
    use crate::PrimitiveDateTime;
    use crate::Time;
    use crate::UtcOffset;
    use crate::Weekday;
    use crate::Month;
    use crate::error;
    use crate::util::DateAdjustment;
    use core::crate::Duration as StdDuration;
    use crate::Duration;

    #[test]
    fn time_in_utc_offset() {
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH.time(),
            Time::from_hms(0, 0, 0).unwrap()
        );
    }

    #[test]
    fn time_in_non_utc_offset() {
        let offset = UtcOffset::from_hms(-1, 0, 0).unwrap();
        let dt = OffsetDateTime::UNIX_EPOCH.to_offset(offset);
        assert_eq!(dt.time(), Time::from_hms(23, 0, 0).unwrap());
    }

    #[test]
    fn time_after_midnight_in_utc_offset() {
        assert_eq!(
            (OffsetDateTime::UNIX_EPOCH + 1.hours()).time(),
            Time::from_hms(1, 0, 0).unwrap()
        );
    }

    #[test]
    fn time_after_midnight_in_non_utc_offset() {
        let offset = UtcOffset::from_hms(2, 0, 0).unwrap();
        let dt = (OffsetDateTime::UNIX_EPOCH + 1.hours()).to_offset(offset);
        assert_eq!(dt.time(), Time::from_hms(3, 0, 0).unwrap());
    }

    #[test]
    fn time_before_midnight_in_utc_offset() {
        assert_eq!(
            (OffsetDateTime::UNIX_EPOCH - 1.hours()).time(),
            Time::from_hms(23, 0, 0).unwrap()
        );
    }

    #[test]
    fn time_before_midnight_in_non_utc_offset() {
        let offset = UtcOffset::from_hms(-2, 0, 0).unwrap();
        let dt = (OffsetDateTime::UNIX_EPOCH - 2.hours()).to_offset(offset);
        assert_eq!(dt.time(), Time::from_hms(22, 0, 0).unwrap());
    }

    #[test]
    fn time_just_before_midnight_in_utc_offset() {
        let dt = OffsetDateTime::UNIX_EPOCH + 23.hours() + 30.minutes();
        assert_eq!(dt.time(), Time::from_hms(23, 30, 0).unwrap());
    }

    #[test]
    fn time_just_before_midnight_in_non_utc_offset() {
        let offset = UtcOffset::from_hms(-2, 0, 0).unwrap();
        let dt = (OffsetDateTime::UNIX_EPOCH + (23.hours() + 30.minutes())).to_offset(offset);
        assert_eq!(dt.time(), Time::from_hms(21, 30, 0).unwrap());
    }

    #[test]
    fn time_just_after_midnight_in_utc_offset() {
        let dt = OffsetDateTime::UNIX_EPOCH + 30.minutes();
        assert_eq!(dt.time(), Time::from_hms(0, 30, 0).unwrap());
    }

    #[test]
    fn time_just_after_midnight_in_non_utc_offset() {
        let offset = UtcOffset::from_hms(2, 0, 0).unwrap();
        let dt = (OffsetDateTime::UNIX_EPOCH + 30.minutes()).to_offset(offset);
        assert_eq!(dt.time(), Time::from_hms(2, 30, 0).unwrap());
    }

    #[test]
    fn time_with_leading_zero_in_utc_offset() {
        let dt = OffsetDateTime::UNIX_EPOCH + 1.minutes();
        assert_eq!(dt.time(), Time::from_hms(0, 1, 0).unwrap());
    }

    #[test]
    fn time_with_leading_zero_in_non_utc_offset() {
        let offset = UtcOffset::from_hms(2, 0, 0).unwrap();
        let dt = (OffsetDateTime::UNIX_EPOCH + 1.minutes()).to_offset(offset);
        assert_eq!(dt.time(), Time::from_hms(2, 1, 0).unwrap());
    }

    #[test]
    fn test_arithmetic() {
        let dt = OffsetDateTime::UNIX_EPOCH + 30.minutes();
        assert_eq!(dt.time(), Time::from_hms(0, 30, 0).unwrap());
        assert_eq!((dt + 1.hours()).time(), Time::from_hms(1, 30, 0).unwrap());
        assert_eq!((dt - 1.hours()).time(), Time::from_hms(23, 30, 0).unwrap());
    }

    #[test]
    fn test_with_time() {
        let date = Date::from_calendar_date(2019, Month::January, 1).unwrap();
        let dt = date.midnight();
        assert_eq!(dt.time(), Time::from_hms(0, 0, 0).unwrap());
        let pdt = date.with_time(Time::from_hms(14, 30, 0).unwrap());
        assert_eq!(pdt.time(), Time::from_hms(14, 30, 0).unwrap());
    }

    #[test]
    fn test_with_hms() {
        let date = Date::from_calendar_date(2019, Month::January, 1).unwrap();
        let pdt = date.with_hms(14, 30, 0).unwrap();
        assert_eq!(pdt.time(), Time::from_hms(14, 30, 0).unwrap());
    }

    #[test]
    #[should_panic(expected = "overflow adding duration to date")]
    fn test_with_hms_out_of_range() {
        let date = Date::from_calendar_date(2019, Month::January, 1).unwrap();
        assert!(date.with_hms(24, 0, 0).is_err());
    }

    #[test]
    #[should_panic(expected = "overflow adding duration to date")]
    fn test_midnight() {
        let date = Date::from_calendar_date(2019, Month::January, 1).unwrap().midnight();
        assert_eq!(date.time(), Time::from_hms(0, 0, 0).unwrap());
    }

    #[test]
    #[should_panic(expected = "overflow adding duration to date")]
    fn test_assume_utc() {
        let date = Date::from_calendar_date(2019, Month::January, 1).unwrap().midnight().assume_utc();
        assert_eq!(date.time(), Time::from_hms(0, 0, 0).unwrap());
    }
}
False
========================================
    use crate::{Month, offset_date_crate::OffsetDateTime};
    use crate::macros::{datetime, offset};

    #[test]
    fn to_calendar_date() {
        assert_eq!(
            datetime!(2019-01-01 0:00 UTC).to_calendar_date(),
            (2019, Month::January, 1)
        );
        assert_eq!(
            datetime!(2019-12-31 23:59:59 UTC).to_calendar_date(),
            (2019, Month::December, 31)
        );
        assert_eq!(
            datetime!(2020-02-29 23:59:59 UTC).to_calendar_date(),
            (2020, Month::February, 29)
        );
        assert_eq!(
            datetime!(2020-02-29 23:59:59 -1).to_calendar_date(),
            (2020, Month::February, 29)
        );
        assert_eq!(
            datetime!(2020-02-29 23:59:59 +1).to_calendar_date(),
            (2020, Month::February, 29)
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::UtcOffset;
    use crate::OffsetDateTime;

    #[test]
    fn to_hms_at_midnight() {
        let odt = PrimitiveDateTime::new(crate::Date::from_calendar_date(2020, crate::Month::January, 1).unwrap(), crate::Time::MIDNIGHT).assume_offset(UtcOffset::UTC);
        assert_eq!(odt.to_hms(), (0, 0, 0));
    }

    #[test]
    fn to_hms_before_noon() {
        let odt = PrimitiveDateTime::new(crate::Date::from_calendar_date(2020, crate::Month::January, 1).unwrap(), crate::Time::from_hms(9, 30, 45).unwrap()).assume_offset(UtcOffset::UTC);
        assert_eq!(odt.to_hms(), (9, 30, 45));
    }

    #[test]
    fn to_hms_after_noon() {
        let odt = PrimitiveDateTime::new(crate::Date::from_calendar_date(2020, crate::Month::January, 1).unwrap(), crate::Time::from_hms(16, 45, 15).unwrap()).assume_offset(UtcOffset::UTC);
        assert_eq!(odt.to_hms(), (16, 45, 15));
    }

    #[test]
    fn to_hms_at_noon() {
        let odt = PrimitiveDateTime::new(crate::Date::from_calendar_date(2020, crate::Month::January, 1).unwrap(), crate::Time::from_hms(12, 0, 0).unwrap()).assume_offset(UtcOffset::UTC);
        assert_eq!(odt.to_hms(), (12, 0, 0));
    }

    #[test]
    fn to_hms_just_before_midnight() {
        let odt = PrimitiveDateTime::new(crate::Date::from_calendar_date(2020, crate::Month::January, 1).unwrap(), crate::Time::from_hms(23, 59, 59).unwrap()).assume_offset(UtcOffset::UTC);
        assert_eq!(odt.to_hms(), (23, 59, 59));
    }

    #[test]
    fn to_hms_with_offset() {
        let odt = PrimitiveDateTime::new(crate::Date::from_calendar_date(2020, crate::Month::January, 1).unwrap(), crate::Time::from_hms(17, 30, 25).unwrap()).assume_offset(UtcOffset::hours(2));
        assert_eq!(odt.to_hms(), (17, 30, 25));
    }
}
False
========================================
    use crate::OffsetDateTime; // Assuming `time` is the correct import path for `OffsetDateTime`
    use time_macros::datetime; // Correct import path for the `datetime!` macro

    #[test]
    fn test_to_hms_micro() {
        // Test midnight
        assert_eq!(
            datetime!(2020-01-01 0:00:00 UTC).to_hms_micro(),
            (0, 0, 0, 0)
        );

        // Test a time with a non-zero microsecond
        assert_eq!(
            datetime!(2020-01-01 12:34:56.789012 UTC).to_hms_micro(),
            (12, 34, 56, 789012)
        );

        // Test the last representable microsecond before midnight
        assert_eq!(
            datetime!(2020-01-01 23:59:59.999999 UTC).to_hms_micro(),
            (23, 59, 59, 999999)
        );

        // Test with a positive UTC offset
        assert_eq!(
            datetime!(2020-01-01 12:34:56.789012 +1).to_hms_micro(),
            (11, 34, 56, 789012)
        );
        
        // Test with a negative UTC offset
        assert_eq!(
            datetime!(2020-01-01 12:34:56.789012 -1).to_hms_micro(),
            (13, 34, 56, 789012)
        );

        // Test the overflow to the next day
        assert_eq!(
            datetime!(2020-01-01 23:59:59.999999 +1).to_hms_micro(),
            (22, 59, 59, 999999)
        );

        // Test the underflow to the previous day
        assert_eq!(
            datetime!(2020-01-01 00:00:00.000000 -1).to_hms_micro(),
            (1, 0, 0, 0)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::util::DateAdjustment;
    use crate::Date;
    use time_macros::time;
    use core::crate::Duration as StdDuration;
    use crate::{Duration, OffsetDateTime, Time, UtcOffset};

    #[test]
    fn to_hms_milli() {
        // Assert equal time components for matching dates.
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH.to_hms_milli(),
            (0, 0, 0, 0)
        );
        assert_eq!(
            (OffsetDateTime::UNIX_EPOCH + Duration::milliseconds(1)).to_hms_milli(),
            (0, 0, 0, 1)
        );
        assert_eq!(
            (OffsetDateTime::UNIX_EPOCH + StdDuration::from_millis(1)).to_hms_milli(),
            (0, 0, 0, 1)
        );
        assert_eq!(
            (OffsetDateTime::UNIX_EPOCH - Duration::milliseconds(1)).to_hms_milli(),
            (23, 59, 59, 999)
        );
        assert_eq!(
            (OffsetDateTime::UNIX_EPOCH - StdDuration::from_millis(1)).to_hms_milli(),
            (23, 59, 59, 999)
        );
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1_546_300_800).unwrap().to_hms_milli(),
            (0, 0, 0, 0)
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .replace_time(time!(23:59:59.999))
                .to_hms_milli(),
            (23, 59, 59, 999)
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .replace_time(time!(12:30:30.5))
                .to_hms_milli(),
            (12, 30, 30, 500)
        );

        // Assert components for non-UTC dates.
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1_546_300_800).unwrap() // 2019-01-01 0:00 UTC
                .to_offset(UtcOffset::from_hms(1, 0, 0).unwrap()) // 2019-01-01 1:00 +01:00
                .to_hms_milli(),
            (1, 0, 0, 0)
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .replace_time(time!(12:30:30.5))
                .to_offset(UtcOffset::from_hms(-1, 0, 0).unwrap()) // 12:30:30.5 -01:00
                .to_hms_milli(),
            (11, 30, 30, 500)
        );
    }
}
False
========================================
    use crate::OffsetDateTime; // Adjust the use path to refer to the super module
    use crate::macros::datetime; // Adjust the use path to use the `time` crate directly

    #[test]
    fn test_to_hms_nano() {
        assert_eq!(
            datetime!(2020-01-01 0:00:00 UTC).to_hms_nano(),
            (0, 0, 0, 0)
        );
        assert_eq!(
            datetime!(2020-01-01 23:59:59.999_999_999 UTC).to_hms_nano(),
            (23, 59, 59, 999_999_999)
        );
        assert_eq!(
            datetime!(2020-01-01 12:34:56.123_456_789 UTC).to_hms_nano(),
            (12, 34, 56, 123_456_789)
        );
        assert_eq!(
            datetime!(2020-01-01 1:2:3.123_456 UTC).to_hms_nano(),
            (1, 2, 3, 123_456_000)
        );
        assert_eq!(
            datetime!(2020-01-01 23:59:59 UTC).to_hms_nano(),
            (23, 59, 59, 0)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Weekday::*;
    use crate::macros::datetime;

    #[test]
    fn test_to_iso_week_date() {
        assert_eq!(
            datetime!(2019-01-01 0:00 UTC).to_iso_week_date(),
            (2019, 1, Tuesday)
        );
        assert_eq!(
            datetime!(2019-10-04 0:00 UTC).to_iso_week_date(),
            (2019, 40, Friday)
        );
        assert_eq!(
            datetime!(2020-01-01 0:00 UTC).to_iso_week_date(),
            (2020, 1, Wednesday)
        );
        assert_eq!(
            datetime!(2020-12-31 0:00 UTC).to_iso_week_date(),
            (2020, 53, Thursday)
        );
        assert_eq!(
            datetime!(2021-01-01 0:00 UTC).to_iso_week_date(),
            (2020, 53, Friday)
        );
    }
}
False
========================================
    use crate::{Date, OffsetDateTime, PrimitiveDateTime, Time, UtcOffset};
    use time_macros::{datetime, offset};

    #[test]
    fn to_julian_day() {
        assert_eq!(datetime!(-4713-11-24 0:00 UTC).to_julian_day(), 0);
        assert_eq!(datetime!(2000-01-01 0:00 UTC).to_julian_day(), 2_451_545);
        assert_eq!(datetime!(2019-01-01 0:00 UTC).to_julian_day(), 2_458_485);
        assert_eq!(datetime!(2019-12-31 0:00 UTC).to_julian_day(), 2_458_849);
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(0)
                .expect("Unable to create OffsetDateTime from unix timestamp 0.")
                .to_julian_day(),
            2_440_588
        );
        assert_eq!(datetime!(1970-01-01 0:00 UTC).to_julian_day(), 2_440_588);
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1_000_000_000)
                .expect("Unable to create OffsetDateTime from unix timestamp 1_000_000_000.")
                .to_julian_day(),
            2_451_616
        );
        assert_eq!(
            datetime!(2001-09-09 1:46:40 UTC).to_julian_day(),
            2_451_616
        );
        assert_eq!(
            datetime!(1970-01-01 0:00 +1)
                .to_offset(offset!(UTC))
                .to_julian_day(),
            2_440_588
        );
    }
}
False
========================================
    use crate::offset_date_crate::OffsetDateTime;
    use crate::crate::Time;
    use crate::date::Date;
    use crate::utc_offset::UtcOffset;
    use time_macros::{datetime, offset};

    #[test]
    fn to_offset_utc_to_negative() {
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(0)
                .unwrap()
                .to_offset(UtcOffset::from_hms(-1, 0, 0).unwrap())
                .year(),
            1969,
        );
    }

    #[test]
    fn to_offset_utc_to_positive() {
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(0)
                .unwrap()
                .to_offset(UtcOffset::from_hms(1, 0, 0).unwrap())
                .year(),
            1970,
        );
    }

    #[test]
    fn to_offset_east_to_utc() {
        assert_eq!(
            datetime!(2000-01-01 1:00 +1)
                .to_offset(UtcOffset::UTC)
                .time(),
            Time::from_hms(0, 0, 0).unwrap(),
        );
    }

    #[test]
    fn to_offset_west_to_utc() {
        assert_eq!(
            datetime!(2000-01-01 1:00 -1)
                .to_offset(UtcOffset::UTC)
                .time(),
            Time::from_hms(2, 0, 0).unwrap(),
        );
    }

    #[test]
    fn to_offset_utc_to_east() {
        assert_eq!(
            datetime!(2000-01-01 0:00 UTC)
                .to_offset(UtcOffset::from_hms(1, 0, 0).unwrap())
                .time(),
            Time::from_hms(1, 0, 0).unwrap(),
        );
    }

    #[test]
    fn to_offset_utc_to_west() {
        assert_eq!(
            datetime!(2000-01-01 0:00 UTC)
                .to_offset(UtcOffset::from_hms(-1, 0, 0).unwrap())
                .time(),
            Time::from_hms(23, 0, 0).unwrap(),
        );
    }

    #[test]
    fn to_offset_east_to_west() {
        let sydney = datetime!(2000-01-01 0:00 +11);
        let new_york = sydney.to_offset(UtcOffset::from_hms(-5, 0, 0).unwrap());
        assert_eq!(new_york.hour(), 8);
        assert_eq!(new_york.date(), Date::from_calendar_date(1999, 12, 31).unwrap());
    }

    #[test]
    fn to_offset_west_to_east() {
        let los_angeles = datetime!(1999-12-31 5:00 -8);
        let sydney = los_angeles.to_offset(UtcOffset::from_hms(11, 0, 0).unwrap());
        assert_eq!(sydney.hour(), 0);
        assert_eq!(sydney.date(), Date::from_calendar_date(2000, 1, 1).unwrap());
    }

    #[test]
    #[should_panic]
    fn to_offset_invalid_date_time() {
        let _ = OffsetDateTime::from_unix_timestamp(i64::MAX)
            .unwrap()
            .to_offset(UtcOffset::from_hms(1, 0, 0).unwrap());
    }
}
False
========================================
    use crate::offset_date_crate::OffsetDateTime;
    use crate::ext::NumericalDuration;
    use time_macros::datetime;

    #[test]
    fn to_ordinal_date() {
        // First day of a common year
        let dt = datetime!(2019-01-01 0:00 UTC);
        assert_eq!(dt.to_ordinal_date(), (2019, 1));

        // Last day of a common year
        let dt = datetime!(2019-12-31 0:00 UTC);
        assert_eq!(dt.to_ordinal_date(), (2019, 365));

        // First day of a leap year
        let dt = datetime!(2020-01-01 0:00 UTC);
        assert_eq!(dt.to_ordinal_date(), (2020, 1));

        // Last day of a leap year
        let dt = datetime!(2020-12-31 0:00 UTC);
        assert_eq!(dt.to_ordinal_date(), (2020, 366));

        // With a non-zero UTC offset
        let dt = datetime!(2020-12-31 0:00 +1);
        assert_eq!(dt.to_ordinal_date(), (2020, 366));

        // With a non-zero UTC offset that changes year
        let dt = datetime!(2019-12-31 23:00 -2);
        assert_eq!(dt.to_ordinal_date(), (2020, 1));

        // With a time component
        let dt = datetime!(2019-12-31 23:59:59 UTC);
        assert_eq!(dt.to_ordinal_date(), (2019, 365));

        // Adding time to last day of a common year
        let dt = datetime!(2019-12-31 0:00 UTC) + 1.days();
        assert_eq!(dt.to_ordinal_date(), (2020, 1));

        // Subtracting time from first day of a common year
        let dt = datetime!(2019-01-01 0:00 UTC) - 1.days();
        assert_eq!(dt.to_ordinal_date(), (2018, 365));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::PrimitiveDateTime;
    use crate::UtcOffset;
    use crate::OffsetDateTime;

    #[test]
    fn unix_timestamp_at_epoch() {
        assert_eq!(OffsetDateTime::UNIX_EPOCH.unix_timestamp(), 0);
    }

    #[test]
    fn unix_timestamp_after_epoch() {
        assert_eq!(PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms(1, 0, 0).unwrap()).assume_utc().unix_timestamp(), 3_600);
    }

    #[test]
    fn unix_timestamp_before_epoch() {
        assert_eq!(PrimitiveDateTime::new(Date::from_calendar_date(1969, Month::December, 31).unwrap(), Time::from_hms(23, 0, 0).unwrap()).assume_utc().unix_timestamp(), -3_600);
    }

    #[test]
    fn unix_timestamp_with_offset() {
        assert_eq!(PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms(1, 0, 0).unwrap()).assume_offset(UtcOffset::from_hms(1, 0, 0).unwrap()).unix_timestamp(), 0);
    }

    #[test]
    fn unix_timestamp_with_large_offset() {
        assert_eq!(PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms(0, 0, 0).unwrap()).assume_offset(UtcOffset::from_hms(1, 0, 0).unwrap()).unix_timestamp(), -3_600);
    }

    #[test]
    fn unix_timestamp_with_negative_offset() {
        assert_eq!(PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms(0, 0, 0).unwrap()).assume_offset(UtcOffset::from_hms(-1, 0, 0).unwrap()).unix_timestamp(), 3_600);
    }

    #[test]
    fn unix_timestamp_with_subsecond() {
        assert_eq!(PrimitiveDateTime::new(Date::from_calendar_date(1970, Month::January, 1).unwrap(), Time::from_hms_milli(0, 0, 1, 500).unwrap()).assume_utc().unix_timestamp(), 1);
    }

    #[test]
    fn unix_timestamp_at_max_date_time() {
        let max_date_utc = PrimitiveDateTime::MAX.assume_utc();
        assert_eq!(max_date_utc.unix_timestamp(), 253_402_300_799);
    }

    #[test]
    fn unix_timestamp_at_min_date_time() {
        let min_date_utc = PrimitiveDateTime::MIN.assume_utc();
        assert_eq!(min_date_utc.unix_timestamp(), -62_167_219_201);
    }
}
True
========================================
    use crate::OffsetDateTime;
    use crate::UtcOffset;
    use crate::ext::NumericalDuration;

    #[test]
    fn unix_timestamp_nanos() {
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH.unix_timestamp_nanos(),
            0
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .to_offset(UtcOffset::hours(-1))
                .unix_timestamp_nanos(),
            3_600_000_000_000
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .to_offset(UtcOffset::hours(-1))
                .unix_timestamp_nanos(),
            3_600_000_000_000
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .to_offset(UtcOffset::hours(1))
                .unix_timestamp_nanos(),
            -3_600_000_000_000
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .to_offset(UtcOffset::minutes(1))
                .unix_timestamp_nanos(),
            -60_000_000_000
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .to_offset(UtcOffset::seconds(1))
                .unix_timestamp_nanos(),
            -1_000_000_000
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .to_offset(UtcOffset::milliseconds(1))
                .unix_timestamp_nanos(),
            -1_000_000
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .to_offset(UtcOffset::microseconds(1))
                .unix_timestamp_nanos(),
            -1_000
        );
        assert_eq!(
            OffsetDateTime::UNIX_EPOCH
                .to_offset(UtcOffset::nanoseconds(1))
                .unix_timestamp_nanos(),
            -1
        );
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::Weekday::{self, *};

    #[test]
    fn test_weekday() {
        assert_eq!(OffsetDateTime::UNIX_EPOCH.weekday(), Weekday::Thursday); // 1970-01-01 is Thursday
        assert_eq!(OffsetDateTime::from_unix_timestamp(1546300800).unwrap().weekday(), Tuesday); // 2019-01-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1548979200).unwrap().weekday(), Friday); // 2019-02-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1551398400).unwrap().weekday(), Friday); // 2019-03-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1554076800).unwrap().weekday(), Monday); // 2019-04-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1556668800).unwrap().weekday(), Wednesday); // 2019-05-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1559347200).unwrap().weekday(), Saturday); // 2019-06-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1561939200).unwrap().weekday(), Monday); // 2019-07-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1564617600).unwrap().weekday(), Thursday); // 2019-08-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1567296000).unwrap().weekday(), Sunday); // 2019-09-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1569888000).unwrap().weekday(), Tuesday); // 2019-10-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1572566400).unwrap().weekday(), Friday); // 2019-11-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1575158400).unwrap().weekday(), Sunday); // 2019-12-01
        assert_eq!(OffsetDateTime::from_unix_timestamp(1577836800).unwrap().weekday(), Wednesday); // 2020-01-01
    }
}
True
========================================
    use crate::{OffsetDateTime, UtcOffset};
    use time_macros::{datetime, offset};

    #[test]
    fn test_year() {
        assert_eq!(datetime!(2019-01-01 0:00 UTC).year(), 2019);
        assert_eq!(
            OffsetDateTime::from_unix_timestamp(1577836800)
                .unwrap()
                .to_offset(offset!(+1))
                .year(),
            2020
        );
        assert_eq!(datetime!(2020-01-01 0:00 UTC).year(), 2020);
    }
}
False
========================================
    use crate::PrimitiveDateTime; // Import `PrimitiveDateTime` into the scope
    use crate::Time; // Import `Time` into the scope
    use time_macros::{datetime, time};

    #[test]
    fn test_as_hms() {
        assert_eq!(datetime!(2020-01-01 0:00:00).as_hms(), (0, 0, 0));
        assert_eq!(datetime!(2020-01-01 23:59:59).as_hms(), (23, 59, 59));
        assert_eq!(datetime!(2020-01-01 12:34:56).as_hms(), (12, 34, 56));
    }

    #[test]
    fn test_as_hms_with_midnight() {
        let time = time!(0:00:00);
        let dt = PrimitiveDateTime::new(crate::Date::MIN, time);
        assert_eq!(dt.as_hms(), (0, 0, 0));
    }

    #[test]
    fn test_as_hms_with_noon() {
        let time = time!(12:00:00);
        let dt = PrimitiveDateTime::new(crate::Date::MIN, time);
        assert_eq!(dt.as_hms(), (12, 0, 0));
    }

    #[test]
    fn test_as_hms_with_last_second() {
        let time = time!(23:59:59);
        let dt = PrimitiveDateTime::new(crate::Date::MIN, time);
        assert_eq!(dt.as_hms(), (23, 59, 59));
    }

    #[test]
    fn test_as_hms_with_subsecond() {
        let time = time!(12:34:56.789_012_345);
        let dt = PrimitiveDateTime::new(crate::Date::MIN, time);
        assert_eq!(dt.as_hms(), (12, 34, 56));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::ext::NumericalDuration;
    use crate::macros::datetime;

    #[test]
    fn as_hms_micro_midnight() {
        let dt = datetime!(2020-01-01 0:00:00);
        assert_eq!(dt.as_hms_micro(), (0, 0, 0, 0));
    }

    #[test]
    fn as_hms_micro_noon() {
        let dt = datetime!(2020-01-01 12:00:00);
        assert_eq!(dt.as_hms_micro(), (12, 0, 0, 0));
    }

    #[test]
    fn as_hms_micro_last_micro_of_day() {
        let dt = datetime!(2020-01-01 23:59:59.999_999);
        assert_eq!(dt.as_hms_micro(), (23, 59, 59, 999_999));
    }

    #[test]
    fn as_hms_micro_arbitrary() {
        let dt = datetime!(2020-01-01 13:45:30.123_456);
        assert_eq!(dt.as_hms_micro(), (13, 45, 30, 123_456));
    }

    #[test]
    fn as_hms_micro_add_duration() {
        let dt = datetime!(2020-01-01 13:45:30.123_456);
        let new_dt = dt + 1.hours() + 30.minutes() + 15.seconds() + 432.milliseconds() + 123_456.microseconds();
        assert_eq!(new_dt.as_hms_micro(), (15, 15, 45, 678_912));
    }

    #[test]
    fn as_hms_micro_sub_duration() {
        let dt = datetime!(2020-01-01 13:45:30.123_456);
        let new_dt = dt - 2.hours() - 15.minutes() - 45.seconds() - 123.milliseconds() - 456.microseconds();
        assert_eq!(new_dt.as_hms_micro(), (11, 29, 44, 999_000));
    }
}
False
========================================
    use super::*;

use crate::*;
    use time_macros::{date, datetime, time};
    use crate::error::ComponentRange;

    #[test]
    fn as_hms_milli() {
        // Regular cases
        assert_eq!(
            datetime!(2020-01-01 0:00:00).as_hms_milli(),
            (0, 0, 0, 0)
        );
        assert_eq!(
            datetime!(2020-01-01 23:59:59.999).as_hms_milli(),
            (23, 59, 59, 999)
        );
        // Test values within the hour
        assert_eq!(
            datetime!(2020-01-01 14:30:15.230).as_hms_milli(),
            (14, 30, 15, 230)
        );
        assert_eq!(
            datetime!(2020-01-01 2:45:7.8).as_hms_milli(),
            (2, 45, 7, 8)
        );

        // Erroneous cases
        let err_time = Time::from_hms_milli(23, 59, 59, 1000).unwrap_err();
        assert_eq!(
            PrimitiveDateTime::new(date!(2020-01-01), err_time.as_hms_milli().unwrap_err()).as_hms_milli(),
            Err(ComponentRange {
                name: "millisecond",
                value: 1000,
                minimum: 0,
                maximum: 999,
                conditional_range: false,
            }),
        );
    }
}
False
========================================
    use crate::{ext::NumericalDuration, macros::datetime, PrimitiveDateTime};

    #[test]
    fn as_hms_nano_midnight() {
        assert_eq!(
            PrimitiveDateTime::new(crate::Date::from_calendar_date(2020, crate::Month::January, 1).unwrap(), crate::Time::MIDNIGHT).as_hms_nano(),
            (0, 0, 0, 0)
        );
    }

    #[test]
    fn as_hms_nano_noon() {
        assert_eq!(
            datetime!(2020-01-01 12:00).as_hms_nano(),
            (12, 0, 0, 0)
        );
    }

    #[test]
    fn as_hms_nano_generic_time() {
        assert_eq!(
            datetime!(2020-01-01 23:59:59).as_hms_nano(),
            (23, 59, 59, 0)
        );
    }

    #[test]
    fn as_hms_nano_precise_time() {
        assert_eq!(
            datetime!(2020-01-01 23:59:59.999_999_999).as_hms_nano(),
            (23, 59, 59, 999_999_999)
        );
    }

    #[test]
    fn as_hms_nano_with_duration() {
        assert_eq!(
            (datetime!(2020-01-01 0:00) + 1.hours() + 2.minutes() + 3.seconds() + 4.milliseconds()).as_hms_nano(),
            (1, 2, 3, 4_000_000)
        );
    }

    #[test]
    fn as_hms_nano_with_negative_duration() {
        assert_eq!(
            (datetime!(2020-01-01 1:2:3) - 1.hours() - 2.minutes() - 3.seconds()).as_hms_nano(),
            (0, 0, 0, 0)
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::OffsetDateTime;
    use crate::UtcOffset;
    use time_macros::datetime;

    #[test]
    fn assume_offset() {
        assert_eq!(
            datetime!(2019-01-01 0:00).assume_offset(UtcOffset::UTC).unix_timestamp(),
            1_546_300_800,
        );
        assert_eq!(
            datetime!(2019-01-01 0:00).assume_offset(UtcOffset::hours_minus_1()).unix_timestamp(),
            1_546_304_400,
        );
        assert_eq!(
            datetime!(2019-01-01 0:00).assume_offset(UtcOffset::hours_1()).unix_timestamp(),
            1_546_297_200,
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::OffsetDateTime;
    use time_macros::{datetime, offset};

    #[test]
    fn assume_utc_midnight() {
        let primitive = datetime!(2022-01-01 0:00);
        let offset = primitive.assume_utc();
        assert_eq!(offset, datetime!(2022-01-01 0:00).assume_utc());
    }

    #[test]
    fn assume_utc_noon() {
        let primitive = datetime!(2022-06-15 12:00);
        let offset = primitive.assume_utc();
        assert_eq!(offset, datetime!(2022-06-15 12:00).assume_utc());
    }

    #[test]
    fn assume_utc_last_second() {
        let primitive = datetime!(2022-12-31 23:59:59);
        let offset = primitive.assume_utc();
        assert_eq!(offset, datetime!(2022-12-31 23:59:59).assume_utc());
    }

    #[test]
    fn assume_utc_with_offset() {
        let primitive = datetime!(2022-01-01 0:00);
        let offset = primitive.assume_offset(offset!(UTC));
        assert_eq!(offset, datetime!(2022-01-01 0:00).assume_utc());
    }

    #[test]
    fn assume_utc_leap_year() {
        let primitive = datetime!(2020-02-29 0:00);
        let offset = primitive.assume_utc();
        assert_eq!(offset, datetime!(2020-02-29 0:00).assume_utc());
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::ext::NumericalDuration;
    use time_macros::datetime;

    #[test]
    fn checked_add_with_overflow() {
        let datetime_min = PrimitiveDateTime::MIN;
        let datetime_max = PrimitiveDateTime::MAX;
        assert_eq!(datetime_min.checked_add((-2).days()), None);
        assert_eq!(datetime_max.checked_add(1.days()), None);
    }

    #[test]
    fn checked_add_without_overflow() {
        assert_eq!(
            datetime!(2019 - 11 - 25 15:30).checked_add(27.hours()),
            Some(datetime!(2019 - 11 - 26 18:30))
        );
    }
}
False
========================================
    use crate::{PrimitiveDateTime, Date, Duration};
    use crate::ext::NumericalDuration;
    use time_macros::datetime;

    #[test]
    fn checked_sub_underflow() {
        let datetime = Date::MIN.midnight();
        assert_eq!(datetime.checked_sub(2.days()), None);
    }

    #[test]
    fn checked_sub_beginning_of_time() {
        let datetime = Date::MIN.midnight();
        assert_eq!(datetime.checked_sub(Duration::MIN), None);
    }

    #[test]
    fn checked_sub_with_duration() {
        assert_eq!(
            datetime!(2019 - 11 - 25 15:30).checked_sub(27.hours()),
            Some(datetime!(2019 - 11 - 24 12:30))
        );
    }
}
False
========================================
    use crate::{Date, PrimitiveDateTime, Time};
    use time_macros::{date, datetime, time};

    #[test]
    fn test_date() {
        let datetime = datetime!(2022-04-29 12:34:56);
        assert_eq!(datetime.date(), date!(2022-04-29));
    }

    #[test]
    #[should_panic(expected = "day out of range")]
    fn test_date_invalid() {
        let datetime = PrimitiveDateTime::new(Date::from_calendar_date(2022, crate::Month::February, 30).unwrap(), Time::from_hms(12,34,56).unwrap());
        datetime.date();
    }
}
False
========================================
#[cfg(test)]
mod unit_tests {
    use crate::{Date, PrimitiveDateTime, Time};

    #[test]
    fn test_day() {
        use time_macros::{datetime, date};

        assert_eq!(datetime!(2023-03-14 12:00).day(), 14);
        assert_eq!(datetime!(2023-03-01 00:00).day(), 1);
        assert_eq!(datetime!(2023-01-01 23:59:59).day(), 1);
        assert_eq!(datetime!(2023-02-28 00:00).day(), 28);
        assert_eq!(datetime!(2023-12-31 12:30:45).day(), 31);
        assert_eq!(datetime!(2023-07-15 12:30:45).replace_date(date!(2023-08-30)).day(), 30);
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use time_macros::datetime;

    #[test]
    fn hour() {
        assert_eq!(PrimitiveDateTime::new(datetime!(2019-01-01 0:00)).hour(), 0);
        assert_eq!(PrimitiveDateTime::new(datetime!(2019-01-01 23:59:59)).hour(), 23);
        assert_eq!(PrimitiveDateTime::new(datetime!(2019-01-01 12:00:00)).hour(), 12);
        assert_eq!(PrimitiveDateTime::new(datetime!(2019-01-01 1:23:45)).hour(), 1);
    }
}
False
========================================
#[cfg(test)]
mod iso_week_tests {
    use crate::PrimitiveDateTime;
    use time_macros::datetime;

    #[test]
    fn iso_week() {
        assert_eq!(datetime!(2019-01-01 0:00).iso_week(), 1);
        assert_eq!(datetime!(2019-10-04 0:00).iso_week(), 40);
        assert_eq!(datetime!(2020-01-01 0:00).iso_week(), 1);
        assert_eq!(datetime!(2020-12-31 0:00).iso_week(), 53);
        assert_eq!(datetime!(2021-01-01 0:00).iso_week(), 53);
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use time_macros::datetime;

    #[test]
    fn microsecond() {
        assert_eq!(datetime!(2019-01-01 0:00:00.0).microsecond(), 0);
        assert_eq!(datetime!(2019-01-01 23:59:59.999_999).microsecond(), 999_999);
        assert_eq!(datetime!(2019-01-01 0:00:00.000_001).microsecond(), 1);
    }
}
False
========================================
    use crate::{PrimitiveDateTime, Time};
    use crate::date::Date;
    use crate::Month;
    use time_macros::datetime;

    #[test]
    fn millisecond() {
        assert_eq!(datetime!(2019-01-01 0:00).millisecond(), 0);
        assert_eq!(datetime!(2019-01-01 23:59:59.001).millisecond(), 1);
        assert_eq!(datetime!(2019-01-01 23:59:59.010).millisecond(), 10);
        assert_eq!(datetime!(2019-01-01 23:59:59.100).millisecond(), 100);
        assert_eq!(datetime!(2019-01-01 23:59:59.999).millisecond(), 999);
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::macros::datetime;

    #[test]
    fn minute() {
        assert_eq!(datetime!(2020-01-01 0:00).minute(), 0);
        assert_eq!(datetime!(2020-01-01 23:59:59).minute(), 59);
        assert_eq!(datetime!(2020-01-01 12:34:56).minute(), 34);
        assert_eq!(datetime!(2020-01-01 12:00:00).minute(), 0);
        assert_eq!(datetime!(2020-01-01 12:00:59).minute(), 0);
        assert_eq!(datetime!(2020-01-01 12:45:00).minute(), 45);
    }
}
False
========================================
    use crate::{PrimitiveDateTime, Time};
    use crate::ext::NumericalStdDuration; // Import extensions for std::crate::Duration if needed
    use time_macros::datetime;
    use core::ops::Sub; // This import is unused and can be removed unless actually used in tests

    #[test]
    fn monday_based_week() {
        assert_eq!(datetime!(2019-01-01 0:00).monday_based_week(), 0);
        assert_eq!(datetime!(2020-01-01 0:00).monday_based_week(), 0);
        assert_eq!(datetime!(2020-12-31 0:00).monday_based_week(), 52);
        assert_eq!(datetime!(2021-01-01 0:00).monday_based_week(), 0);
        assert_eq!(datetime!(2021-12-27 0:00).monday_based_week(), 52); // Monday
        assert_eq!(datetime!(2021-12-28 0:00).monday_based_week(), 52); // Tuesday
        assert_eq!(datetime!(2021-12-29 0:00).monday_based_week(), 52); // Wednesday
        assert_eq!(datetime!(2021-12-30 0:00).monday_based_week(), 52); // Thursday
        assert_eq!(datetime!(2021-12-31 0:00).monday_based_week(), 52); // Friday
        assert_eq!(datetime!(2022-01-01 0:00).monday_based_week(), 0);  // Saturday
        assert_eq!(datetime!(2022-01-02 0:00).monday_based_week(), 0);  // Sunday
        assert_eq!(datetime!(2022-01-03 0:00).monday_based_week(), 1);  // Monday
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::Month::*;
    use time_macros::datetime;

    #[test]
    fn test_month() {
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-01-01), crate::time!(0:00)).month(), January);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-02-01), crate::time!(0:00)).month(), February);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-03-01), crate::time!(0:00)).month(), March);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-04-01), crate::time!(0:00)).month(), April);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-05-01), crate::time!(0:00)).month(), May);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-06-01), crate::time!(0:00)).month(), June);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-07-01), crate::time!(0:00)).month(), July);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-08-01), crate::time!(0:00)).month(), August);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-09-01), crate::time!(0:00)).month(), September);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-10-01), crate::time!(0:00)).month(), October);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-11-01), crate::time!(0:00)).month(), November);
        assert_eq!(PrimitiveDateTime::new(crate::date!(2020-12-01), crate::time!(0:00)).month(), December);
    }
}
False
========================================
#[cfg(test)]
mod nanosecond_tests {
    use crate::PrimitiveDateTime; // Adjusted the import path here
    use time_macros::datetime; // Fixed the import path for the `datetime!` macro

    #[test]
    fn nanosecond() {
        assert_eq!(datetime!(2019-01-01 0:00).nanosecond(), 0);
        assert_eq!(datetime!(2019-01-01 23:59:59.999_999_999).nanosecond(), 999_999_999);
        assert_eq!(datetime!(2020-02-29 13:59).nanosecond(), 0);
        assert_eq!(datetime!(2020-02-29 13:59:59.123_456_789).nanosecond(), 123_456_789);
    }
}
False
========================================
    use crate::date::Date;
    use crate::crate::Time;
    use crate::primitive_date_crate::PrimitiveDateTime;
    use time_macros::{date, time};

    #[test]
    fn new_test() {
        let date = date!(2022-02-27);
        let time = time!(12:34:56.789_012_345);
        let primitive_date_time = PrimitiveDateTime::new(date, time);

        assert_eq!(primitive_date_time.date(), date);
        assert_eq!(primitive_date_time.time(), time);
    }
}
False
========================================
    use crate::primitive_date_crate::PrimitiveDateTime;
    use crate::Duration;
    use time_macros::{datetime, date, time};

    #[test]
    fn ordinal_common_year() {
        assert_eq!(PrimitiveDateTime::new(date!(2019-01-01), time!(0:00)).ordinal(), 1);
        assert_eq!(PrimitiveDateTime::new(date!(2019-12-31), time!(0:00)).ordinal(), 365);
    }

    #[test]
    fn ordinal_leap_year() {
        assert_eq!(PrimitiveDateTime::new(date!(2020-01-01), time!(0:00)).ordinal(), 1);
        assert_eq!(PrimitiveDateTime::new(date!(2020-12-31), time!(0:00)).ordinal(), 366);
    }

    #[test]
    fn ordinal_various_dates() {
        assert_eq!(PrimitiveDateTime::new(date!(2021-03-14), time!(0:00)).ordinal(), 73);
        assert_eq!(PrimitiveDateTime::new(date!(2022-02-28), time!(0:00)).ordinal(), 59);
        assert_eq!(PrimitiveDateTime::new(date!(2024-02-29), time!(0:00)).ordinal(), 60);
    }

    #[test]
    #[should_panic(expected = "overflow adding duration to date")]
    fn ordinal_overflow() {
        let _ = PrimitiveDateTime::new(date!(2021-01-01), time!(0:00)) + Duration::days(i64::MAX);
    }

    #[test]
    #[should_panic(expected = "overflow adding duration to date")]
    fn ordinal_underflow() {
        let _ = PrimitiveDateTime::new(date!(2021-01-01), time!(0:00)) + Duration::days(i64::MIN);
    }
}
False
========================================
    use crate::PrimitiveDateTime; // Correct the path
    use crate::Time; // Correct the path
    use crate::Date; // Correct the path
    use time_macros::{datetime, date, time};

    #[test]
    fn replace_date_preserves_time() {
        let initial_datetime = datetime!(2020-01-01 12:34:56.789_012_345);
        let new_date = date!(2022-03-04);
        let new_datetime = initial_datetime.replace_date(new_date);
        assert_eq!(new_datetime, datetime!(2022-03-04 12:34:56.789_012_345));
    }

    #[test]
    fn replace_date_changes_date() {
        let initial_datetime = datetime!(2020-01-01 12:34:56.789_012_345);
        let new_date = date!(2022-03-04);
        let new_datetime = initial_datetime.replace_date(new_date);
        assert_eq!(new_datetime.date(), new_date);
    }

    #[test]
    fn replace_date_retains_time() {
        let initial_datetime = datetime!(2020-01-01 12:34:56.789_012_345);
        let new_date = date!(2022-03-04);
        let new_datetime = initial_datetime.replace_date(new_date);
        assert_eq!(new_datetime.time(), time!(12:34:56.789_012_345));
    }
}
False
========================================
    use crate::PrimitiveDateTime; // Import PrimitiveDateTime from the current crate
    use crate::error; // Import error from the current crate
    use crate::macros::datetime; // Import the datetime! macro from the time crate

    #[test]
    fn replace_day_valid() {
        assert_eq!(
            PrimitiveDateTime::new(datetime!(2022-02-18 12:00).date(), datetime!(2022-02-18 12:00).time())
                .replace_day(1),
            Ok(PrimitiveDateTime::new(datetime!(2022-02-01 12:00).date(), datetime!(2022-02-01 12:00).time()))
        );
    }

    #[test]
    fn replace_day_invalid_zero() {
        assert!(matches!(
            PrimitiveDateTime::new(datetime!(2022-02-18 12:00).date(), datetime!(2022-02-18 12:00).time())
                .replace_day(0),
            Err(error::ComponentRange { .. })
        ));
    }

    #[test]
    fn replace_day_invalid_overflow() {
        assert!(matches!(
            PrimitiveDateTime::new(datetime!(2022-02-18 12:00).date(), datetime!(2022-02-18 12:00).time())
                .replace_day(30),
            Err(error::ComponentRange { .. })
        ));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use time_macros::datetime;

    #[test]
    fn replace_hour_valid() {
        assert_eq!(
            PrimitiveDateTime::new(Date::from_calendar_date(2022, Month::February, 18).unwrap(), time!(01:02:03))
                .replace_hour(7),
            Ok(PrimitiveDateTime::new(Date::from_calendar_date(2022, Month::February, 18).unwrap(), time!(07:02:03)))
        );
    }

    #[test]
    fn replace_hour_invalid() {
        assert_eq!(
            PrimitiveDateTime::new(Date::from_calendar_date(2022, Month::February, 18).unwrap(), time!(01:02:03))
                .replace_hour(24),
            Err(ComponentRange::new("hour", 24, 0, 23))
        );
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::OffsetDateTime;
    use time_macros::{datetime, offset};

    #[test]
    fn replace_microsecond_valid() {
        let dt = datetime!(2022-02-18 01:02:03.004_005_006);
        assert_eq!(
            dt.replace_microsecond(123_456),
            Ok(datetime!(2022-02-18 01:02:03.123_456))
        );
    }

    #[test]
    fn replace_microsecond_invalid() {
        let dt = datetime!(2022-02-18 01:02:03.004_005_006);
        assert_eq!(
            dt.replace_microsecond(1_000_000),
            Err(ComponentRange {
                name: "microsecond",
                value: 1_000_000,
                minimum: 0,
                maximum: 999_999,
                conditional_range: false,
            })
        );
    }

    #[test]
    fn replace_microsecond_edge_cases() {
        let dt = datetime!(2022-02-18 01:02:03.004_005_006);
        assert_eq!(
            dt.replace_microsecond(0),
            Ok(datetime!(2022-02-18 01:02:03))
        );
        assert_eq!(
            dt.replace_microsecond(999_999),
            Ok(datetime!(2022-02-18 01:02:03.999_999))
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use time_macros::datetime;
    use crate::error::ComponentRange;

    #[test]
    fn replace_millisecond_valid() {
        let original = datetime!(2022-02-18 01:02:03.004_005_006);
        let expected = datetime!(2022-02-18 01:02:03.007);
        assert_eq!(
            original.replace_millisecond(7),
            Ok(expected)
        );
    }

    #[test]
    fn replace_millisecond_invalid() {
        let original = datetime!(2022-02-18 01:02:03.004_005_006);
        let err = original.replace_millisecond(1_000);
        assert!(matches!(err, Err(ComponentRange { .. })));
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::error;
    use time_macros::datetime;

    #[test]
    fn replace_minute_valid() {
        assert_eq!(
            datetime!(2022-02-18 1:02:03.004_005_006)
                .replace_minute(7)
                .unwrap(),
            datetime!(2022-02-18 1:07:03.004_005_006)
        );
    }

    #[test]
    fn replace_minute_invalid() {
        assert!(matches!(
            datetime!(2022-02-18 1:02:03.004_005_006).replace_minute(60),
            Err(error::ComponentRange { .. })
        ));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Month::*;
    use crate::error::ComponentRange;

    #[test]
    fn replace_month_valid() {
        assert_eq!(
            PrimitiveDateTime::new(Date::from_calendar_date(2022, February, 15).unwrap(), Time::MIDNIGHT)
                .replace_month(January),
            Ok(PrimitiveDateTime::new(Date::from_calendar_date(2022, January, 15).unwrap(), Time::MIDNIGHT))
        );
    }

    #[test]
    fn replace_month_invalid() {
        assert_eq!(
            PrimitiveDateTime::new(Date::from_calendar_date(2022, January, 30).unwrap(), Time::MIDNIGHT)
                .replace_month(February),
            Err(ComponentRange {
                name: "day",
                value: 30,
                minimum: 1,
                maximum: 29,
                conditional_range: true,
            })
        );
    }
}
True
========================================
    use super::*;

use crate::*;

    use crate::macros::datetime;

    #[test]
    fn test_replace_nanosecond_valid() {
        assert_eq!(
            datetime!(2022 - 02 - 18 01:02:03.004_005_006)
                .replace_nanosecond(7_008_009)
                .unwrap(),
            datetime!(2022 - 02 - 18 01:02:03.007_008_009)
        );
    }

    #[test]
    fn test_replace_nanosecond_invalid() {
        assert!(datetime!(2022 - 02 - 18 01:02:03.004_005_006)
            .replace_nanosecond(1_000_000_000)
            .is_err());
    }
}
False
========================================
#[cfg(test)]
mod replace_second_tests {
    use crate::PrimitiveDateTime;
    use crate::Time;
    use crate::Date;
    use time_macros::{datetime, time, date};

    #[test]
    fn replace_second_valid() {
        assert_eq!(
            datetime!(2022 - 02 - 18 01:02:03).replace_second(7),
            Ok(datetime!(2022 - 02 - 18 01:02:07))
        );
    }

    #[test]
    fn replace_second_invalid() {
        assert!(matches!(
            datetime!(2022 - 02 - 18 01:02:03).replace_second(60),
            Err(crate::error::ComponentRange { .. })
        ));
    }

    #[test]
    fn replace_second_boundary() {
        assert_eq!(
            datetime!(2022 - 02 - 18 01:02:03).replace_second(59),
            Ok(datetime!(2022 - 02 - 18 01:02:59))
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::Time;
    use crate::time_macros::{datetime, time};

    #[test]
    fn test_replace_time() {
        assert_eq!(
            datetime!(2020-01-01 17:00).replace_time(time!(5:00)),
            datetime!(2020-01-01 5:00)
        );
        assert_eq!(
            datetime!(2020-01-01 0:00).replace_time(time!(23:59)),
            datetime!(2020-01-01 23:59)
        );
        assert_eq!(
            datetime!(2020-01-01 0:00).replace_time(time!(12:34:56)),
            datetime!(2020-01-01 12:34:56)
        );
        assert_eq!(
            datetime!(2020-01-01 0:00).replace_time(time!(5:30:45)),
            datetime!(2020-01-01 5:30:45)
        );
        assert_eq!(
            datetime!(2020-01-01 0:00).replace_time(time!(23:59:59)),
            datetime!(2020-01-01 23:59:59)
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::error::ComponentRange;
    use crate::date;
    use crate::Time; // The error indicates time needs to be in scope
    use time_macros::datetime;

    #[test]
    fn test_replace_year() {
        // Normal replacement
        assert_eq!(
            datetime!(2022 - 02 - 18 12:00).replace_year(2019),
            Ok(datetime!(2019 - 02 - 18 12:00))
        );

        // Year replacement leading to a valid leap day (from a leap year to another leap year)
        assert_eq!(
            datetime!(2020 - 02 - 29 12:00).replace_year(2016),
            Ok(datetime!(2016 - 02 - 29 12:00))
        );

        // Year replacement leading to an invalid leap day (from a leap year to a common year)
        assert_eq!(
            datetime!(2020 - 02 - 29 12:00).replace_year(2019),
            Err(ComponentRange {
                name: "day",
                minimum: 1,
                maximum: 28,
                value: 29,
                conditional_range: true,
            })
        );

        // Replacement leading to an underflow error
        assert_eq!(
            datetime!(2022 - 02 - 18 12:00).replace_year(date::MIN_YEAR - 1), // Use date::MIN_YEAR
            Err(ComponentRange {
                name: "year",
                minimum: date::MIN_YEAR as i64, // Cast to i64
                maximum: date::MAX_YEAR as i64, // Cast to i64
                value: date::MIN_YEAR as i64 - 1, // Cast to i64 and subtract 1
                conditional_range: false,
            })
        );

        // Replacement leading to an overflow error
        assert_eq!(
            datetime!(2022 - 02 - 18 12:00).replace_year(date::MAX_YEAR + 1), // Use date::MAX_YEAR
            Err(ComponentRange {
                name: "year",
                minimum: date::MIN_YEAR as i64, // Cast to i64
                maximum: date::MAX_YEAR as i64, // Cast to i64
                value: date::MAX_YEAR as i64 + 1, // Cast to i64 and add 1
                conditional_range: false,
            })
        );
    }
}
False
========================================
#[cfg(test)]
mod saturating_add_tests {
    use crate::Duration; // Use the current crate
    use crate::PrimitiveDateTime; // Use the current crate
    use crate::ext::NumericalDuration; // Use the extension trait for numerical methods
    use time_macros::datetime; // Use the `time_macros` crate for the `datetime!` macro

    #[test]
    fn saturating_add_duration() {
        // Saturating at MIN
        assert_eq!(
            PrimitiveDateTime::MIN.saturating_add((-2).days()),
            PrimitiveDateTime::MIN
        );
        // Saturating at MAX
        assert_eq!(
            PrimitiveDateTime::MAX.saturating_add(2.days()),
            PrimitiveDateTime::MAX
        );
        // Adding within bounds
        assert_eq!(
            datetime!(2019 - 11 - 25 15:30).saturating_add(27.hours()),
            datetime!(2019 - 11 - 26 18:30)
        );
    }
}
False
========================================
    use crate::{Duration, PrimitiveDateTime};
    use crate::ext::NumericalDuration;
    use time_macros::datetime;

    #[test]
    fn saturating_sub() {
        assert_eq!(
            PrimitiveDateTime::MIN.saturating_sub(2.days()),
            PrimitiveDateTime::MIN
        );
        assert_eq!(
            PrimitiveDateTime::MAX.saturating_sub((-2).days()),
            PrimitiveDateTime::MAX
        );
        assert_eq!(
            datetime!(2019-11-25 15:30).saturating_sub(27.hours()),
            datetime!(2019-11-24 12:30)
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::macros::{datetime, time};

    #[test]
    fn second() {
        assert_eq!(datetime!(2023-04-01 12:00).second(), 0);
        assert_eq!(datetime!(2023-04-01 12:00:59).second(), 59);
        assert_eq!(datetime!(2023-04-01 23:59:59).second(), 59);
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use time_macros::datetime;

    #[test]
    fn sunday_based_week() {
        assert_eq!(datetime!(2019-01-01 0:00).sunday_based_week(), 0);
        assert_eq!(datetime!(2020-01-01 0:00).sunday_based_week(), 0);
        assert_eq!(datetime!(2020-12-31 0:00).sunday_based_week(), 52);
        assert_eq!(datetime!(2021-01-01 0:00).sunday_based_week(), 0);
        // Additional test cases
        assert_eq!(datetime!(2019-12-29 0:00).sunday_based_week(), 52); // 2019-12-29 is a Sunday
        assert_eq!(datetime!(2019-12-30 0:00).sunday_based_week(), 52); // 2019-12-30 is a Monday
        assert_eq!(datetime!(2020-12-27 0:00).sunday_based_week(), 52); // 2020-12-27 is a Sunday
        assert_eq!(datetime!(2020-12-28 0:00).sunday_based_week(), 52); // 2020-12-28 is a Monday
        assert_eq!(datetime!(2021-12-26 0:00).sunday_based_week(), 51); // 2021-12-26 is a Sunday
        assert_eq!(datetime!(2021-12-27 0:00).sunday_based_week(), 52); // 2021-12-27 is a Monday
    }
}
False
========================================
    use crate::OffsetDateTime;
    use crate::Time;
    use time_macros::{datetime, time};

    #[test]
    fn test_time_component() {
        assert_eq!(datetime!(2019-01-01 0:00).time(), time!(0:00));
        assert_eq!(datetime!(2019-01-01 23:59:59).time(), time!(23:59:59));
        assert_eq!(datetime!(2019-12-31 12:34:56).time(), time!(12:34:56));
        assert_eq!(datetime!(2020-02-29 23:59).time(), time!(23:59));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Month::*;

    #[test]
    fn test_to_calendar_date() {
        use crate::date::Date;
        use crate::crate::Time;
        use crate::PrimitiveDateTime;
        use crate::Month::*;

        // Assert a regular date
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2022, April, 19).unwrap(),
                Time::from_hms(14, 15, 16).unwrap()
            )
            .to_calendar_date(),
            (2022, April, 19)
        );

        // Assert date on a leap year
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2020, February, 29).unwrap(),
                Time::from_hms(0, 0, 0).unwrap()
            )
            .to_calendar_date(),
            (2020, February, 29)
        );

        // Assert date on a year with only 365 days
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2021, February, 28).unwrap(),
                Time::from_hms(23, 59, 59).unwrap()
            )
            .to_calendar_date(),
            (2021, February, 28)
        );

        // Assert a date on year's boundary
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(1999, December, 31).unwrap(),
                Time::from_hms(23, 59, 59).unwrap()
            )
            .to_calendar_date(),
            (1999, December, 31)
        );

        // Assert a date with time at midnight
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(1999, December, 31).unwrap(),
                Time::MIDNIGHT
            )
            .to_calendar_date(),
            (1999, December, 31)
        );

        // Assert on year's beginning
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2023, January, 1).unwrap(),
                Time::from_hms(0, 0, 1).unwrap()
            )
            .to_calendar_date(),
            (2023, January, 1)
        );

        // Assert on a leap year with time just before midnight
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2020, February, 28).unwrap(),
                Time::from_hms(23, 59, 59).unwrap()
            )
            .to_calendar_date(),
            (2020, February, 28)
        );

        // Assert on a leap year with time just after midnight
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2020, February, 29).unwrap(),
                Time::from_hms(0, 0, 1).unwrap()
            )
            .to_calendar_date(),
            (2020, February, 29)
        );

        // Assert on a year with only 365 days with time just after midnight
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2021, January, 1).unwrap(),
                Time::from_hms(0, 0, 1).unwrap()
            )
            .to_calendar_date(),
            (2021, January, 1)
        );

        // Assert on a year with only 365 days with time just before midnight
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(2021, December, 31).unwrap(),
                Time::from_hms(23, 59, 59).unwrap()
            )
            .to_calendar_date(),
            (2021, December, 31)
        );

        // Assert with a date in the year 1
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(1, January, 1).unwrap(),
                Time::from_hms_nano(0, 0, 0, 1).unwrap()
            )
            .to_calendar_date(),
            (1, January, 1)
        );

        // Assert with a date at the year 1 before Christ
        assert_eq!(
            PrimitiveDateTime::new(
                Date::from_calendar_date(-1, December, 31).unwrap(),
                Time::MIDNIGHT
            )
            .to_calendar_date(),
            (-1, December, 31)
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::Weekday::*;
    use time_macros::datetime;

    #[test]
    fn test_to_iso_week_date() {
        assert_eq!(
            datetime!(2019-01-01 0:00).to_iso_week_date(),
            (2019, 1, Tuesday)
        );
        assert_eq!(
            datetime!(2019-10-04 0:00).to_iso_week_date(),
            (2019, 40, Friday)
        );
        assert_eq!(
            datetime!(2020-01-01 0:00).to_iso_week_date(),
            (2020, 1, Wednesday)
        );
        assert_eq!(
            datetime!(2020-12-31 0:00).to_iso_week_date(),
            (2020, 53, Thursday)
        );
        assert_eq!(
            datetime!(2021-01-01 0:00).to_iso_week_date(),
            (2020, 53, Friday)
        );
        assert_eq!(
            datetime!(2019-12-30 0:00).to_iso_week_date(),
            (2020, 1, Monday)
        );
        assert_eq!(
            datetime!(2020-12-21 0:00).to_iso_week_date(),
            (2020, 52, Monday)
        );
    }
}
False
========================================
    use crate::PrimitiveDateTime;
    use crate::duration::Duration;
    use crate::macros::{datetime, time};

    #[test]
    fn to_julian_day_midnight() {
        assert_eq!(datetime!(-4713-11-24 0:00).to_julian_day(), 0);
        assert_eq!(datetime!(2000-01-01 0:00).to_julian_day(), 2_451_545);
        assert_eq!(datetime!(2019-01-01 0:00).to_julian_day(), 2_458_485);
        assert_eq!(datetime!(2019-12-31 0:00).to_julian_day(), 2_458_849);
    }

    #[test]
    fn to_julian_day_non_midnight() {
        assert_eq!(datetime!(-4713-11-24 12:00).to_julian_day(), 0);
        assert_eq!(datetime!(2000-01-01 12:34:56).to_julian_day(), 2_451_545);
        assert_eq!(datetime!(2019-01-01 23:59:59).to_julian_day(), 2_458_485);
    }

    #[test]
    fn to_julian_day_with_duration() {
        let base = datetime!(2019-01-01 0:00);
        assert_eq!((base + Duration::days(1)).to_julian_day(), 2_458_486);
        assert_eq!((base + Duration::days(-1)).to_julian_day(), 2_458_484);
        assert_eq!(
            (base + Duration::days(365)).to_julian_day(),
            2_458_485 + 365
        );
    }

    #[test]
    fn to_julian_day_with_time_change() {
        let base = datetime!(2019-01-01 0:00);
        assert_eq!(base.replace_time(time!(12:00)).to_julian_day(), 2_458_485);
        assert_eq!(base.replace_time(time!(23:59:59)).to_julian_day(), 2_458_485);
    }
}
False
========================================
    use crate::{Date, PrimitiveDateTime, Time};
    use time_macros::datetime;

    #[test]
    fn to_ordinal_date() {
        assert_eq!(datetime!(2019-01-01 0:00).to_ordinal_date(), (2019, 1));
        assert_eq!(datetime!(2020-01-01 0:00).to_ordinal_date(), (2020, 1));
        assert_eq!(datetime!(2020-02-29 0:00).to_ordinal_date(), (2020, 60));
        assert_eq!(datetime!(2019-12-31 0:00).to_ordinal_date(), (2019, 365));
        assert_eq!(datetime!(2020-12-31 0:00).to_ordinal_date(), (2020, 366));
    }

    #[test]
    fn to_ordinal_date_midyear() {
        assert_eq!(datetime!(2021-06-30 0:00).to_ordinal_date(), (2021, 181));
        assert_eq!(datetime!(2020-06-30 0:00).to_ordinal_date(), (2020, 182));
    }

    #[test]
    fn to_ordinal_date_with_time() {
        assert_eq!(datetime!(2020-01-01 12:34:56).to_ordinal_date(), (2020, 1));
        assert_eq!(datetime!(2019-12-31 23:59:59).to_ordinal_date(), (2019, 365));
    }

    #[test]
    fn to_ordinal_date_edge_cases() {
        assert_eq!(datetime!(-9999-01-01 0:00).to_ordinal_date(), (-9999, 1));
        assert_eq!(datetime!(9999-12-31 0:00).to_ordinal_date(), (9999, 365));
    }

    #[test]
    fn to_ordinal_date_failure_cases() {
        // The `to_ordinal_date` function does not have failure cases, as input validity is checked on construction.
    }
}
False
========================================
    use crate::macros::datetime;
    use crate::Weekday::*;

    #[test]
    fn weekday() {
        assert_eq!(datetime!(2019-01-01 0:00).weekday(), Tuesday);
        assert_eq!(datetime!(2019-02-01 0:00).weekday(), Friday);
        assert_eq!(datetime!(2019-03-01 0:00).weekday(), Friday);
        assert_eq!(datetime!(2019-04-01 0:00).weekday(), Monday);
        assert_eq!(datetime!(2019-05-01 0:00).weekday(), Wednesday);
        assert_eq!(datetime!(2019-06-01 0:00).weekday(), Saturday);
        assert_eq!(datetime!(2019-07-01 0:00).weekday(), Monday);
        assert_eq!(datetime!(2019-08-01 0:00).weekday(), Thursday);
        assert_eq!(datetime!(2019-09-01 0:00).weekday(), Sunday);
        assert_eq!(datetime!(2019-10-01 0:00).weekday(), Tuesday);
        assert_eq!(datetime!(2019-11-01 0:00).weekday(), Friday);
        assert_eq!(datetime!(2019-12-01 0:00).weekday(), Sunday);
    }
}
False
========================================
    use crate::primitive_date_crate::PrimitiveDateTime;
    use crate::Date;
    use crate::Time;
    use time_macros::datetime;

    #[test]
    fn year() {
        assert_eq!(PrimitiveDateTime::new(Date::from_ordinal_date(-10_000, 1).unwrap(), Time::MIDNIGHT).year(), -10_000);
        assert_eq!(datetime!(-0001-01-01 0:00).year(), -1);
        assert_eq!(datetime!(0000-01-01 0:00).year(), 0);
        assert_eq!(datetime!(0001-01-01 0:00).year(), 1);
        assert_eq!(datetime!(2021-01-01 0:00).year(), 2021);
        assert_eq!(datetime!(2022-01-01 0:00).year(), 2022);
        assert_eq!(datetime!(2023-01-01 0:00).year(), 2023);
        assert_eq!(datetime!(9999-01-01 0:00).year(), 9999);
        assert_eq!(PrimitiveDateTime::new(Date::from_ordinal_date(10_000, 1).unwrap(), Time::MIDNIGHT).year(), 10_000);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_hms_nanos_unchecked_valid() {
        let time = Time::__from_hms_nanos_unchecked(12, 34, 56, 789_456_123);
        assert_eq!(time.hour, 12);
        assert_eq!(time.minute, 34);
        assert_eq!(time.second, 56);
        assert_eq!(time.nanosecond, 789_456_123);
    }

    #[test]
    #[should_panic]
    fn test_from_hms_nanos_unchecked_hour_overflow() {
        let _ = Time::__from_hms_nanos_unchecked(24, 0, 0, 0);
    }

    #[test]
    #[should_panic]
    fn test_from_hms_nanos_unchecked_minute_overflow() {
        let _ = Time::__from_hms_nanos_unchecked(0, 60, 0, 0);
    }

    #[test]
    #[should_panic]
    fn test_from_hms_nanos_unchecked_second_overflow() {
        let _ = Time::__from_hms_nanos_unchecked(0, 0, 60, 0);
    }

    #[test]
    #[should_panic]
    fn test_from_hms_nanos_unchecked_nanos_overflow() {
        let _ = Time::__from_hms_nanos_unchecked(0, 0, 0, 1_000_000_000);
    }
}
True
========================================
#[derive(PartialEq, Debug)]
pub(crate) enum DateAdjustment {
    /// The previous day should be used.
    Previous,
    /// The next day should be used.
    Next,
    /// The date should be used as-is.
    None,
}
False
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;

    #[test]
    fn test_adjusting_add_std_wrapping() {
        // Test normal addition without wrapping
        let t = Time {
            hour: 12,
            minute: 34,
            second: 56,
            nanosecond: 789_000_000,
            padding: Padding::Optimize,
        };
        let dur = StdDuration::new(2 * 3600 + 14 * 60 + 7, 123_456_789);
        let (wrapped, new_time) = t.adjusting_add_std(dur);
        assert_eq!(wrapped, false);
        assert_eq!(
            new_time,
            Time {
                hour: 14,
                minute: 49,
                second: 3,
                nanosecond: 912_456_789,
                padding: Padding::Optimize,
            }
        );

        // Test wrapping at end of day
        let t = Time {
            hour: 23,
            minute: 59,
            second: 59,
            nanosecond: 999_999_999,
            padding: Padding::Optimize,
        };
        let dur = StdDuration::new(2, 1); // 2 seconds and 1 nanosecond
        let (wrapped, new_time) = t.adjusting_add_std(dur);
        assert_eq!(wrapped, true);
        assert_eq!(
            new_time,
            Time {
                hour: 0,
                minute: 0,
                second: 2,
                nanosecond: 0,
                padding: Padding::Optimize,
            }
        );

        // Test wrapping with overflow nanoseconds
        let t = Time {
            hour: 23,
            minute: 59,
            second: 58,
            nanosecond: 500_000_000,
            padding: Padding::Optimize,
        };
        let dur = StdDuration::new(2, 1_000_000_000); // 2 seconds and 1,000,000,000 nanoseconds (1 second)
        let (wrapped, new_time) = t.adjusting_add_std(dur);
        assert_eq!(wrapped, true);
        assert_eq!(
            new_time,
            Time {
                hour: 0,
                minute: 0,
                second: 1,
                nanosecond: 500_000_000,
                padding: Padding::Optimize,
            }
        );
    }
}
False
========================================
    use crate::{util::DateAdjustment, Duration, Time};

    #[derive(Debug, PartialEq)]
    enum Adjustment {
        Previous,
        Next,
        None,
    }

    impl From<DateAdjustment> for Adjustment {
        fn from(adj: DateAdjustment) -> Self {
            match adj {
                DateAdjustment::Previous => Self::Previous,
                DateAdjustment::None => Self::None,
                DateAdjustment::Next => Self::Next,
            }
        }
    }

    #[test]
    fn adjusting_sub_no_change() {
        let time = Time::__from_hms_nanos_unchecked(12, 0, 0, 0);
        let duration = Duration::seconds(1);
        let (adjustment, new_time) = time.adjusting_sub(duration);
        assert_eq!(Adjustment::from(adjustment), Adjustment::None);
        assert_eq!(new_time, Time::__from_hms_nanos_unchecked(11, 59, 59, 0));
    }

    #[test]
    fn adjusting_sub_with_date_change() {
        let time = Time::__from_hms_nanos_unchecked(0, 0, 0, 0);
        let duration = Duration::seconds(1);
        let (adjustment, new_time) = time.adjusting_sub(duration);
        assert_eq!(Adjustment::from(adjustment), Adjustment::Previous);
        assert_eq!(new_time, Time::__from_hms_nanos_unchecked(23, 59, 59, 0));
    }

    #[test]
    fn adjusting_sub_with_overflow() {
        let time = Time::__from_hms_nanos_unchecked(0, 0, 0, 500);
        let duration = Duration::new(0, -501);
        let (adjustment, new_time) = time.adjusting_sub(duration);
        assert_eq!(Adjustment::from(adjustment), Adjustment::None);
        assert_eq!(new_time, Time::__from_hms_nanos_unchecked(23, 59, 59, 999_999_999));
    }

    #[test]
    fn adjusting_sub_with_underflow() {
        let time = Time::__from_hms_nanos_unchecked(23, 59, 59, 500);
        let duration = Duration::seconds(60);
        let (adjustment, new_time) = time.adjusting_sub(duration);
        assert_eq!(Adjustment::from(adjustment), Adjustment::None);
        assert_eq!(new_time, Time::__from_hms_nanos_unchecked(23, 58, 59, 500));
    }

    #[test]
    fn adjusting_sub_with_day_change() {
        let time = Time::__from_hms_nanos_unchecked(0, 0, 1, 0);
        let duration = Duration::seconds(2);
        let (adjustment, new_time) = time.adjusting_sub(duration);
        assert_eq!(Adjustment::from(adjustment), Adjustment::Previous);
        assert_eq!(new_time, Time::__from_hms_nanos_unchecked(23, 59, 59, 0));
    }

    #[test]
    fn adjusting_sub_with_nanos() {
        let time = Time::__from_hms_nanos_unchecked(12, 34, 56, 789_123_456);
        let duration = Duration::new(0, -789_123_456);
        let (adjustment, new_time) = time.adjusting_sub(duration);
        assert_eq!(Adjustment::from(adjustment), Adjustment::None);
        assert_eq!(new_time, Time::__from_hms_nanos_unchecked(12, 34, 57, 0));
    }

    #[test]
    fn adjusting_sub_with_zero() {
        let time = Time::__from_hms_nanos_unchecked(12, 34, 56, 0);
        let duration = Duration::new(0, 0);
        let (adjustment, new_time) = time.adjusting_sub(duration);
        assert_eq!(Adjustment::from(adjustment), Adjustment::None);
        assert_eq!(new_time, Time::__from_hms_nanos_unchecked(12, 34, 56, 0));
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::crate::Duration as StdDuration;
    use crate::Duration;

    #[test]
    fn adjusting_sub_std_wraps_on_subsec_overflow() {
        // Set initial time and subsec to subtract
        let initial_time = Time::__from_hms_nanos_unchecked(0, 0, 0, 500_000_000);
        let subsec_to_sub  = StdDuration::from_nanos(600_000_000);

        // Expected result is previous day and time wrapped to 23:59:59.900_000_000
        let expected = (true, Time::__from_hms_nanos_unchecked(23, 59, 59, 900_000_000));

        assert_eq!(initial_time.adjusting_sub_std(subsec_to_sub), expected);
    }

    #[test]
    fn adjusting_sub_std_wraps_on_second_overflow() {
        // Set initial time and seconds to subtract
        let initial_time = Time::__from_hms_nanos_unchecked(0, 0, 0, 0);
        let seconds_to_sub = StdDuration::from_secs(1);

        // Expected result is previous day and time wrapped to 23:59:59.0
        let expected = (true, Time::__from_hms_nanos_unchecked(23, 59, 59, 0));

        assert_eq!(initial_time.adjusting_sub_std(seconds_to_sub), expected);
    }

    #[test]
    fn adjusting_sub_std_wraps_on_minute_overflow() {
        // Set initial time and minutes to subtract
        let initial_time = Time::__from_hms_nanos_unchecked(0, 0, 0, 0);
        let minutes_to_sub = StdDuration::from_secs(60);

        // Expected result is previous day and time wrapped to 23:59:0.0
        let expected = (true, Time::__from_hms_nanos_unchecked(23, 59, 0, 0));

        assert_eq!(initial_time.adjusting_sub_std(minutes_to_sub), expected);
    }

    #[test]
    fn adjusting_sub_std_wraps_on_hour_overflow() {
        // Set initial time and hours to subtract
        let initial_time = Time::__from_hms_nanos_unchecked(0, 0, 0, 0);
        let hours_to_sub   = StdDuration::from_secs(3600);

        // Expected result is previous day and time wrapped to 23:0:0.0
        let expected = (true, Time::__from_hms_nanos_unchecked(23, 0, 0, 0));

        assert_eq!(initial_time.adjusting_sub_std(hours_to_sub), expected);
    }

    #[test]
    fn adjusting_sub_std_no_overflow() {
        // Set initial time and duration to subtract
        let initial_time = Time::__from_hms_nanos_unchecked(12, 0, 0, 0);
        let duration_to_sub = StdDuration::from_secs(3600);

        // Expected result is same day and time subtracted by one hour
        let expected = (false, Time::__from_hms_nanos_unchecked(11, 0, 0, 0));

        assert_eq!(initial_time.adjusting_sub_std(duration_to_sub), expected);
    }

    #[test]
    fn adjusting_sub_std_full_day() {
        // Set initial time and full day to subtract
        let initial_time = Time::__from_hms_nanos_unchecked(0, 0, 0, 0);
        let full_day_to_sub = StdDuration::from_secs(86400);

        // Expected result is same day because subtracting full day
        let expected = (true, Time::__from_hms_nanos_unchecked(0, 0, 0, 0));

        assert_eq!(initial_time.adjusting_sub_std(full_day_to_sub), expected);
    }
}
False
========================================
    use crate::{Time, error};
    use time_macros::{time, time_};
    use core::crate::Duration;

    #[test]
    fn test_as_hms() {
        assert_eq!(Time::__from_hms_nanos_unchecked(0, 0, 0, 0).as_hms(), (0, 0, 0));
        assert_eq!(Time::__from_hms_nanos_unchecked(23, 59, 59, 0).as_hms(), (23, 59, 59));
        assert_eq!(Time::__from_hms_nanos_unchecked(12, 30, 45, 0).as_hms(), (12, 30, 45));
        assert_eq!(Time::__from_hms_nanos_unchecked(1, 2, 3, 0).as_hms(), (1, 2, 3));
    }
}
False
========================================
    use crate::Time;
    use time_macros::time;

    #[test]
    fn test_as_hms_micro() {
        assert_eq!(Time::from_hms_micro(0, 0, 0, 0).unwrap().as_hms_micro(), (0, 0, 0, 0));
        assert_eq!(Time::from_hms_micro(12, 34, 56, 0).unwrap().as_hms_micro(), (12, 34, 56, 0));
        assert_eq!(Time::from_hms_micro(23, 59, 59, 1).unwrap().as_hms_micro(), (23, 59, 59, 1));
        assert_eq!(Time::from_hms_micro(23, 59, 59, 999_999).unwrap().as_hms_micro(), (23, 59, 59, 999_999));
    }
}
True
========================================
    use crate::{Time, error};

    #[test]
    fn as_hms_milli_midnight() {
        let midnight = Time::__from_hms_nanos_unchecked(0, 0, 0, 0);
        assert_eq!(midnight.as_hms_milli(), (0, 0, 0, 0));
    }
    
    #[test]
    fn as_hms_milli_before_noon() {
        let time = Time::__from_hms_nanos_unchecked(9, 41, 16, 345_000_000);
        assert_eq!(time.as_hms_milli(), (9, 41, 16, 345));
    }
    
    #[test]
    fn as_hms_milli_noon() {
        let noon = Time::__from_hms_nanos_unchecked(12, 0, 0, 0);
        assert_eq!(noon.as_hms_milli(), (12, 0, 0, 0));
    }

    #[test]
    fn as_hms_milli_after_noon() {
        let time = Time::__from_hms_nanos_unchecked(13, 59, 59, 999_000_000);
        assert_eq!(time.as_hms_milli(), (13, 59, 59, 999));
    }

    #[test]
    fn as_hms_milli_before_midnight() {
        let time = Time::__from_hms_nanos_unchecked(23, 59, 59, 999_000_000);
        assert_eq!(time.as_hms_milli(), (23, 59, 59, 999));
    }

    #[test]
    fn as_hms_milli_invalid_nanos() {
        let time = Time::__from_hms_nanos_unchecked(12, 30, 30, 1_000_000_001);
        assert_ne!(time.as_hms_milli(), (12, 30, 30, 1_000));
    }

    #[test]
    fn as_hms_milli_edge_case_nanos() {
        let time = Time::__from_hms_nanos_unchecked(23, 59, 59, 999_999_999);
        assert_eq!(time.as_hms_milli(), (23, 59, 59, 999));
    }
}
True
========================================
    use crate::{Time, error::ComponentRange};

    #[test]
    fn test_as_hms_nano_midnight() {
        let time = Time::MIDNIGHT;
        assert_eq!(time.as_hms_nano(), (0, 0, 0, 0));
    }

    #[test]
    fn test_as_hms_nano_noon() {
        let time = Time::__from_hms_nanos_unchecked(12, 0, 0, 0);
        assert_eq!(time.as_hms_nano(), (12, 0, 0, 0));
    }

    #[test]
    fn test_as_hms_nano_max_time() {
        let time = Time::MAX;
        assert_eq!(time.as_hms_nano(), (23, 59, 59, 999_999_999));
    }

    #[test]
    fn test_as_hms_nano_random_time() {
        let time = Time::__from_hms_nanos_unchecked(13, 29, 31, 123_456_789);
        assert_eq!(time.as_hms_nano(), (13, 29, 31, 123_456_789));
    }

    #[test]
    fn test_as_hms_nano_error_hour() {
        let time = Time::from_hms_nano(24, 0, 0, 0);
        assert!(time.is_err());
        assert!(matches!(time, Err(ComponentRange)));
    }

    #[test]
    fn test_as_hms_nano_error_minute() {
        let time = Time::from_hms_nano(23, 60, 0, 0);
        assert!(time.is_err());
        assert!(matches!(time, Err(ComponentRange)));
    }

    #[test]
    fn test_as_hms_nano_error_second() {
        let time = Time::from_hms_nano(23, 59, 60, 0);
        assert!(time.is_err());
        assert!(matches!(time, Err(ComponentRange)));
    }

    #[test]
    fn test_as_hms_nano_error_nanosecond() {
        let time = Time::from_hms_nano(23, 59, 59, 1_000_000_000);
        assert!(time.is_err());
        assert!(matches!(time, Err(ComponentRange)));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{Time, error::ComponentRange};

    #[test]
    fn test_from_hms_valid_times() {
        assert!(Time::from_hms(0, 0, 0).is_ok());
        assert!(Time::from_hms(23, 59, 59).is_ok());
        assert!(Time::from_hms(12, 30, 45).is_ok());
    }

    #[test]
    fn test_from_hms_invalid_hours() {
        assert!(matches!(Time::from_hms(24, 0, 0), Err(ComponentRange)));
    }

    #[test]
    fn test_from_hms_invalid_minutes() {
        assert!(matches!(Time::from_hms(0, 60, 0), Err(ComponentRange)));
    }

    #[test]
    fn test_from_hms_invalid_seconds() {
        assert!(matches!(Time::from_hms(0, 0, 60), Err(ComponentRange)));
    }
}
True
========================================
    use crate::{Time, error::Error};

    #[test]
    fn test_from_hms_micro_valid() {
        assert!(Time::from_hms_micro(0, 0, 0, 0).is_ok());
        assert!(Time::from_hms_micro(23, 59, 59, 999_999).is_ok());
    }

    #[test]
    fn test_from_hms_micro_invalid_hour() {
        assert!(matches!(
            Time::from_hms_micro(24, 0, 0, 0),
            Err(Error::ComponentRange(_))
        ));
    }

    #[test]
    fn test_from_hms_micro_invalid_minute() {
        assert!(matches!(
            Time::from_hms_micro(0, 60, 0, 0),
            Err(Error::ComponentRange(_))
        ));
    }

    #[test]
    fn test_from_hms_micro_invalid_second() {
        assert!(matches!(
            Time::from_hms_micro(0, 0, 60, 0),
            Err(Error::ComponentRange(_))
        ));
    }

    #[test]
    fn test_from_hms_micro_invalid_microsecond() {
        assert!(matches!(
            Time::from_hms_micro(0, 0, 0, 1_000_000),
            Err(Error::ComponentRange(_))
        ));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRangeError;

    #[test]
    fn from_hms_milli_valid_times() {
        assert!(Time::from_hms_milli(0, 0, 0, 0).is_ok());
        assert!(Time::from_hms_milli(23, 59, 59, 999).is_ok());
    }

    #[test]
    fn from_hms_milli_invalid_hours() {
        match Time::from_hms_milli(24, 0, 0, 0).unwrap_err() {
            ComponentRangeError{..} => {},
            _ => panic!("Expected ComponentRangeError"),
        }
    }

    #[test]
    fn from_hms_milli_invalid_minutes() {
        match Time::from_hms_milli(23, 60, 0, 0).unwrap_err() {
            ComponentRangeError{..} => {},
            _ => panic!("Expected ComponentRangeError"),
        }
    }

    #[test]
    fn from_hms_milli_invalid_seconds() {
        match Time::from_hms_milli(23, 59, 60, 0).unwrap_err() {
            ComponentRangeError{..} => {},
            _ => panic!("Expected ComponentRangeError"),
        }
    }

    #[test]
    fn from_hms_milli_invalid_milliseconds() {
        match Time::from_hms_milli(23, 59, 59, 1_000).unwrap_err() {
            ComponentRangeError{..} => {},
            _ => panic!("Expected ComponentRangeError"),
        }
    }
}
False
========================================
    use crate::Time;
    use crate::error::ComponentRangeError;

    #[test]
    fn test_from_hms_nano_valid_times() {
        assert!(Time::from_hms_nano(0, 0, 0, 0).is_ok());
        assert!(Time::from_hms_nano(23, 59, 59, 999_999_999).is_ok());
        assert!(Time::from_hms_nano(12, 30, 30, 500_000_000).is_ok());
    }
    
    #[test]
    fn test_from_hms_nano_invalid_hours() {
        assert!(matches!(
            Time::from_hms_nano(24, 0, 0, 0),
            Err(ComponentRangeError::Hour(_))
        ));
    }

    #[test]
    fn test_from_hms_nano_invalid_minutes() {
        assert!(matches!(
            Time::from_hms_nano(0, 60, 0, 0),
            Err(ComponentRangeError::Minute(_))
        ));
    }

    #[test]
    fn test_from_hms_nano_invalid_seconds() {
        assert!(matches!(
            Time::from_hms_nano(0, 0, 60, 0),
            Err(ComponentRangeError::Second(_))
        ));
    }

    #[test]
    fn test_from_hms_nano_invalid_nanoseconds() {
        assert!(matches!(
            Time::from_hms_nano(0, 0, 0, 1_000_000_000),
            Err(ComponentRangeError::Nanosecond(_))
        ));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Time;

    #[test]
    fn hour_works_correctly() {
        assert_eq!(Time::__from_hms_nanos_unchecked(0, 0, 0, 0).hour(), 0);
        assert_eq!(Time::__from_hms_nanos_unchecked(1, 0, 0, 0).hour(), 1);
        assert_eq!(Time::__from_hms_nanos_unchecked(12, 30, 30, 0).hour(), 12);
        assert_eq!(Time::__from_hms_nanos_unchecked(23, 59, 59, 0).hour(), 23);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Time;
    use time_macros::time;

    #[test]
    fn microsecond_at_midnight() {
        assert_eq!(Time::from_hms_nano(0, 0, 0, 0).unwrap().microsecond(), 0);
    }

    #[test]
    fn microsecond_within_second() {
        assert_eq!(Time::from_hms_nano(12, 34, 56, 789_012_000).unwrap().microsecond(), 789_012);
    }

    #[test]
    fn microsecond_at_last_microsecond() {
        assert_eq!(Time::from_hms_nano(23, 59, 59, 999_999_000).unwrap().microsecond(), 999_999);
    }

    #[test]
    fn microsecond_just_nanos() {
        assert_eq!(Time::from_hms_nano(23, 59, 59, 1).unwrap().microsecond(), 0);
    }

    #[test]
    fn microsecond_just_before_next_second() {
        assert_eq!(Time::from_hms_nano(23, 59, 59, 999_999_999).unwrap().microsecond(), 999_999);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn millisecond_at_midnight() {
        assert_eq!(Time::MIDNIGHT.millisecond(), 0);
    }

    #[test]
    fn millisecond_at_noon() {
        assert_eq!(Time::__from_hms_nanos_unchecked(12, 0, 0, 0).millisecond(), 0);
    }

    #[test]
    fn millisecond_at_specific_time() {
        assert_eq!(Time::__from_hms_nanos_unchecked(23, 59, 59, 999_000_000).millisecond(), 999);
    }

    #[test]
    fn millisecond_max_value() {
        assert_eq!(Time::MAX.millisecond(), 999);
    }

    #[test]
    fn millisecond_min_value() {
        assert_eq!(Time::MIN.millisecond(), 0);
    }

    #[test]
    fn millisecond_with_various_nanos() {
        assert_eq!(Time::__from_hms_nanos_unchecked(0, 0, 0, 500_000_000).millisecond(), 500);
        assert_eq!(Time::__from_hms_nanos_unchecked(0, 0, 0, 1_000_000).millisecond(), 1);
        assert_eq!(Time::__from_hms_nanos_unchecked(0, 0, 0, 999_999_999).millisecond(), 999);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_minute() {
        assert_eq!(Time::__from_hms_nanos_unchecked(0, 0, 0, 0).minute(), 0);
        assert_eq!(Time::__from_hms_nanos_unchecked(23, 59, 59, 999_999_999).minute(), 59);
        assert_eq!(Time::__from_hms_nanos_unchecked(12, 34, 56, 789_012_345).minute(), 34);
        assert_eq!(Time::__from_hms_nanos_unchecked(6, 15, 30, 123_456_789).minute(), 15);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Time;

    #[test]
    fn nanosecond_at_midnight() {
        assert_eq!(Time::MIDNIGHT.nanosecond(), 0);
    }

    #[test]
    fn nanosecond_at_noon() {
        assert_eq!(Time::from_hms(12, 0, 0).unwrap().nanosecond(), 0);
    }

    #[test]
    fn nanosecond_at_random_time() {
        assert_eq!(Time::from_hms_nano(13, 46, 28, 123_456_789).unwrap().nanosecond(), 123_456_789);
    }

    #[test]
    fn nanosecond_at_last_nano_of_day() {
        assert_eq!(Time::MAX.nanosecond(), 999_999_999);
    }

    #[test]
    #[should_panic]
    fn nanosecond_invalid_time() {
        let _ = Time::__from_hms_nanos_unchecked(25, 61, 61, 1_000_000_000).nanosecond();
    }
}
True
========================================
    use crate::Time; // Import Time from the parent module
    use crate::error::ComponentRange; // Import the ComponentRange error from the crate.
    use time_macros::time; // Import macro from time-macros crate if available.

    #[test]
    fn replace_hour_valid() {
        let initial_time = Time::from_hms_nano(1, 2, 3, 4_005_006).unwrap();
        let expected_time = Time::from_hms_nano(7, 2, 3, 4_005_006).unwrap();
        assert_eq!(initial_time.replace_hour(7), Ok(expected_time));
    }

    #[test]
    fn replace_hour_invalid() {
        let initial_time = Time::from_hms_nano(1, 2, 3, 4_005_006).unwrap();
        assert!(matches!(
            initial_time.replace_hour(24),
            Err(ComponentRange { .. })
        ));
    }
}
True
========================================
    use crate::{error::ComponentRange, macros::time, Time};

    #[test]
    fn replace_microsecond_valid() {
        let original = time!(01:02:03.004_005_006);
        let expected = time!(01:02:03.007_008);
        assert_eq!(
            original.replace_microsecond(7_008),
            Ok(expected)
        );
    }

    #[test]
    fn replace_microsecond_invalid() {
        let original = time!(01:02:03.004_005_006);
        assert_eq!(
            original.replace_microsecond(1_000_000),
            Err(ComponentRange::new("microsecond", 0, 999_999, 1_000_000))
        );
    }
}
False
========================================
    use crate::Time;
    use crate::error::ComponentRangeError;
    use crate::macros::time;

    #[test]
    fn test_replace_millisecond_valid() {
        assert_eq!(
            Time::from_hms_nano(1, 2, 3, 4_005_006).unwrap().replace_millisecond(7),
            Ok(Time::from_hms_nano(1, 2, 3, 7_000_000).unwrap())
        );
    }

    #[test]
    fn test_replace_millisecond_invalid() {
        assert!(
            Time::from_hms_nano(1, 2, 3, 4_005_006).unwrap().replace_millisecond(1_000).is_err()
        );
        
        match Time::from_hms_nano(1, 2, 3, 4_005_006).unwrap().replace_millisecond(1_000) {
            Err(ComponentRangeError {
                name, minimum, maximum, ..
            }) => {
                assert_eq!(name, "millisecond");
                assert_eq!(minimum, 0);
                assert_eq!(maximum, 999);
            }
            _ => unreachable!(),
        }
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_replace_minute_valid() {
        let time = Time::__from_hms_nanos_unchecked(01, 02, 03, 004_005_006);
        let result = time.replace_minute(7);
        assert_eq!(result, Ok(Time::__from_hms_nanos_unchecked(01, 07, 03, 004_005_006)));
    }
    
    #[test]
    fn test_replace_minute_invalid() {
        let time = Time::__from_hms_nanos_unchecked(01, 02, 03, 004_005_006);
        let result = time.replace_minute(60);
        assert!(result.is_err());
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;
    use crate::crate::Time;
    use time_macros::time;

    #[test]
    fn test_replace_nanosecond_valid() {
        assert_eq!(
            Time::from_hms_nano(1, 2, 3, 4_005_006).unwrap()
                .replace_nanosecond(7_008_009)
                .unwrap(),
            Time::from_hms_nano(1, 2, 3, 7_008_009).unwrap()
        );
    }

    #[test]
    fn test_replace_nanosecond_invalid() {
        assert_eq!(
            Time::from_hms_nano(1, 2, 3, 4_005_006).unwrap()
                .replace_nanosecond(1_000_000_000)
                .unwrap_err()
                .to_string(),
            ComponentRange::NANOS.to_string()
        );
    }
}
False
========================================
    use crate::Time;
    use crate::error::ComponentRange;
    use time_macros::time;

    #[test]
    fn test_replace_second_valid() {
        let original = time!(01:02:03);
        let expected = time!(01:02:07);
        assert_eq!(original.replace_second(7), Ok(expected));
    }

    #[test]
    fn test_replace_second_invalid() {
        let original = time!(01:02:03);
        let result = original.replace_second(60);
        assert!(matches!(result, Err(ComponentRange::Second { .. })));
    }

    #[test]
    fn test_replace_second_edge_case() {
        let original = time!(01:02:03.004_005_006);
        let expected = time!(01:02:59.004_005_006);
        assert_eq!(original.replace_second(59), Ok(expected));
    }
}
False
========================================
    use crate::Time;

    #[test]
    fn test_second() {
        assert_eq!(Time::__from_hms_nanos_unchecked(0, 0, 0, 0).second(), 0);
        assert_eq!(Time::__from_hms_nanos_unchecked(23, 59, 59, 0).second(), 59);
        assert_eq!(Time::__from_hms_nanos_unchecked(12, 30, 15, 0).second(), 15);
        assert_eq!(Time::__from_hms_nanos_unchecked(1, 23, 45, 0).second(), 45);
    }
}
True
========================================
    use crate::UtcOffset;

    #[test]
    fn from_hms_unchecked_positive() {
        let offset = UtcOffset::__from_hms_unchecked(1, 30, 45);
        assert_eq!(offset.hours, 1);
        assert_eq!(offset.minutes, 30);
        assert_eq!(offset.seconds, 45);
    }

    #[test]
    fn from_hms_unchecked_negative() {
        let offset = UtcOffset::__from_hms_unchecked(-5, -10, -20);
        assert_eq!(offset.hours, -5);
        assert_eq!(offset.minutes, -10);
        assert_eq!(offset.seconds, -20);
    }

    #[test]
    fn from_hms_unchecked_zero() {
        let offset = UtcOffset::__from_hms_unchecked(0, 0, 0);
        assert_eq!(offset.hours, 0);
        assert_eq!(offset.minutes, 0);
        assert_eq!(offset.seconds, 0);
    }

    #[test]
    #[should_panic]
    fn from_hms_unchecked_panic_mismatched_signs() {
        let _ = UtcOffset::__from_hms_unchecked(-1, 20, 30);
    }

    #[test]
    #[should_panic]
    fn from_hms_unchecked_panic_invalid_hours() {
        let _ = UtcOffset::__from_hms_unchecked(24, 0, 0);
    }

    #[test]
    #[should_panic]
    fn from_hms_unchecked_panic_invalid_minutes() {
        let _ = UtcOffset::__from_hms_unchecked(0, 60, 0);
    }

    #[test]
    #[should_panic]
    fn from_hms_unchecked_panic_invalid_seconds() {
        let _ = UtcOffset::__from_hms_unchecked(0, 0, 60);
    }
}
True
========================================
    use crate::UtcOffset;
    use crate::error::ComponentRange;

    #[test]
    fn as_hms_positive_offset() {
        let offset = UtcOffset::__from_hms_unchecked(1, 2, 3);
        assert_eq!(offset.as_hms(), (1, 2, 3));
    }

    #[test]
    fn as_hms_negative_offset() {
        let offset = UtcOffset::__from_hms_unchecked(-1, -2, -3);
        assert_eq!(offset.as_hms(), (-1, -2, -3));
    }

    #[test]
    fn as_hms_zero_offset() {
        let offset = UtcOffset::UTC;
        assert_eq!(offset.as_hms(), (0, 0, 0));
    }

    #[test]
    fn as_hms_max_offset() {
        let offset = UtcOffset::__from_hms_unchecked(23, 59, 59);
        assert_eq!(offset.as_hms(), (23, 59, 59));
    }

    #[test]
    fn as_hms_min_offset() {
        let offset = UtcOffset::__from_hms_unchecked(-23, -59, -59);
        assert_eq!(offset.as_hms(), (-23, -59, -59));
    }

    #[test]
    fn as_hms_with_constructor() {
        let offset = UtcOffset::from_hms(5, 10, 15).unwrap();
        assert_eq!(offset.as_hms(), (5, 10, 15));
    }

    #[test]
    fn as_hms_with_constructor_negative() {
        let offset = UtcOffset::from_hms(-5, -10, -15).unwrap();
        assert_eq!(offset.as_hms(), (-5, -10, -15));
    }

    #[test]
    fn as_hms_with_constructor_invalid() {
        assert!(UtcOffset::from_hms(24, 0, 0).is_err());
        assert!(UtcOffset::from_hms(-24, 0, 0).is_err());
        assert!(UtcOffset::from_hms(0, 60, 0).is_err());
        assert!(UtcOffset::from_hms(0, -60, 0).is_err());
        assert!(UtcOffset::from_hms(0, 0, 60).is_err());
        assert!(UtcOffset::from_hms(0, 0, -60).is_err());
    }

    #[test]
    fn as_hms_with_constructor_mix_signs() {
        let offset = UtcOffset::from_hms(-5, 10, 15).unwrap();
        assert_eq!(offset.as_hms(), (-5, -10, -15));
    }

    #[test]
    fn as_hms_with_constructor_mix_signs2() {
        let offset = UtcOffset::from_hms(5, -10, -15).unwrap();
        assert_eq!(offset.as_hms(), (5, 10, 15));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::error::ComponentRange;

    #[test]
    fn from_hms_valid_positive_offsets() {
        assert_eq!(UtcOffset::from_hms(1, 2, 3).unwrap().as_hms(), (1, 2, 3));
    }

    #[test]
    fn from_hms_valid_negative_offsets() {
        assert_eq!(UtcOffset::from_hms(-1, -2, -3).unwrap().as_hms(), (-1, -2, -3));
    }

    #[test]
    fn from_hms_valid_mixed_sign_offsets() {
        assert_eq!(UtcOffset::from_hms(1, -2, -3).unwrap().as_hms(), (1, 2, 3));
        assert_eq!(UtcOffset::from_hms(-1, 2, 3).unwrap().as_hms(), (-1, -2, -3));
    }

    #[test]
    fn from_hms_invalid_hours() {
        assert!(matches!(UtcOffset::from_hms(24, 0, 0), Err(ComponentRange)));
        assert!(matches!(UtcOffset::from_hms(-24, 0, 0), Err(ComponentRange)));
    }

    #[test]
    fn from_hms_invalid_minutes() {
        assert!(matches!(UtcOffset::from_hms(0, 60, 0), Err(ComponentRange)));
        assert!(matches!(UtcOffset::from_hms(0, -60, 0), Err(ComponentRange)));
    }

    #[test]
    fn from_hms_invalid_seconds() {
        assert!(matches!(UtcOffset::from_hms(0, 0, 60), Err(ComponentRange)));
        assert!(matches!(UtcOffset::from_hms(0, 0, -60), Err(ComponentRange)));
    }

    #[test]
    fn from_hms_boundary_values() {
        // Test boundary values
        assert_eq!(UtcOffset::from_hms(-23, -59, -59).unwrap().as_hms(), (-23, -59, -59));
        assert_eq!(UtcOffset::from_hms(23, 59, 59).unwrap().as_hms(), (23, 59, 59));
        assert_eq!(UtcOffset::from_hms(0, 0, 0).unwrap().as_hms(), (0, 0, 0));
    }

    #[test]
    fn from_hms_sign_flipping() {
        // Test if minutes and seconds sign is flipped when mismatched with hours
        assert_eq!(UtcOffset::from_hms(-1, 2, 3).unwrap().as_hms(), (-1, -2, -3));
        assert_eq!(UtcOffset::from_hms(1, -2, 3).unwrap().as_hms(), (1, 2, 3));
        assert_eq!(UtcOffset::from_hms(1, 2, -3).unwrap().as_hms(), (1, 2, 3));
        assert_eq!(UtcOffset::from_hms(-1, -2, 3).unwrap().as_hms(), (-1, -2, -3));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::UtcOffset;
    use crate::error::ComponentRange;

    #[test]
    fn from_whole_seconds_valid() {
        let seconds = 3723;
        let offset = UtcOffset::from_whole_seconds(seconds);
        assert!(offset.is_ok());
        let offset = offset.unwrap();
        assert_eq!(offset.as_hms(), (1, 2, 3));
    }

    #[test]
    fn from_whole_seconds_negative() {
        let seconds = -3723;
        let offset = UtcOffset::from_whole_seconds(seconds);
        assert!(offset.is_ok());
        let offset = offset.unwrap();
        assert_eq!(offset.as_hms(), (-1, -2, -3));
    }

    #[test]
    fn from_whole_seconds_too_large() {
        let seconds = 24 * 3600; // one second more than the maximum allowed offset
        let offset = UtcOffset::from_whole_seconds(seconds);
        assert!(offset.is_err());
        if let Err(e) = offset {
            assert!(matches!(e, ComponentRange));
        }
    }

    #[test]
    fn from_whole_seconds_too_small() {
        let seconds = -24 * 3600; // one second less than the minimum allowed offset
        let offset = UtcOffset::from_whole_seconds(seconds);
        assert!(offset.is_err());
        if let Err(e) = offset {
            assert!(matches!(e, ComponentRange));
        }
    }
}
True
========================================
    use crate::UtcOffset;

    #[test]
    fn test_is_negative() {
        assert!(!UtcOffset::UTC.is_negative());
        assert!(!UtcOffset::__from_hms_unchecked(1, 2, 3).is_negative());
        assert!(!UtcOffset::__from_hms_unchecked(0, 2, 3).is_negative());
        assert!(!UtcOffset::__from_hms_unchecked(1, 0, 3).is_negative());
        assert!(!UtcOffset::__from_hms_unchecked(1, 2, 0).is_negative());
        assert!(!UtcOffset::__from_hms_unchecked(0, 0, 3).is_negative());
        assert!(!UtcOffset::__from_hms_unchecked(0, 2, 0).is_negative());
        assert!(!UtcOffset::__from_hms_unchecked(1, 0, 0).is_negative());
        
        assert!(UtcOffset::__from_hms_unchecked(-1, -2, -3).is_negative());
        assert!(UtcOffset::__from_hms_unchecked(-1, 0, 0).is_negative());
        assert!(UtcOffset::__from_hms_unchecked(0, -2, 0).is_negative());
        assert!(UtcOffset::__from_hms_unchecked(0, 0, -3).is_negative());
        assert!(UtcOffset::__from_hms_unchecked(0, -2, -3).is_negative());
        assert!(UtcOffset::__from_hms_unchecked(-1, 0, -3).is_negative());
        assert!(UtcOffset::__from_hms_unchecked(-1, -2, 0).is_negative());
    }
}
True
========================================
    use crate::UtcOffset;

    #[test]
    fn is_positive_returns_true_for_positive_offsets() {
        let positive_offset = UtcOffset::__from_hms_unchecked(1, 0, 0);
        assert!(positive_offset.is_positive());

        let positive_offset = UtcOffset::__from_hms_unchecked(0, 1, 0);
        assert!(positive_offset.is_positive());

        let positive_offset = UtcOffset::__from_hms_unchecked(0, 0, 1);
        assert!(positive_offset.is_positive());

        let positive_offset = UtcOffset::__from_hms_unchecked(1, 1, 1);
        assert!(positive_offset.is_positive());
    }

    #[test]
    fn is_positive_returns_false_for_negative_offsets() {
        let negative_offset = UtcOffset::__from_hms_unchecked(-1, 0, 0);
        assert!(!negative_offset.is_positive());

        let negative_offset = UtcOffset::__from_hms_unchecked(0, -1, 0);
        assert!(!negative_offset.is_positive());

        let negative_offset = UtcOffset::__from_hms_unchecked(0, 0, -1);
        assert!(!negative_offset.is_positive());

        let negative_offset = UtcOffset::__from_hms_unchecked(-1, -1, -1);
        assert!(!negative_offset.is_positive());
    }

    #[test]
    fn is_positive_returns_false_for_utc_offset() {
        let utc_offset = UtcOffset::UTC;
        assert!(!utc_offset.is_positive());
    }
}
True
========================================
    use crate::UtcOffset;
    use time_macros::offset;

    #[test]
    fn utc_offset_is_utc() {
        // Test with UTC itself
        assert!(UtcOffset::UTC.is_utc());

        // Test with positive offset
        assert!(!UtcOffset::__from_hms_unchecked(0, 0, 1).is_utc());
        assert!(!UtcOffset::__from_hms_unchecked(0, 1, 0).is_utc());
        assert!(!UtcOffset::__from_hms_unchecked(1, 0, 0).is_utc());

        // Test with negative offset
        assert!(!UtcOffset::__from_hms_unchecked(0, 0, -1).is_utc());
        assert!(!UtcOffset::__from_hms_unchecked(0, -1, 0).is_utc());
        assert!(!UtcOffset::__from_hms_unchecked(-1, 0, 0).is_utc());
    }
}
True
========================================
    use crate::UtcOffset;
    use time_macros::offset;

    #[test]
    fn minutes_past_hour_positive_offset() {
        assert_eq!(UtcOffset::from_hms(1, 2, 3).unwrap().minutes_past_hour(), 2);
    }

    #[test]
    fn minutes_past_hour_negative_offset() {
        assert_eq!(UtcOffset::from_hms(-1, -2, -3).unwrap().minutes_past_hour(), -2);
    }

    #[test]
    fn minutes_past_hour_zero_offset() {
        assert_eq!(UtcOffset::UTC.minutes_past_hour(), 0);
    }

    #[test]
    fn minutes_past_hour_no_offset() {
        assert_eq!(UtcOffset::from_hms(0, 0, 0).unwrap().minutes_past_hour(), 0);
    }

    #[test]
    fn minutes_past_hour_max_positive_offset() {
        assert_eq!(UtcOffset::from_hms(23, 59, 59).unwrap().minutes_past_hour(), 59);
    }

    #[test]
    fn minutes_past_hour_max_negative_offset() {
        assert_eq!(UtcOffset::from_hms(-23, -59, -59).unwrap().minutes_past_hour(), -59);
    }
}
True
========================================
    use crate::UtcOffset;

    #[test]
    fn seconds_past_minute_positive() {
        let offset = UtcOffset::from_hms(1, 2, 3).unwrap();
        assert_eq!(offset.seconds_past_minute(), 3);
    }

    #[test]
    fn seconds_past_minute_negative() {
        let offset = UtcOffset::from_hms(-1, -2, -3).unwrap();
        assert_eq!(offset.seconds_past_minute(), -3);
    }

    #[test]
    fn seconds_past_minute_zero() {
        let offset = UtcOffset::from_hms(0, 0, 0).unwrap();
        assert_eq!(offset.seconds_past_minute(), 0);
    }

    #[test]
    fn seconds_past_minute_positive_negative() {
        let offset = UtcOffset::from_hms(1, -2, -3).unwrap();
        assert_eq!(offset.seconds_past_minute(), 3);
    }

    #[test]
    fn seconds_past_minute_negative_positive() {
        let offset = UtcOffset::from_hms(-1, 2, 3).unwrap();
        assert_eq!(offset.seconds_past_minute(), -3);
    }

    #[test]
    fn seconds_past_minute_max() {
        let offset = UtcOffset::from_hms(23, 59, 59).unwrap();
        assert_eq!(offset.seconds_past_minute(), 59);
    }

    #[test]
    fn seconds_past_minute_min() {
        let offset = UtcOffset::from_hms(-23, -59, -59).unwrap();
        assert_eq!(offset.seconds_past_minute(), -59);
    }
}
True
========================================
    use crate::UtcOffset;
    use crate::macros::offset;

    #[test]
    fn whole_hours_for_utc() {
        assert_eq!(UtcOffset::UTC.whole_hours(), 0);
    }

    #[test]
    fn whole_hours_for_positive_offset() {
        assert_eq!(offset!(+5:30:45).whole_hours(), 5);
    }

    #[test]
    fn whole_hours_for_negative_offset() {
        assert_eq!(offset!(-2:15:30).whole_hours(), -2);
    }

    #[test]
    fn whole_hours_for_positive_full_hour() {
        assert_eq!(offset!(+4).whole_hours(), 4);
    }

    #[test]
    fn whole_hours_for_negative_full_hour() {
        assert_eq!(offset!(-3).whole_hours(), -3);
    }

    #[test]
    fn whole_hours_for_positive_full_hour_zero_minutes() {
        assert_eq!(offset!(+7:00).whole_hours(), 7);
    }

    #[test]
    fn whole_hours_for_negative_full_hour_zero_minutes() {
        assert_eq!(offset!(-6:00).whole_hours(), -6);
    }

    #[test]
    fn whole_hours_for_zero_hour_positive_minutes() {
        assert_eq!(offset!(+0:45).whole_hours(), 0);
    }

    #[test]
    fn whole_hours_for_zero_hour_negative_minutes() {
        assert_eq!(offset!(-0:30).whole_hours(), 0);
    }

    #[test]
    fn whole_hours_for_zero_hour_zero_minutes_positive_seconds() {
        assert_eq!(offset!(+0:00:25).whole_hours(), 0);
    }

    #[test]
    fn whole_hours_for_zero_hour_zero_minutes_negative_seconds() {
        assert_eq!(offset!(-0:00:10).whole_hours(), 0);
    }

    #[test]
    fn whole_hours_for_positive_max_hour() {
        assert_eq!(offset!(+23:59:59).whole_hours(), 23);
    }

    #[test]
    fn whole_hours_for_negative_max_hour() {
        assert_eq!(offset!(-23:59:59).whole_hours(), -23);
    }

    #[test]
    fn whole_hours_for_positive_max_hour_zero_minutes() {
        assert_eq!(offset!(+23:00).whole_hours(), 23);
    }

    #[test]
    fn whole_hours_for_negative_max_hour_zero_minutes() {
        assert_eq!(offset!(-23:00).whole_hours(), -23);
    }
}
False
========================================
    use crate::UtcOffset;

    #[test]
    fn test_whole_minutes() {
        assert_eq!(UtcOffset::__from_hms_unchecked(1, 2, 3).whole_minutes(), 62);
        assert_eq!(UtcOffset::__from_hms_unchecked(-1, -2, -3).whole_minutes(), -62);
        assert_eq!(UtcOffset::__from_hms_unchecked(0, 0, 0).whole_minutes(), 0);
        assert_eq!(UtcOffset::__from_hms_unchecked(23, 59, 59).whole_minutes(), 1439);
        assert_eq!(UtcOffset::__from_hms_unchecked(-23, -59, -59).whole_minutes(), -1439);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_whole_seconds_positive_offset() {
        let offset = UtcOffset::__from_hms_unchecked(2, 30, 45);
        assert_eq!(offset.whole_seconds(), 9045);
    }

    #[test]
    fn test_whole_seconds_negative_offset() {
        let offset = UtcOffset::__from_hms_unchecked(-2, -30, -45);
        assert_eq!(offset.whole_seconds(), -9045);
    }

    #[test]
    fn test_whole_seconds_zero_offset() {
        let offset = UtcOffset::__from_hms_unchecked(0, 0, 0);
        assert_eq!(offset.whole_seconds(), 0);
    }

    #[test]
    fn test_whole_seconds_max_offset() {
        let offset = UtcOffset::__from_hms_unchecked(23, 59, 59);
        assert_eq!(offset.whole_seconds(), 23 * 3600 + 59 * 60 + 59);
    }

    #[test]
    fn test_whole_seconds_min_offset() {
        let offset = UtcOffset::__from_hms_unchecked(-23, -59, -59);
        assert_eq!(offset.whole_seconds(), -23 * 3600 - 59 * 60 - 59);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Month::*;

    #[test]
    fn test_days_in_month_for_non_leap_year() {
        assert_eq!(days_in_year_month(2021, January), 31);
        assert_eq!(days_in_year_month(2021, February), 28);
        assert_eq!(days_in_year_month(2021, March), 31);
        assert_eq!(days_in_year_month(2021, April), 30);
        assert_eq!(days_in_year_month(2021, May), 31);
        assert_eq!(days_in_year_month(2021, June), 30);
        assert_eq!(days_in_year_month(2021, July), 31);
        assert_eq!(days_in_year_month(2021, August), 31);
        assert_eq!(days_in_year_month(2021, September), 30);
        assert_eq!(days_in_year_month(2021, October), 31);
        assert_eq!(days_in_year_month(2021, November), 30);
        assert_eq!(days_in_year_month(2021, December), 31);
    }

    #[test]
    fn test_days_in_month_for_leap_year() {
        assert_eq!(days_in_year_month(2020, January), 31);
        assert_eq!(days_in_year_month(2020, February), 29);
        assert_eq!(days_in_year_month(2020, March), 31);
        assert_eq!(days_in_year_month(2020, April), 30);
        assert_eq!(days_in_year_month(2020, May), 31);
        assert_eq!(days_in_year_month(2020, June), 30);
        assert_eq!(days_in_year_month(2020, July), 31);
        assert_eq!(days_in_year_month(2020, August), 31);
        assert_eq!(days_in_year_month(2020, September), 30);
        assert_eq!(days_in_year_month(2020, October), 31);
        assert_eq!(days_in_year_month(2020, November), 30);
        assert_eq!(days_in_year_month(2020, December), 31);
    }

    #[test]
    fn test_days_in_month_for_century_non_leap_year() {
        assert_eq!(days_in_year_month(1900, February), 28);
    }

    #[test]
    fn test_days_in_month_for_century_leap_year() {
        assert_eq!(days_in_year_month(2000, February), 29);
    }
}
True
========================================
    use super::*;

use crate::*;
    
    #[test]
    fn test_next_weekday() {
        assert_eq!(Weekday::Monday.next(), Weekday::Tuesday);
        assert_eq!(Weekday::Tuesday.next(), Weekday::Wednesday);
        assert_eq!(Weekday::Wednesday.next(), Weekday::Thursday);
        assert_eq!(Weekday::Thursday.next(), Weekday::Friday);
        assert_eq!(Weekday::Friday.next(), Weekday::Saturday);
        assert_eq!(Weekday::Saturday.next(), Weekday::Sunday);
        assert_eq!(Weekday::Sunday.next(), Weekday::Monday);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_nth_next() {
        use Weekday::*;

        assert_eq!(Monday.nth_next(0), Monday);
        assert_eq!(Monday.nth_next(1), Tuesday);
        assert_eq!(Monday.nth_next(7), Monday);
        assert_eq!(Monday.nth_next(13), Sunday);
        assert_eq!(Monday.nth_next(14), Monday);

        assert_eq!(Tuesday.nth_next(0), Tuesday);
        assert_eq!(Tuesday.nth_next(1), Wednesday);
        assert_eq!(Tuesday.nth_next(6), Monday);
        assert_eq!(Tuesday.nth_next(12), Sunday);
        assert_eq!(Tuesday.nth_next(13), Monday);

        assert_eq!(Wednesday.nth_next(0), Wednesday);
        assert_eq!(Wednesday.nth_next(1), Thursday);
        assert_eq!(Wednesday.nth_next(5), Monday);
        assert_eq!(Wednesday.nth_next(11), Sunday);
        assert_eq!(Wednesday.nth_next(12), Monday);
        
        assert_eq!(Thursday.nth_next(0), Thursday);
        assert_eq!(Thursday.nth_next(1), Friday);
        assert_eq!(Thursday.nth_next(4), Monday);
        assert_eq!(Thursday.nth_next(10), Sunday);
        assert_eq!(Thursday.nth_next(11), Monday);
        
        assert_eq!(Friday.nth_next(0), Friday);
        assert_eq!(Friday.nth_next(1), Saturday);
        assert_eq!(Friday.nth_next(3), Monday);
        assert_eq!(Friday.nth_next(9), Sunday);
        assert_eq!(Friday.nth_next(10), Monday);

        assert_eq!(Saturday.nth_next(0), Saturday);
        assert_eq!(Saturday.nth_next(1), Sunday);
        assert_eq!(Saturday.nth_next(2), Monday);
        assert_eq!(Saturday.nth_next(8), Sunday);
        assert_eq!(Saturday.nth_next(9), Monday);
        
        assert_eq!(Sunday.nth_next(0), Sunday);
        assert_eq!(Sunday.nth_next(1), Monday);
        assert_eq!(Sunday.nth_next(1), Tuesday.nth_next(6));
        assert_eq!(Sunday.nth_next(2), Wednesday.nth_next(5));
        assert_eq!(Sunday.nth_next(7), Sunday);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_number_days_from_monday() {
        assert_eq!(Weekday::Monday.number_days_from_monday(), 0);
        assert_eq!(Weekday::Tuesday.number_days_from_monday(), 1);
        assert_eq!(Weekday::Wednesday.number_days_from_monday(), 2);
        assert_eq!(Weekday::Thursday.number_days_from_monday(), 3);
        assert_eq!(Weekday::Friday.number_days_from_monday(), 4);
        assert_eq!(Weekday::Saturday.number_days_from_monday(), 5);
        assert_eq!(Weekday::Sunday.number_days_from_monday(), 6);
    }
}
True
========================================
    use crate::Weekday;
    use crate::Weekday::*;

    #[test]
    fn test_number_days_from_sunday() {
        assert_eq!(Sunday.number_days_from_sunday(), 0);
        assert_eq!(Monday.number_days_from_sunday(), 1);
        assert_eq!(Tuesday.number_days_from_sunday(), 2);
        assert_eq!(Wednesday.number_days_from_sunday(), 3);
        assert_eq!(Thursday.number_days_from_sunday(), 4);
        assert_eq!(Friday.number_days_from_sunday(), 5);
        assert_eq!(Saturday.number_days_from_sunday(), 6);
    }
}
True
========================================
    use crate::Weekday;

    #[test]
    fn number_from_monday_test() {
        assert_eq!(Weekday::Monday.number_from_monday(), 1);
        assert_eq!(Weekday::Tuesday.number_from_monday(), 2);
        assert_eq!(Weekday::Wednesday.number_from_monday(), 3);
        assert_eq!(Weekday::Thursday.number_from_monday(), 4);
        assert_eq!(Weekday::Friday.number_from_monday(), 5);
        assert_eq!(Weekday::Saturday.number_from_monday(), 6);
        assert_eq!(Weekday::Sunday.number_from_monday(), 7);
    }
}
True
========================================
    use crate::Weekday::*;

    #[test]
    fn test_number_from_sunday() {
        assert_eq!(Sunday.number_from_sunday(), 1, "Sunday should be 1 from Sunday");
        assert_eq!(Monday.number_from_sunday(), 2, "Monday should be 2 from Sunday");
        assert_eq!(Tuesday.number_from_sunday(), 3, "Tuesday should be 3 from Sunday");
        assert_eq!(Wednesday.number_from_sunday(), 4, "Wednesday should be 4 from Sunday");
        assert_eq!(Thursday.number_from_sunday(), 5, "Thursday should be 5 from Sunday");
        assert_eq!(Friday.number_from_sunday(), 6, "Friday should be 6 from Sunday");
        assert_eq!(Saturday.number_from_sunday(), 7, "Saturday should be 7 from Sunday");
    }
}
True
========================================
    use crate::Weekday::*;
    use crate::Weekday;

    #[test]
    fn test_previous_weekday() {
        assert_eq!(Monday.previous(), Sunday);
        assert_eq!(Tuesday.previous(), Monday);
        assert_eq!(Wednesday.previous(), Tuesday);
        assert_eq!(Thursday.previous(), Wednesday);
        assert_eq!(Friday.previous(), Thursday);
        assert_eq!(Saturday.previous(), Friday);
        assert_eq!(Sunday.previous(), Saturday);
    }
}
True
time time 169 489
