{"dependencies":{"<core::Word<'_> as core::Fragment>::penalty_width":["core::Word"],"<core::Word<'_> as core::Fragment>::whitespace_width":["core::Word"],"<core::Word<'_> as core::Fragment>::width":["core::Word"],"<core::Word<'_> as std::ops::Deref>::deref":["core::Word"],"<core::Word<'a> as std::clone::Clone>::clone":["core::Word"],"<core::Word<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["core::Word"],"<core::Word<'a> as std::cmp::PartialEq>::eq":["core::Word"],"<core::Word<'a> as std::fmt::Debug>::fmt":["core::Word","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<line_ending::LineEnding as std::clone::Clone>::clone":["line_ending::LineEnding"],"<line_ending::LineEnding as std::cmp::Eq>::assert_receiver_is_total_eq":["line_ending::LineEnding"],"<line_ending::LineEnding as std::cmp::PartialEq>::eq":["line_ending::LineEnding"],"<line_ending::LineEnding as std::fmt::Debug>::fmt":["line_ending::LineEnding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<line_ending::NonEmptyLines<'a> as std::clone::Clone>::clone":["line_ending::NonEmptyLines"],"<line_ending::NonEmptyLines<'a> as std::fmt::Debug>::fmt":["line_ending::NonEmptyLines","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<line_ending::NonEmptyLines<'a> as std::iter::Iterator>::next":["line_ending::NonEmptyLines","std::marker::Sized","std::option::Option"],"<options::Options<'a> as std::clone::Clone>::clone":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"<options::Options<'a> as std::convert::From<&'a options::Options<'a>>>::from":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"<options::Options<'a> as std::convert::From<usize>>::from":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"<options::Options<'a> as std::fmt::Debug>::fmt":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"<word_separators::WordSeparator as std::clone::Clone>::clone":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","word_separators::WordSeparator"],"<word_separators::WordSeparator as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","word_separators::WordSeparator"],"<word_separators::WordSeparator as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","word_separators::WordSeparator"],"<word_splitters::WordSplitter as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","word_splitters::WordSplitter"],"<word_splitters::WordSplitter as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","word_splitters::WordSplitter"],"<word_splitters::WordSplitter as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","word_splitters::WordSplitter"],"<wrap_algorithms::WrapAlgorithm as std::clone::Clone>::clone":["core::Word","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"<wrap_algorithms::WrapAlgorithm as std::cmp::PartialEq>::eq":["core::Word","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"<wrap_algorithms::WrapAlgorithm as std::default::Default>::default":["core::Word","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"<wrap_algorithms::WrapAlgorithm as std::fmt::Debug>::fmt":["core::Word","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"<wrap_algorithms::optimal_fit::OverflowError as std::cmp::Eq>::assert_receiver_is_total_eq":["wrap_algorithms::optimal_fit::OverflowError"],"<wrap_algorithms::optimal_fit::OverflowError as std::cmp::PartialEq>::eq":["wrap_algorithms::optimal_fit::OverflowError"],"<wrap_algorithms::optimal_fit::OverflowError as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","wrap_algorithms::optimal_fit::OverflowError"],"<wrap_algorithms::optimal_fit::OverflowError as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","wrap_algorithms::optimal_fit::OverflowError"],"<wrap_algorithms::optimal_fit::Penalties as std::clone::Clone>::clone":["wrap_algorithms::optimal_fit::Penalties"],"<wrap_algorithms::optimal_fit::Penalties as std::cmp::Eq>::assert_receiver_is_total_eq":["wrap_algorithms::optimal_fit::Penalties"],"<wrap_algorithms::optimal_fit::Penalties as std::cmp::PartialEq>::eq":["wrap_algorithms::optimal_fit::Penalties"],"<wrap_algorithms::optimal_fit::Penalties as std::default::Default>::default":["wrap_algorithms::optimal_fit::Penalties"],"<wrap_algorithms::optimal_fit::Penalties as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","wrap_algorithms::optimal_fit::Penalties"],"columns::wrap_columns":["std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::vec::Vec"],"core::Fragment::penalty_width":[],"core::Fragment::whitespace_width":[],"core::Fragment::width":[],"core::Word":["core::Word"],"core::Word::<'a>::break_apart":["core::Word"],"core::Word::<'a>::from":["core::Word"],"core::break_words":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"core::ch_width":[],"core::display_width":[],"core::skip_ansi_escape_sequence":["line_ending::NonEmptyLines","std::iter::Iterator","std::marker::Sized"],"fill::fill":["std::convert::Into","std::marker::Sized","std::string::String"],"fill::fill_inplace":["std::string::String"],"fill::fill_slow_path":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::string::String","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"indentation::dedent":["std::string::String"],"indentation::indent":["std::string::String"],"line_ending::LineEnding":["line_ending::LineEnding"],"line_ending::LineEnding::as_str":["line_ending::LineEnding"],"line_ending::NonEmptyLines":["line_ending::NonEmptyLines"],"options::Options":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"options::Options::<'a>::break_words":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"options::Options::<'a>::initial_indent":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"options::Options::<'a>::line_ending":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"options::Options::<'a>::new":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"options::Options::<'a>::subsequent_indent":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"options::Options::<'a>::word_separator":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"options::Options::<'a>::word_splitter":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"options::Options::<'a>::wrap_algorithm":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"refill::refill":["std::convert::Into","std::marker::Sized","std::string::String"],"refill::unfill":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::string::String","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"word_separators::WordSeparator":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","word_separators::WordSeparator"],"word_separators::WordSeparator::find_words":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","word_separators::WordSeparator"],"word_separators::WordSeparator::new":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","word_separators::WordSeparator"],"word_separators::find_words_ascii_space":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"word_separators::find_words_unicode_break_properties":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"word_separators::strip_ansi_escape_sequences":["std::string::String"],"word_splitters::WordSplitter":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","word_splitters::WordSplitter"],"word_splitters::WordSplitter::split_points":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","word_splitters::WordSplitter"],"word_splitters::split_words":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","word_splitters::WordSplitter"],"wrap::wrap":["std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::vec::Vec"],"wrap::wrap_single_line":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"wrap::wrap_single_line_slow_path":["core::Word","line_ending::LineEnding","options::Options","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"wrap_algorithms::WrapAlgorithm":["core::Word","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"wrap_algorithms::WrapAlgorithm::new":["core::Word","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"wrap_algorithms::WrapAlgorithm::new_optimal_fit":["core::Word","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"wrap_algorithms::WrapAlgorithm::wrap":["core::Word","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"wrap_algorithms::optimal_fit::LineNumbers":["std::cell::RefCell","wrap_algorithms::optimal_fit::LineNumbers"],"wrap_algorithms::optimal_fit::LineNumbers::get":["std::cell::RefCell","std::marker::Sized","wrap_algorithms::optimal_fit::LineNumbers"],"wrap_algorithms::optimal_fit::LineNumbers::new":["std::cell::RefCell","wrap_algorithms::optimal_fit::LineNumbers"],"wrap_algorithms::optimal_fit::OverflowError":["wrap_algorithms::optimal_fit::OverflowError"],"wrap_algorithms::optimal_fit::Penalties":["wrap_algorithms::optimal_fit::Penalties"],"wrap_algorithms::optimal_fit::Penalties::new":["wrap_algorithms::optimal_fit::Penalties"],"wrap_algorithms::optimal_fit::wrap_optimal_fit":["core::Fragment","core::Word","std::marker::Sized","std::result::Result","wrap_algorithms::optimal_fit::Penalties"],"wrap_algorithms::wrap_first_fit":["core::Fragment","core::Word","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"]},"glob_path_import":{},"self_to_fn":{"core::Word":["Clone","Copy","Debug","Eq","PartialEq","impl Fragment for Word<'_> {\n    #[inline]\n    fn width(&self) -> f64 {\n        self.width as f64\n    }\n\n    // We assume the whitespace consist of ' ' only. This allows us to\n    // compute the display width in constant time.\n    #[inline]\n    fn whitespace_width(&self) -> f64 {\n        self.whitespace.len() as f64\n    }\n\n    // We assume the penalty is `\"\"` or `\"-\"`. This allows us to\n    // compute the display width in constant time.\n    #[inline]\n    fn penalty_width(&self) -> f64 {\n        self.penalty.len() as f64\n    }\n}","impl std::ops::Deref for Word<'_> {\n    type Target = str;\n\n    fn deref(&self) -> &Self::Target {\n        self.word\n    }\n}","impl<'a> Word<'a> {\n    /// Construct a `Word` from a string.\n    ///\n    /// A trailing stretch of `' '` is automatically taken to be the\n    /// whitespace part of the word.\n    pub fn from(word: &str) -> Word<'_> {\n        let trimmed = word.trim_end_matches(' ');\n        Word {\n            word: trimmed,\n            width: display_width(trimmed),\n            whitespace: &word[trimmed.len()..],\n            penalty: \"\",\n        }\n    }\n\n    /// Break this word into smaller words with a width of at most\n    /// `line_width`. The whitespace and penalty from this `Word` is\n    /// added to the last piece.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use textwrap::core::Word;\n    /// assert_eq!(\n    ///     Word::from(\"Hello!  \").break_apart(3).collect::<Vec<_>>(),\n    ///     vec![Word::from(\"Hel\"), Word::from(\"lo!  \")]\n    /// );\n    /// ```\n    pub fn break_apart<'b>(&'b self, line_width: usize) -> impl Iterator<Item = Word<'a>> + 'b {\n        let mut char_indices = self.word.char_indices();\n        let mut offset = 0;\n        let mut width = 0;\n\n        std::iter::from_fn(move || {\n            while let Some((idx, ch)) = char_indices.next() {\n                if skip_ansi_escape_sequence(ch, &mut char_indices.by_ref().map(|(_, ch)| ch)) {\n                    continue;\n                }\n\n                if width > 0 && width + ch_width(ch) > line_width {\n                    let word = Word {\n                        word: &self.word[offset..idx],\n                        width: width,\n                        whitespace: \"\",\n                        penalty: \"\",\n                    };\n                    offset = idx;\n                    width = ch_width(ch);\n                    return Some(word);\n                }\n\n                width += ch_width(ch);\n            }\n\n            if offset < self.word.len() {\n                let word = Word {\n                    word: &self.word[offset..],\n                    width: width,\n                    whitespace: self.whitespace,\n                    penalty: self.penalty,\n                };\n                offset = self.word.len();\n                return Some(word);\n            }\n\n            None\n        })\n    }\n}"],"line_ending::LineEnding":["Clone","Copy","Debug","Eq","PartialEq","impl LineEnding {\n    /// Turns this [`LineEnding`] value into its ASCII representation.\n    #[inline]\n    pub const fn as_str(&self) -> &'static str {\n        match self {\n            Self::CRLF => \"\\r\\n\",\n            Self::LF => \"\\n\",\n        }\n    }\n}"],"line_ending::NonEmptyLines":["Clone","Copy","Debug","impl<'a> Iterator for NonEmptyLines<'a> {\n    type Item = (&'a str, Option<LineEnding>);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(lf) = self.0.find('\\n') {\n            if lf == 0 || (lf == 1 && self.0.as_bytes()[lf - 1] == b'\\r') {\n                self.0 = &self.0[(lf + 1)..];\n                continue;\n            }\n            let trimmed = match self.0.as_bytes()[lf - 1] {\n                b'\\r' => (&self.0[..(lf - 1)], Some(LineEnding::CRLF)),\n                _ => (&self.0[..lf], Some(LineEnding::LF)),\n            };\n            self.0 = &self.0[(lf + 1)..];\n            return Some(trimmed);\n        }\n        if self.0.is_empty() {\n            None\n        } else {\n            let line = std::mem::take(&mut self.0);\n            Some((line, None))\n        }\n    }\n}"],"options::Options":["Clone","Debug","impl<'a> From<&'a Options<'a>> for Options<'a> {\n    fn from(options: &'a Options<'a>) -> Self {\n        Self {\n            width: options.width,\n            line_ending: options.line_ending,\n            initial_indent: options.initial_indent,\n            subsequent_indent: options.subsequent_indent,\n            break_words: options.break_words,\n            word_separator: options.word_separator,\n            wrap_algorithm: options.wrap_algorithm,\n            word_splitter: options.word_splitter.clone(),\n        }\n    }\n}","impl<'a> From<usize> for Options<'a> {\n    fn from(width: usize) -> Self {\n        Options::new(width)\n    }\n}","impl<'a> Options<'a> {\n    /// Creates a new [`Options`] with the specified width.\n    ///\n    /// The other fields are given default values as follows:\n    ///\n    /// ```\n    /// # use textwrap::{LineEnding, Options, WordSplitter, WordSeparator, WrapAlgorithm};\n    /// # let width = 80;\n    /// let options = Options::new(width);\n    /// assert_eq!(options.line_ending, LineEnding::LF);\n    /// assert_eq!(options.initial_indent, \"\");\n    /// assert_eq!(options.subsequent_indent, \"\");\n    /// assert_eq!(options.break_words, true);\n    ///\n    /// #[cfg(feature = \"unicode-linebreak\")]\n    /// assert_eq!(options.word_separator, WordSeparator::UnicodeBreakProperties);\n    /// #[cfg(not(feature = \"unicode-linebreak\"))]\n    /// assert_eq!(options.word_separator, WordSeparator::AsciiSpace);\n    ///\n    /// #[cfg(feature = \"smawk\")]\n    /// assert_eq!(options.wrap_algorithm, WrapAlgorithm::new_optimal_fit());\n    /// #[cfg(not(feature = \"smawk\"))]\n    /// assert_eq!(options.wrap_algorithm, WrapAlgorithm::FirstFit);\n    ///\n    /// assert_eq!(options.word_splitter, WordSplitter::HyphenSplitter);\n    /// ```\n    ///\n    /// Note that the default word separator and wrap algorithms\n    /// changes based on the available Cargo features. The best\n    /// available algorithms are used by default.\n    pub const fn new(width: usize) -> Self {\n        Options {\n            width,\n            line_ending: LineEnding::LF,\n            initial_indent: \"\",\n            subsequent_indent: \"\",\n            break_words: true,\n            word_separator: WordSeparator::new(),\n            wrap_algorithm: WrapAlgorithm::new(),\n            word_splitter: WordSplitter::HyphenSplitter,\n        }\n    }\n\n    /// Change [`self.line_ending`]. This specifies which of the\n    /// supported line endings should be used to break the lines of the\n    /// input text.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use textwrap::{refill, LineEnding, Options};\n    ///\n    /// let options = Options::new(15).line_ending(LineEnding::CRLF);\n    /// assert_eq!(refill(\"This is a little example.\", options),\n    ///            \"This is a\\r\\nlittle example.\");\n    /// ```\n    ///\n    /// [`self.line_ending`]: #structfield.line_ending\n    pub fn line_ending(self, line_ending: LineEnding) -> Self {\n        Options {\n            line_ending,\n            ..self\n        }\n    }\n\n    /// Change [`self.initial_indent`]. The initial indentation is\n    /// used on the very first line of output.\n    ///\n    /// # Examples\n    ///\n    /// Classic paragraph indentation can be achieved by specifying an\n    /// initial indentation and wrapping each paragraph by itself:\n    ///\n    /// ```\n    /// use textwrap::{wrap, Options};\n    ///\n    /// let options = Options::new(16).initial_indent(\"    \");\n    /// assert_eq!(wrap(\"This is a little example.\", options),\n    ///            vec![\"    This is a\",\n    ///                 \"little example.\"]);\n    /// ```\n    ///\n    /// [`self.initial_indent`]: #structfield.initial_indent\n    pub fn initial_indent(self, indent: &'a str) -> Self {\n        Options {\n            initial_indent: indent,\n            ..self\n        }\n    }\n\n    /// Change [`self.subsequent_indent`]. The subsequent indentation\n    /// is used on lines following the first line of output.\n    ///\n    /// # Examples\n    ///\n    /// Combining initial and subsequent indentation lets you format a\n    /// single paragraph as a bullet list:\n    ///\n    /// ```\n    /// use textwrap::{wrap, Options};\n    ///\n    /// let options = Options::new(12)\n    ///     .initial_indent(\"* \")\n    ///     .subsequent_indent(\"  \");\n    /// #[cfg(feature = \"smawk\")]\n    /// assert_eq!(wrap(\"This is a little example.\", options),\n    ///            vec![\"* This is\",\n    ///                 \"  a little\",\n    ///                 \"  example.\"]);\n    ///\n    /// // Without the `smawk` feature, the wrapping is a little different:\n    /// #[cfg(not(feature = \"smawk\"))]\n    /// assert_eq!(wrap(\"This is a little example.\", options),\n    ///            vec![\"* This is a\",\n    ///                 \"  little\",\n    ///                 \"  example.\"]);\n    /// ```\n    ///\n    /// [`self.subsequent_indent`]: #structfield.subsequent_indent\n    pub fn subsequent_indent(self, indent: &'a str) -> Self {\n        Options {\n            subsequent_indent: indent,\n            ..self\n        }\n    }\n\n    /// Change [`self.break_words`]. This controls if words longer\n    /// than `self.width` can be broken, or if they will be left\n    /// sticking out into the right margin.\n    ///\n    /// See [`Options::word_splitter`] instead if you want to control\n    /// hyphenation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use textwrap::{wrap, Options};\n    ///\n    /// let options = Options::new(4).break_words(true);\n    /// assert_eq!(wrap(\"This is a little example.\", options),\n    ///            vec![\"This\",\n    ///                 \"is a\",\n    ///                 \"litt\",\n    ///                 \"le\",\n    ///                 \"exam\",\n    ///                 \"ple.\"]);\n    /// ```\n    ///\n    /// [`self.break_words`]: #structfield.break_words\n    pub fn break_words(self, setting: bool) -> Self {\n        Options {\n            break_words: setting,\n            ..self\n        }\n    }\n\n    /// Change [`self.word_separator`].\n    ///\n    /// See the [`WordSeparator`] trait for details on the choices.\n    ///\n    /// [`self.word_separator`]: #structfield.word_separator\n    pub fn word_separator(self, word_separator: WordSeparator) -> Options<'a> {\n        Options {\n            width: self.width,\n            line_ending: self.line_ending,\n            initial_indent: self.initial_indent,\n            subsequent_indent: self.subsequent_indent,\n            break_words: self.break_words,\n            word_separator: word_separator,\n            wrap_algorithm: self.wrap_algorithm,\n            word_splitter: self.word_splitter,\n        }\n    }\n\n    /// Change [`self.wrap_algorithm`].\n    ///\n    /// See the [`WrapAlgorithm`] trait for details on the choices.\n    ///\n    /// [`self.wrap_algorithm`]: #structfield.wrap_algorithm\n    pub fn wrap_algorithm(self, wrap_algorithm: WrapAlgorithm) -> Options<'a> {\n        Options {\n            width: self.width,\n            line_ending: self.line_ending,\n            initial_indent: self.initial_indent,\n            subsequent_indent: self.subsequent_indent,\n            break_words: self.break_words,\n            word_separator: self.word_separator,\n            wrap_algorithm: wrap_algorithm,\n            word_splitter: self.word_splitter,\n        }\n    }\n\n    /// Change [`self.word_splitter`]. The [`WordSplitter`] is used to\n    /// fit part of a word into the current line when wrapping text.\n    ///\n    /// See [`Options::break_words`] instead if you want to control the\n    /// handling of words longer than the line width.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use textwrap::{wrap, Options, WordSplitter};\n    ///\n    /// // The default is WordSplitter::HyphenSplitter.\n    /// let options = Options::new(5);\n    /// assert_eq!(wrap(\"foo-bar-baz\", &options),\n    ///            vec![\"foo-\", \"bar-\", \"baz\"]);\n    ///\n    /// // The word is now so long that break_words kick in:\n    /// let options = Options::new(5)\n    ///     .word_splitter(WordSplitter::NoHyphenation);\n    /// assert_eq!(wrap(\"foo-bar-baz\", &options),\n    ///            vec![\"foo-b\", \"ar-ba\", \"z\"]);\n    ///\n    /// // If you want to breaks at all, disable both:\n    /// let options = Options::new(5)\n    ///     .break_words(false)\n    ///     .word_splitter(WordSplitter::NoHyphenation);\n    /// assert_eq!(wrap(\"foo-bar-baz\", &options),\n    ///            vec![\"foo-bar-baz\"]);\n    /// ```\n    ///\n    /// [`self.word_splitter`]: #structfield.word_splitter\n    pub fn word_splitter(self, word_splitter: WordSplitter) -> Options<'a> {\n        Options {\n            width: self.width,\n            line_ending: self.line_ending,\n            initial_indent: self.initial_indent,\n            subsequent_indent: self.subsequent_indent,\n            break_words: self.break_words,\n            word_separator: self.word_separator,\n            wrap_algorithm: self.wrap_algorithm,\n            word_splitter,\n        }\n    }\n}"],"word_separators::WordSeparator":["Clone","Copy","impl PartialEq for WordSeparator {\n    /// Compare two word separators.\n    ///\n    /// ```\n    /// use textwrap::WordSeparator;\n    ///\n    /// assert_eq!(WordSeparator::AsciiSpace, WordSeparator::AsciiSpace);\n    /// #[cfg(feature = \"unicode-linebreak\")] {\n    ///     assert_eq!(WordSeparator::UnicodeBreakProperties,\n    ///                WordSeparator::UnicodeBreakProperties);\n    /// }\n    /// ```\n    ///\n    /// Note that `WordSeparator::Custom` values never compare equal:\n    ///\n    /// ```\n    /// use textwrap::WordSeparator;\n    /// use textwrap::core::Word;\n    /// fn word_separator(line: &str) -> Box<dyn Iterator<Item = Word<'_>> + '_> {\n    ///     Box::new(line.split_inclusive(' ').map(Word::from))\n    /// }\n    /// assert_ne!(WordSeparator::Custom(word_separator),\n    ///            WordSeparator::Custom(word_separator));\n    /// ```\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (WordSeparator::AsciiSpace, WordSeparator::AsciiSpace) => true,\n            #[cfg(feature = \"unicode-linebreak\")]\n            (WordSeparator::UnicodeBreakProperties, WordSeparator::UnicodeBreakProperties) => true,\n            (_, _) => false,\n        }\n    }\n}","impl WordSeparator {\n    /// Create a new word separator.\n    ///\n    /// The best available algorithm is used by default, i.e.,\n    /// [`WordSeparator::UnicodeBreakProperties`] if available,\n    /// otherwise [`WordSeparator::AsciiSpace`].\n    pub const fn new() -> Self {\n        #[cfg(feature = \"unicode-linebreak\")]\n        {\n            WordSeparator::UnicodeBreakProperties\n        }\n\n        #[cfg(not(feature = \"unicode-linebreak\"))]\n        {\n            WordSeparator::AsciiSpace\n        }\n    }\n\n    // This function should really return impl Iterator<Item = Word>, but\n    // this isn't possible until Rust supports higher-kinded types:\n    // https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n    /// Find all words in `line`.\n    pub fn find_words<'a>(&self, line: &'a str) -> Box<dyn Iterator<Item = Word<'a>> + 'a> {\n        match self {\n            WordSeparator::AsciiSpace => find_words_ascii_space(line),\n            #[cfg(feature = \"unicode-linebreak\")]\n            WordSeparator::UnicodeBreakProperties => find_words_unicode_break_properties(line),\n            WordSeparator::Custom(func) => func(line),\n        }\n    }\n}","impl std::fmt::Debug for WordSeparator {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            WordSeparator::AsciiSpace => f.write_str(\"AsciiSpace\"),\n            #[cfg(feature = \"unicode-linebreak\")]\n            WordSeparator::UnicodeBreakProperties => f.write_str(\"UnicodeBreakProperties\"),\n            WordSeparator::Custom(_) => f.write_str(\"Custom(...)\"),\n        }\n    }\n}"],"word_splitters::WordSplitter":["Clone","impl PartialEq<WordSplitter> for WordSplitter {\n    fn eq(&self, other: &WordSplitter) -> bool {\n        match (self, other) {\n            (WordSplitter::NoHyphenation, WordSplitter::NoHyphenation) => true,\n            (WordSplitter::HyphenSplitter, WordSplitter::HyphenSplitter) => true,\n            #[cfg(feature = \"hyphenation\")]\n            (WordSplitter::Hyphenation(this_dict), WordSplitter::Hyphenation(other_dict)) => {\n                this_dict.language() == other_dict.language()\n            }\n            (_, _) => false,\n        }\n    }\n}","impl WordSplitter {\n    /// Return all possible indices where `word` can be split.\n    ///\n    /// The indices are in the range `0..word.len()`. They point to\n    /// the index _after_ the split point, i.e., after `-` if\n    /// splitting on hyphens. This way, `word.split_at(idx)` will\n    /// break the word into two well-formed pieces.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use textwrap::WordSplitter;\n    /// assert_eq!(WordSplitter::NoHyphenation.split_points(\"cannot-be-split\"), vec![]);\n    /// assert_eq!(WordSplitter::HyphenSplitter.split_points(\"can-be-split\"), vec![4, 7]);\n    /// assert_eq!(WordSplitter::Custom(|word| vec![word.len()/2]).split_points(\"middle\"), vec![3]);\n    /// ```\n    pub fn split_points(&self, word: &str) -> Vec<usize> {\n        match self {\n            WordSplitter::NoHyphenation => Vec::new(),\n            WordSplitter::HyphenSplitter => {\n                let mut splits = Vec::new();\n\n                for (idx, _) in word.match_indices('-') {\n                    // We only use hyphens that are surrounded by alphanumeric\n                    // characters. This is to avoid splitting on repeated hyphens,\n                    // such as those found in --foo-bar.\n                    let prev = word[..idx].chars().next_back();\n                    let next = word[idx + 1..].chars().next();\n\n                    if prev.filter(|ch| ch.is_alphanumeric()).is_some()\n                        && next.filter(|ch| ch.is_alphanumeric()).is_some()\n                    {\n                        splits.push(idx + 1); // +1 due to width of '-'.\n                    }\n                }\n\n                splits\n            }\n            WordSplitter::Custom(splitter_func) => splitter_func(word),\n            #[cfg(feature = \"hyphenation\")]\n            WordSplitter::Hyphenation(dictionary) => {\n                use hyphenation::Hyphenator;\n                dictionary.hyphenate(word).breaks\n            }\n        }\n    }\n}","impl std::fmt::Debug for WordSplitter {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            WordSplitter::NoHyphenation => f.write_str(\"NoHyphenation\"),\n            WordSplitter::HyphenSplitter => f.write_str(\"HyphenSplitter\"),\n            WordSplitter::Custom(_) => f.write_str(\"Custom(...)\"),\n            #[cfg(feature = \"hyphenation\")]\n            WordSplitter::Hyphenation(dict) => write!(f, \"Hyphenation({})\", dict.language()),\n        }\n    }\n}"],"wrap_algorithms::WrapAlgorithm":["Clone","Copy","impl Default for WrapAlgorithm {\n    fn default() -> Self {\n        WrapAlgorithm::new()\n    }\n}","impl PartialEq for WrapAlgorithm {\n    /// Compare two wrap algorithms.\n    ///\n    /// ```\n    /// use textwrap::WrapAlgorithm;\n    ///\n    /// assert_eq!(WrapAlgorithm::FirstFit, WrapAlgorithm::FirstFit);\n    /// #[cfg(feature = \"smawk\")] {\n    ///     assert_eq!(WrapAlgorithm::new_optimal_fit(), WrapAlgorithm::new_optimal_fit());\n    /// }\n    /// ```\n    ///\n    /// Note that `WrapAlgorithm::Custom` values never compare equal:\n    ///\n    /// ```\n    /// use textwrap::WrapAlgorithm;\n    ///\n    /// assert_ne!(WrapAlgorithm::Custom(|words, line_widths| vec![words]),\n    ///            WrapAlgorithm::Custom(|words, line_widths| vec![words]));\n    /// ```\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (WrapAlgorithm::FirstFit, WrapAlgorithm::FirstFit) => true,\n            #[cfg(feature = \"smawk\")]\n            (WrapAlgorithm::OptimalFit(a), WrapAlgorithm::OptimalFit(b)) => a == b,\n            (_, _) => false,\n        }\n    }\n}","impl WrapAlgorithm {\n    /// Create new wrap algorithm.\n    ///\n    /// The best wrapping algorithm is used by default, i.e.,\n    /// [`WrapAlgorithm::OptimalFit`] if available, otherwise\n    /// [`WrapAlgorithm::FirstFit`].\n    pub const fn new() -> Self {\n        #[cfg(not(feature = \"smawk\"))]\n        {\n            WrapAlgorithm::FirstFit\n        }\n\n        #[cfg(feature = \"smawk\")]\n        {\n            WrapAlgorithm::new_optimal_fit()\n        }\n    }\n\n    /// New [`WrapAlgorithm::OptimalFit`] with default penalties. This\n    /// works well for monospace text.\n    ///\n    /// **Note:** Only available when the `smawk` Cargo feature is\n    /// enabled.\n    #[cfg(feature = \"smawk\")]\n    pub const fn new_optimal_fit() -> Self {\n        WrapAlgorithm::OptimalFit(Penalties::new())\n    }\n\n    /// Wrap words according to line widths.\n    ///\n    /// The `line_widths` slice gives the target line width for each\n    /// line (the last slice element is repeated as necessary). This\n    /// can be used to implement hanging indentation.\n    #[inline]\n    pub fn wrap<'a, 'b>(\n        &self,\n        words: &'b [Word<'a>],\n        line_widths: &'b [usize],\n    ) -> Vec<&'b [Word<'a>]> {\n        // Every integer up to 2u64.pow(f64::MANTISSA_DIGITS) = 2**53\n        // = 9_007_199_254_740_992 can be represented without loss by\n        // a f64. Larger line widths will be rounded to the nearest\n        // representable number.\n        let f64_line_widths = line_widths.iter().map(|w| *w as f64).collect::<Vec<_>>();\n\n        match self {\n            WrapAlgorithm::FirstFit => wrap_first_fit(words, &f64_line_widths),\n\n            #[cfg(feature = \"smawk\")]\n            WrapAlgorithm::OptimalFit(penalties) => {\n                // The computation cannot overflow when the line\n                // widths are restricted to usize.\n                wrap_optimal_fit(words, &f64_line_widths, penalties).unwrap()\n            }\n\n            WrapAlgorithm::Custom(func) => func(words, line_widths),\n        }\n    }\n}","impl std::fmt::Debug for WrapAlgorithm {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            WrapAlgorithm::FirstFit => f.write_str(\"FirstFit\"),\n            #[cfg(feature = \"smawk\")]\n            WrapAlgorithm::OptimalFit(penalties) => write!(f, \"OptimalFit({:?})\", penalties),\n            WrapAlgorithm::Custom(_) => f.write_str(\"Custom(...)\"),\n        }\n    }\n}"],"wrap_algorithms::optimal_fit::LineNumbers":["impl LineNumbers {\n    fn new(size: usize) -> Self {\n        let mut line_numbers = Vec::with_capacity(size);\n        line_numbers.push(0);\n        LineNumbers {\n            line_numbers: RefCell::new(line_numbers),\n        }\n    }\n\n    fn get<T>(&self, i: usize, minima: &[(usize, T)]) -> usize {\n        while self.line_numbers.borrow_mut().len() < i + 1 {\n            let pos = self.line_numbers.borrow().len();\n            let line_number = 1 + self.get(minima[pos].0, minima);\n            self.line_numbers.borrow_mut().push(line_number);\n        }\n\n        self.line_numbers.borrow()[i]\n    }\n}"],"wrap_algorithms::optimal_fit::OverflowError":["Debug","Eq","PartialEq","impl std::error::Error for OverflowError {}","impl std::fmt::Display for OverflowError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"wrap_optimal_fit cost computation overflowed\")\n    }\n}"],"wrap_algorithms::optimal_fit::Penalties":["Clone","Copy","Debug","Eq","PartialEq","impl Default for Penalties {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl Penalties {\n    /// Default penalties for monospace text.\n    ///\n    /// The penalties here work well for monospace text. This is\n    /// because they expect the gaps at the end of lines to be roughly\n    /// in the range `0..100`. If the gaps are larger, the\n    /// `overflow_penalty` and `hyphen_penalty` become insignificant.\n    pub const fn new() -> Self {\n        Penalties {\n            nline_penalty: 1000,\n            overflow_penalty: 50 * 50,\n            short_last_line_fraction: 4,\n            short_last_line_penalty: 25,\n            hyphen_penalty: 25,\n        }\n    }\n}"]},"single_path_import":{"columns::wrap_columns":"wrap_columns","fill::fill":"fill","fill::fill_inplace":"fill_inplace","indentation::dedent":"dedent","indentation::indent":"indent","line_ending::LineEnding":"LineEnding","options::Options":"Options","refill::refill":"refill","refill::unfill":"unfill","word_separators::WordSeparator":"WordSeparator","word_splitters::WordSplitter":"WordSplitter","wrap::wrap":"wrap","wrap_algorithms::WrapAlgorithm":"WrapAlgorithm","wrap_algorithms::optimal_fit::OverflowError":"wrap_algorithms::OverflowError","wrap_algorithms::optimal_fit::Penalties":"wrap_algorithms::Penalties","wrap_algorithms::optimal_fit::wrap_optimal_fit":"wrap_algorithms::wrap_optimal_fit"},"srcs":{"<core::Word<'_> as core::Fragment>::penalty_width":["#[inline]\nfn penalty_width(&self) -> f64{\n        self.penalty.len() as f64\n    }","Real(LocalPath(\"src/core.rs\"))"],"<core::Word<'_> as core::Fragment>::whitespace_width":["#[inline]\nfn whitespace_width(&self) -> f64{\n        self.whitespace.len() as f64\n    }","Real(LocalPath(\"src/core.rs\"))"],"<core::Word<'_> as core::Fragment>::width":["#[inline]\nfn width(&self) -> f64{\n        self.width as f64\n    }","Real(LocalPath(\"src/core.rs\"))"],"<core::Word<'_> as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        self.word\n    }","Real(LocalPath(\"src/core.rs\"))"],"<line_ending::NonEmptyLines<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        while let Some(lf) = self.0.find('\\n') {\n            if lf == 0 || (lf == 1 && self.0.as_bytes()[lf - 1] == b'\\r') {\n                self.0 = &self.0[(lf + 1)..];\n                continue;\n            }\n            let trimmed = match self.0.as_bytes()[lf - 1] {\n                b'\\r' => (&self.0[..(lf - 1)], Some(LineEnding::CRLF)),\n                _ => (&self.0[..lf], Some(LineEnding::LF)),\n            };\n            self.0 = &self.0[(lf + 1)..];\n            return Some(trimmed);\n        }\n        if self.0.is_empty() {\n            None\n        } else {\n            let line = std::mem::take(&mut self.0);\n            Some((line, None))\n        }\n    }","Real(LocalPath(\"src/line_ending.rs\"))"],"<options::Options<'a> as std::convert::From<&'a options::Options<'a>>>::from":["fn from(options: &'a Options<'a>) -> Self{\n        Self {\n            width: options.width,\n            line_ending: options.line_ending,\n            initial_indent: options.initial_indent,\n            subsequent_indent: options.subsequent_indent,\n            break_words: options.break_words,\n            word_separator: options.word_separator,\n            wrap_algorithm: options.wrap_algorithm,\n            word_splitter: options.word_splitter.clone(),\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"<options::Options<'a> as std::convert::From<usize>>::from":["fn from(width: usize) -> Self{\n        Options::new(width)\n    }","Real(LocalPath(\"src/options.rs\"))"],"<word_separators::WordSeparator as std::cmp::PartialEq>::eq":["/// Compare two word separators.\n///\n/// ```\n/// use textwrap::WordSeparator;\n///\n/// assert_eq!(WordSeparator::AsciiSpace, WordSeparator::AsciiSpace);\n/// #[cfg(feature = \"unicode-linebreak\")] {\n///     assert_eq!(WordSeparator::UnicodeBreakProperties,\n///                WordSeparator::UnicodeBreakProperties);\n/// }\n/// ```\n///\n/// Note that `WordSeparator::Custom` values never compare equal:\n///\n/// ```\n/// use textwrap::WordSeparator;\n/// use textwrap::core::Word;\n/// fn word_separator(line: &str) -> Box<dyn Iterator<Item = Word<'_>> + '_> {\n///     Box::new(line.split_inclusive(' ').map(Word::from))\n/// }\n/// assert_ne!(WordSeparator::Custom(word_separator),\n///            WordSeparator::Custom(word_separator));\n/// ```\nfn eq(&self, other: &Self) -> bool{\n        match (self, other) {\n            (WordSeparator::AsciiSpace, WordSeparator::AsciiSpace) => true,\n            #[cfg(feature = \"unicode-linebreak\")]\n            (WordSeparator::UnicodeBreakProperties, WordSeparator::UnicodeBreakProperties) => true,\n            (_, _) => false,\n        }\n    }","Real(LocalPath(\"src/word_separators.rs\"))"],"<word_separators::WordSeparator as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        match self {\n            WordSeparator::AsciiSpace => f.write_str(\"AsciiSpace\"),\n            #[cfg(feature = \"unicode-linebreak\")]\n            WordSeparator::UnicodeBreakProperties => f.write_str(\"UnicodeBreakProperties\"),\n            WordSeparator::Custom(_) => f.write_str(\"Custom(...)\"),\n        }\n    }","Real(LocalPath(\"src/word_separators.rs\"))"],"<word_splitters::WordSplitter as std::cmp::PartialEq>::eq":["fn eq(&self, other: &WordSplitter) -> bool{\n        match (self, other) {\n            (WordSplitter::NoHyphenation, WordSplitter::NoHyphenation) => true,\n            (WordSplitter::HyphenSplitter, WordSplitter::HyphenSplitter) => true,\n            #[cfg(feature = \"hyphenation\")]\n            (WordSplitter::Hyphenation(this_dict), WordSplitter::Hyphenation(other_dict)) => {\n                this_dict.language() == other_dict.language()\n            }\n            (_, _) => false,\n        }\n    }","Real(LocalPath(\"src/word_splitters.rs\"))"],"<word_splitters::WordSplitter as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        match self {\n            WordSplitter::NoHyphenation => f.write_str(\"NoHyphenation\"),\n            WordSplitter::HyphenSplitter => f.write_str(\"HyphenSplitter\"),\n            WordSplitter::Custom(_) => f.write_str(\"Custom(...)\"),\n            #[cfg(feature = \"hyphenation\")]\n            WordSplitter::Hyphenation(dict) => write!(f, \"Hyphenation({})\", dict.language()),\n        }\n    }","Real(LocalPath(\"src/word_splitters.rs\"))"],"<wrap_algorithms::WrapAlgorithm as std::cmp::PartialEq>::eq":["/// Compare two wrap algorithms.\n///\n/// ```\n/// use textwrap::WrapAlgorithm;\n///\n/// assert_eq!(WrapAlgorithm::FirstFit, WrapAlgorithm::FirstFit);\n/// #[cfg(feature = \"smawk\")] {\n///     assert_eq!(WrapAlgorithm::new_optimal_fit(), WrapAlgorithm::new_optimal_fit());\n/// }\n/// ```\n///\n/// Note that `WrapAlgorithm::Custom` values never compare equal:\n///\n/// ```\n/// use textwrap::WrapAlgorithm;\n///\n/// assert_ne!(WrapAlgorithm::Custom(|words, line_widths| vec![words]),\n///            WrapAlgorithm::Custom(|words, line_widths| vec![words]));\n/// ```\nfn eq(&self, other: &Self) -> bool{\n        match (self, other) {\n            (WrapAlgorithm::FirstFit, WrapAlgorithm::FirstFit) => true,\n            #[cfg(feature = \"smawk\")]\n            (WrapAlgorithm::OptimalFit(a), WrapAlgorithm::OptimalFit(b)) => a == b,\n            (_, _) => false,\n        }\n    }","Real(LocalPath(\"src/wrap_algorithms.rs\"))"],"<wrap_algorithms::WrapAlgorithm as std::default::Default>::default":["fn default() -> Self{\n        WrapAlgorithm::new()\n    }","Real(LocalPath(\"src/wrap_algorithms.rs\"))"],"<wrap_algorithms::WrapAlgorithm as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        match self {\n            WrapAlgorithm::FirstFit => f.write_str(\"FirstFit\"),\n            #[cfg(feature = \"smawk\")]\n            WrapAlgorithm::OptimalFit(penalties) => write!(f, \"OptimalFit({:?})\", penalties),\n            WrapAlgorithm::Custom(_) => f.write_str(\"Custom(...)\"),\n        }\n    }","Real(LocalPath(\"src/wrap_algorithms.rs\"))"],"<wrap_algorithms::optimal_fit::OverflowError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        write!(f, \"wrap_optimal_fit cost computation overflowed\")\n    }","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"<wrap_algorithms::optimal_fit::Penalties as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"columns::wrap_columns":["/// Wrap text into columns with a given total width.\n///\n/// The `left_gap`, `middle_gap` and `right_gap` arguments specify the\n/// strings to insert before, between, and after the columns. The\n/// total width of all columns and all gaps is specified using the\n/// `total_width_or_options` argument. This argument can simply be an\n/// integer if you want to use default settings when wrapping, or it\n/// can be a [`Options`] value if you want to customize the wrapping.\n///\n/// If the columns are narrow, it is recommended to set\n/// [`Options::break_words`] to `true` to prevent words from\n/// protruding into the margins.\n///\n/// The per-column width is computed like this:\n///\n/// ```\n/// # let (left_gap, middle_gap, right_gap) = (\"\", \"\", \"\");\n/// # let columns = 2;\n/// # let options = textwrap::Options::new(80);\n/// let inner_width = options.width\n///     - textwrap::core::display_width(left_gap)\n///     - textwrap::core::display_width(right_gap)\n///     - textwrap::core::display_width(middle_gap) * (columns - 1);\n/// let column_width = inner_width / columns;\n/// ```\n///\n/// The `text` is wrapped using [`wrap()`] and the given `options`\n/// argument, but the width is overwritten to the computed\n/// `column_width`.\n///\n/// # Panics\n///\n/// Panics if `columns` is zero.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::wrap_columns;\n///\n/// let text = \"\\\n/// This is an example text, which is wrapped into three columns. \\\n/// Notice how the final column can be shorter than the others.\";\n///\n/// #[cfg(feature = \"smawk\")]\n/// assert_eq!(wrap_columns(text, 3, 50, \"| \", \" | \", \" |\"),\n///            vec![\"| This is       | into three    | column can be  |\",\n///                 \"| an example    | columns.      | shorter than   |\",\n///                 \"| text, which   | Notice how    | the others.    |\",\n///                 \"| is wrapped    | the final     |                |\"]);\n///\n/// // Without the `smawk` feature, the middle column is a little more uneven:\n/// #[cfg(not(feature = \"smawk\"))]\n/// assert_eq!(wrap_columns(text, 3, 50, \"| \", \" | \", \" |\"),\n///            vec![\"| This is an    | three         | column can be  |\",\n///                 \"| example text, | columns.      | shorter than   |\",\n///                 \"| which is      | Notice how    | the others.    |\",\n///                 \"| wrapped into  | the final     |                |\"]);\npub fn wrap_columns<'a, Opt>(\n    text: &str,\n    columns: usize,\n    total_width_or_options: Opt,\n    left_gap: &str,\n    middle_gap: &str,\n    right_gap: &str,\n) -> Vec<String>\nwhere\n    Opt: Into<Options<'a>>,{\n    assert!(columns > 0);\n\n    let mut options: Options = total_width_or_options.into();\n\n    let inner_width = options\n        .width\n        .saturating_sub(display_width(left_gap))\n        .saturating_sub(display_width(right_gap))\n        .saturating_sub(display_width(middle_gap) * (columns - 1));\n\n    let column_width = std::cmp::max(inner_width / columns, 1);\n    options.width = column_width;\n    let last_column_padding = \" \".repeat(inner_width % column_width);\n    let wrapped_lines = wrap(text, options);\n    let lines_per_column =\n        wrapped_lines.len() / columns + usize::from(wrapped_lines.len() % columns > 0);\n    let mut lines = Vec::new();\n    for line_no in 0..lines_per_column {\n        let mut line = String::from(left_gap);\n        for column_no in 0..columns {\n            match wrapped_lines.get(line_no + column_no * lines_per_column) {\n                Some(column_line) => {\n                    line.push_str(column_line);\n                    line.push_str(&\" \".repeat(column_width - display_width(column_line)));\n                }\n                None => {\n                    line.push_str(&\" \".repeat(column_width));\n                }\n            }\n            if column_no == columns - 1 {\n                line.push_str(&last_column_padding);\n            } else {\n                line.push_str(middle_gap);\n            }\n        }\n        line.push_str(right_gap);\n        lines.push(line);\n    }\n\n    lines\n}","Real(LocalPath(\"src/columns.rs\"))"],"core::Fragment":["/// A (text) fragment denotes the unit which we wrap into lines.\n///\n/// Fragments represent an abstract _word_ plus the _whitespace_\n/// following the word. In case the word falls at the end of the line,\n/// the whitespace is dropped and a so-called _penalty_ is inserted\n/// instead (typically `\"-\"` if the word was hyphenated).\n///\n/// For wrapping purposes, the precise content of the word, the\n/// whitespace, and the penalty is irrelevant. All we need to know is\n/// the displayed width of each part, which this trait provides.\npub trait Fragment: std::fmt::Debug {\n    /// Displayed width of word represented by this fragment.\n    fn width(&self) -> f64;\n\n    /// Displayed width of the whitespace that must follow the word\n    /// when the word is not at the end of a line.\n    fn whitespace_width(&self) -> f64;\n\n    /// Displayed width of the penalty that must be inserted if the\n    /// word falls at the end of a line.\n    fn penalty_width(&self) -> f64;\n}","Real(LocalPath(\"src/core.rs\"))"],"core::Word":["/// A piece of wrappable text, including any trailing whitespace.\n///\n/// A `Word` is an example of a [`Fragment`], so it has a width,\n/// trailing whitespace, and potentially a penalty item.\npub struct Word<'a> {\n    /// Word content.\n    pub word: &'a str,\n    /// Whitespace to insert if the word does not fall at the end of a line.\n    pub whitespace: &'a str,\n    /// Penalty string to insert if the word falls at the end of a line.\n    pub penalty: &'a str,\n    // Cached width in columns.\n    pub(crate) width: usize,\n}","Real(LocalPath(\"src/core.rs\"))"],"core::Word::<'a>::break_apart":["/// Break this word into smaller words with a width of at most\n/// `line_width`. The whitespace and penalty from this `Word` is\n/// added to the last piece.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::core::Word;\n/// assert_eq!(\n///     Word::from(\"Hello!  \").break_apart(3).collect::<Vec<_>>(),\n///     vec![Word::from(\"Hel\"), Word::from(\"lo!  \")]\n/// );\n/// ```\npub fn break_apart<'b>(&'b self, line_width: usize) -> impl Iterator<Item = Word<'a>> + 'b{\n        let mut char_indices = self.word.char_indices();\n        let mut offset = 0;\n        let mut width = 0;\n\n        std::iter::from_fn(move || {\n            while let Some((idx, ch)) = char_indices.next() {\n                if skip_ansi_escape_sequence(ch, &mut char_indices.by_ref().map(|(_, ch)| ch)) {\n                    continue;\n                }\n\n                if width > 0 && width + ch_width(ch) > line_width {\n                    let word = Word {\n                        word: &self.word[offset..idx],\n                        width: width,\n                        whitespace: \"\",\n                        penalty: \"\",\n                    };\n                    offset = idx;\n                    width = ch_width(ch);\n                    return Some(word);\n                }\n\n                width += ch_width(ch);\n            }\n\n            if offset < self.word.len() {\n                let word = Word {\n                    word: &self.word[offset..],\n                    width: width,\n                    whitespace: self.whitespace,\n                    penalty: self.penalty,\n                };\n                offset = self.word.len();\n                return Some(word);\n            }\n\n            None\n        })\n    }","Real(LocalPath(\"src/core.rs\"))"],"core::Word::<'a>::from":["/// Construct a `Word` from a string.\n///\n/// A trailing stretch of `' '` is automatically taken to be the\n/// whitespace part of the word.\npub fn from(word: &str) -> Word<'_>{\n        let trimmed = word.trim_end_matches(' ');\n        Word {\n            word: trimmed,\n            width: display_width(trimmed),\n            whitespace: &word[trimmed.len()..],\n            penalty: \"\",\n        }\n    }","Real(LocalPath(\"src/core.rs\"))"],"core::break_words":["/// Forcibly break words wider than `line_width` into smaller words.\n///\n/// This simply calls [`Word::break_apart`] on words that are too\n/// wide. This means that no extra `'-'` is inserted, the word is\n/// simply broken into smaller pieces.\npub fn break_words<'a, I>(words: I, line_width: usize) -> Vec<Word<'a>>\nwhere\n    I: IntoIterator<Item = Word<'a>>,{\n    let mut shortened_words = Vec::new();\n    for word in words {\n        if word.width() > line_width as f64 {\n            shortened_words.extend(word.break_apart(line_width));\n        } else {\n            shortened_words.push(word);\n        }\n    }\n    shortened_words\n}","Real(LocalPath(\"src/core.rs\"))"],"core::ch_width":["#[cfg(feature = \"unicode-width\")]\n#[inline]\nfn ch_width(ch: char) -> usize{\n    unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0)\n}","Real(LocalPath(\"src/core.rs\"))"],"core::display_width":["/// Compute the display width of `text` while skipping over ANSI\n/// escape sequences.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::core::display_width;\n///\n/// assert_eq!(display_width(\"Café Plain\"), 10);\n/// assert_eq!(display_width(\"\\u{1b}[31mCafé Rouge\\u{1b}[0m\"), 10);\n/// ```\n///\n/// **Note:** When the `unicode-width` Cargo feature is disabled, the\n/// width of a `char` is determined by a crude approximation which\n/// simply counts chars below U+1100 as 1 column wide, and all other\n/// characters as 2 columns wide. With the feature enabled, function\n/// will correctly deal with [combining characters] in their\n/// decomposed form (see [Unicode equivalence]).\n///\n/// An example of a decomposed character is “é”, which can be\n/// decomposed into: “e” followed by a combining acute accent: “◌́”.\n/// Without the `unicode-width` Cargo feature, every `char` below\n/// U+1100 has a width of 1. This includes the combining accent:\n///\n/// ```\n/// use textwrap::core::display_width;\n///\n/// assert_eq!(display_width(\"Cafe Plain\"), 10);\n/// #[cfg(feature = \"unicode-width\")]\n/// assert_eq!(display_width(\"Cafe\\u{301} Plain\"), 10);\n/// #[cfg(not(feature = \"unicode-width\"))]\n/// assert_eq!(display_width(\"Cafe\\u{301} Plain\"), 11);\n/// ```\n///\n/// ## Emojis and CJK Characters\n///\n/// Characters such as emojis and [CJK characters] used in the\n/// Chinese, Japanese, and Korean languages are seen as double-width,\n/// even if the `unicode-width` feature is disabled:\n///\n/// ```\n/// use textwrap::core::display_width;\n///\n/// assert_eq!(display_width(\"😂😭🥺🤣✨😍🙏🥰😊🔥\"), 20);\n/// assert_eq!(display_width(\"你好\"), 4);  // “Nǐ hǎo” or “Hello” in Chinese\n/// ```\n///\n/// # Limitations\n///\n/// The displayed width of a string cannot always be computed from the\n/// string alone. This is because the width depends on the rendering\n/// engine used. This is particularly visible with [emoji modifier\n/// sequences] where a base emoji is modified with, e.g., skin tone or\n/// hair color modifiers. It is up to the rendering engine to detect\n/// this and to produce a suitable emoji.\n///\n/// A simple example is “❤️”, which consists of “❤” (U+2764: Black\n/// Heart Symbol) followed by U+FE0F (Variation Selector-16). By\n/// itself, “❤” is a black heart, but if you follow it with the\n/// variant selector, you may get a wider red heart.\n///\n/// A more complex example would be “👨‍🦰” which should depict a man\n/// with red hair. Here the computed width is too large — and the\n/// width differs depending on the use of the `unicode-width` feature:\n///\n/// ```\n/// use textwrap::core::display_width;\n///\n/// assert_eq!(\"👨‍🦰\".chars().collect::<Vec<char>>(), ['\\u{1f468}', '\\u{200d}', '\\u{1f9b0}']);\n/// #[cfg(feature = \"unicode-width\")]\n/// assert_eq!(display_width(\"👨‍🦰\"), 4);\n/// #[cfg(not(feature = \"unicode-width\"))]\n/// assert_eq!(display_width(\"👨‍🦰\"), 6);\n/// ```\n///\n/// This happens because the grapheme consists of three code points:\n/// “👨” (U+1F468: Man), Zero Width Joiner (U+200D), and “🦰”\n/// (U+1F9B0: Red Hair). You can see them above in the test. With\n/// `unicode-width` enabled, the ZWJ is correctly seen as having zero\n/// width, without it is counted as a double-width character.\n///\n/// ## Terminal Support\n///\n/// Modern browsers typically do a great job at combining characters\n/// as shown above, but terminals often struggle more. As an example,\n/// Gnome Terminal version 3.38.1, shows “❤️” as a big red heart, but\n/// shows \"👨‍🦰\" as “👨🦰”.\n///\n/// [combining characters]: https://en.wikipedia.org/wiki/Combining_character\n/// [Unicode equivalence]: https://en.wikipedia.org/wiki/Unicode_equivalence\n/// [CJK characters]: https://en.wikipedia.org/wiki/CJK_characters\n/// [emoji modifier sequences]: https://unicode.org/emoji/charts/full-emoji-modifiers.html\npub fn display_width(text: &str) -> usize{\n    let mut chars = text.chars();\n    let mut width = 0;\n    while let Some(ch) = chars.next() {\n        if skip_ansi_escape_sequence(ch, &mut chars) {\n            continue;\n        }\n        width += ch_width(ch);\n    }\n    width\n}","Real(LocalPath(\"src/core.rs\"))"],"core::skip_ansi_escape_sequence":["/// Skip ANSI escape sequences. The `ch` is the current `char`, the\n/// `chars` provide the following characters. The `chars` will be\n/// modified if `ch` is the start of an ANSI escape sequence.\n#[inline]\npub(crate) fn skip_ansi_escape_sequence<I: Iterator<Item = char>>(ch: char, chars: &mut I) -> bool{\n    if ch == CSI.0 && chars.next() == Some(CSI.1) {\n        // We have found the start of an ANSI escape code, typically\n        // used for colored terminal text. We skip until we find a\n        // \"final byte\" in the range 0x40–0x7E.\n        for ch in chars {\n            if ANSI_FINAL_BYTE.contains(&ch) {\n                return true;\n            }\n        }\n    }\n    false\n}","Real(LocalPath(\"src/core.rs\"))"],"fill::fill":["/// Fill a line of text at a given width.\n///\n/// The result is a [`String`], complete with newlines between each\n/// line. Use [`wrap()`] if you need access to the individual lines.\n///\n/// The easiest way to use this function is to pass an integer for\n/// `width_or_options`:\n///\n/// ```\n/// use textwrap::fill;\n///\n/// assert_eq!(\n///     fill(\"Memory safety without garbage collection.\", 15),\n///     \"Memory safety\\nwithout garbage\\ncollection.\"\n/// );\n/// ```\n///\n/// If you need to customize the wrapping, you can pass an [`Options`]\n/// instead of an `usize`:\n///\n/// ```\n/// use textwrap::{fill, Options};\n///\n/// let options = Options::new(15)\n///     .initial_indent(\"- \")\n///     .subsequent_indent(\"  \");\n/// assert_eq!(\n///     fill(\"Memory safety without garbage collection.\", &options),\n///     \"- Memory safety\\n  without\\n  garbage\\n  collection.\"\n/// );\n/// ```\npub fn fill<'a, Opt>(text: &str, width_or_options: Opt) -> String\nwhere\n    Opt: Into<Options<'a>>,{\n    let options = width_or_options.into();\n\n    if text.len() < options.width && !text.contains('\\n') && options.initial_indent.is_empty() {\n        String::from(text.trim_end_matches(' '))\n    } else {\n        fill_slow_path(text, options)\n    }\n}","Real(LocalPath(\"src/fill.rs\"))"],"fill::fill_inplace":["/// Fill `text` in-place without reallocating the input string.\n///\n/// This function works by modifying the input string: some `' '`\n/// characters will be replaced by `'\\n'` characters. The rest of the\n/// text remains untouched.\n///\n/// Since we can only replace existing whitespace in the input with\n/// `'\\n'` (there is no space for `\"\\r\\n\"`), we cannot do hyphenation\n/// nor can we split words longer than the line width. We also need to\n/// use `AsciiSpace` as the word separator since we need `' '`\n/// characters between words in order to replace some of them with a\n/// `'\\n'`. Indentation is also ruled out. In other words,\n/// `fill_inplace(width)` behaves as if you had called [`fill()`] with\n/// these options:\n///\n/// ```\n/// # use textwrap::{core, LineEnding, Options, WordSplitter, WordSeparator, WrapAlgorithm};\n/// # let width = 80;\n/// Options::new(width)\n///     .break_words(false)\n///     .line_ending(LineEnding::LF)\n///     .word_separator(WordSeparator::AsciiSpace)\n///     .wrap_algorithm(WrapAlgorithm::FirstFit)\n///     .word_splitter(WordSplitter::NoHyphenation);\n/// ```\n///\n/// The wrap algorithm is\n/// [`WrapAlgorithm::FirstFit`](crate::WrapAlgorithm::FirstFit) since\n/// this is the fastest algorithm — and the main reason to use\n/// `fill_inplace` is to get the string broken into newlines as fast\n/// as possible.\n///\n/// A last difference is that (unlike [`fill()`]) `fill_inplace` can\n/// leave trailing whitespace on lines. This is because we wrap by\n/// inserting a `'\\n'` at the final whitespace in the input string:\n///\n/// ```\n/// let mut text = String::from(\"Hello   World!\");\n/// textwrap::fill_inplace(&mut text, 10);\n/// assert_eq!(text, \"Hello  \\nWorld!\");\n/// ```\n///\n/// If we didn't do this, the word `World!` would end up being\n/// indented. You can avoid this if you make sure that your input text\n/// has no double spaces.\n///\n/// # Performance\n///\n/// In benchmarks, `fill_inplace` is about twice as fast as\n/// [`fill()`]. Please see the [`linear`\n/// benchmark](https://github.com/mgeisler/textwrap/blob/master/benchmarks/linear.rs)\n/// for details.\npub fn fill_inplace(text: &mut String, width: usize){\n    let mut indices = Vec::new();\n\n    let mut offset = 0;\n    for line in text.split('\\n') {\n        let words = WordSeparator::AsciiSpace\n            .find_words(line)\n            .collect::<Vec<_>>();\n        let wrapped_words = wrap_algorithms::wrap_first_fit(&words, &[width as f64]);\n\n        let mut line_offset = offset;\n        for words in &wrapped_words[..wrapped_words.len() - 1] {\n            let line_len = words\n                .iter()\n                .map(|word| word.len() + word.whitespace.len())\n                .sum::<usize>();\n\n            line_offset += line_len;\n            // We've advanced past all ' ' characters -- want to move\n            // one ' ' backwards and insert our '\\n' there.\n            indices.push(line_offset - 1);\n        }\n\n        // Advance past entire line, plus the '\\n' which was removed\n        // by the split call above.\n        offset += line.len() + 1;\n    }\n\n    let mut bytes = std::mem::take(text).into_bytes();\n    for idx in indices {\n        bytes[idx] = b'\\n';\n    }\n    *text = String::from_utf8(bytes).unwrap();\n}","Real(LocalPath(\"src/fill.rs\"))"],"fill::fill_slow_path":["/// Slow path for fill.\n///\n/// This is taken when `text` is longer than `options.width`.\npub(crate) fn fill_slow_path(text: &str, options: Options<'_>) -> String{\n    // This will avoid reallocation in simple cases (no\n    // indentation, no hyphenation).\n    let mut result = String::with_capacity(text.len());\n\n    let line_ending_str = options.line_ending.as_str();\n    for (i, line) in wrap(text, options).iter().enumerate() {\n        if i > 0 {\n            result.push_str(line_ending_str);\n        }\n        result.push_str(line);\n    }\n\n    result\n}","Real(LocalPath(\"src/fill.rs\"))"],"indentation::dedent":["/// Removes common leading whitespace from each line.\n///\n/// This function will look at each non-empty line and determine the\n/// maximum amount of whitespace that can be removed from all lines:\n///\n/// ```\n/// use textwrap::dedent;\n///\n/// assert_eq!(dedent(\"\n///     1st line\n///       2nd line\n///     3rd line\n/// \"), \"\n/// 1st line\n///   2nd line\n/// 3rd line\n/// \");\n/// ```\npub fn dedent(s: &str) -> String{\n    let mut prefix = \"\";\n    let mut lines = s.lines();\n\n    // We first search for a non-empty line to find a prefix.\n    for line in &mut lines {\n        let mut whitespace_idx = line.len();\n        for (idx, ch) in line.char_indices() {\n            if !ch.is_whitespace() {\n                whitespace_idx = idx;\n                break;\n            }\n        }\n\n        // Check if the line had anything but whitespace\n        if whitespace_idx < line.len() {\n            prefix = &line[..whitespace_idx];\n            break;\n        }\n    }\n\n    // We then continue looking through the remaining lines to\n    // possibly shorten the prefix.\n    for line in &mut lines {\n        let mut whitespace_idx = line.len();\n        for ((idx, a), b) in line.char_indices().zip(prefix.chars()) {\n            if a != b {\n                whitespace_idx = idx;\n                break;\n            }\n        }\n\n        // Check if the line had anything but whitespace and if we\n        // have found a shorter prefix\n        if whitespace_idx < line.len() && whitespace_idx < prefix.len() {\n            prefix = &line[..whitespace_idx];\n        }\n    }\n\n    // We now go over the lines a second time to build the result.\n    let mut result = String::new();\n    for line in s.lines() {\n        if line.starts_with(prefix) && line.chars().any(|c| !c.is_whitespace()) {\n            let (_, tail) = line.split_at(prefix.len());\n            result.push_str(tail);\n        }\n        result.push('\\n');\n    }\n\n    if result.ends_with('\\n') && !s.ends_with('\\n') {\n        let new_len = result.len() - 1;\n        result.truncate(new_len);\n    }\n\n    result\n}","Real(LocalPath(\"src/indentation.rs\"))"],"indentation::indent":["/// Indent each line by the given prefix.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::indent;\n///\n/// assert_eq!(indent(\"First line.\\nSecond line.\\n\", \"  \"),\n///            \"  First line.\\n  Second line.\\n\");\n/// ```\n///\n/// When indenting, trailing whitespace is stripped from the prefix.\n/// This means that empty lines remain empty afterwards:\n///\n/// ```\n/// use textwrap::indent;\n///\n/// assert_eq!(indent(\"First line.\\n\\n\\nSecond line.\\n\", \"  \"),\n///            \"  First line.\\n\\n\\n  Second line.\\n\");\n/// ```\n///\n/// Notice how `\"\\n\\n\\n\"` remained as `\"\\n\\n\\n\"`.\n///\n/// This feature is useful when you want to indent text and have a\n/// space between your prefix and the text. In this case, you _don't_\n/// want a trailing space on empty lines:\n///\n/// ```\n/// use textwrap::indent;\n///\n/// assert_eq!(indent(\"foo = 123\\n\\nprint(foo)\\n\", \"# \"),\n///            \"# foo = 123\\n#\\n# print(foo)\\n\");\n/// ```\n///\n/// Notice how `\"\\n\\n\"` became `\"\\n#\\n\"` instead of `\"\\n# \\n\"` which\n/// would have trailing whitespace.\n///\n/// Leading and trailing whitespace coming from the text itself is\n/// kept unchanged:\n///\n/// ```\n/// use textwrap::indent;\n///\n/// assert_eq!(indent(\" \\t  Foo   \", \"->\"), \"-> \\t  Foo   \");\n/// ```\npub fn indent(s: &str, prefix: &str) -> String{\n    // We know we'll need more than s.len() bytes for the output, but\n    // without counting '\\n' characters (which is somewhat slow), we\n    // don't know exactly how much. However, we can preemptively do\n    // the first doubling of the output size.\n    let mut result = String::with_capacity(2 * s.len());\n    let trimmed_prefix = prefix.trim_end();\n    for (idx, line) in s.split_terminator('\\n').enumerate() {\n        if idx > 0 {\n            result.push('\\n');\n        }\n        if line.trim().is_empty() {\n            result.push_str(trimmed_prefix);\n        } else {\n            result.push_str(prefix);\n        }\n        result.push_str(line);\n    }\n    if s.ends_with('\\n') {\n        // split_terminator will have eaten the final '\\n'.\n        result.push('\\n');\n    }\n    result\n}","Real(LocalPath(\"src/indentation.rs\"))"],"line_ending::LineEnding":["/// Supported line endings. Like in the Rust standard library, two line\n/// endings are supported: `\\r\\n` and `\\n`\npub enum LineEnding {\n    /// _Carriage return and line feed_ – a line ending sequence\n    /// historically used in Windows. Corresponds to the sequence\n    /// of ASCII control characters `0x0D 0x0A` or `\\r\\n`\n    CRLF,\n    /// _Line feed_ – a line ending historically used in Unix.\n    ///  Corresponds to the ASCII control character `0x0A` or `\\n`\n    LF,\n}","Real(LocalPath(\"src/line_ending.rs\"))"],"line_ending::LineEnding::as_str":["/// Turns this [`LineEnding`] value into its ASCII representation.\n#[inline]\npub const fn as_str(&self) -> &'static str{\n        match self {\n            Self::CRLF => \"\\r\\n\",\n            Self::LF => \"\\n\",\n        }\n    }","Real(LocalPath(\"src/line_ending.rs\"))"],"line_ending::NonEmptyLines":["/// An iterator over the lines of a string, as tuples of string slice\n/// and [`LineEnding`] value; it only emits non-empty lines (i.e. having\n/// some content before the terminating `\\r\\n` or `\\n`).\n///\n/// This struct is used internally by the library.\npub(crate) struct NonEmptyLines<'a>(pub &'a str);","Real(LocalPath(\"src/line_ending.rs\"))"],"options::Options":["/// Holds configuration options for wrapping and filling text.\n#[non_exhaustive]\npub struct Options<'a> {\n    /// The width in columns at which the text will be wrapped.\n    pub width: usize,\n    /// Line ending used for breaking lines.\n    pub line_ending: LineEnding,\n    /// Indentation used for the first line of output. See the\n    /// [`Options::initial_indent`] method.\n    pub initial_indent: &'a str,\n    /// Indentation used for subsequent lines of output. See the\n    /// [`Options::subsequent_indent`] method.\n    pub subsequent_indent: &'a str,\n    /// Allow long words to be broken if they cannot fit on a line.\n    /// When set to `false`, some lines may be longer than\n    /// `self.width`. See the [`Options::break_words`] method.\n    pub break_words: bool,\n    /// Wrapping algorithm to use, see the implementations of the\n    /// [`WrapAlgorithm`] trait for details.\n    pub wrap_algorithm: WrapAlgorithm,\n    /// The line breaking algorithm to use, see the [`WordSeparator`]\n    /// trait for an overview and possible implementations.\n    pub word_separator: WordSeparator,\n    /// The method for splitting words. This can be used to prohibit\n    /// splitting words on hyphens, or it can be used to implement\n    /// language-aware machine hyphenation.\n    pub word_splitter: WordSplitter,\n}","Real(LocalPath(\"src/options.rs\"))"],"options::Options::<'a>::break_words":["/// Change [`self.break_words`]. This controls if words longer\n/// than `self.width` can be broken, or if they will be left\n/// sticking out into the right margin.\n///\n/// See [`Options::word_splitter`] instead if you want to control\n/// hyphenation.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::{wrap, Options};\n///\n/// let options = Options::new(4).break_words(true);\n/// assert_eq!(wrap(\"This is a little example.\", options),\n///            vec![\"This\",\n///                 \"is a\",\n///                 \"litt\",\n///                 \"le\",\n///                 \"exam\",\n///                 \"ple.\"]);\n/// ```\n///\n/// [`self.break_words`]: #structfield.break_words\npub fn break_words(self, setting: bool) -> Self{\n        Options {\n            break_words: setting,\n            ..self\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"options::Options::<'a>::initial_indent":["/// Change [`self.initial_indent`]. The initial indentation is\n/// used on the very first line of output.\n///\n/// # Examples\n///\n/// Classic paragraph indentation can be achieved by specifying an\n/// initial indentation and wrapping each paragraph by itself:\n///\n/// ```\n/// use textwrap::{wrap, Options};\n///\n/// let options = Options::new(16).initial_indent(\"    \");\n/// assert_eq!(wrap(\"This is a little example.\", options),\n///            vec![\"    This is a\",\n///                 \"little example.\"]);\n/// ```\n///\n/// [`self.initial_indent`]: #structfield.initial_indent\npub fn initial_indent(self, indent: &'a str) -> Self{\n        Options {\n            initial_indent: indent,\n            ..self\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"options::Options::<'a>::line_ending":["/// Change [`self.line_ending`]. This specifies which of the\n/// supported line endings should be used to break the lines of the\n/// input text.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::{refill, LineEnding, Options};\n///\n/// let options = Options::new(15).line_ending(LineEnding::CRLF);\n/// assert_eq!(refill(\"This is a little example.\", options),\n///            \"This is a\\r\\nlittle example.\");\n/// ```\n///\n/// [`self.line_ending`]: #structfield.line_ending\npub fn line_ending(self, line_ending: LineEnding) -> Self{\n        Options {\n            line_ending,\n            ..self\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"options::Options::<'a>::new":["/// Creates a new [`Options`] with the specified width.\n///\n/// The other fields are given default values as follows:\n///\n/// ```\n/// # use textwrap::{LineEnding, Options, WordSplitter, WordSeparator, WrapAlgorithm};\n/// # let width = 80;\n/// let options = Options::new(width);\n/// assert_eq!(options.line_ending, LineEnding::LF);\n/// assert_eq!(options.initial_indent, \"\");\n/// assert_eq!(options.subsequent_indent, \"\");\n/// assert_eq!(options.break_words, true);\n///\n/// #[cfg(feature = \"unicode-linebreak\")]\n/// assert_eq!(options.word_separator, WordSeparator::UnicodeBreakProperties);\n/// #[cfg(not(feature = \"unicode-linebreak\"))]\n/// assert_eq!(options.word_separator, WordSeparator::AsciiSpace);\n///\n/// #[cfg(feature = \"smawk\")]\n/// assert_eq!(options.wrap_algorithm, WrapAlgorithm::new_optimal_fit());\n/// #[cfg(not(feature = \"smawk\"))]\n/// assert_eq!(options.wrap_algorithm, WrapAlgorithm::FirstFit);\n///\n/// assert_eq!(options.word_splitter, WordSplitter::HyphenSplitter);\n/// ```\n///\n/// Note that the default word separator and wrap algorithms\n/// changes based on the available Cargo features. The best\n/// available algorithms are used by default.\npub const fn new(width: usize) -> Self{\n        Options {\n            width,\n            line_ending: LineEnding::LF,\n            initial_indent: \"\",\n            subsequent_indent: \"\",\n            break_words: true,\n            word_separator: WordSeparator::new(),\n            wrap_algorithm: WrapAlgorithm::new(),\n            word_splitter: WordSplitter::HyphenSplitter,\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"options::Options::<'a>::subsequent_indent":["/// Change [`self.subsequent_indent`]. The subsequent indentation\n/// is used on lines following the first line of output.\n///\n/// # Examples\n///\n/// Combining initial and subsequent indentation lets you format a\n/// single paragraph as a bullet list:\n///\n/// ```\n/// use textwrap::{wrap, Options};\n///\n/// let options = Options::new(12)\n///     .initial_indent(\"* \")\n///     .subsequent_indent(\"  \");\n/// #[cfg(feature = \"smawk\")]\n/// assert_eq!(wrap(\"This is a little example.\", options),\n///            vec![\"* This is\",\n///                 \"  a little\",\n///                 \"  example.\"]);\n///\n/// // Without the `smawk` feature, the wrapping is a little different:\n/// #[cfg(not(feature = \"smawk\"))]\n/// assert_eq!(wrap(\"This is a little example.\", options),\n///            vec![\"* This is a\",\n///                 \"  little\",\n///                 \"  example.\"]);\n/// ```\n///\n/// [`self.subsequent_indent`]: #structfield.subsequent_indent\npub fn subsequent_indent(self, indent: &'a str) -> Self{\n        Options {\n            subsequent_indent: indent,\n            ..self\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"options::Options::<'a>::word_separator":["/// Change [`self.word_separator`].\n///\n/// See the [`WordSeparator`] trait for details on the choices.\n///\n/// [`self.word_separator`]: #structfield.word_separator\npub fn word_separator(self, word_separator: WordSeparator) -> Options<'a>{\n        Options {\n            width: self.width,\n            line_ending: self.line_ending,\n            initial_indent: self.initial_indent,\n            subsequent_indent: self.subsequent_indent,\n            break_words: self.break_words,\n            word_separator: word_separator,\n            wrap_algorithm: self.wrap_algorithm,\n            word_splitter: self.word_splitter,\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"options::Options::<'a>::word_splitter":["/// Change [`self.word_splitter`]. The [`WordSplitter`] is used to\n/// fit part of a word into the current line when wrapping text.\n///\n/// See [`Options::break_words`] instead if you want to control the\n/// handling of words longer than the line width.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::{wrap, Options, WordSplitter};\n///\n/// // The default is WordSplitter::HyphenSplitter.\n/// let options = Options::new(5);\n/// assert_eq!(wrap(\"foo-bar-baz\", &options),\n///            vec![\"foo-\", \"bar-\", \"baz\"]);\n///\n/// // The word is now so long that break_words kick in:\n/// let options = Options::new(5)\n///     .word_splitter(WordSplitter::NoHyphenation);\n/// assert_eq!(wrap(\"foo-bar-baz\", &options),\n///            vec![\"foo-b\", \"ar-ba\", \"z\"]);\n///\n/// // If you want to breaks at all, disable both:\n/// let options = Options::new(5)\n///     .break_words(false)\n///     .word_splitter(WordSplitter::NoHyphenation);\n/// assert_eq!(wrap(\"foo-bar-baz\", &options),\n///            vec![\"foo-bar-baz\"]);\n/// ```\n///\n/// [`self.word_splitter`]: #structfield.word_splitter\npub fn word_splitter(self, word_splitter: WordSplitter) -> Options<'a>{\n        Options {\n            width: self.width,\n            line_ending: self.line_ending,\n            initial_indent: self.initial_indent,\n            subsequent_indent: self.subsequent_indent,\n            break_words: self.break_words,\n            word_separator: self.word_separator,\n            wrap_algorithm: self.wrap_algorithm,\n            word_splitter,\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"options::Options::<'a>::wrap_algorithm":["/// Change [`self.wrap_algorithm`].\n///\n/// See the [`WrapAlgorithm`] trait for details on the choices.\n///\n/// [`self.wrap_algorithm`]: #structfield.wrap_algorithm\npub fn wrap_algorithm(self, wrap_algorithm: WrapAlgorithm) -> Options<'a>{\n        Options {\n            width: self.width,\n            line_ending: self.line_ending,\n            initial_indent: self.initial_indent,\n            subsequent_indent: self.subsequent_indent,\n            break_words: self.break_words,\n            word_separator: self.word_separator,\n            wrap_algorithm: wrap_algorithm,\n            word_splitter: self.word_splitter,\n        }\n    }","Real(LocalPath(\"src/options.rs\"))"],"refill::refill":["/// Refill a paragraph of wrapped text with a new width.\n///\n/// This function will first use [`unfill()`] to remove newlines from\n/// the text. Afterwards the text is filled again using [`fill()`].\n///\n/// The `new_width_or_options` argument specify the new width and can\n/// specify other options as well — except for\n/// [`Options::initial_indent`] and [`Options::subsequent_indent`],\n/// which are deduced from `filled_text`.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::refill;\n///\n/// // Some loosely wrapped text. The \"> \" prefix is recognized automatically.\n/// let text = \"\\\n/// > Memory\n/// > safety without garbage\n/// > collection.\n/// \";\n///\n/// assert_eq!(refill(text, 20), \"\\\n/// > Memory safety\n/// > without garbage\n/// > collection.\n/// \");\n///\n/// assert_eq!(refill(text, 40), \"\\\n/// > Memory safety without garbage\n/// > collection.\n/// \");\n///\n/// assert_eq!(refill(text, 60), \"\\\n/// > Memory safety without garbage collection.\n/// \");\n/// ```\n///\n/// You can also reshape bullet points:\n///\n/// ```\n/// use textwrap::refill;\n///\n/// let text = \"\\\n/// - This is my\n///   list item.\n/// \";\n///\n/// assert_eq!(refill(text, 20), \"\\\n/// - This is my list\n///   item.\n/// \");\n/// ```\npub fn refill<'a, Opt>(filled_text: &str, new_width_or_options: Opt) -> String\nwhere\n    Opt: Into<Options<'a>>,{\n    let mut new_options = new_width_or_options.into();\n    let (text, options) = unfill(filled_text);\n    // The original line ending is kept by `unfill`.\n    let stripped = text.strip_suffix(options.line_ending.as_str());\n    let new_line_ending = new_options.line_ending.as_str();\n\n    new_options.initial_indent = options.initial_indent;\n    new_options.subsequent_indent = options.subsequent_indent;\n    let mut refilled = fill(stripped.unwrap_or(&text), new_options);\n\n    // Add back right line ending if we stripped one off above.\n    if stripped.is_some() {\n        refilled.push_str(new_line_ending);\n    }\n    refilled\n}","Real(LocalPath(\"src/refill.rs\"))"],"refill::unfill":["/// Unpack a paragraph of already-wrapped text.\n///\n/// This function attempts to recover the original text from a single\n/// paragraph of wrapped text, such as what [`fill()`] would produce.\n/// This means that it turns\n///\n/// ```text\n/// textwrap: a small\n/// library for\n/// wrapping text.\n/// ```\n///\n/// back into\n///\n/// ```text\n/// textwrap: a small library for wrapping text.\n/// ```\n///\n/// In addition, it will recognize a common prefix and a common line\n/// ending among the lines.\n///\n/// The prefix of the first line is returned in\n/// [`Options::initial_indent`] and the prefix (if any) of the the\n/// other lines is returned in [`Options::subsequent_indent`].\n///\n/// Line ending is returned in [`Options::line_ending`]. If line ending\n/// can not be confidently detected (mixed or no line endings in the\n/// input), [`LineEnding::LF`] will be returned.\n///\n/// In addition to `' '`, the prefixes can consist of characters used\n/// for unordered lists (`'-'`, `'+'`, and `'*'`) and block quotes\n/// (`'>'`) in Markdown as well as characters often used for inline\n/// comments (`'#'` and `'/'`).\n///\n/// The text must come from a single wrapped paragraph. This means\n/// that there can be no empty lines (`\"\\n\\n\"` or `\"\\r\\n\\r\\n\"`) within\n/// the text. It is unspecified what happens if `unfill` is called on\n/// more than one paragraph of text.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::{LineEnding, unfill};\n///\n/// let (text, options) = unfill(\"\\\n/// * This is an\n///   example of\n///   a list item.\n/// \");\n///\n/// assert_eq!(text, \"This is an example of a list item.\\n\");\n/// assert_eq!(options.initial_indent, \"* \");\n/// assert_eq!(options.subsequent_indent, \"  \");\n/// assert_eq!(options.line_ending, LineEnding::LF);\n/// ```\npub fn unfill(text: &str) -> (String, Options<'_>){\n    let prefix_chars: &[_] = &[' ', '-', '+', '*', '>', '#', '/'];\n\n    let mut options = Options::new(0);\n    for (idx, line) in text.lines().enumerate() {\n        options.width = std::cmp::max(options.width, display_width(line));\n        let without_prefix = line.trim_start_matches(prefix_chars);\n        let prefix = &line[..line.len() - without_prefix.len()];\n\n        if idx == 0 {\n            options.initial_indent = prefix;\n        } else if idx == 1 {\n            options.subsequent_indent = prefix;\n        } else if idx > 1 {\n            for ((idx, x), y) in prefix.char_indices().zip(options.subsequent_indent.chars()) {\n                if x != y {\n                    options.subsequent_indent = &prefix[..idx];\n                    break;\n                }\n            }\n            if prefix.len() < options.subsequent_indent.len() {\n                options.subsequent_indent = prefix;\n            }\n        }\n    }\n\n    let mut unfilled = String::with_capacity(text.len());\n    let mut detected_line_ending = None;\n\n    for (idx, (line, ending)) in NonEmptyLines(text).enumerate() {\n        if idx == 0 {\n            unfilled.push_str(&line[options.initial_indent.len()..]);\n        } else {\n            unfilled.push(' ');\n            unfilled.push_str(&line[options.subsequent_indent.len()..]);\n        }\n        match (detected_line_ending, ending) {\n            (None, Some(_)) => detected_line_ending = ending,\n            (Some(LineEnding::CRLF), Some(LineEnding::LF)) => detected_line_ending = ending,\n            _ => (),\n        }\n    }\n\n    // Add back a line ending if `text` ends with the one we detect.\n    if let Some(line_ending) = detected_line_ending {\n        if text.ends_with(line_ending.as_str()) {\n            unfilled.push_str(line_ending.as_str());\n        }\n    }\n\n    options.line_ending = detected_line_ending.unwrap_or(LineEnding::LF);\n    (unfilled, options)\n}","Real(LocalPath(\"src/refill.rs\"))"],"word_separators::WordSeparator":["/// Describes where words occur in a line of text.\n///\n/// The simplest approach is say that words are separated by one or\n/// more ASCII spaces (`' '`). This works for Western languages\n/// without emojis. A more complex approach is to use the Unicode line\n/// breaking algorithm, which finds break points in non-ASCII text.\n///\n/// The line breaks occur between words, please see\n/// [`WordSplitter`](crate::WordSplitter) for options of how to handle\n/// hyphenation of individual words.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::core::Word;\n/// use textwrap::WordSeparator::AsciiSpace;\n///\n/// let words = AsciiSpace.find_words(\"Hello World!\").collect::<Vec<_>>();\n/// assert_eq!(words, vec![Word::from(\"Hello \"), Word::from(\"World!\")]);\n/// ```\npub enum WordSeparator {\n    /// Find words by splitting on runs of `' '` characters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use textwrap::core::Word;\n    /// use textwrap::WordSeparator::AsciiSpace;\n    ///\n    /// let words = AsciiSpace.find_words(\"Hello   World!\").collect::<Vec<_>>();\n    /// assert_eq!(words, vec![Word::from(\"Hello   \"),\n    ///                        Word::from(\"World!\")]);\n    /// ```\n    AsciiSpace,\n\n    /// Split `line` into words using Unicode break properties.\n    ///\n    /// This word separator uses the Unicode line breaking algorithm\n    /// described in [Unicode Standard Annex\n    /// #14](https://www.unicode.org/reports/tr14/) to find legal places\n    /// to break lines. There is a small difference in that the U+002D\n    /// (Hyphen-Minus) and U+00AD (Soft Hyphen) don’t create a line break:\n    /// to allow a line break at a hyphen, use\n    /// [`WordSplitter::HyphenSplitter`](crate::WordSplitter::HyphenSplitter).\n    /// Soft hyphens are not currently supported.\n    ///\n    /// # Examples\n    ///\n    /// Unlike [`WordSeparator::AsciiSpace`], the Unicode line\n    /// breaking algorithm will find line break opportunities between\n    /// some characters with no intervening whitespace:\n    ///\n    /// ```\n    /// #[cfg(feature = \"unicode-linebreak\")] {\n    /// use textwrap::core::Word;\n    /// use textwrap::WordSeparator::UnicodeBreakProperties;\n    ///\n    /// assert_eq!(UnicodeBreakProperties.find_words(\"Emojis: 😂😍\").collect::<Vec<_>>(),\n    ///            vec![Word::from(\"Emojis: \"),\n    ///                 Word::from(\"😂\"),\n    ///                 Word::from(\"😍\")]);\n    ///\n    /// assert_eq!(UnicodeBreakProperties.find_words(\"CJK: 你好\").collect::<Vec<_>>(),\n    ///            vec![Word::from(\"CJK: \"),\n    ///                 Word::from(\"你\"),\n    ///                 Word::from(\"好\")]);\n    /// }\n    /// ```\n    ///\n    /// A U+2060 (Word Joiner) character can be inserted if you want to\n    /// manually override the defaults and keep the characters together:\n    ///\n    /// ```\n    /// #[cfg(feature = \"unicode-linebreak\")] {\n    /// use textwrap::core::Word;\n    /// use textwrap::WordSeparator::UnicodeBreakProperties;\n    ///\n    /// assert_eq!(UnicodeBreakProperties.find_words(\"Emojis: 😂\\u{2060}😍\").collect::<Vec<_>>(),\n    ///            vec![Word::from(\"Emojis: \"),\n    ///                 Word::from(\"😂\\u{2060}😍\")]);\n    /// }\n    /// ```\n    ///\n    /// The Unicode line breaking algorithm will also automatically\n    /// suppress break breaks around certain punctuation characters::\n    ///\n    /// ```\n    /// #[cfg(feature = \"unicode-linebreak\")] {\n    /// use textwrap::core::Word;\n    /// use textwrap::WordSeparator::UnicodeBreakProperties;\n    ///\n    /// assert_eq!(UnicodeBreakProperties.find_words(\"[ foo ] bar !\").collect::<Vec<_>>(),\n    ///            vec![Word::from(\"[ foo ] \"),\n    ///                 Word::from(\"bar !\")]);\n    /// }\n    /// ```\n    #[cfg(feature = \"unicode-linebreak\")]\n    UnicodeBreakProperties,\n\n    /// Find words using a custom word separator\n    Custom(fn(line: &str) -> Box<dyn Iterator<Item = Word<'_>> + '_>),\n}","Real(LocalPath(\"src/word_separators.rs\"))"],"word_separators::WordSeparator::find_words":["/// Find all words in `line`.\npub fn find_words<'a>(&self, line: &'a str) -> Box<dyn Iterator<Item = Word<'a>> + 'a>{\n        match self {\n            WordSeparator::AsciiSpace => find_words_ascii_space(line),\n            #[cfg(feature = \"unicode-linebreak\")]\n            WordSeparator::UnicodeBreakProperties => find_words_unicode_break_properties(line),\n            WordSeparator::Custom(func) => func(line),\n        }\n    }","Real(LocalPath(\"src/word_separators.rs\"))"],"word_separators::WordSeparator::new":["/// Create a new word separator.\n///\n/// The best available algorithm is used by default, i.e.,\n/// [`WordSeparator::UnicodeBreakProperties`] if available,\n/// otherwise [`WordSeparator::AsciiSpace`].\npub const fn new() -> Self{\n        #[cfg(feature = \"unicode-linebreak\")]\n        {\n            WordSeparator::UnicodeBreakProperties\n        }\n\n        #[cfg(not(feature = \"unicode-linebreak\"))]\n        {\n            WordSeparator::AsciiSpace\n        }\n    }","Real(LocalPath(\"src/word_separators.rs\"))"],"word_separators::find_words_ascii_space":["fn find_words_ascii_space<'a>(line: &'a str) -> Box<dyn Iterator<Item = Word<'a>> + 'a>{\n    let mut start = 0;\n    let mut in_whitespace = false;\n    let mut char_indices = line.char_indices();\n\n    Box::new(std::iter::from_fn(move || {\n        for (idx, ch) in char_indices.by_ref() {\n            if in_whitespace && ch != ' ' {\n                let word = Word::from(&line[start..idx]);\n                start = idx;\n                in_whitespace = ch == ' ';\n                return Some(word);\n            }\n\n            in_whitespace = ch == ' ';\n        }\n\n        if start < line.len() {\n            let word = Word::from(&line[start..]);\n            start = line.len();\n            return Some(word);\n        }\n\n        None\n    }))\n}","Real(LocalPath(\"src/word_separators.rs\"))"],"word_separators::find_words_unicode_break_properties":["/// Find words in line. ANSI escape sequences are ignored in `line`.\n#[cfg(feature = \"unicode-linebreak\")]\nfn find_words_unicode_break_properties<'a>(\n    line: &'a str,\n) -> Box<dyn Iterator<Item = Word<'a>> + 'a>{\n    // Construct an iterator over (original index, stripped index)\n    // tuples. We find the Unicode linebreaks on a stripped string,\n    // but we need the original indices so we can form words based on\n    // the original string.\n    let mut last_stripped_idx = 0;\n    let mut char_indices = line.char_indices();\n    let mut idx_map = std::iter::from_fn(move || match char_indices.next() {\n        Some((orig_idx, ch)) => {\n            let stripped_idx = last_stripped_idx;\n            if !skip_ansi_escape_sequence(ch, &mut char_indices.by_ref().map(|(_, ch)| ch)) {\n                last_stripped_idx += ch.len_utf8();\n            }\n            Some((orig_idx, stripped_idx))\n        }\n        None => None,\n    });\n\n    let stripped = strip_ansi_escape_sequences(line);\n    let mut opportunities = unicode_linebreak::linebreaks(&stripped)\n        .filter(|(idx, _)| {\n            #[allow(clippy::match_like_matches_macro)]\n            match &stripped[..*idx].chars().next_back() {\n                // We suppress breaks at ‘-’ since we want to control\n                // this via the WordSplitter.\n                Some('-') => false,\n                // Soft hyphens are currently not supported since we\n                // require all `Word` fragments to be continuous in\n                // the input string.\n                Some(SHY) => false,\n                // Other breaks should be fine!\n                _ => true,\n            }\n        })\n        .collect::<Vec<_>>()\n        .into_iter();\n\n    // Remove final break opportunity, we will add it below using\n    // &line[start..]; This ensures that we correctly include a\n    // trailing ANSI escape sequence.\n    opportunities.next_back();\n\n    let mut start = 0;\n    Box::new(std::iter::from_fn(move || {\n        for (idx, _) in opportunities.by_ref() {\n            if let Some((orig_idx, _)) = idx_map.find(|&(_, stripped_idx)| stripped_idx == idx) {\n                let word = Word::from(&line[start..orig_idx]);\n                start = orig_idx;\n                return Some(word);\n            }\n        }\n\n        if start < line.len() {\n            let word = Word::from(&line[start..]);\n            start = line.len();\n            return Some(word);\n        }\n\n        None\n    }))\n}","Real(LocalPath(\"src/word_separators.rs\"))"],"word_separators::strip_ansi_escape_sequences":["#[cfg(feature = \"unicode-linebreak\")]\nfn strip_ansi_escape_sequences(text: &str) -> String{\n    let mut result = String::with_capacity(text.len());\n\n    let mut chars = text.chars();\n    while let Some(ch) = chars.next() {\n        if skip_ansi_escape_sequence(ch, &mut chars) {\n            continue;\n        }\n        result.push(ch);\n    }\n\n    result\n}","Real(LocalPath(\"src/word_separators.rs\"))"],"word_splitters::WordSplitter":["/// The `WordSplitter` enum describes where words can be split.\n///\n/// If the textwrap crate has been compiled with the `hyphenation`\n/// Cargo feature enabled, you will find a\n/// [`WordSplitter::Hyphenation`] variant. Use this struct for\n/// language-aware hyphenation:\n///\n/// ```\n/// #[cfg(feature = \"hyphenation\")] {\n///     use hyphenation::{Language, Load, Standard};\n///     use textwrap::{wrap, Options, WordSplitter};\n///\n///     let text = \"Oxidation is the loss of electrons.\";\n///     let dictionary = Standard::from_embedded(Language::EnglishUS).unwrap();\n///     let options = Options::new(8).word_splitter(WordSplitter::Hyphenation(dictionary));\n///     assert_eq!(wrap(text, &options), vec![\"Oxida-\",\n///                                           \"tion is\",\n///                                           \"the loss\",\n///                                           \"of elec-\",\n///                                           \"trons.\"]);\n/// }\n/// ```\n///\n/// Please see the documentation for the [hyphenation] crate for more\n/// details.\n///\n/// [hyphenation]: https://docs.rs/hyphenation/\npub enum WordSplitter {\n    /// Use this as a [`Options.word_splitter`] to avoid any kind of\n    /// hyphenation:\n    ///\n    /// ```\n    /// use textwrap::{wrap, Options, WordSplitter};\n    ///\n    /// let options = Options::new(8).word_splitter(WordSplitter::NoHyphenation);\n    /// assert_eq!(wrap(\"foo bar-baz\", &options),\n    ///            vec![\"foo\", \"bar-baz\"]);\n    /// ```\n    ///\n    /// [`Options.word_splitter`]: super::Options::word_splitter\n    NoHyphenation,\n\n    /// `HyphenSplitter` is the default `WordSplitter` used by\n    /// [`Options::new`](super::Options::new). It will split words on\n    /// existing hyphens in the word.\n    ///\n    /// It will only use hyphens that are surrounded by alphanumeric\n    /// characters, which prevents a word like `\"--foo-bar\"` from\n    /// being split into `\"--\"` and `\"foo-bar\"`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use textwrap::WordSplitter;\n    ///\n    /// assert_eq!(WordSplitter::HyphenSplitter.split_points(\"--foo-bar\"),\n    ///            vec![6]);\n    /// ```\n    HyphenSplitter,\n\n    /// Use a custom function as the word splitter.\n    ///\n    /// This variant lets you implement a custom word splitter using\n    /// your own function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use textwrap::WordSplitter;\n    ///\n    /// fn split_at_underscore(word: &str) -> Vec<usize> {\n    ///     word.match_indices('_').map(|(idx, _)| idx + 1).collect()\n    /// }\n    ///\n    /// let word_splitter = WordSplitter::Custom(split_at_underscore);\n    /// assert_eq!(word_splitter.split_points(\"a_long_identifier\"),\n    ///            vec![2, 7]);\n    /// ```\n    Custom(fn(word: &str) -> Vec<usize>),\n\n    /// A hyphenation dictionary can be used to do language-specific\n    /// hyphenation using patterns from the [hyphenation] crate.\n    ///\n    /// **Note:** Only available when the `hyphenation` Cargo feature is\n    /// enabled.\n    ///\n    /// [hyphenation]: https://docs.rs/hyphenation/\n    #[cfg(feature = \"hyphenation\")]\n    Hyphenation(hyphenation::Standard),\n}","Real(LocalPath(\"src/word_splitters.rs\"))"],"word_splitters::WordSplitter::split_points":["/// Return all possible indices where `word` can be split.\n///\n/// The indices are in the range `0..word.len()`. They point to\n/// the index _after_ the split point, i.e., after `-` if\n/// splitting on hyphens. This way, `word.split_at(idx)` will\n/// break the word into two well-formed pieces.\n///\n/// # Examples\n///\n/// ```\n/// use textwrap::WordSplitter;\n/// assert_eq!(WordSplitter::NoHyphenation.split_points(\"cannot-be-split\"), vec![]);\n/// assert_eq!(WordSplitter::HyphenSplitter.split_points(\"can-be-split\"), vec![4, 7]);\n/// assert_eq!(WordSplitter::Custom(|word| vec![word.len()/2]).split_points(\"middle\"), vec![3]);\n/// ```\npub fn split_points(&self, word: &str) -> Vec<usize>{\n        match self {\n            WordSplitter::NoHyphenation => Vec::new(),\n            WordSplitter::HyphenSplitter => {\n                let mut splits = Vec::new();\n\n                for (idx, _) in word.match_indices('-') {\n                    // We only use hyphens that are surrounded by alphanumeric\n                    // characters. This is to avoid splitting on repeated hyphens,\n                    // such as those found in --foo-bar.\n                    let prev = word[..idx].chars().next_back();\n                    let next = word[idx + 1..].chars().next();\n\n                    if prev.filter(|ch| ch.is_alphanumeric()).is_some()\n                        && next.filter(|ch| ch.is_alphanumeric()).is_some()\n                    {\n                        splits.push(idx + 1); // +1 due to width of '-'.\n                    }\n                }\n\n                splits\n            }\n            WordSplitter::Custom(splitter_func) => splitter_func(word),\n            #[cfg(feature = \"hyphenation\")]\n            WordSplitter::Hyphenation(dictionary) => {\n                use hyphenation::Hyphenator;\n                dictionary.hyphenate(word).breaks\n            }\n        }\n    }","Real(LocalPath(\"src/word_splitters.rs\"))"],"word_splitters::split_words":["/// Split words into smaller words according to the split points given\n/// by `word_splitter`.\n///\n/// Note that we split all words, regardless of their length. This is\n/// to more cleanly separate the business of splitting (including\n/// automatic hyphenation) from the business of word wrapping.\npub fn split_words<'a, I>(\n    words: I,\n    word_splitter: &'a WordSplitter,\n) -> impl Iterator<Item = Word<'a>>\nwhere\n    I: IntoIterator<Item = Word<'a>>,{\n    words.into_iter().flat_map(move |word| {\n        let mut prev = 0;\n        let mut split_points = word_splitter.split_points(&word).into_iter();\n        std::iter::from_fn(move || {\n            if let Some(idx) = split_points.next() {\n                let need_hyphen = !word[..idx].ends_with('-');\n                let w = Word {\n                    word: &word.word[prev..idx],\n                    width: display_width(&word[prev..idx]),\n                    whitespace: \"\",\n                    penalty: if need_hyphen { \"-\" } else { \"\" },\n                };\n                prev = idx;\n                return Some(w);\n            }\n\n            if prev < word.word.len() || prev == 0 {\n                let w = Word {\n                    word: &word.word[prev..],\n                    width: display_width(&word[prev..]),\n                    whitespace: word.whitespace,\n                    penalty: word.penalty,\n                };\n                prev = word.word.len() + 1;\n                return Some(w);\n            }\n\n            None\n        })\n    })\n}","Real(LocalPath(\"src/word_splitters.rs\"))"],"wrap::wrap":["/// Wrap a line of text at a given width.\n///\n/// The result is a vector of lines, each line is of type [`Cow<'_,\n/// str>`](Cow), which means that the line will borrow from the input\n/// `&str` if possible. The lines do not have trailing whitespace,\n/// including a final `'\\n'`. Please use [`fill()`](crate::fill()) if\n/// you need a [`String`] instead.\n///\n/// The easiest way to use this function is to pass an integer for\n/// `width_or_options`:\n///\n/// ```\n/// use textwrap::wrap;\n///\n/// let lines = wrap(\"Memory safety without garbage collection.\", 15);\n/// assert_eq!(lines, &[\n///     \"Memory safety\",\n///     \"without garbage\",\n///     \"collection.\",\n/// ]);\n/// ```\n///\n/// If you need to customize the wrapping, you can pass an [`Options`]\n/// instead of an `usize`:\n///\n/// ```\n/// use textwrap::{wrap, Options};\n///\n/// let options = Options::new(15)\n///     .initial_indent(\"- \")\n///     .subsequent_indent(\"  \");\n/// let lines = wrap(\"Memory safety without garbage collection.\", &options);\n/// assert_eq!(lines, &[\n///     \"- Memory safety\",\n///     \"  without\",\n///     \"  garbage\",\n///     \"  collection.\",\n/// ]);\n/// ```\n///\n/// # Optimal-Fit Wrapping\n///\n/// By default, `wrap` will try to ensure an even right margin by\n/// finding breaks which avoid short lines. We call this an\n/// “optimal-fit algorithm” since the line breaks are computed by\n/// considering all possible line breaks. The alternative is a\n/// “first-fit algorithm” which simply accumulates words until they no\n/// longer fit on the line.\n///\n/// As an example, using the first-fit algorithm to wrap the famous\n/// Hamlet quote “To be, or not to be: that is the question” in a\n/// narrow column with room for only 10 characters looks like this:\n///\n/// ```\n/// # use textwrap::{WrapAlgorithm::FirstFit, Options, wrap};\n/// #\n/// # let lines = wrap(\"To be, or not to be: that is the question\",\n/// #                  Options::new(10).wrap_algorithm(FirstFit));\n/// # assert_eq!(lines.join(\"\\n\") + \"\\n\", \"\\\n/// To be, or\n/// not to be:\n/// that is\n/// the\n/// question\n/// # \");\n/// ```\n///\n/// Notice how the second to last line is quite narrow because\n/// “question” was too large to fit? The greedy first-fit algorithm\n/// doesn’t look ahead, so it has no other option than to put\n/// “question” onto its own line.\n///\n/// With the optimal-fit wrapping algorithm, the previous lines are\n/// shortened slightly in order to make the word “is” go into the\n/// second last line:\n///\n/// ```\n/// # #[cfg(feature = \"smawk\")] {\n/// # use textwrap::{Options, WrapAlgorithm, wrap};\n/// #\n/// # let lines = wrap(\n/// #     \"To be, or not to be: that is the question\",\n/// #     Options::new(10).wrap_algorithm(WrapAlgorithm::new_optimal_fit())\n/// # );\n/// # assert_eq!(lines.join(\"\\n\") + \"\\n\", \"\\\n/// To be,\n/// or not to\n/// be: that\n/// is the\n/// question\n/// # \"); }\n/// ```\n///\n/// Please see [`WrapAlgorithm`](crate::WrapAlgorithm) for details on\n/// the choices.\n///\n/// # Examples\n///\n/// The returned iterator yields lines of type `Cow<'_, str>`. If\n/// possible, the wrapped lines will borrow from the input string. As\n/// an example, a hanging indentation, the first line can borrow from\n/// the input, but the subsequent lines become owned strings:\n///\n/// ```\n/// use std::borrow::Cow::{Borrowed, Owned};\n/// use textwrap::{wrap, Options};\n///\n/// let options = Options::new(15).subsequent_indent(\"....\");\n/// let lines = wrap(\"Wrapping text all day long.\", &options);\n/// let annotated = lines\n///     .iter()\n///     .map(|line| match line {\n///         Borrowed(text) => format!(\"[Borrowed] {}\", text),\n///         Owned(text) => format!(\"[Owned]    {}\", text),\n///     })\n///     .collect::<Vec<_>>();\n/// assert_eq!(\n///     annotated,\n///     &[\n///         \"[Borrowed] Wrapping text\",\n///         \"[Owned]    ....all day\",\n///         \"[Owned]    ....long.\",\n///     ]\n/// );\n/// ```\n///\n/// ## Leading and Trailing Whitespace\n///\n/// As a rule, leading whitespace (indentation) is preserved and\n/// trailing whitespace is discarded.\n///\n/// In more details, when wrapping words into lines, words are found\n/// by splitting the input text on space characters. One or more\n/// spaces (shown here as “␣”) are attached to the end of each word:\n///\n/// ```text\n/// \"Foo␣␣␣bar␣baz\" -> [\"Foo␣␣␣\", \"bar␣\", \"baz\"]\n/// ```\n///\n/// These words are then put into lines. The interword whitespace is\n/// preserved, unless the lines are wrapped so that the `\"Foo␣␣␣\"`\n/// word falls at the end of a line:\n///\n/// ```\n/// use textwrap::wrap;\n///\n/// assert_eq!(wrap(\"Foo   bar baz\", 10), vec![\"Foo   bar\", \"baz\"]);\n/// assert_eq!(wrap(\"Foo   bar baz\", 8), vec![\"Foo\", \"bar baz\"]);\n/// ```\n///\n/// Notice how the trailing whitespace is removed in both case: in the\n/// first example, `\"bar␣\"` becomes `\"bar\"` and in the second case\n/// `\"Foo␣␣␣\"` becomes `\"Foo\"`.\n///\n/// Leading whitespace is preserved when the following word fits on\n/// the first line. To understand this, consider how words are found\n/// in a text with leading spaces:\n///\n/// ```text\n/// \"␣␣foo␣bar\" -> [\"␣␣\", \"foo␣\", \"bar\"]\n/// ```\n///\n/// When put into lines, the indentation is preserved if `\"foo\"` fits\n/// on the first line, otherwise you end up with an empty line:\n///\n/// ```\n/// use textwrap::wrap;\n///\n/// assert_eq!(wrap(\"  foo bar\", 8), vec![\"  foo\", \"bar\"]);\n/// assert_eq!(wrap(\"  foo bar\", 4), vec![\"\", \"foo\", \"bar\"]);\n/// ```\npub fn wrap<'a, Opt>(text: &str, width_or_options: Opt) -> Vec<Cow<'_, str>>\nwhere\n    Opt: Into<Options<'a>>,{\n    let options: Options = width_or_options.into();\n    let line_ending_str = options.line_ending.as_str();\n\n    let mut lines = Vec::new();\n    for line in text.split(line_ending_str) {\n        wrap_single_line(line, &options, &mut lines);\n    }\n\n    lines\n}","Real(LocalPath(\"src/wrap.rs\"))"],"wrap::wrap_single_line":["pub(crate) fn wrap_single_line<'a>(\n    line: &'a str,\n    options: &Options<'_>,\n    lines: &mut Vec<Cow<'a, str>>,\n){\n    let indent = if lines.is_empty() {\n        options.initial_indent\n    } else {\n        options.subsequent_indent\n    };\n    if line.len() < options.width && indent.is_empty() {\n        lines.push(Cow::from(line.trim_end_matches(' ')));\n    } else {\n        wrap_single_line_slow_path(line, options, lines)\n    }\n}","Real(LocalPath(\"src/wrap.rs\"))"],"wrap::wrap_single_line_slow_path":["/// Wrap a single line of text.\n///\n/// This is taken when `line` is longer than `options.width`.\npub(crate) fn wrap_single_line_slow_path<'a>(\n    line: &'a str,\n    options: &Options<'_>,\n    lines: &mut Vec<Cow<'a, str>>,\n){\n    let initial_width = options\n        .width\n        .saturating_sub(display_width(options.initial_indent));\n    let subsequent_width = options\n        .width\n        .saturating_sub(display_width(options.subsequent_indent));\n    let line_widths = [initial_width, subsequent_width];\n\n    let words = options.word_separator.find_words(line);\n    let split_words = split_words(words, &options.word_splitter);\n    let broken_words = if options.break_words {\n        let mut broken_words = break_words(split_words, line_widths[1]);\n        if !options.initial_indent.is_empty() {\n            // Without this, the first word will always go into the\n            // first line. However, since we break words based on the\n            // _second_ line width, it can be wrong to unconditionally\n            // put the first word onto the first line. An empty\n            // zero-width word fixed this.\n            broken_words.insert(0, Word::from(\"\"));\n        }\n        broken_words\n    } else {\n        split_words.collect::<Vec<_>>()\n    };\n\n    let wrapped_words = options.wrap_algorithm.wrap(&broken_words, &line_widths);\n\n    let mut idx = 0;\n    for words in wrapped_words {\n        let last_word = match words.last() {\n            None => {\n                lines.push(Cow::from(\"\"));\n                continue;\n            }\n            Some(word) => word,\n        };\n\n        // We assume here that all words are contiguous in `line`.\n        // That is, the sum of their lengths should add up to the\n        // length of `line`.\n        let len = words\n            .iter()\n            .map(|word| word.len() + word.whitespace.len())\n            .sum::<usize>()\n            - last_word.whitespace.len();\n\n        // The result is owned if we have indentation, otherwise we\n        // can simply borrow an empty string.\n        let mut result = if lines.is_empty() && !options.initial_indent.is_empty() {\n            Cow::Owned(options.initial_indent.to_owned())\n        } else if !lines.is_empty() && !options.subsequent_indent.is_empty() {\n            Cow::Owned(options.subsequent_indent.to_owned())\n        } else {\n            // We can use an empty string here since string\n            // concatenation for `Cow` preserves a borrowed value when\n            // either side is empty.\n            Cow::from(\"\")\n        };\n\n        result += &line[idx..idx + len];\n\n        if !last_word.penalty.is_empty() {\n            result.to_mut().push_str(last_word.penalty);\n        }\n\n        lines.push(result);\n\n        // Advance by the length of `result`, plus the length of\n        // `last_word.whitespace` -- even if we had a penalty, we need\n        // to skip over the whitespace.\n        idx += len + last_word.whitespace.len();\n    }\n}","Real(LocalPath(\"src/wrap.rs\"))"],"wrap_algorithms::WrapAlgorithm":["/// Describes how to wrap words into lines.\n///\n/// The simplest approach is to wrap words one word at a time and\n/// accept the first way of wrapping which fit\n/// ([`WrapAlgorithm::FirstFit`]). If the `smawk` Cargo feature is\n/// enabled, a more complex algorithm is available which will look at\n/// an entire paragraph at a time in order to find optimal line breaks\n/// ([`WrapAlgorithm::OptimalFit`]).\npub enum WrapAlgorithm {\n    /// Wrap words using a fast and simple algorithm.\n    ///\n    /// This algorithm uses no look-ahead when finding line breaks.\n    /// Implemented by [`wrap_first_fit()`], please see that function\n    /// for details and examples.\n    FirstFit,\n\n    /// Wrap words using an advanced algorithm with look-ahead.\n    ///\n    /// This wrapping algorithm considers the entire paragraph to find\n    /// optimal line breaks. When wrapping text, \"penalties\" are\n    /// assigned to line breaks based on the gaps left at the end of\n    /// lines. See [`Penalties`] for details.\n    ///\n    /// The underlying wrapping algorithm is implemented by\n    /// [`wrap_optimal_fit()`], please see that function for examples.\n    ///\n    /// **Note:** Only available when the `smawk` Cargo feature is\n    /// enabled.\n    #[cfg(feature = \"smawk\")]\n    OptimalFit(Penalties),\n\n    /// Custom wrapping function.\n    ///\n    /// Use this if you want to implement your own wrapping algorithm.\n    /// The function can freely decide how to turn a slice of\n    /// [`Word`]s into lines.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use textwrap::core::Word;\n    /// use textwrap::{wrap, Options, WrapAlgorithm};\n    ///\n    /// fn stair<'a, 'b>(words: &'b [Word<'a>], _: &'b [usize]) -> Vec<&'b [Word<'a>]> {\n    ///     let mut lines = Vec::new();\n    ///     let mut step = 1;\n    ///     let mut start_idx = 0;\n    ///     while start_idx + step <= words.len() {\n    ///       lines.push(&words[start_idx .. start_idx+step]);\n    ///       start_idx += step;\n    ///       step += 1;\n    ///     }\n    ///     lines\n    /// }\n    ///\n    /// let options = Options::new(10).wrap_algorithm(WrapAlgorithm::Custom(stair));\n    /// assert_eq!(wrap(\"First, second, third, fourth, fifth, sixth\", options),\n    ///            vec![\"First,\",\n    ///                 \"second, third,\",\n    ///                 \"fourth, fifth, sixth\"]);\n    /// ```\n    Custom(for<'a, 'b> fn(words: &'b [Word<'a>], line_widths: &'b [usize]) -> Vec<&'b [Word<'a>]>),\n}","Real(LocalPath(\"src/wrap_algorithms.rs\"))"],"wrap_algorithms::WrapAlgorithm::new":["/// Create new wrap algorithm.\n///\n/// The best wrapping algorithm is used by default, i.e.,\n/// [`WrapAlgorithm::OptimalFit`] if available, otherwise\n/// [`WrapAlgorithm::FirstFit`].\npub const fn new() -> Self{\n        #[cfg(not(feature = \"smawk\"))]\n        {\n            WrapAlgorithm::FirstFit\n        }\n\n        #[cfg(feature = \"smawk\")]\n        {\n            WrapAlgorithm::new_optimal_fit()\n        }\n    }","Real(LocalPath(\"src/wrap_algorithms.rs\"))"],"wrap_algorithms::WrapAlgorithm::new_optimal_fit":["/// New [`WrapAlgorithm::OptimalFit`] with default penalties. This\n/// works well for monospace text.\n///\n/// **Note:** Only available when the `smawk` Cargo feature is\n/// enabled.\n#[cfg(feature = \"smawk\")]\npub const fn new_optimal_fit() -> Self{\n        WrapAlgorithm::OptimalFit(Penalties::new())\n    }","Real(LocalPath(\"src/wrap_algorithms.rs\"))"],"wrap_algorithms::WrapAlgorithm::wrap":["/// Wrap words according to line widths.\n///\n/// The `line_widths` slice gives the target line width for each\n/// line (the last slice element is repeated as necessary). This\n/// can be used to implement hanging indentation.\n#[inline]\npub fn wrap<'a, 'b>(\n        &self,\n        words: &'b [Word<'a>],\n        line_widths: &'b [usize],\n    ) -> Vec<&'b [Word<'a>]>{\n        // Every integer up to 2u64.pow(f64::MANTISSA_DIGITS) = 2**53\n        // = 9_007_199_254_740_992 can be represented without loss by\n        // a f64. Larger line widths will be rounded to the nearest\n        // representable number.\n        let f64_line_widths = line_widths.iter().map(|w| *w as f64).collect::<Vec<_>>();\n\n        match self {\n            WrapAlgorithm::FirstFit => wrap_first_fit(words, &f64_line_widths),\n\n            #[cfg(feature = \"smawk\")]\n            WrapAlgorithm::OptimalFit(penalties) => {\n                // The computation cannot overflow when the line\n                // widths are restricted to usize.\n                wrap_optimal_fit(words, &f64_line_widths, penalties).unwrap()\n            }\n\n            WrapAlgorithm::Custom(func) => func(words, line_widths),\n        }\n    }","Real(LocalPath(\"src/wrap_algorithms.rs\"))"],"wrap_algorithms::optimal_fit::LineNumbers":["/// Cache for line numbers. This is necessary to avoid a O(n**2)\n/// behavior when computing line numbers in [`wrap_optimal_fit`].\nstruct LineNumbers {\n    line_numbers: RefCell<Vec<usize>>,\n}","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"wrap_algorithms::optimal_fit::LineNumbers::get":["fn get<T>(&self, i: usize, minima: &[(usize, T)]) -> usize{\n        while self.line_numbers.borrow_mut().len() < i + 1 {\n            let pos = self.line_numbers.borrow().len();\n            let line_number = 1 + self.get(minima[pos].0, minima);\n            self.line_numbers.borrow_mut().push(line_number);\n        }\n\n        self.line_numbers.borrow()[i]\n    }","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"wrap_algorithms::optimal_fit::LineNumbers::new":["fn new(size: usize) -> Self{\n        let mut line_numbers = Vec::with_capacity(size);\n        line_numbers.push(0);\n        LineNumbers {\n            line_numbers: RefCell::new(line_numbers),\n        }\n    }","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"wrap_algorithms::optimal_fit::OverflowError":["/// Overflow error during the [`wrap_optimal_fit`] computation.\npub struct OverflowError;","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"wrap_algorithms::optimal_fit::Penalties":["/// Penalties for\n/// [`WrapAlgorithm::OptimalFit`](crate::WrapAlgorithm::OptimalFit)\n/// and [`wrap_optimal_fit`].\n///\n/// This wrapping algorithm in [`wrap_optimal_fit`] considers the\n/// entire paragraph to find optimal line breaks. When wrapping text,\n/// \"penalties\" are assigned to line breaks based on the gaps left at\n/// the end of lines. The penalties are given by this struct, with\n/// [`Penalties::default`] assigning penalties that work well for\n/// monospace text.\n///\n/// If you are wrapping proportional text, you are advised to assign\n/// your own penalties according to your font size. See the individual\n/// penalties below for details.\n///\n/// **Note:** Only available when the `smawk` Cargo feature is\n/// enabled.\npub struct Penalties {\n    /// Per-line penalty. This is added for every line, which makes it\n    /// expensive to output more lines than the minimum required.\n    pub nline_penalty: usize,\n\n    /// Per-character cost for lines that overflow the target line width.\n    ///\n    /// With a default value of 50², every single character costs as\n    /// much as leaving a gap of 50 characters behind. This is because\n    /// we assign as cost of `gap * gap` to a short line. When\n    /// wrapping monospace text, we can overflow the line by 1\n    /// character in extreme cases:\n    ///\n    /// ```\n    /// use textwrap::core::Word;\n    /// use textwrap::wrap_algorithms::{wrap_optimal_fit, Penalties};\n    ///\n    /// let short = \"foo \";\n    /// let long = \"x\".repeat(50);\n    /// let length = (short.len() + long.len()) as f64;\n    /// let fragments = vec![Word::from(short), Word::from(&long)];\n    /// let penalties = Penalties::new();\n    ///\n    /// // Perfect fit, both words are on a single line with no overflow.\n    /// let wrapped = wrap_optimal_fit(&fragments, &[length], &penalties).unwrap();\n    /// assert_eq!(wrapped, vec![&[Word::from(short), Word::from(&long)]]);\n    ///\n    /// // The words no longer fit, yet we get a single line back. While\n    /// // the cost of overflow (`1 * 2500`) is the same as the cost of the\n    /// // gap (`50 * 50 = 2500`), the tie is broken by `nline_penalty`\n    /// // which makes it cheaper to overflow than to use two lines.\n    /// let wrapped = wrap_optimal_fit(&fragments, &[length - 1.0], &penalties).unwrap();\n    /// assert_eq!(wrapped, vec![&[Word::from(short), Word::from(&long)]]);\n    ///\n    /// // The cost of overflow would be 2 * 2500, whereas the cost of\n    /// // the gap is only `49 * 49 + nline_penalty = 2401 + 1000 =\n    /// // 3401`. We therefore get two lines.\n    /// let wrapped = wrap_optimal_fit(&fragments, &[length - 2.0], &penalties).unwrap();\n    /// assert_eq!(wrapped, vec![&[Word::from(short)],\n    ///                          &[Word::from(&long)]]);\n    /// ```\n    ///\n    /// This only happens if the overflowing word is 50 characters\n    /// long _and_ if the word overflows the line by exactly one\n    /// character. If it overflows by more than one character, the\n    /// overflow penalty will quickly outgrow the cost of the gap, as\n    /// seen above.\n    pub overflow_penalty: usize,\n\n    /// When should the a single word on the last line be considered\n    /// \"too short\"?\n    ///\n    /// If the last line of the text consist of a single word and if\n    /// this word is shorter than `1 / short_last_line_fraction` of\n    /// the line width, then the final line will be considered \"short\"\n    /// and `short_last_line_penalty` is added as an extra penalty.\n    ///\n    /// The effect of this is to avoid a final line consisting of a\n    /// single small word. For example, with a\n    /// `short_last_line_penalty` of 25 (the default), a gap of up to\n    /// 5 columns will be seen as more desirable than having a final\n    /// short line.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use textwrap::{wrap, wrap_algorithms, Options, WrapAlgorithm};\n    ///\n    /// let text = \"This is a demo of the short last line penalty.\";\n    ///\n    /// // The first-fit algorithm leaves a single short word on the last line:\n    /// assert_eq!(wrap(text, Options::new(37).wrap_algorithm(WrapAlgorithm::FirstFit)),\n    ///            vec![\"This is a demo of the short last line\",\n    ///                 \"penalty.\"]);\n    ///\n    /// #[cfg(feature = \"smawk\")] {\n    /// let mut penalties = wrap_algorithms::Penalties::new();\n    ///\n    /// // Since \"penalty.\" is shorter than 25% of the line width, the\n    /// // optimal-fit algorithm adds a penalty of 25. This is enough\n    /// // to move \"line \" down:\n    /// assert_eq!(wrap(text, Options::new(37).wrap_algorithm(WrapAlgorithm::OptimalFit(penalties))),\n    ///            vec![\"This is a demo of the short last\",\n    ///                 \"line penalty.\"]);\n    ///\n    /// // We can change the meaning of \"short\" lines. Here, only words\n    /// // shorter than 1/10th of the line width will be considered short:\n    /// penalties.short_last_line_fraction = 10;\n    /// assert_eq!(wrap(text, Options::new(37).wrap_algorithm(WrapAlgorithm::OptimalFit(penalties))),\n    ///            vec![\"This is a demo of the short last line\",\n    ///                 \"penalty.\"]);\n    ///\n    /// // If desired, the penalty can also be disabled:\n    /// penalties.short_last_line_fraction = 4;\n    /// penalties.short_last_line_penalty = 0;\n    /// assert_eq!(wrap(text, Options::new(37).wrap_algorithm(WrapAlgorithm::OptimalFit(penalties))),\n    ///            vec![\"This is a demo of the short last line\",\n    ///                 \"penalty.\"]);\n    /// }\n    /// ```\n    pub short_last_line_fraction: usize,\n\n    /// Penalty for a last line with a single short word.\n    ///\n    /// Set this to zero if you do not want to penalize short last lines.\n    pub short_last_line_penalty: usize,\n\n    /// Penalty for lines ending with a hyphen.\n    pub hyphen_penalty: usize,\n}","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"wrap_algorithms::optimal_fit::Penalties::new":["/// Default penalties for monospace text.\n///\n/// The penalties here work well for monospace text. This is\n/// because they expect the gaps at the end of lines to be roughly\n/// in the range `0..100`. If the gaps are larger, the\n/// `overflow_penalty` and `hyphen_penalty` become insignificant.\npub const fn new() -> Self{\n        Penalties {\n            nline_penalty: 1000,\n            overflow_penalty: 50 * 50,\n            short_last_line_fraction: 4,\n            short_last_line_penalty: 25,\n            hyphen_penalty: 25,\n        }\n    }","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"wrap_algorithms::optimal_fit::wrap_optimal_fit":["/// Wrap abstract fragments into lines with an optimal-fit algorithm.\n///\n/// The `line_widths` slice gives the target line width for each line\n/// (the last slice element is repeated as necessary). This can be\n/// used to implement hanging indentation.\n///\n/// The fragments must already have been split into the desired\n/// widths, this function will not (and cannot) attempt to split them\n/// further when arranging them into lines.\n///\n/// # Optimal-Fit Algorithm\n///\n/// The algorithm considers all possible break points and picks the\n/// breaks which minimizes the gaps at the end of each line. More\n/// precisely, the algorithm assigns a cost or penalty to each break\n/// point, determined by `cost = gap * gap` where `gap = target_width -\n/// line_width`. Shorter lines are thus penalized more heavily since\n/// they leave behind a larger gap.\n///\n/// We can illustrate this with the text “To be, or not to be: that is\n/// the question”. We will be wrapping it in a narrow column with room\n/// for only 10 characters. The [greedy\n/// algorithm](super::wrap_first_fit) will produce these lines, each\n/// annotated with the corresponding penalty:\n///\n/// ```text\n/// \"To be, or\"   1² =  1\n/// \"not to be:\"  0² =  0\n/// \"that is\"     3² =  9\n/// \"the\"         7² = 49\n/// \"question\"    2² =  4\n/// ```\n///\n/// We see that line four with “the” leaves a gap of 7 columns, which\n/// gives it a penalty of 49. The sum of the penalties is 63.\n///\n/// There are 10 words, which means that there are `2_u32.pow(9)` or\n/// 512 different ways to typeset it. We can compute\n/// the sum of the penalties for each possible line break and search\n/// for the one with the lowest sum:\n///\n/// ```text\n/// \"To be,\"     4² = 16\n/// \"or not to\"  1² =  1\n/// \"be: that\"   2² =  4\n/// \"is the\"     4² = 16\n/// \"question\"   2² =  4\n/// ```\n///\n/// The sum of the penalties is 41, which is better than what the\n/// greedy algorithm produced.\n///\n/// Searching through all possible combinations would normally be\n/// prohibitively slow. However, it turns out that the problem can be\n/// formulated as the task of finding column minima in a cost matrix.\n/// This matrix has a special form (totally monotone) which lets us\n/// use a [linear-time algorithm called\n/// SMAWK](https://lib.rs/crates/smawk) to find the optimal break\n/// points.\n///\n/// This means that the time complexity remains O(_n_) where _n_ is\n/// the number of words. Compared to\n/// [`wrap_first_fit()`](super::wrap_first_fit), this function is\n/// about 4 times slower.\n///\n/// The optimization of per-line costs over the entire paragraph is\n/// inspired by the line breaking algorithm used in TeX, as described\n/// in the 1981 article [_Breaking Paragraphs into\n/// Lines_](http://www.eprg.org/G53DOC/pdfs/knuth-plass-breaking.pdf)\n/// by Knuth and Plass. The implementation here is based on [Python\n/// code by David\n/// Eppstein](https://github.com/jfinkels/PADS/blob/master/pads/wrap.py).\n///\n/// # Errors\n///\n/// In case of an overflow during the cost computation, an `Err` is\n/// returned. Overflows happens when fragments or lines have infinite\n/// widths (`f64::INFINITY`) or if the widths are so large that the\n/// gaps at the end of lines have sizes larger than `f64::MAX.sqrt()`\n/// (approximately 1e154):\n///\n/// ```\n/// use textwrap::core::Fragment;\n/// use textwrap::wrap_algorithms::{wrap_optimal_fit, OverflowError, Penalties};\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Word(f64);\n///\n/// impl Fragment for Word {\n///     fn width(&self) -> f64 { self.0 }\n///     fn whitespace_width(&self) -> f64 { 1.0 }\n///     fn penalty_width(&self) -> f64 { 0.0 }\n/// }\n///\n/// // Wrapping overflows because 1e155 * 1e155 = 1e310, which is\n/// // larger than f64::MAX:\n/// assert_eq!(wrap_optimal_fit(&[Word(0.0), Word(0.0)], &[1e155], &Penalties::default()),\n///            Err(OverflowError));\n/// ```\n///\n/// When using fragment widths and line widths which fit inside an\n/// `u64`, overflows cannot happen. This means that fragments derived\n/// from a `&str` cannot cause overflows.\n///\n/// **Note:** Only available when the `smawk` Cargo feature is\n/// enabled.\npub fn wrap_optimal_fit<'a, 'b, T: Fragment>(\n    fragments: &'a [T],\n    line_widths: &'b [f64],\n    penalties: &'b Penalties,\n) -> Result<Vec<&'a [T]>, OverflowError>{\n    // The final line width is used for all remaining lines.\n    let default_line_width = line_widths.last().copied().unwrap_or(0.0);\n    let mut widths = Vec::with_capacity(fragments.len() + 1);\n    let mut width = 0.0;\n    widths.push(width);\n    for fragment in fragments {\n        width += fragment.width() + fragment.whitespace_width();\n        widths.push(width);\n    }\n\n    let line_numbers = LineNumbers::new(fragments.len());\n\n    let minima = smawk::online_column_minima(0.0, widths.len(), |minima, i, j| {\n        // Line number for fragment `i`.\n        let line_number = line_numbers.get(i, minima);\n        let line_width = line_widths\n            .get(line_number)\n            .copied()\n            .unwrap_or(default_line_width);\n        let target_width = line_width.max(1.0);\n\n        // Compute the width of a line spanning fragments[i..j] in\n        // constant time. We need to adjust widths[j] by subtracting\n        // the whitespace of fragment[j-1] and then add the penalty.\n        let line_width = widths[j] - widths[i] - fragments[j - 1].whitespace_width()\n            + fragments[j - 1].penalty_width();\n\n        // We compute cost of the line containing fragments[i..j]. We\n        // start with values[i].1, which is the optimal cost for\n        // breaking before fragments[i].\n        //\n        // First, every extra line cost NLINE_PENALTY.\n        let mut cost = minima[i].1 + penalties.nline_penalty as f64;\n\n        // Next, we add a penalty depending on the line length.\n        if line_width > target_width {\n            // Lines that overflow get a hefty penalty.\n            let overflow = line_width - target_width;\n            cost += overflow * penalties.overflow_penalty as f64;\n        } else if j < fragments.len() {\n            // Other lines (except for the last line) get a milder\n            // penalty which depend on the size of the gap.\n            let gap = target_width - line_width;\n            cost += gap * gap;\n        } else if i + 1 == j\n            && line_width < target_width / penalties.short_last_line_fraction as f64\n        {\n            // The last line can have any size gap, but we do add a\n            // penalty if the line is very short (typically because it\n            // contains just a single word).\n            cost += penalties.short_last_line_penalty as f64;\n        }\n\n        // Finally, we discourage hyphens.\n        if fragments[j - 1].penalty_width() > 0.0 {\n            // TODO: this should use a penalty value from the fragment\n            // instead.\n            cost += penalties.hyphen_penalty as f64;\n        }\n\n        cost\n    });\n\n    for (_, cost) in &minima {\n        if cost.is_infinite() {\n            return Err(OverflowError);\n        }\n    }\n\n    let mut lines = Vec::with_capacity(line_numbers.get(fragments.len(), &minima));\n    let mut pos = fragments.len();\n    loop {\n        let prev = minima[pos].0;\n        lines.push(&fragments[prev..pos]);\n        pos = prev;\n        if pos == 0 {\n            break;\n        }\n    }\n\n    lines.reverse();\n    Ok(lines)\n}","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))"],"wrap_algorithms::wrap_first_fit":["/// Wrap abstract fragments into lines with a first-fit algorithm.\n///\n/// The `line_widths` slice gives the target line width for each line\n/// (the last slice element is repeated as necessary). This can be\n/// used to implement hanging indentation.\n///\n/// The fragments must already have been split into the desired\n/// widths, this function will not (and cannot) attempt to split them\n/// further when arranging them into lines.\n///\n/// # First-Fit Algorithm\n///\n/// This implements a simple “greedy” algorithm: accumulate fragments\n/// one by one and when a fragment no longer fits, start a new line.\n/// There is no look-ahead, we simply take first fit of the fragments\n/// we find.\n///\n/// While fast and predictable, this algorithm can produce poor line\n/// breaks when a long fragment is moved to a new line, leaving behind\n/// a large gap:\n///\n/// ```\n/// use textwrap::core::Word;\n/// use textwrap::wrap_algorithms::wrap_first_fit;\n/// use textwrap::WordSeparator;\n///\n/// // Helper to convert wrapped lines to a Vec<String>.\n/// fn lines_to_strings(lines: Vec<&[Word<'_>]>) -> Vec<String> {\n///     lines.iter().map(|line| {\n///         line.iter().map(|word| &**word).collect::<Vec<_>>().join(\" \")\n///     }).collect::<Vec<_>>()\n/// }\n///\n/// let text = \"These few words will unfortunately not wrap nicely.\";\n/// let words = WordSeparator::AsciiSpace.find_words(text).collect::<Vec<_>>();\n/// assert_eq!(lines_to_strings(wrap_first_fit(&words, &[15.0])),\n///            vec![\"These few words\",\n///                 \"will\",  // <-- short line\n///                 \"unfortunately\",\n///                 \"not wrap\",\n///                 \"nicely.\"]);\n///\n/// // We can avoid the short line if we look ahead:\n/// #[cfg(feature = \"smawk\")]\n/// use textwrap::wrap_algorithms::{wrap_optimal_fit, Penalties};\n/// #[cfg(feature = \"smawk\")]\n/// assert_eq!(lines_to_strings(wrap_optimal_fit(&words, &[15.0], &Penalties::new()).unwrap()),\n///            vec![\"These few\",\n///                 \"words will\",\n///                 \"unfortunately\",\n///                 \"not wrap\",\n///                 \"nicely.\"]);\n/// ```\n///\n/// The [`wrap_optimal_fit()`] function was used above to get better\n/// line breaks. It uses an advanced algorithm which tries to avoid\n/// short lines. This function is about 4 times faster than\n/// [`wrap_optimal_fit()`].\n///\n/// # Examples\n///\n/// Imagine you're building a house site and you have a number of\n/// tasks you need to execute. Things like pour foundation, complete\n/// framing, install plumbing, electric cabling, install insulation.\n///\n/// The construction workers can only work during daytime, so they\n/// need to pack up everything at night. Because they need to secure\n/// their tools and move machines back to the garage, this process\n/// takes much more time than the time it would take them to simply\n/// switch to another task.\n///\n/// You would like to make a list of tasks to execute every day based\n/// on your estimates. You can model this with a program like this:\n///\n/// ```\n/// use textwrap::core::{Fragment, Word};\n/// use textwrap::wrap_algorithms::wrap_first_fit;\n///\n/// #[derive(Debug)]\n/// struct Task<'a> {\n///     name: &'a str,\n///     hours: f64,   // Time needed to complete task.\n///     sweep: f64,   // Time needed for a quick sweep after task during the day.\n///     cleanup: f64, // Time needed for full cleanup if day ends with this task.\n/// }\n///\n/// impl Fragment for Task<'_> {\n///     fn width(&self) -> f64 { self.hours }\n///     fn whitespace_width(&self) -> f64 { self.sweep }\n///     fn penalty_width(&self) -> f64 { self.cleanup }\n/// }\n///\n/// // The morning tasks\n/// let tasks = vec![\n///     Task { name: \"Foundation\",  hours: 4.0, sweep: 2.0, cleanup: 3.0 },\n///     Task { name: \"Framing\",     hours: 3.0, sweep: 1.0, cleanup: 2.0 },\n///     Task { name: \"Plumbing\",    hours: 2.0, sweep: 2.0, cleanup: 2.0 },\n///     Task { name: \"Electrical\",  hours: 2.0, sweep: 1.0, cleanup: 2.0 },\n///     Task { name: \"Insulation\",  hours: 2.0, sweep: 1.0, cleanup: 2.0 },\n///     Task { name: \"Drywall\",     hours: 3.0, sweep: 1.0, cleanup: 2.0 },\n///     Task { name: \"Floors\",      hours: 3.0, sweep: 1.0, cleanup: 2.0 },\n///     Task { name: \"Countertops\", hours: 1.0, sweep: 1.0, cleanup: 2.0 },\n///     Task { name: \"Bathrooms\",   hours: 2.0, sweep: 1.0, cleanup: 2.0 },\n/// ];\n///\n/// // Fill tasks into days, taking `day_length` into account. The\n/// // output shows the hours worked per day along with the names of\n/// // the tasks for that day.\n/// fn assign_days<'a>(tasks: &[Task<'a>], day_length: f64) -> Vec<(f64, Vec<&'a str>)> {\n///     let mut days = Vec::new();\n///     // Assign tasks to days. The assignment is a vector of slices,\n///     // with a slice per day.\n///     let assigned_days: Vec<&[Task<'a>]> = wrap_first_fit(&tasks, &[day_length]);\n///     for day in assigned_days.iter() {\n///         let last = day.last().unwrap();\n///         let work_hours: f64 = day.iter().map(|t| t.hours + t.sweep).sum();\n///         let names = day.iter().map(|t| t.name).collect::<Vec<_>>();\n///         days.push((work_hours - last.sweep + last.cleanup, names));\n///     }\n///     days\n/// }\n///\n/// // With a single crew working 8 hours a day:\n/// assert_eq!(\n///     assign_days(&tasks, 8.0),\n///     [\n///         (7.0, vec![\"Foundation\"]),\n///         (8.0, vec![\"Framing\", \"Plumbing\"]),\n///         (7.0, vec![\"Electrical\", \"Insulation\"]),\n///         (5.0, vec![\"Drywall\"]),\n///         (7.0, vec![\"Floors\", \"Countertops\"]),\n///         (4.0, vec![\"Bathrooms\"]),\n///     ]\n/// );\n///\n/// // With two crews working in shifts, 16 hours a day:\n/// assert_eq!(\n///     assign_days(&tasks, 16.0),\n///     [\n///         (14.0, vec![\"Foundation\", \"Framing\", \"Plumbing\"]),\n///         (15.0, vec![\"Electrical\", \"Insulation\", \"Drywall\", \"Floors\"]),\n///         (6.0, vec![\"Countertops\", \"Bathrooms\"]),\n///     ]\n/// );\n/// ```\n///\n/// Apologies to anyone who actually knows how to build a house and\n/// knows how long each step takes :-)\npub fn wrap_first_fit<'a, T: Fragment>(\n    fragments: &'a [T],\n    line_widths: &[f64],\n) -> Vec<&'a [T]>{\n    // The final line width is used for all remaining lines.\n    let default_line_width = line_widths.last().copied().unwrap_or(0.0);\n    let mut lines = Vec::new();\n    let mut start = 0;\n    let mut width = 0.0;\n\n    for (idx, fragment) in fragments.iter().enumerate() {\n        let line_width = line_widths\n            .get(lines.len())\n            .copied()\n            .unwrap_or(default_line_width);\n        if width + fragment.width() + fragment.penalty_width() > line_width && idx > start {\n            lines.push(&fragments[start..idx]);\n            start = idx;\n            width = 0.0;\n        }\n        width += fragment.width() + fragment.whitespace_width();\n    }\n    lines.push(&fragments[start..]);\n    lines\n}","Real(LocalPath(\"src/wrap_algorithms.rs\"))"]},"struct_constructor":{"&'static str":["as_str"],"&<core::Word<'_> as std::ops::Deref>::Target":["deref"],"(std::string::String, options::Options<'_>)":["unfill"],"<line_ending::NonEmptyLines<'a> as std::iter::Iterator>::Item":["next"],"bool":["eq","skip_ansi_escape_sequence"],"core::Word":["clone","from"],"f64":["penalty_width","whitespace_width","width"],"impl std::iter::Iterator<Item = core::Word<'a>>":["split_words"],"impl std::iter::Iterator<Item = core::Word<'a>> + 'b":["break_apart"],"line_ending::LineEnding":["clone"],"line_ending::NonEmptyLines":["clone"],"options::Options":["clone","from","new"],"std::boxed::Box":["find_words","find_words_ascii_space","find_words_unicode_break_properties"],"std::string::String":["dedent","fill","fill_slow_path","indent","refill","strip_ansi_escape_sequences"],"std::vec::Vec":["break_words","split_points","wrap","wrap_columns","wrap_first_fit","wrap_optimal_fit"],"usize":["ch_width","display_width"],"word_separators::WordSeparator":["clone","new"],"word_splitters::WordSplitter":["clone"],"wrap_algorithms::WrapAlgorithm":["clone","default","new","new_optimal_fit"],"wrap_algorithms::optimal_fit::LineNumbers":["new"],"wrap_algorithms::optimal_fit::Penalties":["clone","default","new"]},"struct_to_trait":{"core::Word":["core::Fragment","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref"],"line_ending::LineEnding":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"line_ending::NonEmptyLines":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator","std::marker::Copy"],"options::Options":["std::clone::Clone","std::convert::From","std::fmt::Debug"],"word_separators::WordSeparator":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy"],"word_splitters::WordSplitter":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"],"wrap_algorithms::WrapAlgorithm":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy"],"wrap_algorithms::optimal_fit::OverflowError":["std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"wrap_algorithms::optimal_fit::Penalties":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"]},"targets":{"<core::Word<'_> as core::Fragment>::penalty_width":["penalty_width","Real(LocalPath(\"src/core.rs\"))","core::Fragment"],"<core::Word<'_> as core::Fragment>::whitespace_width":["whitespace_width","Real(LocalPath(\"src/core.rs\"))","core::Fragment"],"<core::Word<'_> as core::Fragment>::width":["width","Real(LocalPath(\"src/core.rs\"))","core::Fragment"],"<core::Word<'_> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/core.rs\"))","std::ops::Deref"],"<line_ending::NonEmptyLines<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/line_ending.rs\"))","std::iter::Iterator"],"<options::Options<'a> as std::convert::From<&'a options::Options<'a>>>::from":["from","Real(LocalPath(\"src/options.rs\"))","std::convert::From"],"<options::Options<'a> as std::convert::From<usize>>::from":["from","Real(LocalPath(\"src/options.rs\"))","std::convert::From"],"<word_separators::WordSeparator as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/word_separators.rs\"))","std::cmp::PartialEq"],"<word_separators::WordSeparator as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/word_separators.rs\"))","std::fmt::Debug"],"<word_splitters::WordSplitter as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/word_splitters.rs\"))","std::cmp::PartialEq"],"<word_splitters::WordSplitter as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/word_splitters.rs\"))","std::fmt::Debug"],"<wrap_algorithms::WrapAlgorithm as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/wrap_algorithms.rs\"))","std::cmp::PartialEq"],"<wrap_algorithms::WrapAlgorithm as std::default::Default>::default":["default","Real(LocalPath(\"src/wrap_algorithms.rs\"))","std::default::Default"],"<wrap_algorithms::WrapAlgorithm as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/wrap_algorithms.rs\"))","std::fmt::Debug"],"<wrap_algorithms::optimal_fit::OverflowError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))","std::fmt::Display"],"<wrap_algorithms::optimal_fit::Penalties as std::default::Default>::default":["default","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))","std::default::Default"],"columns::wrap_columns":["wrap_columns","Real(LocalPath(\"src/columns.rs\"))",""],"core::Word::<'a>::break_apart":["break_apart","Real(LocalPath(\"src/core.rs\"))",""],"core::Word::<'a>::from":["from","Real(LocalPath(\"src/core.rs\"))",""],"core::break_words":["break_words","Real(LocalPath(\"src/core.rs\"))",""],"core::ch_width":["ch_width","Real(LocalPath(\"src/core.rs\"))",""],"core::display_width":["display_width","Real(LocalPath(\"src/core.rs\"))",""],"core::skip_ansi_escape_sequence":["skip_ansi_escape_sequence","Real(LocalPath(\"src/core.rs\"))",""],"fill::fill":["fill","Real(LocalPath(\"src/fill.rs\"))",""],"fill::fill_inplace":["fill_inplace","Real(LocalPath(\"src/fill.rs\"))",""],"fill::fill_slow_path":["fill_slow_path","Real(LocalPath(\"src/fill.rs\"))",""],"indentation::dedent":["dedent","Real(LocalPath(\"src/indentation.rs\"))",""],"indentation::indent":["indent","Real(LocalPath(\"src/indentation.rs\"))",""],"line_ending::LineEnding::as_str":["as_str","Real(LocalPath(\"src/line_ending.rs\"))",""],"options::Options::<'a>::break_words":["break_words","Real(LocalPath(\"src/options.rs\"))",""],"options::Options::<'a>::initial_indent":["initial_indent","Real(LocalPath(\"src/options.rs\"))",""],"options::Options::<'a>::line_ending":["line_ending","Real(LocalPath(\"src/options.rs\"))",""],"options::Options::<'a>::new":["new","Real(LocalPath(\"src/options.rs\"))",""],"options::Options::<'a>::subsequent_indent":["subsequent_indent","Real(LocalPath(\"src/options.rs\"))",""],"options::Options::<'a>::word_separator":["word_separator","Real(LocalPath(\"src/options.rs\"))",""],"options::Options::<'a>::word_splitter":["word_splitter","Real(LocalPath(\"src/options.rs\"))",""],"options::Options::<'a>::wrap_algorithm":["wrap_algorithm","Real(LocalPath(\"src/options.rs\"))",""],"refill::refill":["refill","Real(LocalPath(\"src/refill.rs\"))",""],"refill::unfill":["unfill","Real(LocalPath(\"src/refill.rs\"))",""],"word_separators::WordSeparator::find_words":["find_words","Real(LocalPath(\"src/word_separators.rs\"))",""],"word_separators::WordSeparator::new":["new","Real(LocalPath(\"src/word_separators.rs\"))",""],"word_separators::find_words_ascii_space":["find_words_ascii_space","Real(LocalPath(\"src/word_separators.rs\"))",""],"word_separators::find_words_unicode_break_properties":["find_words_unicode_break_properties","Real(LocalPath(\"src/word_separators.rs\"))",""],"word_separators::strip_ansi_escape_sequences":["strip_ansi_escape_sequences","Real(LocalPath(\"src/word_separators.rs\"))",""],"word_splitters::WordSplitter::split_points":["split_points","Real(LocalPath(\"src/word_splitters.rs\"))",""],"word_splitters::split_words":["split_words","Real(LocalPath(\"src/word_splitters.rs\"))",""],"wrap::wrap":["wrap","Real(LocalPath(\"src/wrap.rs\"))",""],"wrap::wrap_single_line":["wrap_single_line","Real(LocalPath(\"src/wrap.rs\"))",""],"wrap::wrap_single_line_slow_path":["wrap_single_line_slow_path","Real(LocalPath(\"src/wrap.rs\"))",""],"wrap_algorithms::WrapAlgorithm::new":["new","Real(LocalPath(\"src/wrap_algorithms.rs\"))",""],"wrap_algorithms::WrapAlgorithm::new_optimal_fit":["new_optimal_fit","Real(LocalPath(\"src/wrap_algorithms.rs\"))",""],"wrap_algorithms::WrapAlgorithm::wrap":["wrap","Real(LocalPath(\"src/wrap_algorithms.rs\"))",""],"wrap_algorithms::optimal_fit::LineNumbers::get":["get","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))",""],"wrap_algorithms::optimal_fit::LineNumbers::new":["new","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))",""],"wrap_algorithms::optimal_fit::Penalties::new":["new","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))",""],"wrap_algorithms::optimal_fit::wrap_optimal_fit":["wrap_optimal_fit","Real(LocalPath(\"src/wrap_algorithms/optimal_fit.rs\"))",""],"wrap_algorithms::wrap_first_fit":["wrap_first_fit","Real(LocalPath(\"src/wrap_algorithms.rs\"))",""]},"trait_to_struct":{"core::Fragment":["core::Word"],"std::clone::Clone":["core::Word","line_ending::LineEnding","line_ending::NonEmptyLines","options::Options","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"std::cmp::Eq":["core::Word","line_ending::LineEnding","wrap_algorithms::optimal_fit::OverflowError","wrap_algorithms::optimal_fit::Penalties"],"std::cmp::PartialEq":["core::Word","line_ending::LineEnding","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::OverflowError","wrap_algorithms::optimal_fit::Penalties"],"std::convert::From":["options::Options"],"std::default::Default":["wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"std::error::Error":["wrap_algorithms::optimal_fit::OverflowError"],"std::fmt::Debug":["core::Word","line_ending::LineEnding","line_ending::NonEmptyLines","options::Options","word_separators::WordSeparator","word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::OverflowError","wrap_algorithms::optimal_fit::Penalties"],"std::fmt::Display":["wrap_algorithms::optimal_fit::OverflowError"],"std::iter::Iterator":["line_ending::NonEmptyLines"],"std::marker::Copy":["core::Word","line_ending::LineEnding","line_ending::NonEmptyLines","word_separators::WordSeparator","wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::Penalties"],"std::marker::StructuralEq":["core::Word","line_ending::LineEnding","wrap_algorithms::optimal_fit::OverflowError","wrap_algorithms::optimal_fit::Penalties"],"std::marker::StructuralPartialEq":["core::Word","line_ending::LineEnding","wrap_algorithms::optimal_fit::OverflowError","wrap_algorithms::optimal_fit::Penalties"],"std::ops::Deref":["core::Word"]},"type_to_def_path":{"core::Word<'a>":"core::Word","line_ending::LineEnding":"line_ending::LineEnding","line_ending::NonEmptyLines<'a>":"line_ending::NonEmptyLines","options::Options<'a>":"options::Options","word_separators::WordSeparator":"word_separators::WordSeparator","word_splitters::WordSplitter":"word_splitters::WordSplitter","wrap_algorithms::WrapAlgorithm":"wrap_algorithms::WrapAlgorithm","wrap_algorithms::optimal_fit::LineNumbers":"wrap_algorithms::optimal_fit::LineNumbers","wrap_algorithms::optimal_fit::OverflowError":"wrap_algorithms::optimal_fit::OverflowError","wrap_algorithms::optimal_fit::Penalties":"wrap_algorithms::optimal_fit::Penalties"}}