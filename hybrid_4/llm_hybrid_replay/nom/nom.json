{"dependencies":{"<&'a [T] as traits::InputLength>::input_len":[],"<&'a [char] as traits::FindToken<char>>::find_token":[],"<&'a [u8; N] as traits::AsBytes>::as_bytes":[],"<&'a [u8; N] as traits::InputLength>::input_len":[],"<&'a [u8] as traits::AsBytes>::as_bytes":[],"<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare":["traits::CompareResult"],"<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare_no_case":["traits::CompareResult"],"<&'a [u8] as traits::Compare<&'b [u8]>>::compare":["traits::CompareResult"],"<&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case":["traits::CompareResult"],"<&'a [u8] as traits::Compare<&'b str>>::compare":["traits::CompareResult"],"<&'a [u8] as traits::Compare<&'b str>>::compare_no_case":["traits::CompareResult"],"<&'a [u8] as traits::Compare<[u8; N]>>::compare":["traits::CompareResult"],"<&'a [u8] as traits::Compare<[u8; N]>>::compare_no_case":["traits::CompareResult"],"<&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring":["std::marker::Sized","std::option::Option"],"<&'a [u8] as traits::FindSubstring<&'b str>>::find_substring":["std::marker::Sized","std::option::Option"],"<&'a [u8] as traits::FindToken<char>>::find_token":[],"<&'a [u8] as traits::FindToken<u8>>::find_token":[],"<&'a [u8] as traits::Input>::input_len":[],"<&'a [u8] as traits::Input>::iter_elements":[],"<&'a [u8] as traits::Input>::iter_indices":[],"<&'a [u8] as traits::Input>::position":["std::marker::Sized","std::ops::Fn","std::option::Option"],"<&'a [u8] as traits::Input>::slice_index":["std::marker::Sized","std::result::Result"],"<&'a [u8] as traits::Input>::split_at_position":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"<&'a [u8] as traits::Input>::split_at_position1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"<&'a [u8] as traits::Input>::split_at_position1_complete":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"<&'a [u8] as traits::Input>::split_at_position_complete":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"<&'a [u8] as traits::Input>::take":[],"<&'a [u8] as traits::Input>::take_from":[],"<&'a [u8] as traits::Input>::take_split":[],"<&'a [u8] as traits::Offset>::offset":[],"<&'a [u8] as traits::ParseTo<R>>::parse_to":["std::marker::Sized","std::option::Option"],"<&'a char as traits::AsChar>::as_char":[],"<&'a char as traits::AsChar>::is_alpha":[],"<&'a char as traits::AsChar>::is_alphanum":[],"<&'a char as traits::AsChar>::is_dec_digit":[],"<&'a char as traits::AsChar>::is_hex_digit":[],"<&'a char as traits::AsChar>::is_oct_digit":[],"<&'a char as traits::AsChar>::len":[],"<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next":["combinator::ParserIterator","std::marker::Sized","std::option::Option"],"<&'a str as traits::AsBytes>::as_bytes":[],"<&'a str as traits::Compare<&'b [u8]>>::compare":["traits::CompareResult"],"<&'a str as traits::Compare<&'b [u8]>>::compare_no_case":["traits::CompareResult"],"<&'a str as traits::Compare<&'b str>>::compare":["traits::CompareResult"],"<&'a str as traits::Compare<&'b str>>::compare_no_case":["traits::CompareResult"],"<&'a str as traits::FindSubstring<&'b str>>::find_substring":["std::marker::Sized","std::option::Option"],"<&'a str as traits::FindToken<char>>::find_token":[],"<&'a str as traits::FindToken<u8>>::find_token":[],"<&'a str as traits::Input>::input_len":[],"<&'a str as traits::Input>::iter_elements":[],"<&'a str as traits::Input>::iter_indices":[],"<&'a str as traits::Input>::position":["std::marker::Sized","std::ops::Fn","std::option::Option"],"<&'a str as traits::Input>::slice_index":["std::marker::Sized","std::result::Result"],"<&'a str as traits::Input>::split_at_position":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"<&'a str as traits::Input>::split_at_position1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"<&'a str as traits::Input>::split_at_position1_complete":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"<&'a str as traits::Input>::split_at_position_complete":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"<&'a str as traits::Input>::take":[],"<&'a str as traits::Input>::take_from":[],"<&'a str as traits::Input>::take_split":[],"<&'a str as traits::InputLength>::input_len":[],"<&'a str as traits::Offset>::offset":[],"<&'a str as traits::ParseTo<R>>::parse_to":["std::marker::Sized","std::option::Option"],"<&'a u8 as traits::AsChar>::as_char":[],"<&'a u8 as traits::AsChar>::is_alpha":[],"<&'a u8 as traits::AsChar>::is_alphanum":[],"<&'a u8 as traits::AsChar>::is_dec_digit":[],"<&'a u8 as traits::AsChar>::is_hex_digit":[],"<&'a u8 as traits::AsChar>::is_oct_digit":[],"<&'a u8 as traits::AsChar>::len":[],"<&'b [char] as traits::FindToken<&'a char>>::find_token":[],"<&'b [u8] as traits::FindToken<&'a u8>>::find_token":[],"<&'b str as traits::FindToken<&'a u8>>::find_token":[],"<&[u8] as traits::ExtendInto>::extend_into":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<&[u8] as traits::ExtendInto>::new_builder":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<&str as traits::ExtendInto>::extend_into":["std::string::String"],"<&str as traits::ExtendInto>::new_builder":["std::string::String"],"<(&'a [u8], usize) as traits::InputLength>::input_len":[],"<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert":["error::ErrorKind"],"<() as error::FromExternalError<I, E>>::from_external_error":["error::ErrorKind"],"<() as error::ParseError<I>>::append":["error::ErrorKind"],"<() as error::ParseError<I>>::from_error_kind":["error::ErrorKind"],"<() as sequence::Tuple<I, (), E>>::parse":["std::marker::Sized","std::result::Result"],"<() as traits::ErrorConvert<()>>::convert":[],"<(A, B) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(A,) as branch::Alt<Input, Output, Error>>::choice":["std::marker::Sized","std::result::Result"],"<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation":["std::marker::Sized","std::result::Result"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse":["std::marker::Sized","std::result::Result"],"<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error":["error::ErrorKind"],"<(I, error::ErrorKind) as error::ParseError<I>>::append":["error::ErrorKind"],"<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind":["error::ErrorKind"],"<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert":["error::ErrorKind"],"<(P1, P2) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<(P1,) as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<F as internal::Parser<I>>::parse":["std::marker::Sized","std::result::Result"],"<[u8; N] as traits::AsBytes>::as_bytes":[],"<[u8; N] as traits::FindToken<&'a u8>>::find_token":[],"<[u8; N] as traits::FindToken<u8>>::find_token":[],"<[u8; N] as traits::InputLength>::input_len":[],"<[u8] as traits::AsBytes>::as_bytes":[],"<[u8] as traits::ExtendInto>::extend_into":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<[u8] as traits::ExtendInto>::new_builder":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<[u8] as traits::HexDisplay>::to_hex":["std::string::String"],"<[u8] as traits::HexDisplay>::to_hex_from":["std::string::String"],"<[u8] as traits::Offset>::offset":[],"<char as traits::AsChar>::as_char":[],"<char as traits::AsChar>::is_alpha":[],"<char as traits::AsChar>::is_alphanum":[],"<char as traits::AsChar>::is_dec_digit":[],"<char as traits::AsChar>::is_hex_digit":[],"<char as traits::AsChar>::is_oct_digit":[],"<char as traits::AsChar>::len":[],"<char as traits::ExtendInto>::extend_into":["std::string::String"],"<char as traits::ExtendInto>::new_builder":["std::string::String"],"<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<I> as error::FromExternalError<I, E>>::from_external_error":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<I> as error::ParseError<I>>::append":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<I> as error::ParseError<I>>::from_error_kind":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<I> as std::clone::Clone>::clone":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<I> as std::cmp::Eq>::assert_receiver_is_total_eq":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<I> as std::cmp::PartialEq>::eq":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<I> as std::fmt::Debug>::fmt":["error::Error","error::ErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error<I> as std::fmt::Display>::fmt":["error::Error","error::ErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<std::string::String> as std::convert::From<error::Error<&str>>>::from":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::Error<std::vec::Vec<u8>> as std::convert::From<error::Error<&[u8]>>>::from":["error::Error","error::ErrorKind","std::marker::Sized"],"<error::ErrorKind as std::clone::Clone>::clone":["error::ErrorKind"],"<error::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["error::ErrorKind"],"<error::ErrorKind as std::cmp::PartialEq>::eq":["error::ErrorKind"],"<error::ErrorKind as std::fmt::Debug>::fmt":["error::ErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ErrorKind as std::hash::Hash>::hash":["error::ErrorKind","std::hash::Hasher","std::marker::Sized"],"<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as error::ContextError<I>>::add_context":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error":["error::ErrorKind","error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as error::ParseError<I>>::append":["error::ErrorKind","error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as error::ParseError<I>>::from_char":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as error::ParseError<I>>::from_error_kind":["error::ErrorKind","error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as std::clone::Clone>::clone":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as std::cmp::Eq>::assert_receiver_is_total_eq":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as std::cmp::PartialEq>::eq":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<I> as std::fmt::Debug>::fmt":["error::VerboseError","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<error::VerboseError<I> as std::fmt::Display>::fmt":["error::VerboseError","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<std::string::String> as std::convert::From<error::VerboseError<&str>>>::from":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseError<std::vec::Vec<u8>> as std::convert::From<error::VerboseError<&[u8]>>>::from":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<error::VerboseErrorKind as std::clone::Clone>::clone":["error::ErrorKind","error::VerboseErrorKind"],"<error::VerboseErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["error::ErrorKind","error::VerboseErrorKind"],"<error::VerboseErrorKind as std::cmp::PartialEq>::eq":["error::ErrorKind","error::VerboseErrorKind"],"<error::VerboseErrorKind as std::fmt::Debug>::fmt":["error::ErrorKind","error::VerboseErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<internal::And<F, G> as internal::Parser<I>>::parse":["internal::And","std::marker::Sized","std::result::Result"],"<internal::AndThen<F, G> as internal::Parser<I>>::parse":["internal::AndThen","std::marker::Sized","std::result::Result"],"<internal::Err<E> as std::clone::Clone>::clone":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"<internal::Err<E> as std::cmp::PartialEq>::eq":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"<internal::Err<E> as std::error::Error>::source":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize","std::option::Option"],"<internal::Err<E> as std::fmt::Debug>::fmt":["internal::Err","internal::Needed","std::fmt::Formatter","std::marker::Sized","std::num::NonZeroUsize","std::result::Result"],"<internal::Err<E> as std::fmt::Display>::fmt":["internal::Err","internal::Needed","std::fmt::Formatter","std::marker::Sized","std::num::NonZeroUsize","std::result::Result"],"<internal::FlatMap<F, G> as internal::Parser<I>>::parse":["internal::FlatMap","std::marker::Sized","std::result::Result"],"<internal::Into<F, O2, E2> as internal::Parser<I>>::parse":["internal::Into","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<internal::Map<F, G> as internal::Parser<I>>::parse":["internal::Map","std::marker::Sized","std::result::Result"],"<internal::MapOpt<F, G> as internal::Parser<I>>::parse":["internal::MapOpt","std::marker::Sized","std::result::Result"],"<internal::MapRes<F, G> as internal::Parser<I>>::parse":["internal::MapRes","std::marker::Sized","std::result::Result"],"<internal::Needed as std::clone::Clone>::clone":["internal::Needed","std::num::NonZeroUsize"],"<internal::Needed as std::cmp::Eq>::assert_receiver_is_total_eq":["internal::Needed","std::num::NonZeroUsize"],"<internal::Needed as std::cmp::PartialEq>::eq":["internal::Needed","std::num::NonZeroUsize"],"<internal::Needed as std::fmt::Debug>::fmt":["internal::Needed","std::fmt::Formatter","std::marker::Sized","std::num::NonZeroUsize","std::result::Result"],"<internal::Or<F, G> as internal::Parser<I>>::parse":["internal::Or","std::marker::Sized","std::result::Result"],"<number::Endianness as std::clone::Clone>::clone":["number::Endianness"],"<number::Endianness as std::cmp::Eq>::assert_receiver_is_total_eq":["number::Endianness"],"<number::Endianness as std::cmp::PartialEq>::eq":["number::Endianness"],"<number::Endianness as std::fmt::Debug>::fmt":["number::Endianness","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)> as internal::Parser<I>>::parse":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<std::ops::Range<usize> as traits::NomRange<usize>>::bounded_iter":["std::marker::Sized","std::ops::Range"],"<std::ops::Range<usize> as traits::NomRange<usize>>::bounds":["std::collections::Bound","std::marker::Sized","std::ops::Range"],"<std::ops::Range<usize> as traits::NomRange<usize>>::contains":["std::marker::Sized","std::ops::Range"],"<std::ops::Range<usize> as traits::NomRange<usize>>::is_inverted":["std::marker::Sized","std::ops::Range"],"<std::ops::Range<usize> as traits::NomRange<usize>>::saturating_iter":["std::marker::Sized","std::ops::Range"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounded_iter":["std::marker::Sized","std::ops::RangeFrom"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounds":["std::collections::Bound","std::marker::Sized","std::ops::RangeFrom"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::contains":["std::marker::Sized","std::ops::RangeFrom"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::is_inverted":["std::marker::Sized","std::ops::RangeFrom"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::saturating_iter":["std::marker::Sized","std::ops::RangeFrom"],"<std::ops::RangeFull as traits::NomRange<usize>>::bounded_iter":["std::ops::RangeFull"],"<std::ops::RangeFull as traits::NomRange<usize>>::bounds":["std::collections::Bound","std::marker::Sized","std::ops::RangeFull"],"<std::ops::RangeFull as traits::NomRange<usize>>::contains":["std::ops::RangeFull"],"<std::ops::RangeFull as traits::NomRange<usize>>::is_inverted":["std::ops::RangeFull"],"<std::ops::RangeFull as traits::NomRange<usize>>::saturating_iter":["std::ops::RangeFull"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounded_iter":["std::marker::Sized","std::ops::RangeInclusive"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounds":["std::collections::Bound","std::marker::Sized","std::ops::RangeInclusive"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::contains":["std::marker::Sized","std::ops::RangeInclusive"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::is_inverted":["std::marker::Sized","std::ops::RangeInclusive"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::saturating_iter":["std::marker::Sized","std::ops::RangeInclusive"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounded_iter":["std::marker::Sized","std::ops::RangeTo"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounds":["std::collections::Bound","std::marker::Sized","std::ops::RangeTo"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::contains":["std::marker::Sized","std::ops::RangeTo"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::is_inverted":["std::marker::Sized","std::ops::RangeTo"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::saturating_iter":["std::marker::Sized","std::ops::RangeTo"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounded_iter":["std::marker::Sized","std::ops::RangeToInclusive"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounds":["std::collections::Bound","std::marker::Sized","std::ops::RangeToInclusive"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::contains":["std::marker::Sized","std::ops::RangeToInclusive"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::is_inverted":["std::marker::Sized","std::ops::RangeToInclusive"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::saturating_iter":["std::marker::Sized","std::ops::RangeToInclusive"],"<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish":["std::marker::Sized","std::result::Result"],"<str as traits::AsBytes>::as_bytes":[],"<str as traits::ExtendInto>::extend_into":["std::string::String"],"<str as traits::ExtendInto>::new_builder":["std::string::String"],"<str as traits::HexDisplay>::to_hex":["std::string::String"],"<str as traits::HexDisplay>::to_hex_from":["std::string::String"],"<str as traits::Offset>::offset":[],"<traits::CompareResult as std::cmp::Eq>::assert_receiver_is_total_eq":["traits::CompareResult"],"<traits::CompareResult as std::cmp::PartialEq>::eq":["traits::CompareResult"],"<traits::CompareResult as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","traits::CompareResult"],"<traits::SaturatingIterator as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","traits::SaturatingIterator"],"<u16 as traits::ToUsize>::to_usize":[],"<u32 as traits::ToUsize>::to_usize":[],"<u64 as traits::ToUsize>::to_usize":[],"<u8 as traits::AsChar>::as_char":[],"<u8 as traits::AsChar>::is_alpha":[],"<u8 as traits::AsChar>::is_alphanum":[],"<u8 as traits::AsChar>::is_dec_digit":[],"<u8 as traits::AsChar>::is_hex_digit":[],"<u8 as traits::AsChar>::is_oct_digit":[],"<u8 as traits::AsChar>::len":[],"<u8 as traits::ToUsize>::to_usize":[],"<usize as traits::NomRange<usize>>::bounded_iter":[],"<usize as traits::NomRange<usize>>::bounds":["std::collections::Bound","std::marker::Sized"],"<usize as traits::NomRange<usize>>::contains":[],"<usize as traits::NomRange<usize>>::is_inverted":[],"<usize as traits::NomRange<usize>>::saturating_iter":[],"<usize as traits::ToUsize>::to_usize":[],"bits::bits":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized","traits::ErrorConvert","traits::Input"],"bits::bytes":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::ErrorConvert","traits::Input"],"bits::complete::bool":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"bits::complete::tag":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::marker::Sized","std::ops::AddAssign","std::ops::Shl","std::ops::Shr","traits::Input","traits::ToUsize"],"bits::complete::take":["error::Error","error::ErrorKind","error::ParseError","std::convert::From","std::marker::Sized","std::ops::AddAssign","std::ops::Shl","std::ops::Shr","traits::Input","traits::ToUsize"],"bits::streaming::bool":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"bits::streaming::tag":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::marker::Sized","std::ops::AddAssign","std::ops::Shl","std::ops::Shr","traits::Input","traits::ToUsize"],"bits::streaming::take":["error::Error","error::ErrorKind","error::ParseError","std::convert::From","std::marker::Sized","std::ops::AddAssign","std::ops::Shl","std::ops::Shr","traits::Input","traits::ToUsize"],"branch::Alt::choice":["std::marker::Sized","std::result::Result"],"branch::Permutation::permutation":["std::marker::Sized","std::result::Result"],"branch::alt":["branch::Alt","error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized"],"branch::permutation":["branch::Permutation","error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized"],"bytes::complete::escaped":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::AsChar","traits::Input","traits::Offset"],"bytes::complete::escaped_transform":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::AsChar","traits::ExtendInto","traits::Input","traits::Offset"],"bytes::complete::is_a":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::FindToken","traits::Input"],"bytes::complete::is_not":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::FindToken","traits::Input"],"bytes::complete::tag":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","traits::Compare","traits::Input","traits::InputLength"],"bytes::complete::tag_no_case":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","traits::Compare","traits::Input","traits::InputLength"],"bytes::complete::take":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::Input","traits::ToUsize"],"bytes::complete::take_till":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::complete::take_till1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::complete::take_until":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","traits::FindSubstring","traits::Input","traits::InputLength"],"bytes::complete::take_until1":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","traits::FindSubstring","traits::Input","traits::InputLength"],"bytes::complete::take_while":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::complete::take_while1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::complete::take_while_m_n":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::streaming::escaped":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::AsChar","traits::Input","traits::Offset"],"bytes::streaming::escaped_transform":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::AsChar","traits::ExtendInto","traits::Input","traits::Offset"],"bytes::streaming::is_a":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::FindToken","traits::Input"],"bytes::streaming::is_not":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::FindToken","traits::Input"],"bytes::streaming::tag":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","traits::Compare","traits::Input","traits::InputLength"],"bytes::streaming::tag_no_case":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","traits::Compare","traits::Input","traits::InputLength"],"bytes::streaming::take":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::Input","traits::InputLength","traits::ToUsize"],"bytes::streaming::take_till":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::streaming::take_till1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::streaming::take_until":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","traits::FindSubstring","traits::Input"],"bytes::streaming::take_until1":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","traits::FindSubstring","traits::Input"],"bytes::streaming::take_while":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::streaming::take_while1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"bytes::streaming::take_while_m_n":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::Input"],"character::complete::alpha0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::alpha1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::alphanumeric0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::alphanumeric1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::anychar":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::char":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::AsChar","traits::Input"],"character::complete::crlf":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Compare","traits::Input"],"character::complete::digit0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::digit1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::hex_digit0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::hex_digit1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::i128":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::complete::i16":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::complete::i32":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::complete::i64":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::complete::i8":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::complete::line_ending":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Compare","traits::Input","traits::InputLength"],"character::complete::multispace0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::multispace1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::newline":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::none_of":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::AsChar","traits::FindToken","traits::Input"],"character::complete::not_line_ending":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::complete::oct_digit0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::oct_digit1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::one_of":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::AsChar","traits::FindToken","traits::Input"],"character::complete::satisfy":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::AsChar","traits::Input"],"character::complete::sign":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::Compare","traits::Input"],"character::complete::space0":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::space1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::tab":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::u128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::u16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::u32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::u64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::complete::u8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::is_alphabetic":[],"character::is_alphanumeric":[],"character::is_digit":[],"character::is_hex_digit":[],"character::is_newline":[],"character::is_oct_digit":[],"character::is_space":[],"character::streaming::alpha0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::alpha1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::alphanumeric0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::alphanumeric1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::anychar":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::char":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::AsChar","traits::Input"],"character::streaming::crlf":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Compare","traits::Input"],"character::streaming::digit0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::digit1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::hex_digit0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::hex_digit1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::i128":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::streaming::i16":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::streaming::i32":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::streaming::i64":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::streaming::i8":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::streaming::line_ending":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Compare","traits::Input"],"character::streaming::multispace0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::multispace1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::newline":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::none_of":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::AsChar","traits::FindToken","traits::Input"],"character::streaming::not_line_ending":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input"],"character::streaming::oct_digit0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::oct_digit1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::one_of":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","traits::AsChar","traits::FindToken","traits::Input"],"character::streaming::satisfy":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","traits::AsChar","traits::Input"],"character::streaming::sign":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::Compare","traits::Input"],"character::streaming::space0":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::space1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::tab":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::u128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::u16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::u32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::u64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"character::streaming::u8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input"],"combinator::ParserIterator":["combinator::ParserIterator","std::marker::Sized","std::option::Option"],"combinator::ParserIterator::<I, E, F>::finish":["combinator::ParserIterator","std::marker::Sized","std::option::Option","std::result::Result"],"combinator::State":["combinator::State","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"combinator::all_consuming":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized","traits::InputLength"],"combinator::complete":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized"],"combinator::cond":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized"],"combinator::consumed":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::Input","traits::Offset"],"combinator::cut":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized"],"combinator::eof":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::InputLength"],"combinator::fail":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result"],"combinator::flat_map":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized","std::ops::FnMut"],"combinator::into":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::convert::Into","std::marker::Sized"],"combinator::iterator":["<F as internal::Parser<I>>::F","combinator::ParserIterator","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized","std::option::Option"],"combinator::map":["<F as internal::Parser<I>>::F","internal::Parser","std::marker::Sized","std::ops::FnMut"],"combinator::map_opt":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","std::ops::FnMut"],"combinator::map_parser":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized"],"combinator::map_res":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::FromExternalError","internal::Parser","std::clone::Clone","std::marker::Sized","std::ops::FnMut"],"combinator::not":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized"],"combinator::opt":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized"],"combinator::peek":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized"],"combinator::recognize":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::Input","traits::Offset"],"combinator::rest":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"combinator::rest_len":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::InputLength"],"combinator::success":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized"],"combinator::value":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized"],"combinator::verify":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::borrow::Borrow","std::clone::Clone","std::marker::Sized","std::ops::Fn"],"error::ContextError::add_context":[],"error::Error":["error::Error","error::ErrorKind","std::marker::Sized"],"error::Error::<I>::new":["error::Error","error::ErrorKind","std::marker::Sized"],"error::ErrorKind":["error::ErrorKind"],"error::ErrorKind::description":["error::ErrorKind"],"error::FromExternalError::from_external_error":["error::ErrorKind"],"error::ParseError::append":["error::ErrorKind"],"error::ParseError::from_char":[],"error::ParseError::from_error_kind":["error::ErrorKind"],"error::ParseError::or":[],"error::VerboseError":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"error::VerboseErrorKind":["error::ErrorKind","error::VerboseErrorKind"],"error::append_error":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized"],"error::context":["<F as internal::Parser<I>>::F","error::ContextError","error::Error","error::ErrorKind","internal::Parser","std::clone::Clone","std::marker::Sized"],"error::convert_error":["error::VerboseError","std::alloc::Allocator","std::marker::Sized","std::ops::Deref","std::string::String","std::vec::Vec"],"error::dbg_dmp":["error::Error","error::ErrorKind","std::fmt::Debug","std::marker::Sized","std::ops::Fn"],"error::error_to_u32":["error::ErrorKind"],"error::make_error":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized"],"internal::And":["internal::And","std::marker::Sized"],"internal::AndThen":["internal::AndThen","std::marker::Sized"],"internal::Err":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"internal::Err::<(&[u8], error::ErrorKind)>::to_owned":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"internal::Err::<(&str, error::ErrorKind)>::to_owned":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"internal::Err::<(T, error::ErrorKind)>::map_input":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize","std::ops::FnOnce"],"internal::Err::<E>::convert":["error::Error","error::ErrorKind","internal::Err","internal::Needed","std::convert::From","std::marker::Sized","std::num::NonZeroUsize"],"internal::Err::<E>::is_incomplete":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"internal::Err::<E>::map":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize","std::ops::FnOnce"],"internal::Err::<error::Error<&[u8]>>::to_owned":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"internal::Err::<error::Error<&str>>::to_owned":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize"],"internal::Err::<error::Error<T>>::map_input":["internal::Err","internal::Needed","std::marker::Sized","std::num::NonZeroUsize","std::ops::FnOnce"],"internal::Finish::finish":["std::marker::Sized","std::result::Result"],"internal::FlatMap":["internal::FlatMap","std::marker::Sized"],"internal::Into":["internal::Into","std::marker::PhantomData","std::marker::Sized"],"internal::Map":["internal::Map","std::marker::Sized"],"internal::MapOpt":["internal::MapOpt","std::marker::Sized"],"internal::MapRes":["internal::MapRes","std::marker::Sized"],"internal::Needed":["internal::Needed","std::num::NonZeroUsize"],"internal::Needed::is_known":["internal::Needed","std::num::NonZeroUsize"],"internal::Needed::map":["internal::Needed","std::marker::Sized","std::num::NonZeroUsize","std::ops::Fn"],"internal::Needed::new":["internal::Needed","std::num::NonZeroUsize"],"internal::Or":["internal::Or","std::marker::Sized"],"internal::Parser::and":["<F as internal::Parser<I>>::F","internal::And","internal::Parser","std::marker::Sized"],"internal::Parser::and_then":["<F as internal::Parser<I>>::F","internal::AndThen","internal::Parser","std::marker::Sized"],"internal::Parser::flat_map":["<F as internal::Parser<I>>::F","internal::FlatMap","internal::Parser","std::marker::Sized","std::ops::FnMut"],"internal::Parser::into":["error::Error","error::ErrorKind","internal::Into","std::convert::From","std::marker::PhantomData","std::marker::Sized"],"internal::Parser::map":["internal::Map","std::marker::Sized","std::ops::FnMut"],"internal::Parser::map_opt":["internal::MapOpt","std::marker::Sized","std::ops::Fn"],"internal::Parser::map_res":["error::Error","error::ErrorKind","error::FromExternalError","internal::MapRes","std::marker::Sized","std::ops::Fn"],"internal::Parser::or":["<F as internal::Parser<I>>::F","internal::Or","internal::Parser","std::marker::Sized"],"internal::Parser::parse":["std::marker::Sized","std::result::Result"],"multi::count":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"],"multi::fill":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"],"multi::fold":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","std::ops::FnMut","std::ops::Range","traits::InputLength","traits::NomRange"],"multi::fold_many0":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","std::ops::FnMut","traits::InputLength"],"multi::fold_many1":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","std::ops::FnMut","traits::InputLength"],"multi::fold_many_m_n":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","std::ops::FnMut","traits::InputLength"],"multi::length_count":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::ToUsize"],"multi::length_data":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized","traits::Input","traits::ToUsize"],"multi::length_value":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::Input","traits::ToUsize"],"multi::many":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::default::Default","std::iter::Extend","std::marker::Sized","std::ops::Range","traits::InputLength","traits::NomRange"],"multi::many0":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","internal::Parser","std::clone::Clone","std::marker::Sized","traits::InputLength"],"multi::many0_count":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::InputLength"],"multi::many1":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","internal::Parser","std::clone::Clone","std::marker::Sized","traits::InputLength"],"multi::many1_count":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::InputLength"],"multi::many_m_n":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::InputLength"],"multi::many_till":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::InputLength"],"multi::separated_list0":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::InputLength"],"multi::separated_list1":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::clone::Clone","std::marker::Sized","traits::InputLength"],"number::Endianness":["number::Endianness"],"number::complete::be_f32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_f64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_i128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_i16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_i24":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_i32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_i64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_i8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_u128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_u16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_u24":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_u32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_u64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_u8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::be_uint":["error::Error","error::ErrorKind","error::ParseError","std::convert::From","std::default::Default","std::marker::Sized","std::ops::Add","std::ops::Shl","std::result::Result","traits::Input"],"number::complete::double":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsBytes","traits::AsChar","traits::Compare","traits::Input","traits::Offset","traits::ParseTo"],"number::complete::f32":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::f64":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::float":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsBytes","traits::AsChar","traits::Compare","traits::Input","traits::Offset","traits::ParseTo"],"number::complete::hex_u32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsBytes","traits::AsChar","traits::Input"],"number::complete::i128":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::i16":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::i24":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::i32":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::i64":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::i8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_f32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_f64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_i128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_i16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_i24":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_i32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_i64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_i8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_u128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_u16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_u24":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_u32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_u64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_u8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::le_uint":["error::Error","error::ErrorKind","error::ParseError","std::convert::From","std::default::Default","std::marker::Sized","std::ops::Add","std::ops::Shl","std::result::Result","traits::Input"],"number::complete::recognize_float":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input","traits::Offset"],"number::complete::recognize_float_or_exceptions":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input","traits::Offset"],"number::complete::recognize_float_parts":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsBytes","traits::AsChar","traits::Compare","traits::Input","traits::Offset"],"number::complete::u128":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::u16":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::u24":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::u32":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::u64":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::complete::u8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_f32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_f64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_i128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_i16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_i24":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_i32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_i64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_i8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_u128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_u16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_u24":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_u32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_u64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_u8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::be_uint":["error::Error","error::ErrorKind","error::ParseError","std::convert::From","std::default::Default","std::marker::Sized","std::ops::Add","std::ops::Shl","std::result::Result","traits::Input"],"number::streaming::double":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsBytes","traits::AsChar","traits::Compare","traits::Input","traits::Offset","traits::ParseTo"],"number::streaming::f32":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::f64":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::float":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsBytes","traits::AsChar","traits::Compare","traits::Input","traits::Offset","traits::ParseTo"],"number::streaming::hex_u32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::AsBytes","traits::AsChar","traits::Input"],"number::streaming::i128":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::i16":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::i24":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::i32":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::i64":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::i8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_f32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_f64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_i128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_i16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_i24":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_i32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_i64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_i8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_u128":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_u16":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_u24":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_u32":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_u64":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_u8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::le_uint":["error::Error","error::ErrorKind","error::ParseError","std::convert::From","std::default::Default","std::marker::Sized","std::ops::Add","std::ops::Shl","std::result::Result","traits::Input"],"number::streaming::recognize_float":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Input","traits::Offset"],"number::streaming::recognize_float_or_exceptions":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsChar","traits::Compare","traits::Input","traits::Offset"],"number::streaming::recognize_float_parts":["error::Error","error::ErrorKind","error::ParseError","std::clone::Clone","std::marker::Sized","std::result::Result","traits::AsBytes","traits::AsChar","traits::Compare","traits::Input","traits::Offset"],"number::streaming::u128":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::u16":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::u24":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::u32":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::u64":["error::Error","error::ErrorKind","error::ParseError","number::Endianness","std::marker::Sized","std::result::Result","traits::Input"],"number::streaming::u8":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::result::Result","traits::Input"],"sequence::Tuple::parse":["std::marker::Sized","std::result::Result"],"sequence::delimited":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized"],"sequence::pair":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized"],"sequence::preceded":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized"],"sequence::separated_pair":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized"],"sequence::terminated":["<F as internal::Parser<I>>::F","error::Error","error::ErrorKind","error::ParseError","internal::Parser","std::marker::Sized"],"sequence::tuple":["error::Error","error::ErrorKind","error::ParseError","sequence::Tuple","std::marker::Sized"],"traits::AsBytes::as_bytes":[],"traits::AsChar::as_char":[],"traits::AsChar::is_alpha":[],"traits::AsChar::is_alphanum":[],"traits::AsChar::is_dec_digit":[],"traits::AsChar::is_hex_digit":[],"traits::AsChar::is_oct_digit":[],"traits::AsChar::len":[],"traits::Compare::compare":["traits::CompareResult"],"traits::Compare::compare_no_case":["traits::CompareResult"],"traits::CompareResult":["traits::CompareResult"],"traits::ErrorConvert::convert":[],"traits::ExtendInto::extend_into":[],"traits::ExtendInto::new_builder":[],"traits::FindSubstring::find_substring":["std::marker::Sized","std::option::Option"],"traits::FindToken::find_token":[],"traits::HexDisplay::to_hex":["std::string::String"],"traits::HexDisplay::to_hex_from":["std::string::String"],"traits::Input::input_len":[],"traits::Input::iter_elements":[],"traits::Input::iter_indices":[],"traits::Input::position":["std::marker::Sized","std::ops::Fn","std::option::Option"],"traits::Input::slice_index":["std::marker::Sized","std::result::Result"],"traits::Input::split_at_position":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"traits::Input::split_at_position1":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"traits::Input::split_at_position1_complete":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"traits::Input::split_at_position_complete":["error::Error","error::ErrorKind","error::ParseError","std::marker::Sized","std::ops::Fn","std::result::Result"],"traits::Input::take":[],"traits::Input::take_from":[],"traits::Input::take_split":[],"traits::InputLength::input_len":[],"traits::NomRange::bounded_iter":[],"traits::NomRange::bounds":["std::collections::Bound","std::marker::Sized"],"traits::NomRange::contains":[],"traits::NomRange::is_inverted":[],"traits::NomRange::saturating_iter":[],"traits::Offset::offset":[],"traits::ParseTo::parse_to":["std::marker::Sized","std::option::Option"],"traits::SaturatingIterator":["traits::SaturatingIterator"],"traits::ToUsize::to_usize":[],"traits::lowercase_byte":[]},"glob_path_import":{"bits":"","internal":"","str":"","traits":""},"self_to_fn":{"<F as internal::Parser<I>>::F":["impl<I, O, E: ParseError<I>, F> Parser<I> for F\nwhere\n  F: FnMut(I) -> IResult<I, O, E>,\n{\n  type Output = O;\n  type Error = E;\n  fn parse(&mut self, i: I) -> IResult<I, O, E> {\n    self(i)\n  }\n}"],"combinator::ParserIterator":["impl<I: Clone, E, F> ParserIterator<I, E, F> {\n  /// Returns the remaining input if parsing was successful, or the error if we encountered an error.\n  pub fn finish(mut self) -> IResult<I, (), E> {\n    match self.state.take().unwrap() {\n      State::Running | State::Done => Ok((self.input, ())),\n      State::Failure(e) => Err(Err::Failure(e)),\n      State::Incomplete(i) => Err(Err::Incomplete(i)),\n    }\n  }\n}"],"error::Error":["Clone","Debug","Eq","PartialEq","impl From<Error<&[u8]>> for Error<crate::lib::std::vec::Vec<u8>> {\n  fn from(value: Error<&[u8]>) -> Self {\n    Error {\n      input: value.input.to_owned(),\n      code: value.code,\n    }\n  }\n}","impl From<Error<&str>> for Error<crate::lib::std::string::String> {\n  fn from(value: Error<&str>) -> Self {\n    Error {\n      input: value.input.to_owned(),\n      code: value.code,\n    }\n  }\n}","impl<I, E> FromExternalError<I, E> for Error<I> {\n  /// Create a new error from an input position and an external error\n  fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self {\n    Error { input, code: kind }\n  }\n}","impl<I: fmt::Debug + fmt::Display> std::error::Error for Error<I> {}","impl<I: fmt::Display> fmt::Display for Error<I> {\n  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    write!(f, \"error {:?} at: {}\", self.code, self.input)\n  }\n}","impl<I> ContextError<I> for Error<I> {}","impl<I> Error<I> {\n  /// creates a new basic error\n  pub fn new(input: I, code: ErrorKind) -> Error<I> {\n    Error { input, code }\n  }\n}","impl<I> ErrorConvert<error::Error<(I, usize)>> for error::Error<I> {\n  fn convert(self) -> error::Error<(I, usize)> {\n    error::Error {\n      input: (self.input, 0),\n      code: self.code,\n    }\n  }\n}","impl<I> ErrorConvert<error::Error<I>> for error::Error<(I, usize)> {\n  fn convert(self) -> error::Error<I> {\n    error::Error {\n      input: self.input.0,\n      code: self.code,\n    }\n  }\n}","impl<I> ParseError<I> for Error<I> {\n  fn from_error_kind(input: I, kind: ErrorKind) -> Self {\n    Error { input, code: kind }\n  }\n\n  fn append(_: I, _: ErrorKind, other: Self) -> Self {\n    other\n  }\n}"],"error::ErrorKind":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl ErrorKind {\n  #[rustfmt::skip]\n  #[allow(deprecated)]\n  /// Converts an ErrorKind to a text description\n  pub fn description(&self) -> &str {\n    match *self {\n      ErrorKind::Tag                       => \"Tag\",\n      ErrorKind::MapRes                    => \"Map on Result\",\n      ErrorKind::MapOpt                    => \"Map on Option\",\n      ErrorKind::Alt                       => \"Alternative\",\n      ErrorKind::IsNot                     => \"IsNot\",\n      ErrorKind::IsA                       => \"IsA\",\n      ErrorKind::SeparatedList             => \"Separated list\",\n      ErrorKind::SeparatedNonEmptyList     => \"Separated non empty list\",\n      ErrorKind::Many0                     => \"Many0\",\n      ErrorKind::Many1                     => \"Many1\",\n      ErrorKind::Count                     => \"Count\",\n      ErrorKind::TakeUntil                 => \"Take until\",\n      ErrorKind::LengthValue               => \"Length followed by value\",\n      ErrorKind::TagClosure                => \"Tag closure\",\n      ErrorKind::Alpha                     => \"Alphabetic\",\n      ErrorKind::Digit                     => \"Digit\",\n      ErrorKind::AlphaNumeric              => \"AlphaNumeric\",\n      ErrorKind::Space                     => \"Space\",\n      ErrorKind::MultiSpace                => \"Multiple spaces\",\n      ErrorKind::LengthValueFn             => \"LengthValueFn\",\n      ErrorKind::Eof                       => \"End of file\",\n      ErrorKind::Switch                    => \"Switch\",\n      ErrorKind::TagBits                   => \"Tag on bitstream\",\n      ErrorKind::OneOf                     => \"OneOf\",\n      ErrorKind::NoneOf                    => \"NoneOf\",\n      ErrorKind::Char                      => \"Char\",\n      ErrorKind::CrLf                      => \"CrLf\",\n      ErrorKind::RegexpMatch               => \"RegexpMatch\",\n      ErrorKind::RegexpMatches             => \"RegexpMatches\",\n      ErrorKind::RegexpFind                => \"RegexpFind\",\n      ErrorKind::RegexpCapture             => \"RegexpCapture\",\n      ErrorKind::RegexpCaptures            => \"RegexpCaptures\",\n      ErrorKind::TakeWhile1                => \"TakeWhile1\",\n      ErrorKind::Complete                  => \"Complete\",\n      ErrorKind::Fix                       => \"Fix\",\n      ErrorKind::Escaped                   => \"Escaped\",\n      ErrorKind::EscapedTransform          => \"EscapedTransform\",\n      ErrorKind::NonEmpty                  => \"NonEmpty\",\n      ErrorKind::ManyMN                    => \"Many(m, n)\",\n      ErrorKind::HexDigit                  => \"Hexadecimal Digit\",\n      ErrorKind::OctDigit                  => \"Octal digit\",\n      ErrorKind::Not                       => \"Negation\",\n      ErrorKind::Permutation               => \"Permutation\",\n      ErrorKind::ManyTill                  => \"ManyTill\",\n      ErrorKind::Verify                    => \"predicate verification\",\n      ErrorKind::TakeTill1                 => \"TakeTill1\",\n      ErrorKind::TakeWhileMN               => \"TakeWhileMN\",\n      ErrorKind::TooLarge                  => \"Needed data size is too large\",\n      ErrorKind::Many0Count                => \"Count occurrence of >=0 patterns\",\n      ErrorKind::Many1Count                => \"Count occurrence of >=1 patterns\",\n      ErrorKind::Float                     => \"Float\",\n      ErrorKind::Satisfy                   => \"Satisfy\",\n      ErrorKind::Fail                      => \"Fail\",\n      ErrorKind::Many                      => \"Many\",\n      ErrorKind::Fold                      => \"Fold\",\n    }\n  }\n}"],"error::VerboseError":["Clone","Debug","Eq","PartialEq","impl From<VerboseError<&[u8]>> for VerboseError<crate::lib::std::vec::Vec<u8>> {\n  fn from(value: VerboseError<&[u8]>) -> Self {\n    VerboseError {\n      errors: value\n        .errors\n        .into_iter()\n        .map(|(i, e)| (i.to_owned(), e))\n        .collect(),\n    }\n  }\n}","impl From<VerboseError<&str>> for VerboseError<crate::lib::std::string::String> {\n  fn from(value: VerboseError<&str>) -> Self {\n    VerboseError {\n      errors: value\n        .errors\n        .into_iter()\n        .map(|(i, e)| (i.to_owned(), e))\n        .collect(),\n    }\n  }\n}","impl<I, E> FromExternalError<I, E> for VerboseError<I> {\n  /// Create a new error from an input position and an external error\n  fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self {\n    Self::from_error_kind(input, kind)\n  }\n}","impl<I: fmt::Debug + fmt::Display> std::error::Error for VerboseError<I> {}","impl<I: fmt::Display> fmt::Display for VerboseError<I> {\n  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    writeln!(f, \"Parse error:\")?;\n    for (input, error) in &self.errors {\n      match error {\n        VerboseErrorKind::Nom(e) => writeln!(f, \"{:?} at: {}\", e, input)?,\n        VerboseErrorKind::Char(c) => writeln!(f, \"expected '{}' at: {}\", c, input)?,\n        VerboseErrorKind::Context(s) => writeln!(f, \"in section '{}', at: {}\", s, input)?,\n      }\n    }\n\n    Ok(())\n  }\n}","impl<I> ContextError<I> for VerboseError<I> {\n  fn add_context(input: I, ctx: &'static str, mut other: Self) -> Self {\n    other.errors.push((input, VerboseErrorKind::Context(ctx)));\n    other\n  }\n}","impl<I> ErrorConvert<error::VerboseError<(I, usize)>> for error::VerboseError<I> {\n  fn convert(self) -> error::VerboseError<(I, usize)> {\n    error::VerboseError {\n      errors: self.errors.into_iter().map(|(i, e)| ((i, 0), e)).collect(),\n    }\n  }\n}","impl<I> ErrorConvert<error::VerboseError<I>> for error::VerboseError<(I, usize)> {\n  fn convert(self) -> error::VerboseError<I> {\n    error::VerboseError {\n      errors: self.errors.into_iter().map(|(i, e)| (i.0, e)).collect(),\n    }\n  }\n}","impl<I> ParseError<I> for VerboseError<I> {\n  fn from_error_kind(input: I, kind: ErrorKind) -> Self {\n    VerboseError {\n      errors: vec![(input, VerboseErrorKind::Nom(kind))],\n    }\n  }\n\n  fn append(input: I, kind: ErrorKind, mut other: Self) -> Self {\n    other.errors.push((input, VerboseErrorKind::Nom(kind)));\n    other\n  }\n\n  fn from_char(input: I, c: char) -> Self {\n    VerboseError {\n      errors: vec![(input, VerboseErrorKind::Char(c))],\n    }\n  }\n}"],"error::VerboseErrorKind":["Clone","Debug","Eq","PartialEq"],"internal::And":["impl<I, E: ParseError<I>, F: Parser<I, Error = E>, G: Parser<I, Error = E>> Parser<I>\n  for And<F, G>\n{\n  type Output = (<F as Parser<I>>::Output, <G as Parser<I>>::Output);\n  type Error = E;\n\n  fn parse(&mut self, i: I) -> IResult<I, Self::Output, Self::Error> {\n    let (i, o1) = self.f.parse(i)?;\n    let (i, o2) = self.g.parse(i)?;\n    Ok((i, (o1, o2)))\n  }\n}"],"internal::AndThen":["impl<I, F: Parser<I>, G: Parser<<F as Parser<I>>::Output, Error = <F as Parser<I>>::Error>>\n  Parser<I> for AndThen<F, G>\n{\n  type Output = <G as Parser<<F as Parser<I>>::Output>>::Output;\n  type Error = <F as Parser<I>>::Error;\n\n  fn parse(&mut self, i: I) -> IResult<I, Self::Output, Self::Error> {\n    let (i, o1) = self.f.parse(i)?;\n    let (_, o2) = self.g.parse(o1)?;\n    Ok((i, o2))\n  }\n}"],"internal::Err":["Clone","Debug","PartialEq","impl Err<(&[u8], ErrorKind)> {\n  /// Obtaining ownership\n  #[cfg_attr(feature = \"docsrs\", doc(cfg(feature = \"alloc\")))]\n  pub fn to_owned(self) -> Err<(Vec<u8>, ErrorKind)> {\n    self.map_input(ToOwned::to_owned)\n  }\n}","impl Err<(&str, ErrorKind)> {\n  /// Obtaining ownership\n  #[cfg_attr(feature = \"docsrs\", doc(cfg(feature = \"alloc\")))]\n  pub fn to_owned(self) -> Err<(String, ErrorKind)> {\n    self.map_input(ToOwned::to_owned)\n  }\n}","impl Err<error::Error<&[u8]>> {\n  /// Obtaining ownership\n  #[cfg_attr(feature = \"docsrs\", doc(cfg(feature = \"alloc\")))]\n  pub fn to_owned(self) -> Err<error::Error<Vec<u8>>> {\n    self.map_input(ToOwned::to_owned)\n  }\n}","impl Err<error::Error<&str>> {\n  /// Obtaining ownership\n  #[cfg_attr(feature = \"docsrs\", doc(cfg(feature = \"alloc\")))]\n  pub fn to_owned(self) -> Err<error::Error<String>> {\n    self.map_input(ToOwned::to_owned)\n  }\n}","impl<E: Eq> Eq for Err<E> {}","impl<E> Err<E> {\n  /// Tests if the result is Incomplete\n  pub fn is_incomplete(&self) -> bool {\n    matches!(self, Err::Incomplete(..))\n  }\n\n  /// Applies the given function to the inner error\n  pub fn map<E2, F>(self, f: F) -> Err<E2>\n  where\n    F: FnOnce(E) -> E2,\n  {\n    match self {\n      Err::Incomplete(n) => Err::Incomplete(n),\n      Err::Failure(t) => Err::Failure(f(t)),\n      Err::Error(t) => Err::Error(f(t)),\n    }\n  }\n\n  /// Automatically converts between errors if the underlying type supports it\n  pub fn convert<F>(e: Err<F>) -> Self\n  where\n    E: From<F>,\n  {\n    e.map(crate::lib::std::convert::Into::into)\n  }\n}","impl<E> Error for Err<E>\nwhere\n  E: fmt::Debug,\n{\n  fn source(&self) -> Option<&(dyn Error + 'static)> {\n    None // no underlying error\n  }\n}","impl<E> fmt::Display for Err<E>\nwhere\n  E: fmt::Debug,\n{\n  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    match self {\n      Err::Incomplete(Needed::Size(u)) => write!(f, \"Parsing requires {} bytes/chars\", u),\n      Err::Incomplete(Needed::Unknown) => write!(f, \"Parsing requires more data\"),\n      Err::Failure(c) => write!(f, \"Parsing Failure: {:?}\", c),\n      Err::Error(c) => write!(f, \"Parsing Error: {:?}\", c),\n    }\n  }\n}","impl<T> Err<(T, ErrorKind)> {\n  /// Maps `Err<(T, ErrorKind)>` to `Err<(U, ErrorKind)>` with the given `F: T -> U`\n  pub fn map_input<U, F>(self, f: F) -> Err<(U, ErrorKind)>\n  where\n    F: FnOnce(T) -> U,\n  {\n    match self {\n      Err::Incomplete(n) => Err::Incomplete(n),\n      Err::Failure((input, k)) => Err::Failure((f(input), k)),\n      Err::Error((input, k)) => Err::Error((f(input), k)),\n    }\n  }\n}","impl<T> Err<error::Error<T>> {\n  /// Maps `Err<error::Error<T>>` to `Err<error::Error<U>>` with the given `F: T -> U`\n  pub fn map_input<U, F>(self, f: F) -> Err<error::Error<U>>\n  where\n    F: FnOnce(T) -> U,\n  {\n    match self {\n      Err::Incomplete(n) => Err::Incomplete(n),\n      Err::Failure(error::Error { input, code }) => Err::Failure(error::Error {\n        input: f(input),\n        code,\n      }),\n      Err::Error(error::Error { input, code }) => Err::Error(error::Error {\n        input: f(input),\n        code,\n      }),\n    }\n  }\n}"],"internal::FlatMap":["impl<\n    I,\n    E: ParseError<I>,\n    F: Parser<I, Error = E>,\n    G: FnMut(<F as Parser<I>>::Output) -> H,\n    H: Parser<I, Error = E>,\n  > Parser<I> for FlatMap<F, G>\n{\n  type Output = <H as Parser<I>>::Output;\n  type Error = E;\n\n  fn parse(&mut self, i: I) -> IResult<I, Self::Output, E> {\n    let (i, o1) = self.f.parse(i)?;\n    (self.g)(o1).parse(i)\n  }\n}"],"internal::IResult":["impl<I, O, E> Finish<I, O, E> for IResult<I, O, E> {\n  fn finish(self) -> Result<(I, O), E> {\n    match self {\n      Ok(res) => Ok(res),\n      Err(Err::Error(e)) | Err(Err::Failure(e)) => Err(e),\n      Err(Err::Incomplete(_)) => {\n        panic!(\"Cannot call `finish()` on `Err(Err::Incomplete(_))`: this result means that the parser does not have enough data to decide, you should gather more data and try to reapply  the parser instead\")\n      }\n    }\n  }\n}"],"internal::Into":["impl<\n    I: Clone,\n    O2: From<<F as Parser<I>>::Output>,\n    E2: crate::error::ParseError<I> + From<<F as Parser<I>>::Error>,\n    F: Parser<I>,\n  > Parser<I> for Into<F, O2, E2>\n{\n  type Output = O2;\n  type Error = E2;\n\n  fn parse(&mut self, i: I) -> IResult<I, Self::Output, Self::Error> {\n    match self.f.parse(i) {\n      Ok((i, o)) => Ok((i, o.into())),\n      Err(Err::Error(e)) => Err(Err::Error(e.into())),\n      Err(Err::Failure(e)) => Err(Err::Failure(e.into())),\n      Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),\n    }\n  }\n}"],"internal::Map":["impl<I, O2, E: ParseError<I>, F: Parser<I, Error = E>, G: FnMut(<F as Parser<I>>::Output) -> O2>\n  Parser<I> for Map<F, G>\n{\n  type Output = O2;\n  type Error = E;\n\n  fn parse(&mut self, i: I) -> IResult<I, O2, E> {\n    match self.f.parse(i) {\n      Err(e) => Err(e),\n      Ok((i, o)) => Ok((i, (self.g)(o))),\n    }\n  }\n}"],"internal::MapOpt":["impl<I, O2, F, G> Parser<I> for MapOpt<F, G>\nwhere\n  I: Clone,\n  F: Parser<I>,\n  G: Fn(<F as Parser<I>>::Output) -> Option<O2>,\n{\n  type Output = O2;\n  type Error = <F as Parser<I>>::Error;\n\n  fn parse(&mut self, input: I) -> IResult<I, O2, <F as Parser<I>>::Error> {\n    let i = input.clone();\n    let (input, o1) = self.f.parse(input)?;\n    match (self.g)(o1) {\n      Some(o2) => Ok((input, o2)),\n      None => Err(Err::Error(<F as Parser<I>>::Error::from_error_kind(\n        i,\n        ErrorKind::MapOpt,\n      ))),\n    }\n  }\n}"],"internal::MapRes":["impl<I, O2, E2, F, G> Parser<I> for MapRes<F, G>\nwhere\n  I: Clone,\n  <F as Parser<I>>::Error: FromExternalError<I, E2>,\n  F: Parser<I>,\n  G: Fn(<F as Parser<I>>::Output) -> Result<O2, E2>,\n{\n  type Output = O2;\n  type Error = <F as Parser<I>>::Error;\n  fn parse(&mut self, input: I) -> IResult<I, O2, <F as Parser<I>>::Error> {\n    let i = input.clone();\n    let (input, o1) = self.f.parse(input)?;\n    match (self.g)(o1) {\n      Ok(o2) => Ok((input, o2)),\n      Err(e) => Err(Err::Error(<F as Parser<I>>::Error::from_external_error(\n        i,\n        ErrorKind::MapRes,\n        e,\n      ))),\n    }\n  }\n}"],"internal::Needed":["Clone","Copy","Debug","Eq","PartialEq","impl Needed {\n  /// Creates `Needed` instance, returns `Needed::Unknown` if the argument is zero\n  pub fn new(s: usize) -> Self {\n    match NonZeroUsize::new(s) {\n      Some(sz) => Needed::Size(sz),\n      None => Needed::Unknown,\n    }\n  }\n\n  /// Indicates if we know how many bytes we need\n  pub fn is_known(&self) -> bool {\n    *self != Unknown\n  }\n\n  /// Maps a `Needed` to `Needed` by applying a function to a contained `Size` value.\n  #[inline]\n  pub fn map<F: Fn(NonZeroUsize) -> usize>(self, f: F) -> Needed {\n    match self {\n      Unknown => Unknown,\n      Size(n) => Needed::new(f(n)),\n    }\n  }\n}"],"internal::Or":["impl<\n    I: Clone,\n    O,\n    E: ParseError<I>,\n    F: Parser<I, Output = O, Error = E>,\n    G: Parser<I, Output = O, Error = E>,\n  > Parser<I> for Or<F, G>\n{\n  type Output = <F as Parser<I>>::Output;\n  type Error = <F as Parser<I>>::Error;\n\n  fn parse(&mut self, i: I) -> IResult<I, Self::Output, Self::Error> {\n    match self.f.parse(i.clone()) {\n      Err(Err::Error(e1)) => match self.g.parse(i) {\n        Err(Err::Error(e2)) => Err(Err::Error(e1.or(e2))),\n        res => res,\n      },\n      res => res,\n    }\n  }\n}"],"number::Endianness":["Clone","Copy","Debug","Eq","PartialEq"],"std::boxed::Box":["impl<I, O, E: ParseError<I>> Parser<I> for Box<dyn Parser<I, Output = O, Error = E>> {\n  type Output = O;\n  type Error = E;\n  fn parse(&mut self, input: I) -> IResult<I, O, E> {\n    (**self).parse(input)\n  }\n}"],"std::ops::Range":["impl NomRange<usize> for Range<usize> {\n  type Saturating = Range<usize>;\n  type Bounded = Range<usize>;\n\n  fn bounds(&self) -> (Bound<usize>, Bound<usize>) {\n    (Bound::Included(self.start), Bound::Excluded(self.end))\n  }\n\n  fn contains(&self, item: &usize) -> bool {\n    RangeBounds::contains(self, item)\n  }\n\n  fn is_inverted(&self) -> bool {\n    !(self.start < self.end)\n  }\n\n  fn saturating_iter(&self) -> Self::Saturating {\n    if self.end == 0 {\n      1..0\n    } else {\n      0..self.end - 1\n    }\n  }\n\n  fn bounded_iter(&self) -> Self::Bounded {\n    if self.end == 0 {\n      1..0\n    } else {\n      0..self.end - 1\n    }\n  }\n}"],"std::ops::RangeFrom":["impl NomRange<usize> for RangeFrom<usize> {\n  type Saturating = SaturatingIterator;\n  type Bounded = Range<usize>;\n\n  fn bounds(&self) -> (Bound<usize>, Bound<usize>) {\n    (Bound::Included(self.start), Bound::Unbounded)\n  }\n\n  fn contains(&self, item: &usize) -> bool {\n    RangeBounds::contains(self, item)\n  }\n\n  fn is_inverted(&self) -> bool {\n    false\n  }\n\n  fn saturating_iter(&self) -> Self::Saturating {\n    SaturatingIterator { count: 0 }\n  }\n\n  fn bounded_iter(&self) -> Self::Bounded {\n    0..core::usize::MAX\n  }\n}"],"std::ops::RangeFull":["impl NomRange<usize> for RangeFull {\n  type Saturating = SaturatingIterator;\n  type Bounded = Range<usize>;\n\n  fn bounds(&self) -> (Bound<usize>, Bound<usize>) {\n    (Bound::Unbounded, Bound::Unbounded)\n  }\n\n  fn contains(&self, item: &usize) -> bool {\n    RangeBounds::contains(self, item)\n  }\n\n  fn is_inverted(&self) -> bool {\n    false\n  }\n\n  fn saturating_iter(&self) -> Self::Saturating {\n    SaturatingIterator { count: 0 }\n  }\n\n  fn bounded_iter(&self) -> Self::Bounded {\n    0..core::usize::MAX\n  }\n}"],"std::ops::RangeInclusive":["impl NomRange<usize> for RangeInclusive<usize> {\n  type Saturating = Range<usize>;\n  type Bounded = Range<usize>;\n\n  fn bounds(&self) -> (Bound<usize>, Bound<usize>) {\n    (Bound::Included(*self.start()), Bound::Included(*self.end()))\n  }\n\n  fn contains(&self, item: &usize) -> bool {\n    RangeBounds::contains(self, item)\n  }\n\n  fn is_inverted(&self) -> bool {\n    !RangeInclusive::contains(self, self.start())\n  }\n\n  fn saturating_iter(&self) -> Self::Saturating {\n    0..*self.end()\n  }\n\n  fn bounded_iter(&self) -> Self::Bounded {\n    0..*self.end()\n  }\n}"],"std::ops::RangeTo":["impl NomRange<usize> for RangeTo<usize> {\n  type Saturating = Range<usize>;\n  type Bounded = Range<usize>;\n\n  fn bounds(&self) -> (Bound<usize>, Bound<usize>) {\n    (Bound::Unbounded, Bound::Excluded(self.end))\n  }\n\n  fn contains(&self, item: &usize) -> bool {\n    RangeBounds::contains(self, item)\n  }\n\n  fn is_inverted(&self) -> bool {\n    false\n  }\n\n  fn saturating_iter(&self) -> Self::Saturating {\n    if self.end == 0 {\n      1..0\n    } else {\n      0..self.end - 1\n    }\n  }\n\n  fn bounded_iter(&self) -> Self::Bounded {\n    if self.end == 0 {\n      1..0\n    } else {\n      0..self.end - 1\n    }\n  }\n}"],"std::ops::RangeToInclusive":["impl NomRange<usize> for RangeToInclusive<usize> {\n  type Saturating = Range<usize>;\n  type Bounded = Range<usize>;\n\n  fn bounds(&self) -> (Bound<usize>, Bound<usize>) {\n    (Bound::Unbounded, Bound::Included(self.end))\n  }\n\n  fn contains(&self, item: &usize) -> bool {\n    RangeBounds::contains(self, item)\n  }\n\n  fn is_inverted(&self) -> bool {\n    false\n  }\n\n  fn saturating_iter(&self) -> Self::Saturating {\n    0..self.end\n  }\n\n  fn bounded_iter(&self) -> Self::Bounded {\n    0..self.end\n  }\n}"],"traits::CompareResult":["Debug","Eq","PartialEq"],"traits::SaturatingIterator":["impl Iterator for SaturatingIterator {\n  type Item = usize;\n\n  fn next(&mut self) -> Option<Self::Item> {\n    let old_count = self.count;\n    self.count = self.count.saturating_add(1);\n    Some(old_count)\n  }\n}"]},"single_path_import":{"std::alloc":"lib::std::alloc","std::borrow":"lib::std::borrow","std::boxed":"lib::std::boxed","std::cmp":"lib::std::cmp","std::collections":"lib::std::collections","std::convert":"lib::std::convert","std::fmt":"lib::std::fmt","std::hash":"lib::std::hash","std::iter":"lib::std::iter","std::mem":"lib::std::mem","std::num":"lib::std::num","std::ops":"lib::std::ops","std::option":"lib::std::option","std::prelude":"lib::std::prelude::prelude","std::result":"lib::std::result","std::slice":"lib::std::slice","std::str":"lib::std::str","std::string":"lib::std::string","std::vec":"lib::std::vec"},"srcs":{"<&'a [T] as traits::InputLength>::input_len":["#[inline]\nfn input_len(&self) -> usize{\n    self.len()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [char] as traits::FindToken<char>>::find_token":["fn find_token(&self, token: char) -> bool{\n    self.iter().any(|i| *i == token)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8; N] as traits::AsBytes>::as_bytes":["#[inline(always)]\nfn as_bytes(&self) -> &[u8]{\n    *self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8; N] as traits::InputLength>::input_len":["#[inline]\nfn input_len(&self) -> usize{\n    self.len()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::AsBytes>::as_bytes":["#[inline(always)]\nfn as_bytes(&self) -> &[u8]{\n    self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare":["#[inline(always)]\nfn compare(&self, t: &'b [u8; N]) -> CompareResult{\n    self.compare(&t[..])\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare_no_case":["#[inline(always)]\nfn compare_no_case(&self, t: &'b [u8; N]) -> CompareResult{\n    self.compare_no_case(&t[..])\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Compare<&'b [u8]>>::compare":["#[inline(always)]\nfn compare(&self, t: &'b [u8]) -> CompareResult{\n    let pos = self.iter().zip(t.iter()).position(|(a, b)| a != b);\n\n    match pos {\n      Some(_) => CompareResult::Error,\n      None => {\n        if self.len() >= t.len() {\n          CompareResult::Ok\n        } else {\n          CompareResult::Incomplete\n        }\n      }\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case":["#[inline(always)]\nfn compare_no_case(&self, t: &'b [u8]) -> CompareResult{\n    if self\n      .iter()\n      .zip(t)\n      .any(|(a, b)| lowercase_byte(*a) != lowercase_byte(*b))\n    {\n      CompareResult::Error\n    } else if self.len() < t.len() {\n      CompareResult::Incomplete\n    } else {\n      CompareResult::Ok\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Compare<&'b str>>::compare":["#[inline(always)]\nfn compare(&self, t: &'b str) -> CompareResult{\n    self.compare(AsBytes::as_bytes(t))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Compare<&'b str>>::compare_no_case":["#[inline(always)]\nfn compare_no_case(&self, t: &'b str) -> CompareResult{\n    self.compare_no_case(AsBytes::as_bytes(t))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Compare<[u8; N]>>::compare":["#[inline(always)]\nfn compare(&self, t: [u8; N]) -> CompareResult{\n    self.compare(&t[..])\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Compare<[u8; N]>>::compare_no_case":["#[inline(always)]\nfn compare_no_case(&self, t: [u8; N]) -> CompareResult{\n    self.compare_no_case(&t[..])\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring":["fn find_substring(&self, substr: &'b [u8]) -> Option<usize>{\n    if substr.len() > self.len() {\n      return None;\n    }\n\n    let (&substr_first, substr_rest) = match substr.split_first() {\n      Some(split) => split,\n      // an empty substring is found at position 0\n      // This matches the behavior of str.find(\"\").\n      None => return Some(0),\n    };\n\n    if substr_rest.is_empty() {\n      return memchr::memchr(substr_first, self);\n    }\n\n    let mut offset = 0;\n    let haystack = &self[..self.len() - substr_rest.len()];\n\n    while let Some(position) = memchr::memchr(substr_first, &haystack[offset..]) {\n      offset += position;\n      let next_offset = offset + 1;\n      if &self[next_offset..][..substr_rest.len()] == substr_rest {\n        return Some(offset);\n      }\n\n      offset = next_offset;\n    }\n\n    None\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::FindSubstring<&'b str>>::find_substring":["fn find_substring(&self, substr: &'b str) -> Option<usize>{\n    self.find_substring(AsBytes::as_bytes(substr))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::FindToken<char>>::find_token":["fn find_token(&self, token: char) -> bool{\n    self.iter().any(|i| *i == token as u8)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::FindToken<u8>>::find_token":["fn find_token(&self, token: u8) -> bool{\n    memchr::memchr(token, self).is_some()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::input_len":["fn input_len(&self) -> usize{\n    self.len()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::iter_elements":["#[inline]\nfn iter_elements(&self) -> Self::Iter{\n    self.iter().copied()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::iter_indices":["#[inline]\nfn iter_indices(&self) -> Self::IterIndices{\n    self.iter_elements().enumerate()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::position":["#[inline]\nfn position<P>(&self, predicate: P) -> Option<usize>\n  where\n    P: Fn(Self::Item) -> bool,{\n    self.iter().position(|b| predicate(*b))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::slice_index":["#[inline]\nfn slice_index(&self, count: usize) -> Result<usize, Needed>{\n    if self.len() >= count {\n      Ok(count)\n    } else {\n      Err(Needed::new(count - self.len()))\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::split_at_position":["fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.iter().position(|c| predicate(*c)) {\n      Some(i) => Ok(self.take_split(i)),\n      None => Err(Err::Incomplete(Needed::new(1))),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::split_at_position1":["fn split_at_position1<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n    e: ErrorKind,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.iter().position(|c| predicate(*c)) {\n      Some(0) => Err(Err::Error(E::from_error_kind(self, e))),\n      Some(i) => Ok(self.take_split(i)),\n      None => Err(Err::Incomplete(Needed::new(1))),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::split_at_position1_complete":["fn split_at_position1_complete<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n    e: ErrorKind,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.iter().position(|c| predicate(*c)) {\n      Some(0) => Err(Err::Error(E::from_error_kind(self, e))),\n      Some(i) => Ok(self.take_split(i)),\n      None => {\n        if self.is_empty() {\n          Err(Err::Error(E::from_error_kind(self, e)))\n        } else {\n          Ok(self.take_split(self.len()))\n        }\n      }\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::split_at_position_complete":["fn split_at_position_complete<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.iter().position(|c| predicate(*c)) {\n      Some(i) => Ok(self.take_split(i)),\n      None => Ok(self.take_split(self.len())),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::take":["#[inline]\nfn take(&self, index: usize) -> Self{\n    &self[0..index]\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::take_from":["fn take_from(&self, index: usize) -> Self{\n    &self[index..]\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Input>::take_split":["#[inline]\nfn take_split(&self, index: usize) -> (Self, Self){\n    let (prefix, suffix) = self.split_at(index);\n    (suffix, prefix)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::Offset>::offset":["fn offset(&self, second: &Self) -> usize{\n    let fst = self.as_ptr();\n    let snd = second.as_ptr();\n\n    snd as usize - fst as usize\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a [u8] as traits::ParseTo<R>>::parse_to":["fn parse_to(&self) -> Option<R>{\n    from_utf8(self).ok().and_then(|s| s.parse().ok())\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a char as traits::AsChar>::as_char":["#[inline]\nfn as_char(self) -> char{\n    *self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a char as traits::AsChar>::is_alpha":["#[inline]\nfn is_alpha(self) -> bool{\n    self.is_ascii_alphabetic()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a char as traits::AsChar>::is_alphanum":["#[inline]\nfn is_alphanum(self) -> bool{\n    self.is_alpha() || self.is_dec_digit()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a char as traits::AsChar>::is_dec_digit":["#[inline]\nfn is_dec_digit(self) -> bool{\n    self.is_ascii_digit()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a char as traits::AsChar>::is_hex_digit":["#[inline]\nfn is_hex_digit(self) -> bool{\n    self.is_ascii_hexdigit()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a char as traits::AsChar>::is_oct_digit":["#[inline]\nfn is_oct_digit(self) -> bool{\n    self.is_digit(8)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a char as traits::AsChar>::len":["#[inline]\nfn len(self) -> usize{\n    self.len_utf8()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n    if let State::Running = self.state.take().unwrap() {\n      let input = self.input.clone();\n\n      match (self.iterator)(input) {\n        Ok((i, o)) => {\n          self.input = i;\n          self.state = Some(State::Running);\n          Some(o)\n        }\n        Err(Err::Error(_)) => {\n          self.state = Some(State::Done);\n          None\n        }\n        Err(Err::Failure(e)) => {\n          self.state = Some(State::Failure(e));\n          None\n        }\n        Err(Err::Incomplete(i)) => {\n          self.state = Some(State::Incomplete(i));\n          None\n        }\n      }\n    } else {\n      None\n    }\n  }","Real(LocalPath(\"src/combinator/mod.rs\"))"],"<&'a str as traits::AsBytes>::as_bytes":["#[inline(always)]\nfn as_bytes(&self) -> &[u8]{\n    (*self).as_bytes()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Compare<&'b [u8]>>::compare":["#[inline(always)]\nfn compare(&self, t: &'b [u8]) -> CompareResult{\n    AsBytes::as_bytes(self).compare(t)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Compare<&'b [u8]>>::compare_no_case":["#[inline(always)]\nfn compare_no_case(&self, t: &'b [u8]) -> CompareResult{\n    AsBytes::as_bytes(self).compare_no_case(t)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Compare<&'b str>>::compare":["#[inline(always)]\nfn compare(&self, t: &'b str) -> CompareResult{\n    self.as_bytes().compare(t.as_bytes())\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Compare<&'b str>>::compare_no_case":["#[inline(always)]\nfn compare_no_case(&self, t: &'b str) -> CompareResult{\n    let pos = self\n      .chars()\n      .zip(t.chars())\n      .position(|(a, b)| a.to_lowercase().ne(b.to_lowercase()));\n\n    match pos {\n      Some(_) => CompareResult::Error,\n      None => {\n        if self.len() >= t.len() {\n          CompareResult::Ok\n        } else {\n          CompareResult::Incomplete\n        }\n      }\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::FindSubstring<&'b str>>::find_substring":["fn find_substring(&self, substr: &'b str) -> Option<usize>{\n    self.find(substr)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::FindToken<char>>::find_token":["fn find_token(&self, token: char) -> bool{\n    self.chars().any(|i| i == token)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::FindToken<u8>>::find_token":["fn find_token(&self, token: u8) -> bool{\n    self.as_bytes().find_token(token)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::input_len":["fn input_len(&self) -> usize{\n    self.len()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::iter_elements":["#[inline]\nfn iter_elements(&self) -> Self::Iter{\n    self.chars()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::iter_indices":["#[inline]\nfn iter_indices(&self) -> Self::IterIndices{\n    self.char_indices()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::position":["fn position<P>(&self, predicate: P) -> Option<usize>\n  where\n    P: Fn(Self::Item) -> bool,{\n    self.find(predicate)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::slice_index":["#[inline]\nfn slice_index(&self, count: usize) -> Result<usize, Needed>{\n    let mut cnt = 0;\n    for (index, _) in self.char_indices() {\n      if cnt == count {\n        return Ok(index);\n      }\n      cnt += 1;\n    }\n    if cnt == count {\n      return Ok(self.len());\n    }\n    Err(Needed::Unknown)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::split_at_position":["fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.find(predicate) {\n      // find() returns a byte index that is already in the slice at a char boundary\n      Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },\n      None => Err(Err::Incomplete(Needed::new(1))),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::split_at_position1":["fn split_at_position1<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n    e: ErrorKind,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.find(predicate) {\n      Some(0) => Err(Err::Error(E::from_error_kind(self, e))),\n      // find() returns a byte index that is already in the slice at a char boundary\n      Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },\n      None => Err(Err::Incomplete(Needed::new(1))),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::split_at_position1_complete":["fn split_at_position1_complete<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n    e: ErrorKind,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.find(predicate) {\n      Some(0) => Err(Err::Error(E::from_error_kind(self, e))),\n      // find() returns a byte index that is already in the slice at a char boundary\n      Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },\n      None => {\n        if self.is_empty() {\n          Err(Err::Error(E::from_error_kind(self, e)))\n        } else {\n          // the end of slice is a char boundary\n          unsafe {\n            Ok((\n              self.get_unchecked(self.len()..),\n              self.get_unchecked(..self.len()),\n            ))\n          }\n        }\n      }\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::split_at_position_complete":["fn split_at_position_complete<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.find(predicate) {\n      // find() returns a byte index that is already in the slice at a char boundary\n      Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },\n      // the end of slice is a char boundary\n      None => unsafe {\n        Ok((\n          self.get_unchecked(self.len()..),\n          self.get_unchecked(..self.len()),\n        ))\n      },\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::take":["#[inline]\nfn take(&self, index: usize) -> Self{\n    &self[..index]\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::take_from":["#[inline]\nfn take_from(&self, index: usize) -> Self{\n    &self[index..]\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Input>::take_split":["#[inline]\nfn take_split(&self, index: usize) -> (Self, Self){\n    let (prefix, suffix) = self.split_at(index);\n    (suffix, prefix)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::InputLength>::input_len":["#[inline]\nfn input_len(&self) -> usize{\n    self.len()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::Offset>::offset":["fn offset(&self, second: &Self) -> usize{\n    let fst = self.as_ptr();\n    let snd = second.as_ptr();\n\n    snd as usize - fst as usize\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a str as traits::ParseTo<R>>::parse_to":["fn parse_to(&self) -> Option<R>{\n    self.parse().ok()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a u8 as traits::AsChar>::as_char":["#[inline]\nfn as_char(self) -> char{\n    *self as char\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a u8 as traits::AsChar>::is_alpha":["#[inline]\nfn is_alpha(self) -> bool{\n    matches!(*self, 0x41..=0x5A | 0x61..=0x7A)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a u8 as traits::AsChar>::is_alphanum":["#[inline]\nfn is_alphanum(self) -> bool{\n    self.is_alpha() || self.is_dec_digit()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a u8 as traits::AsChar>::is_dec_digit":["#[inline]\nfn is_dec_digit(self) -> bool{\n    matches!(*self, 0x30..=0x39)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a u8 as traits::AsChar>::is_hex_digit":["#[inline]\nfn is_hex_digit(self) -> bool{\n    matches!(*self, 0x30..=0x39 | 0x41..=0x46 | 0x61..=0x66)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a u8 as traits::AsChar>::is_oct_digit":["#[inline]\nfn is_oct_digit(self) -> bool{\n    matches!(*self, 0x30..=0x37)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'a u8 as traits::AsChar>::len":["#[inline]\nfn len(self) -> usize{\n    1\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'b [char] as traits::FindToken<&'a char>>::find_token":["fn find_token(&self, token: &char) -> bool{\n    self.find_token(*token)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'b [u8] as traits::FindToken<&'a u8>>::find_token":["fn find_token(&self, token: &u8) -> bool{\n    self.find_token(*token)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&'b str as traits::FindToken<&'a u8>>::find_token":["fn find_token(&self, token: &u8) -> bool{\n    self.as_bytes().find_token(token)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&[u8] as traits::ExtendInto>::extend_into":["#[inline]\nfn extend_into(&self, acc: &mut Vec<u8>){\n    acc.extend_from_slice(self);\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&[u8] as traits::ExtendInto>::new_builder":["#[inline]\nfn new_builder(&self) -> Vec<u8>{\n    Vec::new()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&str as traits::ExtendInto>::extend_into":["#[inline]\nfn extend_into(&self, acc: &mut String){\n    acc.push_str(self);\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<&str as traits::ExtendInto>::new_builder":["#[inline]\nfn new_builder(&self) -> String{\n    String::new()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<(&'a [u8], usize) as traits::InputLength>::input_len":["#[inline]\nfn input_len(&self) -> usize{\n    //println!(\"bit input length for ({:?}, {}):\", self.0, self.1);\n    //println!(\"-> {}\", self.0.len() * 8 - self.1);\n    self.0.len() * 8 - self.1\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert":["fn convert(self) -> (I, ErrorKind){\n    ((self.0).0, self.1)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<() as error::FromExternalError<I, E>>::from_external_error":["fn from_external_error(_input: I, _kind: ErrorKind, _e: E) -> Self{}","Real(LocalPath(\"src/error.rs\"))"],"<() as error::ParseError<I>>::append":["fn append(_: I, _: ErrorKind, _: Self) -> Self{}","Real(LocalPath(\"src/error.rs\"))"],"<() as error::ParseError<I>>::from_error_kind":["fn from_error_kind(_: I, _: ErrorKind) -> Self{}","Real(LocalPath(\"src/error.rs\"))"],"<() as sequence::Tuple<I, (), E>>::parse":["fn parse(&mut self, input: I) -> IResult<I, (), E>{\n    Ok((input, ()))\n  }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<() as traits::ErrorConvert<()>>::convert":["fn convert(self){}","Real(LocalPath(\"src/traits.rs\"))"],"<(A, B) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n        match self.0.parse(input.clone()) {\n          Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),\n          res => res,\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(A,) as branch::Alt<Input, Output, Error>>::choice":["fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>{\n    self.0.parse(input)\n  }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, (Output,), Error>{\n    self.0.parse(input).map(|(i, o)| (i, (o,)))\n  }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation":["fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        let mut res = ($(Option::<$ty>::None),+);\n\n        loop {\n          let mut err: Option<Error> = None;\n          permutation_trait_inner!(0, self, input, res, err, $($name)+);\n\n          // If we reach here, every iterator has either been applied before,\n          // or errored on the remaining input\n          if let Some(err) = err {\n            // There are remaining parsers, and all errored on the remaining input\n            return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));\n          }\n\n          // All parsers were applied\n          match res {\n            ($(Some($item)),+) => return Ok((input, ($($item),+))),\n            _ => unreachable!(),\n          }\n        }\n      }","Real(LocalPath(\"src/branch/mod.rs\"))"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse":["fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>{\n        tuple_trait_inner!(0, self, input, (), $($name)+)\n\n      }","Real(LocalPath(\"src/sequence/mod.rs\"))"],"<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error":["fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self{\n    (input, kind)\n  }","Real(LocalPath(\"src/error.rs\"))"],"<(I, error::ErrorKind) as error::ParseError<I>>::append":["fn append(_: I, _: ErrorKind, other: Self) -> Self{\n    other\n  }","Real(LocalPath(\"src/error.rs\"))"],"<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind":["fn from_error_kind(input: I, kind: ErrorKind) -> Self{\n    (input, kind)\n  }","Real(LocalPath(\"src/error.rs\"))"],"<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert":["fn convert(self) -> ((I, usize), ErrorKind){\n    ((self.0, 0), self.1)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<(P1, P2) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<(P1,) as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, ($($output),+,), E>{\n        let ($(ref mut $parser),+,) = *self;\n\n        $(let(i, $output) = $parser.parse(i)?;)+\n\n        Ok((i, ($($output),+,)))\n      }","Real(LocalPath(\"src/internal.rs\"))"],"<F as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, O, E>{\n    self(i)\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<[u8; N] as traits::AsBytes>::as_bytes":["#[inline(always)]\nfn as_bytes(&self) -> &[u8]{\n    self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8; N] as traits::FindToken<&'a u8>>::find_token":["fn find_token(&self, token: &u8) -> bool{\n    self.find_token(*token)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8; N] as traits::FindToken<u8>>::find_token":["fn find_token(&self, token: u8) -> bool{\n    memchr::memchr(token, &self[..]).is_some()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8; N] as traits::InputLength>::input_len":["#[inline]\nfn input_len(&self) -> usize{\n    self.len()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8] as traits::AsBytes>::as_bytes":["#[inline(always)]\nfn as_bytes(&self) -> &[u8]{\n    self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8] as traits::ExtendInto>::extend_into":["#[inline]\nfn extend_into(&self, acc: &mut Vec<u8>){\n    acc.extend(self.iter().cloned());\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8] as traits::ExtendInto>::new_builder":["#[inline]\nfn new_builder(&self) -> Vec<u8>{\n    Vec::new()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8] as traits::HexDisplay>::to_hex":["#[allow(unused_variables)]\nfn to_hex(&self, chunk_size: usize) -> String{\n    self.to_hex_from(chunk_size, 0)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8] as traits::HexDisplay>::to_hex_from":["#[allow(unused_variables)]\nfn to_hex_from(&self, chunk_size: usize, from: usize) -> String{\n    let mut v = Vec::with_capacity(self.len() * 3);\n    let mut i = from;\n    for chunk in self.chunks(chunk_size) {\n      let s = format!(\"{:08x}\", i);\n      for &ch in s.as_bytes().iter() {\n        v.push(ch);\n      }\n      v.push(b'\\t');\n\n      i += chunk_size;\n\n      for &byte in chunk {\n        v.push(CHARS[(byte >> 4) as usize]);\n        v.push(CHARS[(byte & 0xf) as usize]);\n        v.push(b' ');\n      }\n      if chunk_size > chunk.len() {\n        for j in 0..(chunk_size - chunk.len()) {\n          v.push(b' ');\n          v.push(b' ');\n          v.push(b' ');\n        }\n      }\n      v.push(b'\\t');\n\n      for &byte in chunk {\n        if matches!(byte, 32..=126 | 128..=255) {\n          v.push(byte);\n        } else {\n          v.push(b'.');\n        }\n      }\n      v.push(b'\\n');\n    }\n\n    String::from_utf8_lossy(&v[..]).into_owned()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<[u8] as traits::Offset>::offset":["fn offset(&self, second: &Self) -> usize{\n    let fst = self.as_ptr();\n    let snd = second.as_ptr();\n\n    snd as usize - fst as usize\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::AsChar>::as_char":["#[inline]\nfn as_char(self) -> char{\n    self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::AsChar>::is_alpha":["#[inline]\nfn is_alpha(self) -> bool{\n    self.is_ascii_alphabetic()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::AsChar>::is_alphanum":["#[inline]\nfn is_alphanum(self) -> bool{\n    self.is_alpha() || self.is_dec_digit()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::AsChar>::is_dec_digit":["#[inline]\nfn is_dec_digit(self) -> bool{\n    self.is_ascii_digit()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::AsChar>::is_hex_digit":["#[inline]\nfn is_hex_digit(self) -> bool{\n    self.is_ascii_hexdigit()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::AsChar>::is_oct_digit":["#[inline]\nfn is_oct_digit(self) -> bool{\n    self.is_digit(8)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::AsChar>::len":["#[inline]\nfn len(self) -> usize{\n    self.len_utf8()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::ExtendInto>::extend_into":["#[inline]\nfn extend_into(&self, acc: &mut String){\n    acc.push(*self);\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::ExtendInto>::new_builder":["#[inline]\nfn new_builder(&self) -> String{\n    String::new()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert":["fn convert(self) -> error::Error<I>{\n    error::Error {\n      input: self.input.0,\n      code: self.code,\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<error::Error<I> as error::FromExternalError<I, E>>::from_external_error":["/// Create a new error from an input position and an external error\nfn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self{\n    Error { input, code: kind }\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error<I> as error::ParseError<I>>::append":["fn append(_: I, _: ErrorKind, other: Self) -> Self{\n    other\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error<I> as error::ParseError<I>>::from_error_kind":["fn from_error_kind(input: I, kind: ErrorKind) -> Self{\n    Error { input, code: kind }\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error<I> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n    write!(f, \"error {:?} at: {}\", self.code, self.input)\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert":["fn convert(self) -> error::Error<(I, usize)>{\n    error::Error {\n      input: (self.input, 0),\n      code: self.code,\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<error::Error<std::string::String> as std::convert::From<error::Error<&str>>>::from":["fn from(value: Error<&str>) -> Self{\n    Error {\n      input: value.input.to_owned(),\n      code: value.code,\n    }\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error<std::vec::Vec<u8>> as std::convert::From<error::Error<&[u8]>>>::from":["fn from(value: Error<&[u8]>) -> Self{\n    Error {\n      input: value.input.to_owned(),\n      code: value.code,\n    }\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert":["fn convert(self) -> error::VerboseError<I>{\n    error::VerboseError {\n      errors: self.errors.into_iter().map(|(i, e)| (i.0, e)).collect(),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<error::VerboseError<I> as error::ContextError<I>>::add_context":["fn add_context(input: I, ctx: &'static str, mut other: Self) -> Self{\n    other.errors.push((input, VerboseErrorKind::Context(ctx)));\n    other\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error":["/// Create a new error from an input position and an external error\nfn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self{\n    Self::from_error_kind(input, kind)\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::VerboseError<I> as error::ParseError<I>>::append":["fn append(input: I, kind: ErrorKind, mut other: Self) -> Self{\n    other.errors.push((input, VerboseErrorKind::Nom(kind)));\n    other\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::VerboseError<I> as error::ParseError<I>>::from_char":["fn from_char(input: I, c: char) -> Self{\n    VerboseError {\n      errors: vec![(input, VerboseErrorKind::Char(c))],\n    }\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::VerboseError<I> as error::ParseError<I>>::from_error_kind":["fn from_error_kind(input: I, kind: ErrorKind) -> Self{\n    VerboseError {\n      errors: vec![(input, VerboseErrorKind::Nom(kind))],\n    }\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::VerboseError<I> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n    writeln!(f, \"Parse error:\")?;\n    for (input, error) in &self.errors {\n      match error {\n        VerboseErrorKind::Nom(e) => writeln!(f, \"{:?} at: {}\", e, input)?,\n        VerboseErrorKind::Char(c) => writeln!(f, \"expected '{}' at: {}\", c, input)?,\n        VerboseErrorKind::Context(s) => writeln!(f, \"in section '{}', at: {}\", s, input)?,\n      }\n    }\n\n    Ok(())\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert":["fn convert(self) -> error::VerboseError<(I, usize)>{\n    error::VerboseError {\n      errors: self.errors.into_iter().map(|(i, e)| ((i, 0), e)).collect(),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<error::VerboseError<std::string::String> as std::convert::From<error::VerboseError<&str>>>::from":["fn from(value: VerboseError<&str>) -> Self{\n    VerboseError {\n      errors: value\n        .errors\n        .into_iter()\n        .map(|(i, e)| (i.to_owned(), e))\n        .collect(),\n    }\n  }","Real(LocalPath(\"src/error.rs\"))"],"<error::VerboseError<std::vec::Vec<u8>> as std::convert::From<error::VerboseError<&[u8]>>>::from":["fn from(value: VerboseError<&[u8]>) -> Self{\n    VerboseError {\n      errors: value\n        .errors\n        .into_iter()\n        .map(|(i, e)| (i.to_owned(), e))\n        .collect(),\n    }\n  }","Real(LocalPath(\"src/error.rs\"))"],"<internal::And<F, G> as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, Self::Output, Self::Error>{\n    let (i, o1) = self.f.parse(i)?;\n    let (i, o2) = self.g.parse(i)?;\n    Ok((i, (o1, o2)))\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::AndThen<F, G> as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, Self::Output, Self::Error>{\n    let (i, o1) = self.f.parse(i)?;\n    let (_, o2) = self.g.parse(o1)?;\n    Ok((i, o2))\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::Err<E> as std::error::Error>::source":["fn source(&self) -> Option<&(dyn Error + 'static)>{\n    None // no underlying error\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::Err<E> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n    match self {\n      Err::Incomplete(Needed::Size(u)) => write!(f, \"Parsing requires {} bytes/chars\", u),\n      Err::Incomplete(Needed::Unknown) => write!(f, \"Parsing requires more data\"),\n      Err::Failure(c) => write!(f, \"Parsing Failure: {:?}\", c),\n      Err::Error(c) => write!(f, \"Parsing Error: {:?}\", c),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::FlatMap<F, G> as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, Self::Output, E>{\n    let (i, o1) = self.f.parse(i)?;\n    (self.g)(o1).parse(i)\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::Into<F, O2, E2> as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, Self::Output, Self::Error>{\n    match self.f.parse(i) {\n      Ok((i, o)) => Ok((i, o.into())),\n      Err(Err::Error(e)) => Err(Err::Error(e.into())),\n      Err(Err::Failure(e)) => Err(Err::Failure(e.into())),\n      Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::Map<F, G> as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, O2, E>{\n    match self.f.parse(i) {\n      Err(e) => Err(e),\n      Ok((i, o)) => Ok((i, (self.g)(o))),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::MapOpt<F, G> as internal::Parser<I>>::parse":["fn parse(&mut self, input: I) -> IResult<I, O2, <F as Parser<I>>::Error>{\n    let i = input.clone();\n    let (input, o1) = self.f.parse(input)?;\n    match (self.g)(o1) {\n      Some(o2) => Ok((input, o2)),\n      None => Err(Err::Error(<F as Parser<I>>::Error::from_error_kind(\n        i,\n        ErrorKind::MapOpt,\n      ))),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::MapRes<F, G> as internal::Parser<I>>::parse":["fn parse(&mut self, input: I) -> IResult<I, O2, <F as Parser<I>>::Error>{\n    let i = input.clone();\n    let (input, o1) = self.f.parse(input)?;\n    match (self.g)(o1) {\n      Ok(o2) => Ok((input, o2)),\n      Err(e) => Err(Err::Error(<F as Parser<I>>::Error::from_external_error(\n        i,\n        ErrorKind::MapRes,\n        e,\n      ))),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<internal::Or<F, G> as internal::Parser<I>>::parse":["fn parse(&mut self, i: I) -> IResult<I, Self::Output, Self::Error>{\n    match self.f.parse(i.clone()) {\n      Err(Err::Error(e1)) => match self.g.parse(i) {\n        Err(Err::Error(e2)) => Err(Err::Error(e1.or(e2))),\n        res => res,\n      },\n      res => res,\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)> as internal::Parser<I>>::parse":["fn parse(&mut self, input: I) -> IResult<I, O, E>{\n    (**self).parse(input)\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<std::ops::Range<usize> as traits::NomRange<usize>>::bounded_iter":["fn bounded_iter(&self) -> Self::Bounded{\n    if self.end == 0 {\n      1..0\n    } else {\n      0..self.end - 1\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::Range<usize> as traits::NomRange<usize>>::bounds":["fn bounds(&self) -> (Bound<usize>, Bound<usize>){\n    (Bound::Included(self.start), Bound::Excluded(self.end))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::Range<usize> as traits::NomRange<usize>>::contains":["fn contains(&self, item: &usize) -> bool{\n    RangeBounds::contains(self, item)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::Range<usize> as traits::NomRange<usize>>::is_inverted":["fn is_inverted(&self) -> bool{\n    !(self.start < self.end)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::Range<usize> as traits::NomRange<usize>>::saturating_iter":["fn saturating_iter(&self) -> Self::Saturating{\n    if self.end == 0 {\n      1..0\n    } else {\n      0..self.end - 1\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounded_iter":["fn bounded_iter(&self) -> Self::Bounded{\n    0..core::usize::MAX\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounds":["fn bounds(&self) -> (Bound<usize>, Bound<usize>){\n    (Bound::Included(self.start), Bound::Unbounded)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::contains":["fn contains(&self, item: &usize) -> bool{\n    RangeBounds::contains(self, item)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::is_inverted":["fn is_inverted(&self) -> bool{\n    false\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::saturating_iter":["fn saturating_iter(&self) -> Self::Saturating{\n    SaturatingIterator { count: 0 }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFull as traits::NomRange<usize>>::bounded_iter":["fn bounded_iter(&self) -> Self::Bounded{\n    0..core::usize::MAX\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFull as traits::NomRange<usize>>::bounds":["fn bounds(&self) -> (Bound<usize>, Bound<usize>){\n    (Bound::Unbounded, Bound::Unbounded)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFull as traits::NomRange<usize>>::contains":["fn contains(&self, item: &usize) -> bool{\n    RangeBounds::contains(self, item)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFull as traits::NomRange<usize>>::is_inverted":["fn is_inverted(&self) -> bool{\n    false\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeFull as traits::NomRange<usize>>::saturating_iter":["fn saturating_iter(&self) -> Self::Saturating{\n    SaturatingIterator { count: 0 }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounded_iter":["fn bounded_iter(&self) -> Self::Bounded{\n    0..*self.end()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounds":["fn bounds(&self) -> (Bound<usize>, Bound<usize>){\n    (Bound::Included(*self.start()), Bound::Included(*self.end()))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::contains":["fn contains(&self, item: &usize) -> bool{\n    RangeBounds::contains(self, item)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::is_inverted":["fn is_inverted(&self) -> bool{\n    !RangeInclusive::contains(self, self.start())\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::saturating_iter":["fn saturating_iter(&self) -> Self::Saturating{\n    0..*self.end()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounded_iter":["fn bounded_iter(&self) -> Self::Bounded{\n    if self.end == 0 {\n      1..0\n    } else {\n      0..self.end - 1\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounds":["fn bounds(&self) -> (Bound<usize>, Bound<usize>){\n    (Bound::Unbounded, Bound::Excluded(self.end))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::contains":["fn contains(&self, item: &usize) -> bool{\n    RangeBounds::contains(self, item)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::is_inverted":["fn is_inverted(&self) -> bool{\n    false\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::saturating_iter":["fn saturating_iter(&self) -> Self::Saturating{\n    if self.end == 0 {\n      1..0\n    } else {\n      0..self.end - 1\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounded_iter":["fn bounded_iter(&self) -> Self::Bounded{\n    0..self.end\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounds":["fn bounds(&self) -> (Bound<usize>, Bound<usize>){\n    (Bound::Unbounded, Bound::Included(self.end))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::contains":["fn contains(&self, item: &usize) -> bool{\n    RangeBounds::contains(self, item)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::is_inverted":["fn is_inverted(&self) -> bool{\n    false\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::saturating_iter":["fn saturating_iter(&self) -> Self::Saturating{\n    0..self.end\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish":["fn finish(self) -> Result<(I, O), E>{\n    match self {\n      Ok(res) => Ok(res),\n      Err(Err::Error(e)) | Err(Err::Failure(e)) => Err(e),\n      Err(Err::Incomplete(_)) => {\n        panic!(\"Cannot call `finish()` on `Err(Err::Incomplete(_))`: this result means that the parser does not have enough data to decide, you should gather more data and try to reapply  the parser instead\")\n      }\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"<str as traits::AsBytes>::as_bytes":["#[inline(always)]\nfn as_bytes(&self) -> &[u8]{\n    self.as_ref()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<str as traits::ExtendInto>::extend_into":["#[inline]\nfn extend_into(&self, acc: &mut String){\n    acc.push_str(self);\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<str as traits::ExtendInto>::new_builder":["#[inline]\nfn new_builder(&self) -> String{\n    String::new()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<str as traits::HexDisplay>::to_hex":["#[allow(unused_variables)]\nfn to_hex(&self, chunk_size: usize) -> String{\n    self.to_hex_from(chunk_size, 0)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<str as traits::HexDisplay>::to_hex_from":["#[allow(unused_variables)]\nfn to_hex_from(&self, chunk_size: usize, from: usize) -> String{\n    self.as_bytes().to_hex_from(chunk_size, from)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<str as traits::Offset>::offset":["fn offset(&self, second: &Self) -> usize{\n    let fst = self.as_ptr();\n    let snd = second.as_ptr();\n\n    snd as usize - fst as usize\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<traits::SaturatingIterator as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n    let old_count = self.count;\n    self.count = self.count.saturating_add(1);\n    Some(old_count)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u16 as traits::ToUsize>::to_usize":["#[inline]\nfn to_usize(&self) -> usize{\n    *self as usize\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u32 as traits::ToUsize>::to_usize":["#[inline]\nfn to_usize(&self) -> usize{\n    *self as usize\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u64 as traits::ToUsize>::to_usize":["#[inline]\nfn to_usize(&self) -> usize{\n    *self as usize\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::AsChar>::as_char":["#[inline]\nfn as_char(self) -> char{\n    self as char\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::AsChar>::is_alpha":["#[inline]\nfn is_alpha(self) -> bool{\n    matches!(self, 0x41..=0x5A | 0x61..=0x7A)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::AsChar>::is_alphanum":["#[inline]\nfn is_alphanum(self) -> bool{\n    self.is_alpha() || self.is_dec_digit()\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::AsChar>::is_dec_digit":["#[inline]\nfn is_dec_digit(self) -> bool{\n    matches!(self, 0x30..=0x39)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::AsChar>::is_hex_digit":["#[inline]\nfn is_hex_digit(self) -> bool{\n    matches!(self, 0x30..=0x39 | 0x41..=0x46 | 0x61..=0x66)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::AsChar>::is_oct_digit":["#[inline]\nfn is_oct_digit(self) -> bool{\n    matches!(self, 0x30..=0x37)\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::AsChar>::len":["#[inline]\nfn len(self) -> usize{\n    1\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::ToUsize>::to_usize":["#[inline]\nfn to_usize(&self) -> usize{\n    *self as usize\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<usize as traits::NomRange<usize>>::bounded_iter":["fn bounded_iter(&self) -> Self::Bounded{\n    0..*self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<usize as traits::NomRange<usize>>::bounds":["fn bounds(&self) -> (Bound<usize>, Bound<usize>){\n    (Bound::Included(*self), Bound::Included(*self))\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<usize as traits::NomRange<usize>>::contains":["fn contains(&self, item: &usize) -> bool{\n    self == item\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<usize as traits::NomRange<usize>>::is_inverted":["fn is_inverted(&self) -> bool{\n    false\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<usize as traits::NomRange<usize>>::saturating_iter":["fn saturating_iter(&self) -> Self::Saturating{\n    0..*self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"<usize as traits::ToUsize>::to_usize":["#[inline]\nfn to_usize(&self) -> usize{\n    *self\n  }","Real(LocalPath(\"src/traits.rs\"))"],"bits::bits":["/// Converts a byte-level input to a bit-level input, for consumption by a parser that uses bits.\n///\n/// Afterwards, the input is converted back to a byte-level parser, with any remaining bits thrown\n/// away.\n///\n/// # Example\n/// ```\n/// use nom::bits::{bits, streaming::take};\n/// use nom::error::Error;\n/// use nom::IResult;\n///\n/// fn parse(input: &[u8]) -> IResult<&[u8], (u8, u8)> {\n///     bits::<_, _, Error<(&[u8], usize)>, _, _>((take(4usize), take(8usize)))(input)\n/// }\n///\n/// let input = &[0x12, 0x34, 0xff, 0xff];\n///\n/// let output = parse(input).expect(\"We take 1.5 bytes and the input is longer than 2 bytes\");\n///\n/// // The first byte is consumed, the second byte is partially consumed and dropped.\n/// let remaining = output.0;\n/// assert_eq!(remaining, [0xff, 0xff]);\n///\n/// let parsed = output.1;\n/// assert_eq!(parsed.0, 0x01);\n/// assert_eq!(parsed.1, 0x23);\n/// ```\npub fn bits<I, O, E1, E2, P>(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2>\nwhere\n  E1: ParseError<(I, usize)> + ErrorConvert<E2>,\n  E2: ParseError<I>,\n  I: Input,\n  P: Parser<(I, usize), Output = O, Error = E1>,{\n  move |input: I| match parser.parse((input, 0)) {\n    Ok(((rest, offset), result)) => {\n      // If the next byte has been partially read, it will be sliced away as well.\n      // The parser functions might already slice away all fully read bytes.\n      // That's why `offset / 8` isn't necessarily needed at all times.\n      let remaining_bytes_index = offset / 8 + if offset % 8 == 0 { 0 } else { 1 };\n      Ok((rest.take_from(remaining_bytes_index), result))\n    }\n    Err(Err::Incomplete(n)) => Err(Err::Incomplete(n.map(|u| u.get() / 8 + 1))),\n    Err(Err::Error(e)) => Err(Err::Error(e.convert())),\n    Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),\n  }\n}","Real(LocalPath(\"src/bits/mod.rs\"))"],"bits::bytes":["/// Counterpart to `bits`, `bytes` transforms its bit stream input into a byte slice for the underlying\n/// parser, allowing byte-slice parsers to work on bit streams.\n///\n/// A partial byte remaining in the input will be ignored and the given parser will start parsing\n/// at the next full byte.\n///\n/// ```\n/// use nom::bits::{bits, bytes, streaming::take};\n/// use nom::combinator::rest;\n/// use nom::error::Error;\n/// use nom::IResult;\n///\n/// fn parse(input: &[u8]) -> IResult<&[u8], (u8, u8, &[u8])> {\n///   bits::<_, _, Error<(&[u8], usize)>, _, _>((\n///     take(4usize),\n///     take(8usize),\n///     bytes::<_, _, Error<&[u8]>, _, _>(rest)\n///   ))(input)\n/// }\n///\n/// let input = &[0x12, 0x34, 0xff, 0xff];\n///\n/// assert_eq!(parse( input ), Ok(( &[][..], (0x01, 0x23, &[0xff, 0xff][..]) )));\n/// ```\npub fn bytes<I, O, E1, E2, P>(mut parser: P) -> impl FnMut((I, usize)) -> IResult<(I, usize), O, E2>\nwhere\n  E1: ParseError<I> + ErrorConvert<E2>,\n  E2: ParseError<(I, usize)>,\n  I: Input + Clone,\n  P: Parser<I, Output = O, Error = E1>,{\n  move |(input, offset): (I, usize)| {\n    let inner = if offset % 8 != 0 {\n      input.take_from(1 + offset / 8)\n    } else {\n      input.take_from(offset / 8)\n    };\n    let i = (input, offset);\n    match parser.parse(inner) {\n      Ok((rest, res)) => Ok(((rest, 0), res)),\n      Err(Err::Incomplete(Needed::Unknown)) => Err(Err::Incomplete(Needed::Unknown)),\n      Err(Err::Incomplete(Needed::Size(sz))) => Err(match sz.get().checked_mul(8) {\n        Some(v) => Err::Incomplete(Needed::new(v)),\n        None => Err::Failure(E2::from_error_kind(i, ErrorKind::TooLarge)),\n      }),\n      Err(Err::Error(e)) => Err(Err::Error(e.convert())),\n      Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),\n    }\n  }\n}","Real(LocalPath(\"src/bits/mod.rs\"))"],"bits::complete::bool":["/// Parses one specific bit as a bool.\n///\n/// # Example\n/// ```rust\n/// # use nom::bits::complete::bool;\n/// # use nom::IResult;\n/// # use nom::error::{Error, ErrorKind};\n///\n/// fn parse(input: (&[u8], usize)) -> IResult<(&[u8], usize), bool> {\n///     bool(input)\n/// }\n///\n/// assert_eq!(parse(([0b10000000].as_ref(), 0)), Ok((([0b10000000].as_ref(), 1), true)));\n/// assert_eq!(parse(([0b10000000].as_ref(), 1)), Ok((([0b10000000].as_ref(), 2), false)));\n/// ```\npub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E>\nwhere\n  I: Input<Item = u8>,{\n  let (res, bit): (_, u32) = take(1usize)(input)?;\n  Ok((res, bit != 0))\n}","Real(LocalPath(\"src/bits/complete.rs\"))"],"bits::complete::tag":["/// Generates a parser taking `count` bits and comparing them to `pattern`\npub fn tag<I, O, C, E: ParseError<(I, usize)>>(\n  pattern: O,\n  count: C,\n) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E>\nwhere\n  I: Input<Item = u8> + Clone,\n  C: ToUsize,\n  O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq,{\n  let count = count.to_usize();\n  move |input: (I, usize)| {\n    let inp = input.clone();\n\n    take(count)(input).and_then(|(i, o)| {\n      if pattern == o {\n        Ok((i, o))\n      } else {\n        Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))\n      }\n    })\n  }\n}","Real(LocalPath(\"src/bits/complete.rs\"))"],"bits::complete::take":["/// Generates a parser taking `count` bits\n///\n/// # Example\n/// ```rust\n/// # use nom::bits::complete::take;\n/// # use nom::IResult;\n/// # use nom::error::{Error, ErrorKind};\n/// // Input is a tuple of (input: I, bit_offset: usize)\n/// fn parser(input: (&[u8], usize), count: usize)-> IResult<(&[u8], usize), u8> {\n///  take(count)(input)\n/// }\n///\n/// // Consumes 0 bits, returns 0\n/// assert_eq!(parser(([0b00010010].as_ref(), 0), 0), Ok((([0b00010010].as_ref(), 0), 0)));\n///\n/// // Consumes 4 bits, returns their values and increase offset to 4\n/// assert_eq!(parser(([0b00010010].as_ref(), 0), 4), Ok((([0b00010010].as_ref(), 4), 0b00000001)));\n///\n/// // Consumes 4 bits, offset is 4, returns their values and increase offset to 0 of next byte\n/// assert_eq!(parser(([0b00010010].as_ref(), 4), 4), Ok((([].as_ref(), 0), 0b00000010)));\n///\n/// // Tries to consume 12 bits but only 8 are available\n/// assert_eq!(parser(([0b00010010].as_ref(), 0), 12), Err(nom::Err::Error(Error{input: ([0b00010010].as_ref(), 0), code: ErrorKind::Eof })));\n/// ```\npub fn take<I, O, C, E: ParseError<(I, usize)>>(\n  count: C,\n) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E>\nwhere\n  I: Input<Item = u8>,\n  C: ToUsize,\n  O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>,{\n  let count = count.to_usize();\n  move |(input, bit_offset): (I, usize)| {\n    if count == 0 {\n      Ok(((input, bit_offset), 0u8.into()))\n    } else {\n      let cnt = (count + bit_offset).div(8);\n      if input.input_len() * 8 < count + bit_offset {\n        Err(Err::Error(E::from_error_kind(\n          (input, bit_offset),\n          ErrorKind::Eof,\n        )))\n      } else {\n        let mut acc: O = 0_u8.into();\n        let mut offset: usize = bit_offset;\n        let mut remaining: usize = count;\n        let mut end_offset: usize = 0;\n\n        for byte in input.iter_elements().take(cnt + 1) {\n          if remaining == 0 {\n            break;\n          }\n          let val: O = if offset == 0 {\n            byte.into()\n          } else {\n            ((byte << offset) as u8 >> offset).into()\n          };\n\n          if remaining < 8 - offset {\n            acc += val >> (8 - offset - remaining);\n            end_offset = remaining + offset;\n            break;\n          } else {\n            acc += val << (remaining - (8 - offset));\n            remaining -= 8 - offset;\n            offset = 0;\n          }\n        }\n        Ok(((input.take_from(cnt), end_offset), acc))\n      }\n    }\n  }\n}","Real(LocalPath(\"src/bits/complete.rs\"))"],"bits::streaming::bool":["/// Parses one specific bit as a bool.\n///\n/// # Example\n/// ```rust\n/// # use nom::bits::complete::bool;\n/// # use nom::IResult;\n/// # use nom::error::{Error, ErrorKind};\n///\n/// fn parse(input: (&[u8], usize)) -> IResult<(&[u8], usize), bool> {\n///     bool(input)\n/// }\n///\n/// assert_eq!(parse(([0b10000000].as_ref(), 0)), Ok((([0b10000000].as_ref(), 1), true)));\n/// assert_eq!(parse(([0b10000000].as_ref(), 1)), Ok((([0b10000000].as_ref(), 2), false)));\n/// ```\npub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E>\nwhere\n  I: Input<Item = u8>,{\n  let (res, bit): (_, u32) = take(1usize)(input)?;\n  Ok((res, bit != 0))\n}","Real(LocalPath(\"src/bits/streaming.rs\"))"],"bits::streaming::tag":["/// Generates a parser taking `count` bits and comparing them to `pattern`\npub fn tag<I, O, C, E: ParseError<(I, usize)>>(\n  pattern: O,\n  count: C,\n) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E>\nwhere\n  I: Input<Item = u8> + Clone,\n  C: ToUsize,\n  O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq,{\n  let count = count.to_usize();\n  move |input: (I, usize)| {\n    let inp = input.clone();\n\n    take(count)(input).and_then(|(i, o)| {\n      if pattern == o {\n        Ok((i, o))\n      } else {\n        Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))\n      }\n    })\n  }\n}","Real(LocalPath(\"src/bits/streaming.rs\"))"],"bits::streaming::take":["/// Generates a parser taking `count` bits\npub fn take<I, O, C, E: ParseError<(I, usize)>>(\n  count: C,\n) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E>\nwhere\n  I: Input<Item = u8>,\n  C: ToUsize,\n  O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>,{\n  let count = count.to_usize();\n  move |(input, bit_offset): (I, usize)| {\n    if count == 0 {\n      Ok(((input, bit_offset), 0u8.into()))\n    } else {\n      let cnt = (count + bit_offset).div(8);\n      if input.input_len() * 8 < count + bit_offset {\n        Err(Err::Incomplete(Needed::new(count as usize)))\n      } else {\n        let mut acc: O = 0_u8.into();\n        let mut offset: usize = bit_offset;\n        let mut remaining: usize = count;\n        let mut end_offset: usize = 0;\n\n        for byte in input.iter_elements().take(cnt + 1) {\n          if remaining == 0 {\n            break;\n          }\n          let val: O = if offset == 0 {\n            byte.into()\n          } else {\n            ((byte << offset) as u8 >> offset).into()\n          };\n\n          if remaining < 8 - offset {\n            acc += val >> (8 - offset - remaining);\n            end_offset = remaining + offset;\n            break;\n          } else {\n            acc += val << (remaining - (8 - offset));\n            remaining -= 8 - offset;\n            offset = 0;\n          }\n        }\n        Ok(((input.take_from(cnt), end_offset), acc))\n      }\n    }\n  }\n}","Real(LocalPath(\"src/bits/streaming.rs\"))"],"branch::Alt":["/// Helper trait for the [alt()] combinator.\n///\n/// This trait is implemented for tuples of up to 21 elements\npub trait Alt<I, O, E> {\n  /// Tests each parser in the tuple and returns the result of the first one that succeeds\n  fn choice(&mut self, input: I) -> IResult<I, O, E>;\n}","Real(LocalPath(\"src/branch/mod.rs\"))"],"branch::Permutation":["/// Helper trait for the [permutation()] combinator.\n///\n/// This trait is implemented for tuples of up to 21 elements\npub trait Permutation<I, O, E> {\n  /// Tries to apply all parsers in the tuple in various orders until all of them succeed\n  fn permutation(&mut self, input: I) -> IResult<I, O, E>;\n}","Real(LocalPath(\"src/branch/mod.rs\"))"],"branch::alt":["/// Tests a list of parsers one by one until one succeeds.\n///\n/// It takes as argument a tuple of parsers. There is a maximum of 21\n/// parsers. If you need more, it is possible to nest them in other `alt` calls,\n/// like this: `alt(parser_a, alt(parser_b, parser_c))`\n///\n/// ```rust\n/// # use nom::error_position;\n/// # use nom::{Err,error::ErrorKind, Needed, IResult};\n/// use nom::character::complete::{alpha1, digit1};\n/// use nom::branch::alt;\n/// # fn main() {\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///   alt((alpha1, digit1))(input)\n/// };\n///\n/// // the first parser, alpha1, recognizes the input\n/// assert_eq!(parser(\"abc\"), Ok((\"\", \"abc\")));\n///\n/// // the first parser returns an error, so alt tries the second one\n/// assert_eq!(parser(\"123456\"), Ok((\"\", \"123456\")));\n///\n/// // both parsers failed, and with the default error type, alt will return the last error\n/// assert_eq!(parser(\" \"), Err(Err::Error(error_position!(\" \", ErrorKind::Digit))));\n/// # }\n/// ```\n///\n/// With a custom error type, it is possible to have alt return the error of the parser\n/// that went the farthest in the input data\npub fn alt<I: Clone, O, E: ParseError<I>, List: Alt<I, O, E>>(\n  mut l: List,\n) -> impl FnMut(I) -> IResult<I, O, E>{\n  move |i: I| l.choice(i)\n}","Real(LocalPath(\"src/branch/mod.rs\"))"],"branch::permutation":["/// Applies a list of parsers in any order.\n///\n/// Permutation will succeed if all of the child parsers succeeded.\n/// It takes as argument a tuple of parsers, and returns a\n/// tuple of the parser results.\n///\n/// ```rust\n/// # use nom::{Err,error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::character::complete::{alpha1, digit1};\n/// use nom::branch::permutation;\n/// # fn main() {\n/// fn parser(input: &str) -> IResult<&str, (&str, &str)> {\n///   permutation((alpha1, digit1))(input)\n/// }\n///\n/// // permutation recognizes alphabetic characters then digit\n/// assert_eq!(parser(\"abc123\"), Ok((\"\", (\"abc\", \"123\"))));\n///\n/// // but also in inverse order\n/// assert_eq!(parser(\"123abc\"), Ok((\"\", (\"abc\", \"123\"))));\n///\n/// // it will fail if one of the parsers failed\n/// assert_eq!(parser(\"abc;\"), Err(Err::Error(Error::new(\";\", ErrorKind::Digit))));\n/// # }\n/// ```\n///\n/// The parsers are applied greedily: if there are multiple unapplied parsers\n/// that could parse the next slice of input, the first one is used.\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult};\n/// use nom::branch::permutation;\n/// use nom::character::complete::{anychar, char};\n///\n/// fn parser(input: &str) -> IResult<&str, (char, char)> {\n///   permutation((anychar, char('a')))(input)\n/// }\n///\n/// // anychar parses 'b', then char('a') parses 'a'\n/// assert_eq!(parser(\"ba\"), Ok((\"\", ('b', 'a'))));\n///\n/// // anychar parses 'a', then char('a') fails on 'b',\n/// // even though char('a') followed by anychar would succeed\n/// assert_eq!(parser(\"ab\"), Err(Err::Error(Error::new(\"b\", ErrorKind::Char))));\n/// ```\n///\npub fn permutation<I: Clone, O, E: ParseError<I>, List: Permutation<I, O, E>>(\n  mut l: List,\n) -> impl FnMut(I) -> IResult<I, O, E>{\n  move |i: I| l.permutation(i)\n}","Real(LocalPath(\"src/branch/mod.rs\"))"],"bytes::complete::escaped":["/// Matches a byte string with escaped characters.\n///\n/// * The first argument matches the normal characters (it must not accept the control character)\n/// * The second argument is the control character (like `\\` in most languages)\n/// * The third argument matches the escaped characters\n/// # Example\n/// ```\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// # use nom::character::complete::digit1;\n/// use nom::bytes::complete::escaped;\n/// use nom::character::complete::one_of;\n///\n/// fn esc(s: &str) -> IResult<&str, &str> {\n///   escaped(digit1, '\\\\', one_of(r#\"\"n\\\"#))(s)\n/// }\n///\n/// assert_eq!(esc(\"123;\"), Ok((\";\", \"123\")));\n/// assert_eq!(esc(r#\"12\\\"34;\"#), Ok((\";\", r#\"12\\\"34\"#)));\n/// ```\n///\npub fn escaped<'a, I: 'a, Error, F, G>(\n  mut normal: F,\n  control_char: char,\n  mut escapable: G,\n) -> impl FnMut(I) -> IResult<I, I, Error>\nwhere\n  I: Clone + crate::traits::Offset + Input,\n  <I as Input>::Item: crate::traits::AsChar,\n  F: Parser<I, Error = Error>,\n  G: Parser<I, Error = Error>,\n  Error: ParseError<I>,{\n  use crate::traits::AsChar;\n\n  move |input: I| {\n    let mut i = input.clone();\n\n    while i.input_len() > 0 {\n      let current_len = i.input_len();\n\n      match normal.parse(i.clone()) {\n        Ok((i2, _)) => {\n          // return if we consumed everything or if the normal parser\n          // does not consume anything\n          if i2.input_len() == 0 {\n            return Ok(input.take_split(input.input_len()));\n          } else if i2.input_len() == current_len {\n            let index = input.offset(&i2);\n            return Ok(input.take_split(index));\n          } else {\n            i = i2;\n          }\n        }\n        Err(Err::Error(_)) => {\n          // unwrap() should be safe here since index < $i.input_len()\n          if i.iter_elements().next().unwrap().as_char() == control_char {\n            let next = control_char.len_utf8();\n            if next >= i.input_len() {\n              return Err(Err::Error(Error::from_error_kind(\n                input,\n                ErrorKind::Escaped,\n              )));\n            } else {\n              match escapable.parse(i.take_from(next)) {\n                Ok((i2, _)) => {\n                  if i2.input_len() == 0 {\n                    return Ok(input.take_split(input.input_len()));\n                  } else {\n                    i = i2;\n                  }\n                }\n                Err(e) => return Err(e),\n              }\n            }\n          } else {\n            let index = input.offset(&i);\n            if index == 0 {\n              return Err(Err::Error(Error::from_error_kind(\n                input,\n                ErrorKind::Escaped,\n              )));\n            }\n            return Ok(input.take_split(index));\n          }\n        }\n        Err(e) => {\n          return Err(e);\n        }\n      }\n    }\n\n    Ok(input.take_split(input.input_len()))\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::escaped_transform":["/// Matches a byte string with escaped characters.\n///\n/// * The first argument matches the normal characters (it must not match the control character)\n/// * The second argument is the control character (like `\\` in most languages)\n/// * The third argument matches the escaped characters and transforms them\n///\n/// As an example, the chain `abc\\tdef` could be `abc    def` (it also consumes the control character)\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// # use std::str::from_utf8;\n/// use nom::bytes::complete::{escaped_transform, tag};\n/// use nom::character::complete::alpha1;\n/// use nom::branch::alt;\n/// use nom::combinator::value;\n///\n/// fn parser(input: &str) -> IResult<&str, String> {\n///   escaped_transform(\n///     alpha1,\n///     '\\\\',\n///     alt((\n///       value(\"\\\\\", tag(\"\\\\\")),\n///       value(\"\\\"\", tag(\"\\\"\")),\n///       value(\"\\n\", tag(\"n\")),\n///     ))\n///   )(input)\n/// }\n///\n/// assert_eq!(parser(\"ab\\\\\\\"cd\"), Ok((\"\", String::from(\"ab\\\"cd\"))));\n/// assert_eq!(parser(\"ab\\\\ncd\"), Ok((\"\", String::from(\"ab\\ncd\"))));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn escaped_transform<I, Error, F, G, O1, O2, ExtendItem, Output>(\n  mut normal: F,\n  control_char: char,\n  mut transform: G,\n) -> impl FnMut(I) -> IResult<I, Output, Error>\nwhere\n  I: Clone + crate::traits::Offset + Input,\n  I: crate::traits::ExtendInto<Item = ExtendItem, Extender = Output>,\n  O1: crate::traits::ExtendInto<Item = ExtendItem, Extender = Output>,\n  O2: crate::traits::ExtendInto<Item = ExtendItem, Extender = Output>,\n  <I as Input>::Item: crate::traits::AsChar,\n  F: Parser<I, Output = O1, Error = Error>,\n  G: Parser<I, Output = O2, Error = Error>,\n  Error: ParseError<I>,{\n  use crate::traits::AsChar;\n\n  move |input: I| {\n    let mut index = 0;\n    let mut res = input.new_builder();\n\n    let i = input.clone();\n\n    while index < i.input_len() {\n      let current_len = i.input_len();\n      let remainder = i.take_from(index);\n      match normal.parse(remainder.clone()) {\n        Ok((i2, o)) => {\n          o.extend_into(&mut res);\n          if i2.input_len() == 0 {\n            return Ok((i.take_from(i.input_len()), res));\n          } else if i2.input_len() == current_len {\n            return Ok((remainder, res));\n          } else {\n            index = input.offset(&i2);\n          }\n        }\n        Err(Err::Error(_)) => {\n          // unwrap() should be safe here since index < $i.input_len()\n          if remainder.iter_elements().next().unwrap().as_char() == control_char {\n            let next = index + control_char.len_utf8();\n            let input_len = input.input_len();\n\n            if next >= input_len {\n              return Err(Err::Error(Error::from_error_kind(\n                remainder,\n                ErrorKind::EscapedTransform,\n              )));\n            } else {\n              match transform.parse(i.take_from(next)) {\n                Ok((i2, o)) => {\n                  o.extend_into(&mut res);\n                  if i2.input_len() == 0 {\n                    return Ok((i.take_from(i.input_len()), res));\n                  } else {\n                    index = input.offset(&i2);\n                  }\n                }\n                Err(e) => return Err(e),\n              }\n            }\n          } else {\n            if index == 0 {\n              return Err(Err::Error(Error::from_error_kind(\n                remainder,\n                ErrorKind::EscapedTransform,\n              )));\n            }\n            return Ok((remainder, res));\n          }\n        }\n        Err(e) => return Err(e),\n      }\n    }\n    Ok((input.take_from(index), res))\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::is_a":["/// Returns the longest slice of the matches the pattern.\n///\n/// The parser will return the longest slice consisting of the characters in provided in the\n/// combinator's argument.\n///\n/// It will return a `Err(Err::Error((_, ErrorKind::IsA)))` if the pattern wasn't met.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::is_a;\n///\n/// fn hex(s: &str) -> IResult<&str, &str> {\n///   is_a(\"1234567890ABCDEF\")(s)\n/// }\n///\n/// assert_eq!(hex(\"123 and voila\"), Ok((\" and voila\", \"123\")));\n/// assert_eq!(hex(\"DEADBEEF and others\"), Ok((\" and others\", \"DEADBEEF\")));\n/// assert_eq!(hex(\"BADBABEsomething\"), Ok((\"something\", \"BADBABE\")));\n/// assert_eq!(hex(\"D15EA5E\"), Ok((\"\", \"D15EA5E\")));\n/// assert_eq!(hex(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::IsA))));\n/// ```\npub fn is_a<T, I, Error: ParseError<I>>(arr: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  T: FindToken<<I as Input>::Item>,{\n  move |i: I| {\n    let e: ErrorKind = ErrorKind::IsA;\n    i.split_at_position1_complete(|c| !arr.find_token(c), e)\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::is_not":["/// Parse till certain characters are met.\n///\n/// The parser will return the longest slice till one of the characters of the combinator's argument are met.\n///\n/// It doesn't consume the matched character.\n///\n/// It will return a `Err::Error((\"\", ErrorKind::IsNot))` if the pattern wasn't met.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::is_not;\n///\n/// fn not_space(s: &str) -> IResult<&str, &str> {\n///   is_not(\" \\t\\r\\n\")(s)\n/// }\n///\n/// assert_eq!(not_space(\"Hello, World!\"), Ok((\" World!\", \"Hello,\")));\n/// assert_eq!(not_space(\"Sometimes\\t\"), Ok((\"\\t\", \"Sometimes\")));\n/// assert_eq!(not_space(\"Nospace\"), Ok((\"\", \"Nospace\")));\n/// assert_eq!(not_space(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::IsNot))));\n/// ```\npub fn is_not<T, I, Error: ParseError<I>>(arr: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  T: FindToken<<I as Input>::Item>,{\n  move |i: I| {\n    let e: ErrorKind = ErrorKind::IsNot;\n    i.split_at_position1_complete(|c| arr.find_token(c), e)\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::tag":["/// Recognizes a pattern\n///\n/// The input data will be compared to the tag combinator's argument and will return the part of\n/// the input that matches the argument\n///\n/// It will return `Err(Err::Error((_, ErrorKind::Tag)))` if the input doesn't match the pattern\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, &str> {\n///   tag(\"Hello\")(s)\n/// }\n///\n/// assert_eq!(parser(\"Hello, World!\"), Ok((\", World!\", \"Hello\")));\n/// assert_eq!(parser(\"Something\"), Err(Err::Error(Error::new(\"Something\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Tag))));\n/// ```\npub fn tag<T, I, Error: ParseError<I>>(tag: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + Compare<T>,\n  T: InputLength + Clone,{\n  move |i: I| {\n    let tag_len = tag.input_len();\n    let t = tag.clone();\n    let res: IResult<_, _, Error> = match i.compare(t) {\n      CompareResult::Ok => Ok(i.take_split(tag_len)),\n      _ => {\n        let e: ErrorKind = ErrorKind::Tag;\n        Err(Err::Error(Error::from_error_kind(i, e)))\n      }\n    };\n    res\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::tag_no_case":["/// Recognizes a case insensitive pattern.\n///\n/// The input data will be compared to the tag combinator's argument and will return the part of\n/// the input that matches the argument with no regard to case.\n///\n/// It will return `Err(Err::Error((_, ErrorKind::Tag)))` if the input doesn't match the pattern.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::tag_no_case;\n///\n/// fn parser(s: &str) -> IResult<&str, &str> {\n///   tag_no_case(\"hello\")(s)\n/// }\n///\n/// assert_eq!(parser(\"Hello, World!\"), Ok((\", World!\", \"Hello\")));\n/// assert_eq!(parser(\"hello, World!\"), Ok((\", World!\", \"hello\")));\n/// assert_eq!(parser(\"HeLlO, World!\"), Ok((\", World!\", \"HeLlO\")));\n/// assert_eq!(parser(\"Something\"), Err(Err::Error(Error::new(\"Something\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Tag))));\n/// ```\npub fn tag_no_case<T, I, Error: ParseError<I>>(tag: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + Compare<T>,\n  T: InputLength + Clone,{\n  move |i: I| {\n    let tag_len = tag.input_len();\n    let t = tag.clone();\n\n    let res: IResult<_, _, Error> = match (i).compare_no_case(t) {\n      CompareResult::Ok => Ok(i.take_split(tag_len)),\n      _ => {\n        let e: ErrorKind = ErrorKind::Tag;\n        Err(Err::Error(Error::from_error_kind(i, e)))\n      }\n    };\n    res\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::take":["/// Returns an input slice containing the first N input elements (Input[..N]).\n///\n/// It will return `Err(Err::Error((_, ErrorKind::Eof)))` if the input is shorter than the argument.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::take;\n///\n/// fn take6(s: &str) -> IResult<&str, &str> {\n///   take(6usize)(s)\n/// }\n///\n/// assert_eq!(take6(\"1234567\"), Ok((\"7\", \"123456\")));\n/// assert_eq!(take6(\"things\"), Ok((\"\", \"things\")));\n/// assert_eq!(take6(\"short\"), Err(Err::Error(Error::new(\"short\", ErrorKind::Eof))));\n/// assert_eq!(take6(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Eof))));\n/// ```\n///\n/// The units that are taken will depend on the input type. For example, for a\n/// `&str` it will take a number of `char`'s, whereas for a `&[u8]` it will\n/// take that many `u8`'s:\n///\n/// ```rust\n/// use nom::error::Error;\n/// use nom::bytes::complete::take;\n///\n/// assert_eq!(take::<_, _, Error<_>>(1usize)(\"\"), Ok((\"\", \"\")));\n/// assert_eq!(take::<_, _, Error<_>>(1usize)(\"\".as_bytes()), Ok((b\"\\x9F\\x92\\x99\".as_ref(), b\"\\xF0\".as_ref())));\n/// ```\npub fn take<C, I, Error: ParseError<I>>(count: C) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  C: ToUsize,{\n  let c = count.to_usize();\n  move |i: I| match i.slice_index(c) {\n    Err(_needed) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Eof))),\n    Ok(index) => Ok(i.take_split(index)),\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::take_till":["/// Returns the longest input slice (if any) till a predicate is met.\n///\n/// The parser will return the longest slice till the given predicate *(a function that\n/// takes the input and returns a bool)*.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::bytes::complete::take_till;\n///\n/// fn till_colon(s: &str) -> IResult<&str, &str> {\n///   take_till(|c| c == ':')(s)\n/// }\n///\n/// assert_eq!(till_colon(\"latin:123\"), Ok((\":123\", \"latin\")));\n/// assert_eq!(till_colon(\":empty matched\"), Ok((\":empty matched\", \"\"))); //allowed\n/// assert_eq!(till_colon(\"12345\"), Ok((\"\", \"12345\")));\n/// assert_eq!(till_colon(\"\"), Ok((\"\", \"\")));\n/// ```\n#[allow(clippy::redundant_closure)]\npub fn take_till<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| i.split_at_position_complete(|c| cond(c))\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::take_till1":["/// Returns the longest (at least 1) input slice till a predicate is met.\n///\n/// The parser will return the longest slice till the given predicate *(a function that\n/// takes the input and returns a bool)*.\n///\n/// It will return `Err(Err::Error((_, ErrorKind::TakeTill1)))` if the input is empty or the\n/// predicate matches the first input.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::take_till1;\n///\n/// fn till_colon(s: &str) -> IResult<&str, &str> {\n///   take_till1(|c| c == ':')(s)\n/// }\n///\n/// assert_eq!(till_colon(\"latin:123\"), Ok((\":123\", \"latin\")));\n/// assert_eq!(till_colon(\":empty matched\"), Err(Err::Error(Error::new(\":empty matched\", ErrorKind::TakeTill1))));\n/// assert_eq!(till_colon(\"12345\"), Ok((\"\", \"12345\")));\n/// assert_eq!(till_colon(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::TakeTill1))));\n/// ```\n#[allow(clippy::redundant_closure)]\npub fn take_till1<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| {\n    let e: ErrorKind = ErrorKind::TakeTill1;\n    i.split_at_position1_complete(|c| cond(c), e)\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::take_until":["/// Returns the input slice up to the first occurrence of the pattern.\n///\n/// It doesn't consume the pattern. It will return `Err(Err::Error((_, ErrorKind::TakeUntil)))`\n/// if the pattern wasn't met.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::take_until;\n///\n/// fn until_eof(s: &str) -> IResult<&str, &str> {\n///   take_until(\"eof\")(s)\n/// }\n///\n/// assert_eq!(until_eof(\"hello, worldeof\"), Ok((\"eof\", \"hello, world\")));\n/// assert_eq!(until_eof(\"hello, world\"), Err(Err::Error(Error::new(\"hello, world\", ErrorKind::TakeUntil))));\n/// assert_eq!(until_eof(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::TakeUntil))));\n/// assert_eq!(until_eof(\"1eof2eof\"), Ok((\"eof2eof\", \"1\")));\n/// ```\npub fn take_until<T, I, Error: ParseError<I>>(tag: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + FindSubstring<T>,\n  T: InputLength + Clone,{\n  move |i: I| {\n    let t = tag.clone();\n    let res: IResult<_, _, Error> = match i.find_substring(t) {\n      None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),\n      Some(index) => Ok(i.take_split(index)),\n    };\n    res\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::take_until1":["/// Returns the non empty input slice up to the first occurrence of the pattern.\n///\n/// It doesn't consume the pattern. It will return `Err(Err::Error((_, ErrorKind::TakeUntil)))`\n/// if the pattern wasn't met.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::take_until1;\n///\n/// fn until_eof(s: &str) -> IResult<&str, &str> {\n///   take_until1(\"eof\")(s)\n/// }\n///\n/// assert_eq!(until_eof(\"hello, worldeof\"), Ok((\"eof\", \"hello, world\")));\n/// assert_eq!(until_eof(\"hello, world\"), Err(Err::Error(Error::new(\"hello, world\", ErrorKind::TakeUntil))));\n/// assert_eq!(until_eof(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::TakeUntil))));\n/// assert_eq!(until_eof(\"1eof2eof\"), Ok((\"eof2eof\", \"1\")));\n/// assert_eq!(until_eof(\"eof\"), Err(Err::Error(Error::new(\"eof\", ErrorKind::TakeUntil))));\n/// ```\npub fn take_until1<T, I, Error: ParseError<I>>(tag: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + FindSubstring<T>,\n  T: InputLength + Clone,{\n  move |i: I| {\n    let t = tag.clone();\n    let res: IResult<_, _, Error> = match i.find_substring(t) {\n      None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),\n      Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),\n      Some(index) => Ok(i.take_split(index)),\n    };\n    res\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::take_while":["/// Returns the longest input slice (if any) that matches the predicate.\n///\n/// The parser will return the longest slice that matches the given predicate *(a function that\n/// takes the input and returns a bool)*.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::bytes::complete::take_while;\n/// use nom::character::is_alphabetic;\n///\n/// fn alpha(s: &[u8]) -> IResult<&[u8], &[u8]> {\n///   take_while(is_alphabetic)(s)\n/// }\n///\n/// assert_eq!(alpha(b\"latin123\"), Ok((&b\"123\"[..], &b\"latin\"[..])));\n/// assert_eq!(alpha(b\"12345\"), Ok((&b\"12345\"[..], &b\"\"[..])));\n/// assert_eq!(alpha(b\"latin\"), Ok((&b\"\"[..], &b\"latin\"[..])));\n/// assert_eq!(alpha(b\"\"), Ok((&b\"\"[..], &b\"\"[..])));\n/// ```\npub fn take_while<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| i.split_at_position_complete(|c| !cond(c))\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::take_while1":["/// Returns the longest (at least 1) input slice that matches the predicate.\n///\n/// The parser will return the longest slice that matches the given predicate *(a function that\n/// takes the input and returns a bool)*.\n///\n/// It will return an `Err(Err::Error((_, ErrorKind::TakeWhile1)))` if the pattern wasn't met.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::take_while1;\n/// use nom::character::is_alphabetic;\n///\n/// fn alpha(s: &[u8]) -> IResult<&[u8], &[u8]> {\n///   take_while1(is_alphabetic)(s)\n/// }\n///\n/// assert_eq!(alpha(b\"latin123\"), Ok((&b\"123\"[..], &b\"latin\"[..])));\n/// assert_eq!(alpha(b\"latin\"), Ok((&b\"\"[..], &b\"latin\"[..])));\n/// assert_eq!(alpha(b\"12345\"), Err(Err::Error(Error::new(&b\"12345\"[..], ErrorKind::TakeWhile1))));\n/// ```\npub fn take_while1<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| {\n    let e: ErrorKind = ErrorKind::TakeWhile1;\n    i.split_at_position1_complete(|c| !cond(c), e)\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::complete::take_while_m_n":["/// Returns the longest (m <= len <= n) input slice that matches the predicate.\n///\n/// The parser will return the longest slice that matches the given predicate *(a function that\n/// takes the input and returns a bool)*.\n///\n/// It will return an `Err::Error((_, ErrorKind::TakeWhileMN))` if the pattern wasn't met or is out\n/// of range (m <= len <= n).\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::complete::take_while_m_n;\n/// use nom::character::is_alphabetic;\n///\n/// fn short_alpha(s: &[u8]) -> IResult<&[u8], &[u8]> {\n///   take_while_m_n(3, 6, is_alphabetic)(s)\n/// }\n///\n/// assert_eq!(short_alpha(b\"latin123\"), Ok((&b\"123\"[..], &b\"latin\"[..])));\n/// assert_eq!(short_alpha(b\"lengthy\"), Ok((&b\"y\"[..], &b\"length\"[..])));\n/// assert_eq!(short_alpha(b\"latin\"), Ok((&b\"\"[..], &b\"latin\"[..])));\n/// assert_eq!(short_alpha(b\"ed\"), Err(Err::Error(Error::new(&b\"ed\"[..], ErrorKind::TakeWhileMN))));\n/// assert_eq!(short_alpha(b\"12345\"), Err(Err::Error(Error::new(&b\"12345\"[..], ErrorKind::TakeWhileMN))));\n/// ```\npub fn take_while_m_n<F, I, Error: ParseError<I>>(\n  m: usize,\n  n: usize,\n  cond: F,\n) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| {\n    let input = i;\n    let mut count = 0;\n    for (i, (index, item)) in input.iter_indices().enumerate() {\n      if i == n {\n        return Ok(input.take_split(index));\n      }\n\n      if !cond(item) {\n        if i >= m {\n          return Ok(input.take_split(index));\n        } else {\n          return Err(Err::Error(Error::from_error_kind(\n            input,\n            ErrorKind::TakeWhileMN,\n          )));\n        }\n      }\n\n      count += 1;\n    }\n\n    if count >= m {\n      Ok(input.take_split(input.input_len()))\n    } else {\n      Err(Err::Error(Error::from_error_kind(\n        input,\n        ErrorKind::TakeWhileMN,\n      )))\n    }\n  }\n}","Real(LocalPath(\"src/bytes/complete.rs\"))"],"bytes::streaming::escaped":["/// Matches a byte string with escaped characters.\n///\n/// * The first argument matches the normal characters (it must not accept the control character)\n/// * The second argument is the control character (like `\\` in most languages)\n/// * The third argument matches the escaped characters\n/// # Example\n/// ```\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// # use nom::character::complete::digit1;\n/// use nom::bytes::streaming::escaped;\n/// use nom::character::streaming::one_of;\n///\n/// fn esc(s: &str) -> IResult<&str, &str> {\n///   escaped(digit1, '\\\\', one_of(\"\\\"n\\\\\"))(s)\n/// }\n///\n/// assert_eq!(esc(\"123;\"), Ok((\";\", \"123\")));\n/// assert_eq!(esc(\"12\\\\\\\"34;\"), Ok((\";\", \"12\\\\\\\"34\")));\n/// ```\n///\npub fn escaped<I, Error, F, G>(\n  mut normal: F,\n  control_char: char,\n  mut escapable: G,\n) -> impl FnMut(I) -> IResult<I, I, Error>\nwhere\n  I: Input + Clone + crate::traits::Offset,\n  <I as Input>::Item: crate::traits::AsChar,\n  F: Parser<I, Error = Error>,\n  G: Parser<I, Error = Error>,\n  Error: ParseError<I>,{\n  use crate::traits::AsChar;\n\n  move |input: I| {\n    let mut i = input.clone();\n\n    while i.input_len() > 0 {\n      let current_len = i.input_len();\n\n      match normal.parse(i.clone()) {\n        Ok((i2, _)) => {\n          if i2.input_len() == 0 {\n            return Err(Err::Incomplete(Needed::Unknown));\n          } else if i2.input_len() == current_len {\n            let index = input.offset(&i2);\n            return Ok(input.take_split(index));\n          } else {\n            i = i2;\n          }\n        }\n        Err(Err::Error(_)) => {\n          // unwrap() should be safe here since index < $i.input_len()\n          if i.iter_elements().next().unwrap().as_char() == control_char {\n            let next = control_char.len_utf8();\n            if next >= i.input_len() {\n              return Err(Err::Incomplete(Needed::new(1)));\n            } else {\n              match escapable.parse(i.take_from(next)) {\n                Ok((i2, _)) => {\n                  if i2.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::Unknown));\n                  } else {\n                    i = i2;\n                  }\n                }\n                Err(e) => return Err(e),\n              }\n            }\n          } else {\n            let index = input.offset(&i);\n            return Ok(input.take_split(index));\n          }\n        }\n        Err(e) => {\n          return Err(e);\n        }\n      }\n    }\n\n    Err(Err::Incomplete(Needed::Unknown))\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::escaped_transform":["/// Matches a byte string with escaped characters.\n///\n/// * The first argument matches the normal characters (it must not match the control character)\n/// * The second argument is the control character (like `\\` in most languages)\n/// * The third argument matches the escaped characters and transforms them\n///\n/// As an example, the chain `abc\\tdef` could be `abc    def` (it also consumes the control character)\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// # use std::str::from_utf8;\n/// use nom::bytes::streaming::{escaped_transform, tag};\n/// use nom::character::streaming::alpha1;\n/// use nom::branch::alt;\n/// use nom::combinator::value;\n///\n/// fn parser(input: &str) -> IResult<&str, String> {\n///   escaped_transform(\n///     alpha1,\n///     '\\\\',\n///     alt((\n///       value(\"\\\\\", tag(\"\\\\\")),\n///       value(\"\\\"\", tag(\"\\\"\")),\n///       value(\"\\n\", tag(\"n\")),\n///     ))\n///   )(input)\n/// }\n///\n/// assert_eq!(parser(\"ab\\\\\\\"cd\\\"\"), Ok((\"\\\"\", String::from(\"ab\\\"cd\"))));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn escaped_transform<I, Error, F, G, O1, O2, ExtendItem, Output>(\n  mut normal: F,\n  control_char: char,\n  mut transform: G,\n) -> impl FnMut(I) -> IResult<I, Output, Error>\nwhere\n  I: Clone + crate::traits::Offset + Input,\n  I: crate::traits::ExtendInto<Item = ExtendItem, Extender = Output>,\n  O1: crate::traits::ExtendInto<Item = ExtendItem, Extender = Output>,\n  O2: crate::traits::ExtendInto<Item = ExtendItem, Extender = Output>,\n  <I as Input>::Item: crate::traits::AsChar,\n  F: Parser<I, Output = O1, Error = Error>,\n  G: Parser<I, Output = O2, Error = Error>,\n  Error: ParseError<I>,{\n  use crate::traits::AsChar;\n\n  move |input: I| {\n    let mut index = 0;\n    let mut res = input.new_builder();\n\n    let i = input.clone();\n\n    while index < i.input_len() {\n      let current_len = i.input_len();\n      let remainder = i.take_from(index);\n      match normal.parse(remainder.clone()) {\n        Ok((i2, o)) => {\n          o.extend_into(&mut res);\n          if i2.input_len() == 0 {\n            return Err(Err::Incomplete(Needed::Unknown));\n          } else if i2.input_len() == current_len {\n            return Ok((remainder, res));\n          } else {\n            index = input.offset(&i2);\n          }\n        }\n        Err(Err::Error(_)) => {\n          // unwrap() should be safe here since index < $i.input_len()\n          if remainder.iter_elements().next().unwrap().as_char() == control_char {\n            let next = index + control_char.len_utf8();\n            let input_len = input.input_len();\n\n            if next >= input_len {\n              return Err(Err::Incomplete(Needed::Unknown));\n            } else {\n              match transform.parse(i.take_from(next)) {\n                Ok((i2, o)) => {\n                  o.extend_into(&mut res);\n                  if i2.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::Unknown));\n                  } else {\n                    index = input.offset(&i2);\n                  }\n                }\n                Err(e) => return Err(e),\n              }\n            }\n          } else {\n            return Ok((remainder, res));\n          }\n        }\n        Err(e) => return Err(e),\n      }\n    }\n    Err(Err::Incomplete(Needed::Unknown))\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::is_a":["/// Returns the longest slice of the matches the pattern.\n///\n/// The parser will return the longest slice consisting of the characters in provided in the\n/// combinator's argument.\n///\n/// # Streaming specific\n/// *Streaming version* will return a `Err::Incomplete(Needed::new(1))` if the pattern wasn't met\n/// or if the pattern reaches the end of the input.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::bytes::streaming::is_a;\n///\n/// fn hex(s: &str) -> IResult<&str, &str> {\n///   is_a(\"1234567890ABCDEF\")(s)\n/// }\n///\n/// assert_eq!(hex(\"123 and voila\"), Ok((\" and voila\", \"123\")));\n/// assert_eq!(hex(\"DEADBEEF and others\"), Ok((\" and others\", \"DEADBEEF\")));\n/// assert_eq!(hex(\"BADBABEsomething\"), Ok((\"something\", \"BADBABE\")));\n/// assert_eq!(hex(\"D15EA5E\"), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(hex(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn is_a<T, I, Error: ParseError<I>>(arr: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  T: FindToken<<I as Input>::Item>,{\n  move |i: I| {\n    let e: ErrorKind = ErrorKind::IsA;\n    i.split_at_position1(|c| !arr.find_token(c), e)\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::is_not":["/// Parse till certain characters are met.\n///\n/// The parser will return the longest slice till one of the characters of the combinator's argument are met.\n///\n/// It doesn't consume the matched character.\n///\n/// It will return a `Err::Incomplete(Needed::new(1))` if the pattern wasn't met.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::bytes::streaming::is_not;\n///\n/// fn not_space(s: &str) -> IResult<&str, &str> {\n///   is_not(\" \\t\\r\\n\")(s)\n/// }\n///\n/// assert_eq!(not_space(\"Hello, World!\"), Ok((\" World!\", \"Hello,\")));\n/// assert_eq!(not_space(\"Sometimes\\t\"), Ok((\"\\t\", \"Sometimes\")));\n/// assert_eq!(not_space(\"Nospace\"), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(not_space(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn is_not<T, I, Error: ParseError<I>>(arr: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  T: FindToken<<I as Input>::Item>,{\n  move |i: I| {\n    let e: ErrorKind = ErrorKind::IsNot;\n    i.split_at_position1(|c| arr.find_token(c), e)\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::tag":["/// Recognizes a pattern.\n///\n/// The input data will be compared to the tag combinator's argument and will return the part of\n/// the input that matches the argument.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::streaming::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, &str> {\n///   tag(\"Hello\")(s)\n/// }\n///\n/// assert_eq!(parser(\"Hello, World!\"), Ok((\", World!\", \"Hello\")));\n/// assert_eq!(parser(\"Something\"), Err(Err::Error(Error::new(\"Something\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"S\"), Err(Err::Error(Error::new(\"S\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"H\"), Err(Err::Incomplete(Needed::new(4))));\n/// ```\npub fn tag<T, I, Error: ParseError<I>>(tag: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + Compare<T>,\n  T: InputLength + Clone,{\n  move |i: I| {\n    let tag_len = tag.input_len();\n    let t = tag.clone();\n\n    let res: IResult<_, _, Error> = match i.compare(t) {\n      CompareResult::Ok => Ok(i.take_split(tag_len)),\n      CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),\n      CompareResult::Error => {\n        let e: ErrorKind = ErrorKind::Tag;\n        Err(Err::Error(Error::from_error_kind(i, e)))\n      }\n    };\n    res\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::tag_no_case":["/// Recognizes a case insensitive pattern.\n///\n/// The input data will be compared to the tag combinator's argument and will return the part of\n/// the input that matches the argument with no regard to case.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::streaming::tag_no_case;\n///\n/// fn parser(s: &str) -> IResult<&str, &str> {\n///   tag_no_case(\"hello\")(s)\n/// }\n///\n/// assert_eq!(parser(\"Hello, World!\"), Ok((\", World!\", \"Hello\")));\n/// assert_eq!(parser(\"hello, World!\"), Ok((\", World!\", \"hello\")));\n/// assert_eq!(parser(\"HeLlO, World!\"), Ok((\", World!\", \"HeLlO\")));\n/// assert_eq!(parser(\"Something\"), Err(Err::Error(Error::new(\"Something\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"\"), Err(Err::Incomplete(Needed::new(5))));\n/// ```\npub fn tag_no_case<T, I, Error: ParseError<I>>(tag: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + Compare<T>,\n  T: InputLength + Clone,{\n  move |i: I| {\n    let tag_len = tag.input_len();\n    let t = tag.clone();\n\n    let res: IResult<_, _, Error> = match (i).compare_no_case(t) {\n      CompareResult::Ok => Ok(i.take_split(tag_len)),\n      CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),\n      CompareResult::Error => {\n        let e: ErrorKind = ErrorKind::Tag;\n        Err(Err::Error(Error::from_error_kind(i, e)))\n      }\n    };\n    res\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::take":["/// Returns an input slice containing the first N input elements (Input[..N]).\n///\n/// # Streaming Specific\n/// *Streaming version* if the input has less than N elements, `take` will\n/// return a `Err::Incomplete(Needed::new(M))` where M is the number of\n/// additional bytes the parser would need to succeed.\n/// It is well defined for `&[u8]` as the number of elements is the byte size,\n/// but for types like `&str`, we cannot know how many bytes correspond for\n/// the next few chars, so the result will be `Err::Incomplete(Needed::Unknown)`\n///\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::bytes::streaming::take;\n///\n/// fn take6(s: &str) -> IResult<&str, &str> {\n///   take(6usize)(s)\n/// }\n///\n/// assert_eq!(take6(\"1234567\"), Ok((\"7\", \"123456\")));\n/// assert_eq!(take6(\"things\"), Ok((\"\", \"things\")));\n/// assert_eq!(take6(\"short\"), Err(Err::Incomplete(Needed::Unknown)));\n/// ```\npub fn take<C, I, Error: ParseError<I>>(count: C) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + InputLength,\n  C: ToUsize,{\n  let c = count.to_usize();\n  move |i: I| match i.slice_index(c) {\n    Err(i) => Err(Err::Incomplete(i)),\n    Ok(index) => Ok(i.take_split(index)),\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::take_till":["/// Returns the longest input slice (if any) till a predicate is met.\n///\n/// The parser will return the longest slice till the given predicate *(a function that\n/// takes the input and returns a bool)*.\n///\n/// # Streaming Specific\n/// *Streaming version* will return a `Err::Incomplete(Needed::new(1))` if the match reaches the\n/// end of input or if there was not match.\n///\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::bytes::streaming::take_till;\n///\n/// fn till_colon(s: &str) -> IResult<&str, &str> {\n///   take_till(|c| c == ':')(s)\n/// }\n///\n/// assert_eq!(till_colon(\"latin:123\"), Ok((\":123\", \"latin\")));\n/// assert_eq!(till_colon(\":empty matched\"), Ok((\":empty matched\", \"\"))); //allowed\n/// assert_eq!(till_colon(\"12345\"), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(till_colon(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[allow(clippy::redundant_closure)]\npub fn take_till<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| i.split_at_position(|c| cond(c))\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::take_till1":["/// Returns the longest (at least 1) input slice till a predicate is met.\n///\n/// The parser will return the longest slice till the given predicate *(a function that\n/// takes the input and returns a bool)*.\n///\n/// # Streaming Specific\n/// *Streaming version* will return a `Err::Incomplete(Needed::new(1))` if the match reaches the\n/// end of input or if there was not match.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::streaming::take_till1;\n///\n/// fn till_colon(s: &str) -> IResult<&str, &str> {\n///   take_till1(|c| c == ':')(s)\n/// }\n///\n/// assert_eq!(till_colon(\"latin:123\"), Ok((\":123\", \"latin\")));\n/// assert_eq!(till_colon(\":empty matched\"), Err(Err::Error(Error::new(\":empty matched\", ErrorKind::TakeTill1))));\n/// assert_eq!(till_colon(\"12345\"), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(till_colon(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[allow(clippy::redundant_closure)]\npub fn take_till1<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| {\n    let e: ErrorKind = ErrorKind::TakeTill1;\n    i.split_at_position1(|c| cond(c), e)\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::take_until":["/// Returns the input slice up to the first occurrence of the pattern.\n///\n/// It doesn't consume the pattern.\n///\n/// # Streaming Specific\n/// *Streaming version* will return a `Err::Incomplete(Needed::new(N))` if the input doesn't\n/// contain the pattern or if the input is smaller than the pattern.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::bytes::streaming::take_until;\n///\n/// fn until_eof(s: &str) -> IResult<&str, &str> {\n///   take_until(\"eof\")(s)\n/// }\n///\n/// assert_eq!(until_eof(\"hello, worldeof\"), Ok((\"eof\", \"hello, world\")));\n/// assert_eq!(until_eof(\"hello, world\"), Err(Err::Incomplete(Needed::Unknown)));\n/// assert_eq!(until_eof(\"hello, worldeo\"), Err(Err::Incomplete(Needed::Unknown)));\n/// assert_eq!(until_eof(\"1eof2eof\"), Ok((\"eof2eof\", \"1\")));\n/// ```\npub fn take_until<T, I, Error: ParseError<I>>(tag: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + FindSubstring<T>,\n  T: Clone,{\n  move |i: I| {\n    let t = tag.clone();\n\n    let res: IResult<_, _, Error> = match i.find_substring(t) {\n      None => Err(Err::Incomplete(Needed::Unknown)),\n      Some(index) => Ok(i.take_split(index)),\n    };\n    res\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::take_until1":["/// Returns the non empty input slice up to the first occurrence of the pattern.\n///\n/// It doesn't consume the pattern.\n///\n/// # Streaming Specific\n/// *Streaming version* will return a `Err::Incomplete(Needed::new(N))` if the input doesn't\n/// contain the pattern or if the input is smaller than the pattern.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::streaming::take_until1;\n///\n/// fn until_eof(s: &str) -> IResult<&str, &str> {\n///   take_until1(\"eof\")(s)\n/// }\n///\n/// assert_eq!(until_eof(\"hello, worldeof\"), Ok((\"eof\", \"hello, world\")));\n/// assert_eq!(until_eof(\"hello, world\"), Err(Err::Incomplete(Needed::Unknown)));\n/// assert_eq!(until_eof(\"hello, worldeo\"), Err(Err::Incomplete(Needed::Unknown)));\n/// assert_eq!(until_eof(\"1eof2eof\"), Ok((\"eof2eof\", \"1\")));\n/// assert_eq!(until_eof(\"eof\"),  Err(Err::Error(Error::new(\"eof\", ErrorKind::TakeUntil))));\n/// ```\npub fn take_until1<T, I, Error: ParseError<I>>(tag: T) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input + FindSubstring<T>,\n  T: Clone,{\n  move |i: I| {\n    let t = tag.clone();\n\n    let res: IResult<_, _, Error> = match i.find_substring(t) {\n      None => Err(Err::Incomplete(Needed::Unknown)),\n      Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),\n      Some(index) => Ok(i.take_split(index)),\n    };\n    res\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::take_while":["/// Returns the longest input slice (if any) that matches the predicate.\n///\n/// The parser will return the longest slice that matches the given predicate *(a function that\n/// takes the input and returns a bool)*.\n///\n/// # Streaming Specific\n/// *Streaming version* will return a `Err::Incomplete(Needed::new(1))` if the pattern reaches the end of the input.\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::bytes::streaming::take_while;\n/// use nom::character::is_alphabetic;\n///\n/// fn alpha(s: &[u8]) -> IResult<&[u8], &[u8]> {\n///   take_while(is_alphabetic)(s)\n/// }\n///\n/// assert_eq!(alpha(b\"latin123\"), Ok((&b\"123\"[..], &b\"latin\"[..])));\n/// assert_eq!(alpha(b\"12345\"), Ok((&b\"12345\"[..], &b\"\"[..])));\n/// assert_eq!(alpha(b\"latin\"), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(alpha(b\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn take_while<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| i.split_at_position(|c| !cond(c))\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::take_while1":["/// Returns the longest (at least 1) input slice that matches the predicate.\n///\n/// The parser will return the longest slice that matches the given predicate *(a function that\n/// takes the input and returns a bool)*.\n///\n/// It will return an `Err(Err::Error((_, ErrorKind::TakeWhile1)))` if the pattern wasn't met.\n///\n/// # Streaming Specific\n/// *Streaming version* will return a `Err::Incomplete(Needed::new(1))` or if the pattern reaches the end of the input.\n///\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::streaming::take_while1;\n/// use nom::character::is_alphabetic;\n///\n/// fn alpha(s: &[u8]) -> IResult<&[u8], &[u8]> {\n///   take_while1(is_alphabetic)(s)\n/// }\n///\n/// assert_eq!(alpha(b\"latin123\"), Ok((&b\"123\"[..], &b\"latin\"[..])));\n/// assert_eq!(alpha(b\"latin\"), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(alpha(b\"12345\"), Err(Err::Error(Error::new(&b\"12345\"[..], ErrorKind::TakeWhile1))));\n/// ```\npub fn take_while1<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| {\n    let e: ErrorKind = ErrorKind::TakeWhile1;\n    i.split_at_position1(|c| !cond(c), e)\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"bytes::streaming::take_while_m_n":["/// Returns the longest (m <= len <= n) input slice  that matches the predicate.\n///\n/// The parser will return the longest slice that matches the given predicate *(a function that\n/// takes the input and returns a bool)*.\n///\n/// It will return an `Err::Error((_, ErrorKind::TakeWhileMN))` if the pattern wasn't met.\n/// # Streaming Specific\n/// *Streaming version* will return a `Err::Incomplete(Needed::new(1))`  if the pattern reaches the end of the input or is too short.\n///\n/// # Example\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::bytes::streaming::take_while_m_n;\n/// use nom::character::is_alphabetic;\n///\n/// fn short_alpha(s: &[u8]) -> IResult<&[u8], &[u8]> {\n///   take_while_m_n(3, 6, is_alphabetic)(s)\n/// }\n///\n/// assert_eq!(short_alpha(b\"latin123\"), Ok((&b\"123\"[..], &b\"latin\"[..])));\n/// assert_eq!(short_alpha(b\"lengthy\"), Ok((&b\"y\"[..], &b\"length\"[..])));\n/// assert_eq!(short_alpha(b\"latin\"), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(short_alpha(b\"ed\"), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(short_alpha(b\"12345\"), Err(Err::Error(Error::new(&b\"12345\"[..], ErrorKind::TakeWhileMN))));\n/// ```\npub fn take_while_m_n<F, I, Error: ParseError<I>>(\n  m: usize,\n  n: usize,\n  cond: F,\n) -> impl Fn(I) -> IResult<I, I, Error>\nwhere\n  I: Input,\n  F: Fn(<I as Input>::Item) -> bool,{\n  move |i: I| {\n    let input = i;\n\n    for (i, (index, item)) in input.iter_indices().enumerate() {\n      if i == n {\n        return Ok(input.take_split(index));\n      }\n\n      if !cond(item) {\n        if i >= m {\n          return Ok(input.take_split(index));\n        } else {\n          return Err(Err::Error(Error::from_error_kind(\n            input,\n            ErrorKind::TakeWhileMN,\n          )));\n        }\n      }\n    }\n\n    let input_len = input.input_len();\n    let needed = if m > input_len { m - input_len } else { 1 };\n    Err(Err::Incomplete(Needed::new(needed)))\n  }\n}","Real(LocalPath(\"src/bytes/streaming.rs\"))"],"character::complete::alpha0":["/// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z\n///\n/// *Complete version*: Will return the whole input if no terminating token is found (a non\n/// alphabetic character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::complete::alpha0;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     alpha0(input)\n/// }\n///\n/// assert_eq!(parser(\"ab1c\"), Ok((\"1c\", \"ab\")));\n/// assert_eq!(parser(\"1c\"), Ok((\"1c\", \"\")));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// ```\npub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position_complete(|item| !item.is_alpha())\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::alpha1":["/// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z\n///\n/// *Complete version*: Will return an error if there's not enough input data,\n/// or the whole input if no terminating token is found  (a non alphabetic character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::alpha1;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     alpha1(input)\n/// }\n///\n/// assert_eq!(parser(\"aB1c\"), Ok((\"1c\", \"aB\")));\n/// assert_eq!(parser(\"1c\"), Err(Err::Error(Error::new(\"1c\", ErrorKind::Alpha))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Alpha))));\n/// ```\npub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1_complete(|item| !item.is_alpha(), ErrorKind::Alpha)\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::alphanumeric0":["/// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z\n///\n/// *Complete version*: Will return the whole input if no terminating token is found (a non\n/// alphanumerical character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::complete::alphanumeric0;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     alphanumeric0(input)\n/// }\n///\n/// assert_eq!(parser(\"21cZ%1\"), Ok((\"%1\", \"21cZ\")));\n/// assert_eq!(parser(\"&Z21c\"), Ok((\"&Z21c\", \"\")));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// ```\npub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position_complete(|item| !item.is_alphanum())\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::alphanumeric1":["/// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z\n///\n/// *Complete version*: Will return an error if there's not enough input data,\n/// or the whole input if no terminating token is found (a non alphanumerical character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::alphanumeric1;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     alphanumeric1(input)\n/// }\n///\n/// assert_eq!(parser(\"21cZ%1\"), Ok((\"%1\", \"21cZ\")));\n/// assert_eq!(parser(\"&H2\"), Err(Err::Error(Error::new(\"&H2\", ErrorKind::AlphaNumeric))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::AlphaNumeric))));\n/// ```\npub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1_complete(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric)\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::anychar":["/// Matches one byte as a character. Note that the input type will\n/// accept a `str`, but not a `&[u8]`, unlike many other nom parsers.\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{character::complete::anychar, Err, error::{Error, ErrorKind}, IResult};\n/// fn parser(input: &str) -> IResult<&str, char> {\n///     anychar(input)\n/// }\n///\n/// assert_eq!(parser(\"abc\"), Ok((\"bc\",'a')));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Eof))));\n/// ```\npub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  let mut it = input.iter_elements();\n  match it.next() {\n    None => Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof))),\n    Some(c) => Ok((input.take_from(c.len()), c.as_char())),\n  }\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::char":["/// Recognizes one character.\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{ErrorKind, Error}, IResult};\n/// # use nom::character::complete::char;\n/// fn parser(i: &str) -> IResult<&str, char> {\n///     char('a')(i)\n/// }\n/// assert_eq!(parser(\"abc\"), Ok((\"bc\", 'a')));\n/// assert_eq!(parser(\" abc\"), Err(Err::Error(Error::new(\" abc\", ErrorKind::Char))));\n/// assert_eq!(parser(\"bc\"), Err(Err::Error(Error::new(\"bc\", ErrorKind::Char))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Char))));\n/// ```\npub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,{\n  move |i: I| match (i).iter_elements().next().map(|t| {\n    let b = t.as_char() == c;\n    (&c, b)\n  }) {\n    Some((c, true)) => Ok((i.take_from(c.len()), c.as_char())),\n    _ => Err(Err::Error(Error::from_char(i, c))),\n  }\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::crlf":["/// Recognizes the string \"\\r\\n\".\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult};\n/// # use nom::character::complete::crlf;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     crlf(input)\n/// }\n///\n/// assert_eq!(parser(\"\\r\\nc\"), Ok((\"c\", \"\\r\\n\")));\n/// assert_eq!(parser(\"ab\\r\\nc\"), Err(Err::Error(Error::new(\"ab\\r\\nc\", ErrorKind::CrLf))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::CrLf))));\n/// ```\npub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  T: Compare<&'static str>,{\n  match input.compare(\"\\r\\n\") {\n    CompareResult::Ok => Ok(input.take_split(2)),\n    _ => {\n      let e: ErrorKind = ErrorKind::CrLf;\n      Err(Err::Error(E::from_error_kind(input, e)))\n    }\n  }\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::digit0":["/// Recognizes zero or more ASCII numerical characters: 0-9\n///\n/// *Complete version*: Will return an error if there's not enough input data,\n/// or the whole input if no terminating token is found (a non digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::complete::digit0;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     digit0(input)\n/// }\n///\n/// assert_eq!(parser(\"21c\"), Ok((\"c\", \"21\")));\n/// assert_eq!(parser(\"21\"), Ok((\"\", \"21\")));\n/// assert_eq!(parser(\"a21c\"), Ok((\"a21c\", \"\")));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// ```\npub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position_complete(|item| !item.is_dec_digit())\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::digit1":["/// Recognizes one or more ASCII numerical characters: 0-9\n///\n/// *Complete version*: Will return an error if there's not enough input data,\n/// or the whole input if no terminating token is found (a non digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::digit1;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     digit1(input)\n/// }\n///\n/// assert_eq!(parser(\"21c\"), Ok((\"c\", \"21\")));\n/// assert_eq!(parser(\"c1\"), Err(Err::Error(Error::new(\"c1\", ErrorKind::Digit))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Digit))));\n/// ```\n///\n/// ## Parsing an integer\n/// You can use `digit1` in combination with [`map_res`] to parse an integer:\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::combinator::map_res;\n/// # use nom::character::complete::digit1;\n/// fn parser(input: &str) -> IResult<&str, u32> {\n///   map_res(digit1, str::parse)(input)\n/// }\n///\n/// assert_eq!(parser(\"416\"), Ok((\"\", 416)));\n/// assert_eq!(parser(\"12b\"), Ok((\"b\", 12)));\n/// assert!(parser(\"b\").is_err());\n/// ```\n///\n/// [`map_res`]: crate::combinator::map_res\npub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1_complete(|item| !item.is_dec_digit(), ErrorKind::Digit)\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::hex_digit0":["/// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f\n///\n/// *Complete version*: Will return the whole input if no terminating token is found (a non hexadecimal digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::complete::hex_digit0;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     hex_digit0(input)\n/// }\n///\n/// assert_eq!(parser(\"21cZ\"), Ok((\"Z\", \"21c\")));\n/// assert_eq!(parser(\"Z21c\"), Ok((\"Z21c\", \"\")));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// ```\npub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position_complete(|item| !item.is_hex_digit())\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::hex_digit1":["/// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f\n///\n/// *Complete version*: Will return an error if there's not enough input data,\n/// or the whole input if no terminating token is found (a non hexadecimal digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::hex_digit1;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     hex_digit1(input)\n/// }\n///\n/// assert_eq!(parser(\"21cZ\"), Ok((\"Z\", \"21c\")));\n/// assert_eq!(parser(\"H2\"), Err(Err::Error(Error::new(\"H2\", ErrorKind::HexDigit))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::HexDigit))));\n/// ```\npub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1_complete(|item| !item.is_hex_digit(), ErrorKind::HexDigit)\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::i128":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input  + Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n                let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                  let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::i16":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input  + Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n                let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                  let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::i32":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input  + Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n                let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                  let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::i64":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input  + Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n                let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                  let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::i8":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input  + Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n                let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                  let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::line_ending":["/// Recognizes an end of line (both '\\n' and '\\r\\n').\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::line_ending;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     line_ending(input)\n/// }\n///\n/// assert_eq!(parser(\"\\r\\nc\"), Ok((\"c\", \"\\r\\n\")));\n/// assert_eq!(parser(\"ab\\r\\nc\"), Err(Err::Error(Error::new(\"ab\\r\\nc\", ErrorKind::CrLf))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::CrLf))));\n/// ```\npub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input + InputLength,\n  T: Compare<&'static str>,{\n  match input.compare(\"\\n\") {\n    CompareResult::Ok => Ok(input.take_split(1)),\n    CompareResult::Incomplete => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),\n    CompareResult::Error => match input.compare(\"\\r\\n\") {\n      CompareResult::Ok => Ok(input.take_split(2)),\n      _ => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),\n    },\n  }\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::multispace0":["/// Recognizes zero or more spaces, tabs, carriage returns and line feeds.\n///\n/// *Complete version*: will return the whole input if no terminating token is found (a non space\n/// character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::complete::multispace0;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     multispace0(input)\n/// }\n///\n/// assert_eq!(parser(\" \\t\\n\\r21c\"), Ok((\"21c\", \" \\t\\n\\r\")));\n/// assert_eq!(parser(\"Z21c\"), Ok((\"Z21c\", \"\")));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// ```\npub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position_complete(|item| {\n    let c = item.as_char();\n    !(c == ' ' || c == '\\t' || c == '\\r' || c == '\\n')\n  })\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::multispace1":["/// Recognizes one or more spaces, tabs, carriage returns and line feeds.\n///\n/// *Complete version*: will return an error if there's not enough input data,\n/// or the whole input if no terminating token is found (a non space character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::multispace1;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     multispace1(input)\n/// }\n///\n/// assert_eq!(parser(\" \\t\\n\\r21c\"), Ok((\"21c\", \" \\t\\n\\r\")));\n/// assert_eq!(parser(\"H2\"), Err(Err::Error(Error::new(\"H2\", ErrorKind::MultiSpace))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::MultiSpace))));\n/// ```\npub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1_complete(\n    |item| {\n      let c = item.as_char();\n      !(c == ' ' || c == '\\t' || c == '\\r' || c == '\\n')\n    },\n    ErrorKind::MultiSpace,\n  )\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::newline":["/// Matches a newline character '\\n'.\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::newline;\n/// fn parser(input: &str) -> IResult<&str, char> {\n///     newline(input)\n/// }\n///\n/// assert_eq!(parser(\"\\nc\"), Ok((\"c\", '\\n')));\n/// assert_eq!(parser(\"\\r\\nc\"), Err(Err::Error(Error::new(\"\\r\\nc\", ErrorKind::Char))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Char))));\n/// ```\npub fn newline<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,{\n  char('\\n')(input)\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::none_of":["/// Recognizes a character that is not in the provided characters.\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind};\n/// # use nom::character::complete::none_of;\n/// assert_eq!(none_of::<_, _, (&str, ErrorKind)>(\"abc\")(\"z\"), Ok((\"\", 'z')));\n/// assert_eq!(none_of::<_, _, (&str, ErrorKind)>(\"ab\")(\"a\"), Err(Err::Error((\"a\", ErrorKind::NoneOf))));\n/// assert_eq!(none_of::<_, _, (&str, ErrorKind)>(\"a\")(\"\"), Err(Err::Error((\"\", ErrorKind::NoneOf))));\n/// ```\npub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,\n  T: FindToken<<I as Input>::Item>,{\n  move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c))) {\n    Some((c, true)) => Ok((i.take_from(c.len()), c.as_char())),\n    _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),\n  }\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::not_line_ending":["/// Recognizes a string of any char except '\\r\\n' or '\\n'.\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::not_line_ending;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     not_line_ending(input)\n/// }\n///\n/// assert_eq!(parser(\"ab\\r\\nc\"), Ok((\"\\r\\nc\", \"ab\")));\n/// assert_eq!(parser(\"ab\\nc\"), Ok((\"\\nc\", \"ab\")));\n/// assert_eq!(parser(\"abc\"), Ok((\"\", \"abc\")));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// assert_eq!(parser(\"a\\rb\\nc\"), Err(Err::Error(Error { input: \"a\\rb\\nc\", code: ErrorKind::Tag })));\n/// assert_eq!(parser(\"a\\rbc\"), Err(Err::Error(Error { input: \"a\\rbc\", code: ErrorKind::Tag })));\n/// ```\npub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  T: Compare<&'static str>,\n  <T as Input>::Item: AsChar,{\n  match input.position(|item| {\n    let c = item.as_char();\n    c == '\\r' || c == '\\n'\n  }) {\n    None => Ok(input.take_split(input.input_len())),\n    Some(index) => {\n      let mut it = input.take_from(index).iter_elements();\n      let nth = it.next().unwrap().as_char();\n      if nth == '\\r' {\n        let sliced = input.take_from(index);\n        let comp = sliced.compare(\"\\r\\n\");\n        match comp {\n          //FIXME: calculate the right index\n          CompareResult::Ok => Ok(input.take_split(index)),\n          _ => {\n            let e: ErrorKind = ErrorKind::Tag;\n            Err(Err::Error(E::from_error_kind(input, e)))\n          }\n        }\n      } else {\n        Ok(input.take_split(index))\n      }\n    }\n  }\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::oct_digit0":["/// Recognizes zero or more octal characters: 0-7\n///\n/// *Complete version*: Will return the whole input if no terminating token is found (a non octal\n/// digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::complete::oct_digit0;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     oct_digit0(input)\n/// }\n///\n/// assert_eq!(parser(\"21cZ\"), Ok((\"cZ\", \"21\")));\n/// assert_eq!(parser(\"Z21c\"), Ok((\"Z21c\", \"\")));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// ```\npub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position_complete(|item| !item.is_oct_digit())\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::oct_digit1":["/// Recognizes one or more octal characters: 0-7\n///\n/// *Complete version*: Will return an error if there's not enough input data,\n/// or the whole input if no terminating token is found (a non octal digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::oct_digit1;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     oct_digit1(input)\n/// }\n///\n/// assert_eq!(parser(\"21cZ\"), Ok((\"cZ\", \"21\")));\n/// assert_eq!(parser(\"H2\"), Err(Err::Error(Error::new(\"H2\", ErrorKind::OctDigit))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::OctDigit))));\n/// ```\npub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1_complete(|item| !item.is_oct_digit(), ErrorKind::OctDigit)\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::one_of":["/// Recognizes one of the provided characters.\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind};\n/// # use nom::character::complete::one_of;\n/// assert_eq!(one_of::<_, _, (&str, ErrorKind)>(\"abc\")(\"b\"), Ok((\"\", 'b')));\n/// assert_eq!(one_of::<_, _, (&str, ErrorKind)>(\"a\")(\"bc\"), Err(Err::Error((\"bc\", ErrorKind::OneOf))));\n/// assert_eq!(one_of::<_, _, (&str, ErrorKind)>(\"a\")(\"\"), Err(Err::Error((\"\", ErrorKind::OneOf))));\n/// ```\npub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,\n  T: FindToken<<I as Input>::Item>,{\n  move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c))) {\n    Some((c, true)) => Ok((i.take_from(c.len()), c.as_char())),\n    _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),\n  }\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::satisfy":["/// Recognizes one character and checks that it satisfies a predicate\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{ErrorKind, Error}, Needed, IResult};\n/// # use nom::character::complete::satisfy;\n/// fn parser(i: &str) -> IResult<&str, char> {\n///     satisfy(|c| c == 'a' || c == 'b')(i)\n/// }\n/// assert_eq!(parser(\"abc\"), Ok((\"bc\", 'a')));\n/// assert_eq!(parser(\"cd\"), Err(Err::Error(Error::new(\"cd\", ErrorKind::Satisfy))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Satisfy))));\n/// ```\npub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,\n  F: Fn(char) -> bool,{\n  move |i: I| match (i).iter_elements().next().map(|t| {\n    let c = t.as_char();\n    let b = cond(c);\n    (c, b)\n  }) {\n    Some((c, true)) => Ok((i.take_from(c.len()), c)),\n    _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),\n  }\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::sign":["pub(crate) fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E>\nwhere\n  T: Clone + Input,\n  T: for<'a> Compare<&'a [u8]>,{\n  use crate::bytes::complete::tag;\n  use crate::combinator::value;\n\n  let (i, opt_sign) = opt(alt((\n    value(false, tag(&b\"-\"[..])),\n    value(true, tag(&b\"+\"[..])),\n  )))(input)?;\n  let sign = opt_sign.unwrap_or(true);\n\n  Ok((i, sign))\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::space0":["/// Recognizes zero or more spaces and tabs.\n///\n/// *Complete version*: Will return the whole input if no terminating token is found (a non space\n/// character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::complete::space0;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     space0(input)\n/// }\n///\n/// assert_eq!(parser(\" \\t21c\"), Ok((\"21c\", \" \\t\")));\n/// assert_eq!(parser(\"Z21c\"), Ok((\"Z21c\", \"\")));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// ```\npub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar + Clone,{\n  input.split_at_position_complete(|item| {\n    let c = item.as_char();\n    !(c == ' ' || c == '\\t')\n  })\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::space1":["/// Recognizes one or more spaces and tabs.\n///\n/// *Complete version*: Will return an error if there's not enough input data,\n/// or the whole input if no terminating token is found (a non space character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::space1;\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///     space1(input)\n/// }\n///\n/// assert_eq!(parser(\" \\t21c\"), Ok((\"21c\", \" \\t\")));\n/// assert_eq!(parser(\"H2\"), Err(Err::Error(Error::new(\"H2\", ErrorKind::Space))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Space))));\n/// ```\npub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1_complete(\n    |item| {\n      let c = item.as_char();\n      !(c == ' ' || c == '\\t')\n    },\n    ErrorKind::Space,\n  )\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::tab":["/// Matches a tab character '\\t'.\n///\n/// *Complete version*: Will return an error if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::complete::tab;\n/// fn parser(input: &str) -> IResult<&str, char> {\n///     tab(input)\n/// }\n///\n/// assert_eq!(parser(\"\\tc\"), Ok((\"c\", '\\t')));\n/// assert_eq!(parser(\"\\r\\nc\"), Err(Err::Error(Error::new(\"\\r\\nc\", ErrorKind::Char))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Char))));\n/// ```\npub fn tab<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,{\n  char('\\t')(input)\n}","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::u128":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::u16":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::u32":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::u64":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::complete::u8":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Ok((i.take_from(i.input_len()), value))\n            }","Real(LocalPath(\"src/character/complete.rs\"))"],"character::is_alphabetic":["/// Tests if byte is ASCII alphabetic: A-Z, a-z\n///\n/// # Example\n///\n/// ```\n/// # use nom::character::is_alphabetic;\n/// assert_eq!(is_alphabetic(b'9'), false);\n/// assert_eq!(is_alphabetic(b'a'), true);\n/// ```\n#[inline]\npub fn is_alphabetic(chr: u8) -> bool{\n  matches!(chr, 0x41..=0x5A | 0x61..=0x7A)\n}","Real(LocalPath(\"src/character/mod.rs\"))"],"character::is_alphanumeric":["/// Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9\n///\n/// # Example\n///\n/// ```\n/// # use nom::character::is_alphanumeric;\n/// assert_eq!(is_alphanumeric(b'-'), false);\n/// assert_eq!(is_alphanumeric(b'a'), true);\n/// assert_eq!(is_alphanumeric(b'9'), true);\n/// assert_eq!(is_alphanumeric(b'A'), true);\n/// ```\n#[inline]\npub fn is_alphanumeric(chr: u8) -> bool{\n  is_alphabetic(chr) || is_digit(chr)\n}","Real(LocalPath(\"src/character/mod.rs\"))"],"character::is_digit":["/// Tests if byte is ASCII digit: 0-9\n///\n/// # Example\n///\n/// ```\n/// # use nom::character::is_digit;\n/// assert_eq!(is_digit(b'a'), false);\n/// assert_eq!(is_digit(b'9'), true);\n/// ```\n#[inline]\npub fn is_digit(chr: u8) -> bool{\n  matches!(chr, 0x30..=0x39)\n}","Real(LocalPath(\"src/character/mod.rs\"))"],"character::is_hex_digit":["/// Tests if byte is ASCII hex digit: 0-9, A-F, a-f\n///\n/// # Example\n///\n/// ```\n/// # use nom::character::is_hex_digit;\n/// assert_eq!(is_hex_digit(b'a'), true);\n/// assert_eq!(is_hex_digit(b'9'), true);\n/// assert_eq!(is_hex_digit(b'A'), true);\n/// assert_eq!(is_hex_digit(b'x'), false);\n/// ```\n#[inline]\npub fn is_hex_digit(chr: u8) -> bool{\n  matches!(chr, 0x30..=0x39 | 0x41..=0x46 | 0x61..=0x66)\n}","Real(LocalPath(\"src/character/mod.rs\"))"],"character::is_newline":["/// Tests if byte is ASCII newline: \\n\n///\n/// # Example\n///\n/// ```\n/// # use nom::character::is_newline;\n/// assert_eq!(is_newline(b'\\n'), true);\n/// assert_eq!(is_newline(b'\\r'), false);\n/// assert_eq!(is_newline(b' '), false);\n/// assert_eq!(is_newline(b'\\t'), false);\n/// ```\n#[inline]\npub fn is_newline(chr: u8) -> bool{\n  chr == b'\\n'\n}","Real(LocalPath(\"src/character/mod.rs\"))"],"character::is_oct_digit":["/// Tests if byte is ASCII octal digit: 0-7\n///\n/// # Example\n///\n/// ```\n/// # use nom::character::is_oct_digit;\n/// assert_eq!(is_oct_digit(b'a'), false);\n/// assert_eq!(is_oct_digit(b'9'), false);\n/// assert_eq!(is_oct_digit(b'6'), true);\n/// ```\n#[inline]\npub fn is_oct_digit(chr: u8) -> bool{\n  matches!(chr, 0x30..=0x37)\n}","Real(LocalPath(\"src/character/mod.rs\"))"],"character::is_space":["/// Tests if byte is ASCII space or tab\n///\n/// # Example\n///\n/// ```\n/// # use nom::character::is_space;\n/// assert_eq!(is_space(b'\\n'), false);\n/// assert_eq!(is_space(b'\\r'), false);\n/// assert_eq!(is_space(b' '), true);\n/// assert_eq!(is_space(b'\\t'), true);\n/// ```\n#[inline]\npub fn is_space(chr: u8) -> bool{\n  chr == b' ' || chr == b'\\t'\n}","Real(LocalPath(\"src/character/mod.rs\"))"],"character::streaming::alpha0":["/// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non alphabetic character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::alpha0;\n/// assert_eq!(alpha0::<_, (_, ErrorKind)>(\"ab1c\"), Ok((\"1c\", \"ab\")));\n/// assert_eq!(alpha0::<_, (_, ErrorKind)>(\"1c\"), Ok((\"1c\", \"\")));\n/// assert_eq!(alpha0::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position(|item| !item.is_alpha())\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::alpha1":["/// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non alphabetic character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::alpha1;\n/// assert_eq!(alpha1::<_, (_, ErrorKind)>(\"aB1c\"), Ok((\"1c\", \"aB\")));\n/// assert_eq!(alpha1::<_, (_, ErrorKind)>(\"1c\"), Err(Err::Error((\"1c\", ErrorKind::Alpha))));\n/// assert_eq!(alpha1::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1(|item| !item.is_alpha(), ErrorKind::Alpha)\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::alphanumeric0":["/// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non alphanumerical character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::alphanumeric0;\n/// assert_eq!(alphanumeric0::<_, (_, ErrorKind)>(\"21cZ%1\"), Ok((\"%1\", \"21cZ\")));\n/// assert_eq!(alphanumeric0::<_, (_, ErrorKind)>(\"&Z21c\"), Ok((\"&Z21c\", \"\")));\n/// assert_eq!(alphanumeric0::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position(|item| !item.is_alphanum())\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::alphanumeric1":["/// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non alphanumerical character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::alphanumeric1;\n/// assert_eq!(alphanumeric1::<_, (_, ErrorKind)>(\"21cZ%1\"), Ok((\"%1\", \"21cZ\")));\n/// assert_eq!(alphanumeric1::<_, (_, ErrorKind)>(\"&H2\"), Err(Err::Error((\"&H2\", ErrorKind::AlphaNumeric))));\n/// assert_eq!(alphanumeric1::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric)\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::anychar":["/// Matches one byte as a character. Note that the input type will\n/// accept a `str`, but not a `&[u8]`, unlike many other nom parsers.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{character::streaming::anychar, Err, error::ErrorKind, IResult, Needed};\n/// assert_eq!(anychar::<_, (_, ErrorKind)>(\"abc\"), Ok((\"bc\",'a')));\n/// assert_eq!(anychar::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  let mut it = input.iter_elements();\n  match it.next() {\n    None => Err(Err::Incomplete(Needed::new(1))),\n    Some(c) => Ok((input.take_from(c.len()), c.as_char())),\n  }\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::char":["/// Recognizes one character.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{ErrorKind, Error}, Needed, IResult};\n/// # use nom::character::streaming::char;\n/// fn parser(i: &str) -> IResult<&str, char> {\n///     char('a')(i)\n/// }\n/// assert_eq!(parser(\"abc\"), Ok((\"bc\", 'a')));\n/// assert_eq!(parser(\"bc\"), Err(Err::Error(Error::new(\"bc\", ErrorKind::Char))));\n/// assert_eq!(parser(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,{\n  move |i: I| match (i).iter_elements().next().map(|t| {\n    let b = t.as_char() == c;\n    (&c, b)\n  }) {\n    None => Err(Err::Incomplete(Needed::new(c.len() - i.input_len()))),\n    Some((_, false)) => Err(Err::Error(Error::from_char(i, c))),\n    Some((c, true)) => Ok((i.take_from(c.len()), c.as_char())),\n  }\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::crlf":["/// Recognizes the string \"\\r\\n\".\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::crlf;\n/// assert_eq!(crlf::<_, (_, ErrorKind)>(\"\\r\\nc\"), Ok((\"c\", \"\\r\\n\")));\n/// assert_eq!(crlf::<_, (_, ErrorKind)>(\"ab\\r\\nc\"), Err(Err::Error((\"ab\\r\\nc\", ErrorKind::CrLf))));\n/// assert_eq!(crlf::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(2))));\n/// ```\npub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  T: Compare<&'static str>,{\n  match input.compare(\"\\r\\n\") {\n    //FIXME: is this the right index?\n    CompareResult::Ok => Ok(input.take_split(2)),\n    CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),\n    CompareResult::Error => {\n      let e: ErrorKind = ErrorKind::CrLf;\n      Err(Err::Error(E::from_error_kind(input, e)))\n    }\n  }\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::digit0":["/// Recognizes zero or more ASCII numerical characters: 0-9\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::digit0;\n/// assert_eq!(digit0::<_, (_, ErrorKind)>(\"21c\"), Ok((\"c\", \"21\")));\n/// assert_eq!(digit0::<_, (_, ErrorKind)>(\"a21c\"), Ok((\"a21c\", \"\")));\n/// assert_eq!(digit0::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position(|item| !item.is_dec_digit())\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::digit1":["/// Recognizes one or more ASCII numerical characters: 0-9\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::digit1;\n/// assert_eq!(digit1::<_, (_, ErrorKind)>(\"21c\"), Ok((\"c\", \"21\")));\n/// assert_eq!(digit1::<_, (_, ErrorKind)>(\"c1\"), Err(Err::Error((\"c1\", ErrorKind::Digit))));\n/// assert_eq!(digit1::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1(|item| !item.is_dec_digit(), ErrorKind::Digit)\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::hex_digit0":["/// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non hexadecimal digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::hex_digit0;\n/// assert_eq!(hex_digit0::<_, (_, ErrorKind)>(\"21cZ\"), Ok((\"Z\", \"21c\")));\n/// assert_eq!(hex_digit0::<_, (_, ErrorKind)>(\"Z21c\"), Ok((\"Z21c\", \"\")));\n/// assert_eq!(hex_digit0::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position(|item| !item.is_hex_digit())\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::hex_digit1":["/// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non hexadecimal digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::hex_digit1;\n/// assert_eq!(hex_digit1::<_, (_, ErrorKind)>(\"21cZ\"), Ok((\"Z\", \"21c\")));\n/// assert_eq!(hex_digit1::<_, (_, ErrorKind)>(\"H2\"), Err(Err::Error((\"H2\", ErrorKind::HexDigit))));\n/// assert_eq!(hex_digit1::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1(|item| !item.is_hex_digit(), ErrorKind::HexDigit)\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::i128":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input +  Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n              let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::i16":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input +  Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n              let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::i32":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input +  Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n              let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::i64":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input +  Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n              let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::i8":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input +  Clone,\n            <T as Input>::Item: AsChar,\n            T: for <'a> Compare<&'a[u8]>,{\n              let (i, sign) = sign(input.clone())?;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                if sign {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                } else {\n                    let mut pos = 0;\n                    for c in i.iter_elements() {\n                        match c.as_char().to_digit(10) {\n                            None => {\n                                if pos == 0 {\n                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));\n                                } else {\n                                    return Ok((i.take_from(pos), value));\n                                }\n                            },\n                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {\n                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),\n                                Some(v) => {\n                                  pos += c.len();\n                                  value = v;\n                                },\n                            }\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::line_ending":["/// Recognizes an end of line (both '\\n' and '\\r\\n').\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::line_ending;\n/// assert_eq!(line_ending::<_, (_, ErrorKind)>(\"\\r\\nc\"), Ok((\"c\", \"\\r\\n\")));\n/// assert_eq!(line_ending::<_, (_, ErrorKind)>(\"ab\\r\\nc\"), Err(Err::Error((\"ab\\r\\nc\", ErrorKind::CrLf))));\n/// assert_eq!(line_ending::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  T: Compare<&'static str>,{\n  match input.compare(\"\\n\") {\n    CompareResult::Ok => Ok(input.take_split(1)),\n    CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(1))),\n    CompareResult::Error => {\n      match input.compare(\"\\r\\n\") {\n        //FIXME: is this the right index?\n        CompareResult::Ok => Ok(input.take_split(2)),\n        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),\n        CompareResult::Error => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),\n      }\n    }\n  }\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::multispace0":["/// Recognizes zero or more spaces, tabs, carriage returns and line feeds.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non space character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::multispace0;\n/// assert_eq!(multispace0::<_, (_, ErrorKind)>(\" \\t\\n\\r21c\"), Ok((\"21c\", \" \\t\\n\\r\")));\n/// assert_eq!(multispace0::<_, (_, ErrorKind)>(\"Z21c\"), Ok((\"Z21c\", \"\")));\n/// assert_eq!(multispace0::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position(|item| {\n    let c = item.as_char();\n    !(c == ' ' || c == '\\t' || c == '\\r' || c == '\\n')\n  })\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::multispace1":["/// Recognizes one or more spaces, tabs, carriage returns and line feeds.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non space character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::multispace1;\n/// assert_eq!(multispace1::<_, (_, ErrorKind)>(\" \\t\\n\\r21c\"), Ok((\"21c\", \" \\t\\n\\r\")));\n/// assert_eq!(multispace1::<_, (_, ErrorKind)>(\"H2\"), Err(Err::Error((\"H2\", ErrorKind::MultiSpace))));\n/// assert_eq!(multispace1::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1(\n    |item| {\n      let c = item.as_char();\n      !(c == ' ' || c == '\\t' || c == '\\r' || c == '\\n')\n    },\n    ErrorKind::MultiSpace,\n  )\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::newline":["/// Matches a newline character '\\\\n'.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::newline;\n/// assert_eq!(newline::<_, (_, ErrorKind)>(\"\\nc\"), Ok((\"c\", '\\n')));\n/// assert_eq!(newline::<_, (_, ErrorKind)>(\"\\r\\nc\"), Err(Err::Error((\"\\r\\nc\", ErrorKind::Char))));\n/// assert_eq!(newline::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn newline<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,{\n  char('\\n')(input)\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::none_of":["/// Recognizes a character that is not in the provided characters.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::character::streaming::none_of;\n/// assert_eq!(none_of::<_, _, (_, ErrorKind)>(\"abc\")(\"z\"), Ok((\"\", 'z')));\n/// assert_eq!(none_of::<_, _, (_, ErrorKind)>(\"ab\")(\"a\"), Err(Err::Error((\"a\", ErrorKind::NoneOf))));\n/// assert_eq!(none_of::<_, _, (_, ErrorKind)>(\"a\")(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,\n  T: FindToken<<I as Input>::Item>,{\n  move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c))) {\n    None => Err(Err::Incomplete(Needed::new(1))),\n    Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),\n    Some((c, true)) => Ok((i.take_from(c.len()), c.as_char())),\n  }\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::not_line_ending":["/// Recognizes a string of any char except '\\r\\n' or '\\n'.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult, Needed};\n/// # use nom::character::streaming::not_line_ending;\n/// assert_eq!(not_line_ending::<_, (_, ErrorKind)>(\"ab\\r\\nc\"), Ok((\"\\r\\nc\", \"ab\")));\n/// assert_eq!(not_line_ending::<_, (_, ErrorKind)>(\"abc\"), Err(Err::Incomplete(Needed::Unknown)));\n/// assert_eq!(not_line_ending::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::Unknown)));\n/// assert_eq!(not_line_ending::<_, (_, ErrorKind)>(\"a\\rb\\nc\"), Err(Err::Error((\"a\\rb\\nc\", ErrorKind::Tag ))));\n/// assert_eq!(not_line_ending::<_, (_, ErrorKind)>(\"a\\rbc\"), Err(Err::Error((\"a\\rbc\", ErrorKind::Tag ))));\n/// ```\npub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  T: Compare<&'static str>,\n  <T as Input>::Item: AsChar,{\n  match input.position(|item| {\n    let c = item.as_char();\n    c == '\\r' || c == '\\n'\n  }) {\n    None => Err(Err::Incomplete(Needed::Unknown)),\n    Some(index) => {\n      let mut it = input.take_from(index).iter_elements();\n      let nth = it.next().unwrap().as_char();\n      if nth == '\\r' {\n        let sliced = input.take_from(index);\n        let comp = sliced.compare(\"\\r\\n\");\n        match comp {\n          //FIXME: calculate the right index\n          CompareResult::Incomplete => Err(Err::Incomplete(Needed::Unknown)),\n          CompareResult::Error => {\n            let e: ErrorKind = ErrorKind::Tag;\n            Err(Err::Error(E::from_error_kind(input, e)))\n          }\n          CompareResult::Ok => Ok(input.take_split(index)),\n        }\n      } else {\n        Ok(input.take_split(index))\n      }\n    }\n  }\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::oct_digit0":["/// Recognizes zero or more octal characters: 0-7\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non octal digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::oct_digit0;\n/// assert_eq!(oct_digit0::<_, (_, ErrorKind)>(\"21cZ\"), Ok((\"cZ\", \"21\")));\n/// assert_eq!(oct_digit0::<_, (_, ErrorKind)>(\"Z21c\"), Ok((\"Z21c\", \"\")));\n/// assert_eq!(oct_digit0::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position(|item| !item.is_oct_digit())\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::oct_digit1":["/// Recognizes one or more octal characters: 0-7\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non octal digit character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::oct_digit1;\n/// assert_eq!(oct_digit1::<_, (_, ErrorKind)>(\"21cZ\"), Ok((\"cZ\", \"21\")));\n/// assert_eq!(oct_digit1::<_, (_, ErrorKind)>(\"H2\"), Err(Err::Error((\"H2\", ErrorKind::OctDigit))));\n/// assert_eq!(oct_digit1::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1(|item| !item.is_oct_digit(), ErrorKind::OctDigit)\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::one_of":["/// Recognizes one of the provided characters.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::character::streaming::one_of;\n/// assert_eq!(one_of::<_, _, (_, ErrorKind)>(\"abc\")(\"b\"), Ok((\"\", 'b')));\n/// assert_eq!(one_of::<_, _, (_, ErrorKind)>(\"a\")(\"bc\"), Err(Err::Error((\"bc\", ErrorKind::OneOf))));\n/// assert_eq!(one_of::<_, _, (_, ErrorKind)>(\"a\")(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,\n  T: FindToken<<I as Input>::Item>,{\n  move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c))) {\n    None => Err(Err::Incomplete(Needed::new(1))),\n    Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),\n    Some((c, true)) => Ok((i.take_from(c.len()), c.as_char())),\n  }\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::satisfy":["/// Recognizes one character and checks that it satisfies a predicate\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::{ErrorKind, Error}, Needed, IResult};\n/// # use nom::character::streaming::satisfy;\n/// fn parser(i: &str) -> IResult<&str, char> {\n///     satisfy(|c| c == 'a' || c == 'b')(i)\n/// }\n/// assert_eq!(parser(\"abc\"), Ok((\"bc\", 'a')));\n/// assert_eq!(parser(\"cd\"), Err(Err::Error(Error::new(\"cd\", ErrorKind::Satisfy))));\n/// assert_eq!(parser(\"\"), Err(Err::Incomplete(Needed::Unknown)));\n/// ```\npub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,\n  F: Fn(char) -> bool,{\n  move |i: I| match (i).iter_elements().next().map(|t| {\n    let c = t.as_char();\n    let b = cond(c);\n    (c, b)\n  }) {\n    None => Err(Err::Incomplete(Needed::Unknown)),\n    Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),\n    Some((c, true)) => Ok((i.take_from(c.len()), c)),\n  }\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::sign":["pub(crate) fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E>\nwhere\n  T: Clone + Input,\n  T: for<'a> Compare<&'a [u8]>,{\n  use crate::bytes::streaming::tag;\n  use crate::combinator::value;\n\n  let (i, opt_sign) = opt(alt((\n    value(false, tag(&b\"-\"[..])),\n    value(true, tag(&b\"+\"[..])),\n  )))(input)?;\n  let sign = opt_sign.unwrap_or(true);\n\n  Ok((i, sign))\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::space0":["/// Recognizes zero or more spaces and tabs.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non space character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::space0;\n/// assert_eq!(space0::<_, (_, ErrorKind)>(\" \\t21c\"), Ok((\"21c\", \" \\t\")));\n/// assert_eq!(space0::<_, (_, ErrorKind)>(\"Z21c\"), Ok((\"Z21c\", \"\")));\n/// assert_eq!(space0::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position(|item| {\n    let c = item.as_char();\n    !(c == ' ' || c == '\\t')\n  })\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::space1":["/// Recognizes one or more spaces and tabs.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data,\n/// or if no terminating token is found (a non space character).\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::space1;\n/// assert_eq!(space1::<_, (_, ErrorKind)>(\" \\t21c\"), Ok((\"21c\", \" \\t\")));\n/// assert_eq!(space1::<_, (_, ErrorKind)>(\"H2\"), Err(Err::Error((\"H2\", ErrorKind::Space))));\n/// assert_eq!(space1::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  input.split_at_position1(\n    |item| {\n      let c = item.as_char();\n      !(c == ' ' || c == '\\t')\n    },\n    ErrorKind::Space,\n  )\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::tab":["/// Matches a tab character '\\t'.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there's not enough input data.\n/// # Example\n///\n/// ```\n/// # use nom::{Err, error::ErrorKind, IResult, Needed};\n/// # use nom::character::streaming::tab;\n/// assert_eq!(tab::<_, (_, ErrorKind)>(\"\\tc\"), Ok((\"c\", '\\t')));\n/// assert_eq!(tab::<_, (_, ErrorKind)>(\"\\r\\nc\"), Err(Err::Error((\"\\r\\nc\", ErrorKind::Char))));\n/// assert_eq!(tab::<_, (_, ErrorKind)>(\"\"), Err(Err::Incomplete(Needed::new(1))));\n/// ```\npub fn tab<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,{\n  char('\\t')(input)\n}","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::u128":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::u16":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::u32":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::u64":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"character::streaming::u8":["/// will parse a number in text form to a number\n///\n/// *Complete version*: can parse until the end of input.\npub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>\n            where\n            T: Input ,\n            <T as Input>::Item: AsChar,{\n                let i = input;\n\n                if i.input_len() == 0 {\n                    return Err(Err::Incomplete(Needed::new(1)));\n                }\n\n                let mut value: $t = 0;\n                let mut pos = 0;\n                for c in i.iter_elements() {\n                    match c.as_char().to_digit(10) {\n                        None => {\n                            if pos == 0 {\n                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));\n                            } else {\n                                return Ok((i.take_from(pos), value));\n                            }\n                        },\n                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {\n                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),\n                            Some(v) => {\n                              pos += c.len();\n                              value = v;\n                            },\n                        }\n                    }\n                }\n\n                Err(Err::Incomplete(Needed::new(1)))\n            }","Real(LocalPath(\"src/character/streaming.rs\"))"],"combinator::ParserIterator":["/// Main structure associated to the [iterator] function.\npub struct ParserIterator<I, E, F> {\n  iterator: F,\n  input: I,\n  state: Option<State<E>>,\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::ParserIterator::<I, E, F>::finish":["/// Returns the remaining input if parsing was successful, or the error if we encountered an error.\npub fn finish(mut self) -> IResult<I, (), E>{\n    match self.state.take().unwrap() {\n      State::Running | State::Done => Ok((self.input, ())),\n      State::Failure(e) => Err(Err::Failure(e)),\n      State::Incomplete(i) => Err(Err::Incomplete(i)),\n    }\n  }","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::State":["enum State<E> {\n  Running,\n  Done,\n  Failure(E),\n  Incomplete(Needed),\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::all_consuming":["/// Succeeds if all the input has been consumed by its child parser.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::combinator::all_consuming;\n/// use nom::character::complete::alpha1;\n/// # fn main() {\n///\n/// let mut parser = all_consuming(alpha1);\n///\n/// assert_eq!(parser(\"abcd\"), Ok((\"\", \"abcd\")));\n/// assert_eq!(parser(\"abcd;\"),Err(Err::Error((\";\", ErrorKind::Eof))));\n/// assert_eq!(parser(\"123abcd;\"),Err(Err::Error((\"123abcd;\", ErrorKind::Alpha))));\n/// # }\n/// ```\npub fn all_consuming<I, E: ParseError<I>, F>(\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, <F as Parser<I>>::Output, E>\nwhere\n  I: InputLength,\n  F: Parser<I, Error = E>,{\n  move |input: I| {\n    let (input, res) = f.parse(input)?;\n    if input.input_len() == 0 {\n      Ok((input, res))\n    } else {\n      Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof)))\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::complete":["/// Transforms Incomplete into `Error`.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::bytes::streaming::take;\n/// use nom::combinator::complete;\n/// # fn main() {\n///\n/// let mut parser = complete(take(5u8));\n///\n/// assert_eq!(parser(\"abcdefg\"), Ok((\"fg\", \"abcde\")));\n/// assert_eq!(parser(\"abcd\"), Err(Err::Error((\"abcd\", ErrorKind::Complete))));\n/// # }\n/// ```\npub fn complete<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Output = O, Error = E>,{\n  move |input: I| {\n    let i = input.clone();\n    match f.parse(input) {\n      Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),\n      rest => rest,\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::cond":["/// Calls the parser if the condition is met.\n///\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, IResult};\n/// use nom::combinator::cond;\n/// use nom::character::complete::alpha1;\n/// # fn main() {\n///\n/// fn parser(b: bool, i: &str) -> IResult<&str, Option<&str>> {\n///   cond(b, alpha1)(i)\n/// }\n///\n/// assert_eq!(parser(true, \"abcd;\"), Ok((\";\", Some(\"abcd\"))));\n/// assert_eq!(parser(false, \"abcd;\"), Ok((\"abcd;\", None)));\n/// assert_eq!(parser(true, \"123;\"), Err(Err::Error(Error::new(\"123;\", ErrorKind::Alpha))));\n/// assert_eq!(parser(false, \"123;\"), Ok((\"123;\", None)));\n/// # }\n/// ```\npub fn cond<I, E: ParseError<I>, F>(\n  b: bool,\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, Option<<F as Parser<I>>::Output>, E>\nwhere\n  F: Parser<I, Error = E>,{\n  move |input: I| {\n    if b {\n      match f.parse(input) {\n        Ok((i, o)) => Ok((i, Some(o))),\n        Err(e) => Err(e),\n      }\n    } else {\n      Ok((input, None))\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::consumed":["/// if the child parser was successful, return the consumed input with the output\n/// as a tuple. Functions similarly to [recognize](fn.recognize.html) except it\n/// returns the parser output as well.\n///\n/// This can be useful especially in cases where the output is not the same type\n/// as the input, or the input is a user defined type.\n///\n/// Returned tuple is of the format `(consumed input, produced output)`.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::combinator::{consumed, value, recognize, map};\n/// use nom::character::complete::{char, alpha1};\n/// use nom::bytes::complete::tag;\n/// use nom::sequence::separated_pair;\n///\n/// fn inner_parser(input: &str) -> IResult<&str, bool> {\n///     value(true, tag(\"1234\"))(input)\n/// }\n///\n/// # fn main() {\n///\n/// let mut consumed_parser = consumed(value(true, separated_pair(alpha1, char(','), alpha1)));\n///\n/// assert_eq!(consumed_parser(\"abcd,efgh1\"), Ok((\"1\", (\"abcd,efgh\", true))));\n/// assert_eq!(consumed_parser(\"abcd;\"),Err(Err::Error((\";\", ErrorKind::Char))));\n///\n///\n/// // the first output (representing the consumed input)\n/// // should be the same as that of the `recognize` parser.\n/// let mut recognize_parser = recognize(inner_parser);\n/// let mut consumed_parser = map(consumed(inner_parser), |(consumed, output)| consumed);\n///\n/// assert_eq!(recognize_parser(\"1234\"), consumed_parser(\"1234\"));\n/// assert_eq!(recognize_parser(\"abcd\"), consumed_parser(\"abcd\"));\n/// # }\n/// ```\npub fn consumed<I, F, E>(\n  mut parser: F,\n) -> impl FnMut(I) -> IResult<I, (I, <F as Parser<I>>::Output), E>\nwhere\n  I: Clone + Offset + Input,\n  E: ParseError<I>,\n  F: Parser<I, Error = E>,{\n  move |input: I| {\n    let i = input.clone();\n    match parser.parse(i) {\n      Ok((remaining, result)) => {\n        let index = input.offset(&remaining);\n        let consumed = input.take(index);\n        Ok((remaining, (consumed, result)))\n      }\n      Err(e) => Err(e),\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::cut":["/// Transforms an [`Err::Error`] (recoverable) to [`Err::Failure`] (unrecoverable)\n///\n/// This commits the parse result, preventing alternative branch paths like with\n/// [`nom::branch::alt`][crate::branch::alt].\n///\n/// # Example\n///\n/// Without `cut`:\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// # use nom::character::complete::{one_of, digit1};\n/// # use nom::combinator::rest;\n/// # use nom::branch::alt;\n/// # use nom::sequence::preceded;\n/// # fn main() {\n///\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///   alt((\n///     preceded(one_of(\"+-\"), digit1),\n///     rest\n///   ))(input)\n/// }\n///\n/// assert_eq!(parser(\"+10 ab\"), Ok((\" ab\", \"10\")));\n/// assert_eq!(parser(\"ab\"), Ok((\"\", \"ab\")));\n/// assert_eq!(parser(\"+\"), Ok((\"\", \"+\")));\n/// # }\n/// ```\n///\n/// With `cut`:\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult, error::Error};\n/// # use nom::character::complete::{one_of, digit1};\n/// # use nom::combinator::rest;\n/// # use nom::branch::alt;\n/// # use nom::sequence::preceded;\n/// use nom::combinator::cut;\n/// # fn main() {\n///\n/// fn parser(input: &str) -> IResult<&str, &str> {\n///   alt((\n///     preceded(one_of(\"+-\"), cut(digit1)),\n///     rest\n///   ))(input)\n/// }\n///\n/// assert_eq!(parser(\"+10 ab\"), Ok((\" ab\", \"10\")));\n/// assert_eq!(parser(\"ab\"), Ok((\"\", \"ab\")));\n/// assert_eq!(parser(\"+\"), Err(Err::Failure(Error { input: \"\", code: ErrorKind::Digit })));\n/// # }\n/// ```\npub fn cut<I, E: ParseError<I>, F>(\n  mut parser: F,\n) -> impl FnMut(I) -> IResult<I, <F as Parser<I>>::Output, E>\nwhere\n  F: Parser<I, Error = E>,{\n  move |input: I| match parser.parse(input) {\n    Err(Err::Error(e)) => Err(Err::Failure(e)),\n    rest => rest,\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::eof":["/// returns its input if it is at the end of input data\n///\n/// When we're at the end of the data, this combinator\n/// will succeed\n///\n/// ```\n/// # use std::str;\n/// # use nom::{Err, error::ErrorKind, IResult};\n/// # use nom::combinator::eof;\n///\n/// # fn main() {\n/// let parser = eof;\n/// assert_eq!(parser(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Eof))));\n/// assert_eq!(parser(\"\"), Ok((\"\", \"\")));\n/// # }\n/// ```\npub fn eof<I: InputLength + Clone, E: ParseError<I>>(input: I) -> IResult<I, I, E>{\n  if input.input_len() == 0 {\n    let clone = input.clone();\n    Ok((input, clone))\n  } else {\n    Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof)))\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::fail":["/// A parser which always fails.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, IResult};\n/// use nom::combinator::fail;\n///\n/// let s = \"string\";\n/// assert_eq!(fail::<_, &str, _>(s), Err(Err::Error((s, ErrorKind::Fail))));\n/// ```\npub fn fail<I, O, E: ParseError<I>>(i: I) -> IResult<I, O, E>{\n  Err(Err::Error(E::from_error_kind(i, ErrorKind::Fail)))\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::flat_map":["/// Creates a new parser from the output of the first parser, then apply that parser over the rest of the input.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::bytes::complete::take;\n/// use nom::number::complete::u8;\n/// use nom::combinator::flat_map;\n/// # fn main() {\n///\n/// let mut parse = flat_map(u8, take);\n///\n/// assert_eq!(parse(&[2, 0, 1, 2][..]), Ok((&[2][..], &[0, 1][..])));\n/// assert_eq!(parse(&[4, 0, 1, 2][..]), Err(Err::Error((&[0, 1, 2][..], ErrorKind::Eof))));\n/// # }\n/// ```\npub fn flat_map<I, O, E: ParseError<I>, F, G, H>(\n  mut parser: F,\n  mut applied_parser: G,\n) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Error = E>,\n  G: FnMut(<F as Parser<I>>::Output) -> H,\n  H: Parser<I, Output = O, Error = E>,{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    applied_parser(o1).parse(input)\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::into":["/// automatically converts the child parser's result to another type\n///\n/// it will be able to convert the output value and the error value\n/// as long as the `Into` implementations are available\n///\n/// ```rust\n/// # use nom::IResult;\n/// use nom::combinator::into;\n/// use nom::character::complete::alpha1;\n/// # fn main() {\n///\n///  fn parser1(i: &str) -> IResult<&str, &str> {\n///    alpha1(i)\n///  }\n///\n///  let mut parser2 = into(parser1);\n///\n/// // the parser converts the &str output of the child parser into a Vec<u8>\n/// let bytes: IResult<&str, Vec<u8>> = parser2(\"abcd\");\n/// assert_eq!(bytes, Ok((\"\", vec![97, 98, 99, 100])));\n/// # }\n/// ```\npub fn into<I, O1, O2, E1, E2, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O2, E2>\nwhere\n  O1: Into<O2>,\n  E1: Into<E2>,\n  E1: ParseError<I>,\n  E2: ParseError<I>,\n  F: Parser<I, Output = O1, Error = E1>,{\n  //map(parser, Into::into)\n  move |input: I| match parser.parse(input) {\n    Ok((i, o)) => Ok((i, o.into())),\n    Err(Err::Error(e)) => Err(Err::Error(e.into())),\n    Err(Err::Failure(e)) => Err(Err::Failure(e.into())),\n    Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::iterator":["/// Creates an iterator from input data and a parser.\n///\n/// Call the iterator's [ParserIterator::finish] method to get the remaining input if successful,\n/// or the error value if we encountered an error.\n///\n/// On [`Err::Error`], iteration will stop. To instead chain an error up, see [`cut`].\n///\n/// ```rust\n/// use nom::{combinator::iterator, IResult, bytes::complete::tag, character::complete::alpha1, sequence::terminated};\n/// use std::collections::HashMap;\n///\n/// let data = \"abc|defg|hijkl|mnopqr|123\";\n/// let mut it = iterator(data, terminated(alpha1, tag(\"|\")));\n///\n/// let parsed = it.map(|v| (v, v.len())).collect::<HashMap<_,_>>();\n/// let res: IResult<_,_> = it.finish();\n///\n/// assert_eq!(parsed, [(\"abc\", 3usize), (\"defg\", 4), (\"hijkl\", 5), (\"mnopqr\", 6)].iter().cloned().collect());\n/// assert_eq!(res, Ok((\"123\", ())));\n/// ```\npub fn iterator<Input, Error, F>(input: Input, f: F) -> ParserIterator<Input, Error, F>\nwhere\n  F: Parser<Input>,\n  Error: ParseError<Input>,{\n  ParserIterator {\n    iterator: f,\n    input,\n    state: Some(State::Running),\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::map":["/// Maps a function on the result of a parser.\n///\n/// ```rust\n/// use nom::{Err,error::ErrorKind, IResult,Parser};\n/// use nom::character::complete::digit1;\n/// use nom::combinator::map;\n/// # fn main() {\n///\n/// let mut parser = map(digit1, |s: &str| s.len());\n///\n/// // the parser will count how many characters were returned by digit1\n/// assert_eq!(parser.parse(\"123456\"), Ok((\"\", 6)));\n///\n/// // this will fail if digit1 fails\n/// assert_eq!(parser.parse(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Digit))));\n/// # }\n/// ```\npub fn map<I, O, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Error = E>,\n  G: FnMut(<F as Parser<I>>::Output) -> O,{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    Ok((input, f(o1)))\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::map_opt":["/// Applies a function returning an `Option` over the result of a parser.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::character::complete::digit1;\n/// use nom::combinator::map_opt;\n/// # fn main() {\n///\n/// let mut parse = map_opt(digit1, |s: &str| s.parse::<u8>().ok());\n///\n/// // the parser will convert the result of digit1 to a number\n/// assert_eq!(parse(\"123\"), Ok((\"\", 123)));\n///\n/// // this will fail if digit1 fails\n/// assert_eq!(parse(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Digit))));\n///\n/// // this will fail if the mapped function fails (a `u8` is too small to hold `123456`)\n/// assert_eq!(parse(\"123456\"), Err(Err::Error((\"123456\", ErrorKind::MapOpt))));\n/// # }\n/// ```\npub fn map_opt<I: Clone, O, E: ParseError<I>, F, G>(\n  mut parser: F,\n  mut f: G,\n) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Error = E>,\n  G: FnMut(<F as Parser<I>>::Output) -> Option<O>,{\n  move |input: I| {\n    let i = input.clone();\n    let (input, o1) = parser.parse(input)?;\n    match f(o1) {\n      Some(o2) => Ok((input, o2)),\n      None => Err(Err::Error(E::from_error_kind(i, ErrorKind::MapOpt))),\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::map_parser":["/// Applies a parser over the result of another one.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::character::complete::digit1;\n/// use nom::bytes::complete::take;\n/// use nom::combinator::map_parser;\n/// # fn main() {\n///\n/// let mut parse = map_parser(take(5u8), digit1);\n///\n/// assert_eq!(parse(\"12345\"), Ok((\"\", \"12345\")));\n/// assert_eq!(parse(\"123ab\"), Ok((\"\", \"123\")));\n/// assert_eq!(parse(\"123\"), Err(Err::Error((\"123\", ErrorKind::Eof))));\n/// # }\n/// ```\npub fn map_parser<I, O, E: ParseError<I>, F, G>(\n  mut parser: F,\n  mut applied_parser: G,\n) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Error = E>,\n  G: Parser<<F as Parser<I>>::Output, Output = O, Error = E>,{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    let (_, o2) = applied_parser.parse(o1)?;\n    Ok((input, o2))\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::map_res":["/// Applies a function returning a `Result` over the result of a parser.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::character::complete::digit1;\n/// use nom::combinator::map_res;\n/// # fn main() {\n///\n/// let mut parse = map_res(digit1, |s: &str| s.parse::<u8>());\n///\n/// // the parser will convert the result of digit1 to a number\n/// assert_eq!(parse(\"123\"), Ok((\"\", 123)));\n///\n/// // this will fail if digit1 fails\n/// assert_eq!(parse(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Digit))));\n///\n/// // this will fail if the mapped function fails (a `u8` is too small to hold `123456`)\n/// assert_eq!(parse(\"123456\"), Err(Err::Error((\"123456\", ErrorKind::MapRes))));\n/// # }\n/// ```\npub fn map_res<I: Clone, O, E: FromExternalError<I, E2>, E2, F, G>(\n  mut parser: F,\n  mut f: G,\n) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Error = E>,\n  G: FnMut(<F as Parser<I>>::Output) -> Result<O, E2>,{\n  move |input: I| {\n    let i = input.clone();\n    let (input, o1) = parser.parse(input)?;\n    match f(o1) {\n      Ok(o2) => Ok((input, o2)),\n      Err(e) => Err(Err::Error(E::from_external_error(i, ErrorKind::MapRes, e))),\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::not":["/// Succeeds if the child parser returns an error.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::combinator::not;\n/// use nom::character::complete::alpha1;\n/// # fn main() {\n///\n/// let mut parser = not(alpha1);\n///\n/// assert_eq!(parser(\"123\"), Ok((\"123\", ())));\n/// assert_eq!(parser(\"abcd\"), Err(Err::Error((\"abcd\", ErrorKind::Not))));\n/// # }\n/// ```\npub fn not<I: Clone, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, (), E>\nwhere\n  F: Parser<I, Error = E>,{\n  move |input: I| {\n    let i = input.clone();\n    match parser.parse(input) {\n      Ok(_) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Not))),\n      Err(Err::Error(_)) => Ok((i, ())),\n      Err(e) => Err(e),\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::opt":["/// Optional parser, will return `None` on [`Err::Error`].\n///\n/// To chain an error up, see [`cut`].\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::combinator::opt;\n/// use nom::character::complete::alpha1;\n/// # fn main() {\n///\n/// fn parser(i: &str) -> IResult<&str, Option<&str>> {\n///   opt(alpha1)(i)\n/// }\n///\n/// assert_eq!(parser(\"abcd;\"), Ok((\";\", Some(\"abcd\"))));\n/// assert_eq!(parser(\"123;\"), Ok((\"123;\", None)));\n/// # }\n/// ```\npub fn opt<I: Clone, E: ParseError<I>, F>(\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, Option<<F as Parser<I>>::Output>, E>\nwhere\n  F: Parser<I, Error = E>,{\n  move |input: I| {\n    let i = input.clone();\n    match f.parse(input) {\n      Ok((i, o)) => Ok((i, Some(o))),\n      Err(Err::Error(_)) => Ok((i, None)),\n      Err(e) => Err(e),\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::peek":["/// Tries to apply its parser without consuming the input.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::combinator::peek;\n/// use nom::character::complete::alpha1;\n/// # fn main() {\n///\n/// let mut parser = peek(alpha1);\n///\n/// assert_eq!(parser(\"abcd;\"), Ok((\"abcd;\", \"abcd\")));\n/// assert_eq!(parser(\"123;\"), Err(Err::Error((\"123;\", ErrorKind::Alpha))));\n/// # }\n/// ```\npub fn peek<I: Clone, E: ParseError<I>, F>(\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, <F as Parser<I>>::Output, E>\nwhere\n  F: Parser<I, Error = E>,{\n  move |input: I| {\n    let i = input.clone();\n    match f.parse(input) {\n      Ok((_, o)) => Ok((i, o)),\n      Err(e) => Err(e),\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::recognize":["/// If the child parser was successful, return the consumed input as produced value.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::combinator::recognize;\n/// use nom::character::complete::{char, alpha1};\n/// use nom::sequence::separated_pair;\n/// # fn main() {\n///\n/// let mut parser = recognize(separated_pair(alpha1, char(','), alpha1));\n///\n/// assert_eq!(parser(\"abcd,efgh\"), Ok((\"\", \"abcd,efgh\")));\n/// assert_eq!(parser(\"abcd;\"),Err(Err::Error((\";\", ErrorKind::Char))));\n/// # }\n/// ```\npub fn recognize<I: Clone + Offset + Input, E: ParseError<I>, F>(\n  mut parser: F,\n) -> impl FnMut(I) -> IResult<I, I, E>\nwhere\n  F: Parser<I, Error = E>,{\n  move |input: I| {\n    let i = input.clone();\n    match parser.parse(i) {\n      Ok((i, _)) => {\n        let index = input.offset(&i);\n        Ok((i, input.take(index)))\n      }\n      Err(e) => Err(e),\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::rest":["/// Return the remaining input.\n///\n/// ```rust\n/// # use nom::error::ErrorKind;\n/// use nom::combinator::rest;\n/// assert_eq!(rest::<_,(_, ErrorKind)>(\"abc\"), Ok((\"\", \"abc\")));\n/// assert_eq!(rest::<_,(_, ErrorKind)>(\"\"), Ok((\"\", \"\")));\n/// ```\n#[inline]\npub fn rest<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Input,{\n  Ok(input.take_split(input.input_len()))\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::rest_len":["/// Return the length of the remaining input.\n///\n/// ```rust\n/// # use nom::error::ErrorKind;\n/// use nom::combinator::rest_len;\n/// assert_eq!(rest_len::<_,(_, ErrorKind)>(\"abc\"), Ok((\"abc\", 3)));\n/// assert_eq!(rest_len::<_,(_, ErrorKind)>(\"\"), Ok((\"\", 0)));\n/// ```\n#[inline]\npub fn rest_len<T, E: ParseError<T>>(input: T) -> IResult<T, usize, E>\nwhere\n  T: InputLength,{\n  let len = input.input_len();\n  Ok((input, len))\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::success":["/// a parser which always succeeds with given value without consuming any input.\n///\n/// It can be used for example as the last alternative in `alt` to\n/// specify the default case.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::branch::alt;\n/// use nom::combinator::{success, value};\n/// use nom::character::complete::char;\n/// # fn main() {\n///\n/// let mut parser = success::<_,_,(_,ErrorKind)>(10);\n/// assert_eq!(parser(\"xyz\"), Ok((\"xyz\", 10)));\n///\n/// let mut sign = alt((value(-1, char('-')), value(1, char('+')), success::<_,_,(_,ErrorKind)>(1)));\n/// assert_eq!(sign(\"+10\"), Ok((\"10\", 1)));\n/// assert_eq!(sign(\"-10\"), Ok((\"10\", -1)));\n/// assert_eq!(sign(\"10\"), Ok((\"10\", 1)));\n/// # }\n/// ```\npub fn success<I, O: Clone, E: ParseError<I>>(val: O) -> impl Fn(I) -> IResult<I, O, E>{\n  move |input: I| Ok((input, val.clone()))\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::value":["/// Returns the provided value if the child parser succeeds.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::combinator::value;\n/// use nom::character::complete::alpha1;\n/// # fn main() {\n///\n/// let mut parser = value(1234, alpha1);\n///\n/// assert_eq!(parser(\"abcd\"), Ok((\"\", 1234)));\n/// assert_eq!(parser(\"123abcd;\"), Err(Err::Error((\"123abcd;\", ErrorKind::Alpha))));\n/// # }\n/// ```\npub fn value<I, O1: Clone, E: ParseError<I>, F>(\n  val: O1,\n  mut parser: F,\n) -> impl FnMut(I) -> IResult<I, O1, E>\nwhere\n  F: Parser<I, Error = E>,{\n  move |input: I| parser.parse(input).map(|(i, _)| (i, val.clone()))\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"combinator::verify":["/// Returns the result of the child parser if it satisfies a verification function.\n///\n/// The verification function takes as argument a reference to the output of the\n/// parser.\n///\n/// ```rust\n/// # use nom::{Err,error::ErrorKind, IResult};\n/// use nom::combinator::verify;\n/// use nom::character::complete::alpha1;\n/// # fn main() {\n///\n/// let mut parser = verify(alpha1, |s: &str| s.len() == 4);\n///\n/// assert_eq!(parser(\"abcd\"), Ok((\"\", \"abcd\")));\n/// assert_eq!(parser(\"abcde\"), Err(Err::Error((\"abcde\", ErrorKind::Verify))));\n/// assert_eq!(parser(\"123abcd;\"),Err(Err::Error((\"123abcd;\", ErrorKind::Alpha))));\n/// # }\n/// ```\npub fn verify<I: Clone, O2, E: ParseError<I>, F, G>(\n  mut first: F,\n  second: G,\n) -> impl FnMut(I) -> IResult<I, <F as Parser<I>>::Output, E>\nwhere\n  F: Parser<I, Error = E>,\n  G: Fn(&O2) -> bool,\n  <F as Parser<I>>::Output: Borrow<O2>,\n  O2: ?Sized,{\n  move |input: I| {\n    let i = input.clone();\n    let (input, o) = first.parse(input)?;\n\n    if second(o.borrow()) {\n      Ok((input, o))\n    } else {\n      Err(Err::Error(E::from_error_kind(i, ErrorKind::Verify)))\n    }\n  }\n}","Real(LocalPath(\"src/combinator/mod.rs\"))"],"error::ContextError":["/// This trait is required by the `context` combinator to add a static string\n/// to an existing error\npub trait ContextError<I>: Sized {\n  /// Creates a new error from an input position, a static string and an existing error.\n  /// This is used mainly in the [context] combinator, to add user friendly information\n  /// to errors when backtracking through a parse tree\n  fn add_context(_input: I, _ctx: &'static str, other: Self) -> Self {\n    other\n  }\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ContextError::add_context":["/// Creates a new error from an input position, a static string and an existing error.\n/// This is used mainly in the [context] combinator, to add user friendly information\n/// to errors when backtracking through a parse tree\nfn add_context(_input: I, _ctx: &'static str, other: Self) -> Self{\n    other\n  }","Real(LocalPath(\"src/error.rs\"))"],"error::Error":["/// default error type, only contains the error' location and code\npub struct Error<I> {\n  /// position of the error in the input data\n  pub input: I,\n  /// nom error code\n  pub code: ErrorKind,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Error::<I>::new":["/// creates a new basic error\npub fn new(input: I, code: ErrorKind) -> Error<I>{\n    Error { input, code }\n  }","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorKind":["/// Indicates which parser returned an error\n#[rustfmt::skip]\n#[allow(deprecated,missing_docs)]\npub enum ErrorKind {\n  Tag,\n  MapRes,\n  MapOpt,\n  Alt,\n  IsNot,\n  IsA,\n  SeparatedList,\n  SeparatedNonEmptyList,\n  Many0,\n  Many1,\n  ManyTill,\n  Count,\n  TakeUntil,\n  LengthValue,\n  TagClosure,\n  Alpha,\n  Digit,\n  HexDigit,\n  OctDigit,\n  AlphaNumeric,\n  Space,\n  MultiSpace,\n  LengthValueFn,\n  Eof,\n  Switch,\n  TagBits,\n  OneOf,\n  NoneOf,\n  Char,\n  CrLf,\n  RegexpMatch,\n  RegexpMatches,\n  RegexpFind,\n  RegexpCapture,\n  RegexpCaptures,\n  TakeWhile1,\n  Complete,\n  Fix,\n  Escaped,\n  EscapedTransform,\n  NonEmpty,\n  ManyMN,\n  Not,\n  Permutation,\n  Verify,\n  TakeTill1,\n  TakeWhileMN,\n  TooLarge,\n  Many0Count,\n  Many1Count,\n  Float,\n  Satisfy,\n  Fail,\n  Many,\n  Fold,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorKind::description":["#[rustfmt::skip]\n#[allow(deprecated)]\n/// Converts an ErrorKind to a text description\npub fn description(&self) -> &str{\n    match *self {\n      ErrorKind::Tag                       => \"Tag\",\n      ErrorKind::MapRes                    => \"Map on Result\",\n      ErrorKind::MapOpt                    => \"Map on Option\",\n      ErrorKind::Alt                       => \"Alternative\",\n      ErrorKind::IsNot                     => \"IsNot\",\n      ErrorKind::IsA                       => \"IsA\",\n      ErrorKind::SeparatedList             => \"Separated list\",\n      ErrorKind::SeparatedNonEmptyList     => \"Separated non empty list\",\n      ErrorKind::Many0                     => \"Many0\",\n      ErrorKind::Many1                     => \"Many1\",\n      ErrorKind::Count                     => \"Count\",\n      ErrorKind::TakeUntil                 => \"Take until\",\n      ErrorKind::LengthValue               => \"Length followed by value\",\n      ErrorKind::TagClosure                => \"Tag closure\",\n      ErrorKind::Alpha                     => \"Alphabetic\",\n      ErrorKind::Digit                     => \"Digit\",\n      ErrorKind::AlphaNumeric              => \"AlphaNumeric\",\n      ErrorKind::Space                     => \"Space\",\n      ErrorKind::MultiSpace                => \"Multiple spaces\",\n      ErrorKind::LengthValueFn             => \"LengthValueFn\",\n      ErrorKind::Eof                       => \"End of file\",\n      ErrorKind::Switch                    => \"Switch\",\n      ErrorKind::TagBits                   => \"Tag on bitstream\",\n      ErrorKind::OneOf                     => \"OneOf\",\n      ErrorKind::NoneOf                    => \"NoneOf\",\n      ErrorKind::Char                      => \"Char\",\n      ErrorKind::CrLf                      => \"CrLf\",\n      ErrorKind::RegexpMatch               => \"RegexpMatch\",\n      ErrorKind::RegexpMatches             => \"RegexpMatches\",\n      ErrorKind::RegexpFind                => \"RegexpFind\",\n      ErrorKind::RegexpCapture             => \"RegexpCapture\",\n      ErrorKind::RegexpCaptures            => \"RegexpCaptures\",\n      ErrorKind::TakeWhile1                => \"TakeWhile1\",\n      ErrorKind::Complete                  => \"Complete\",\n      ErrorKind::Fix                       => \"Fix\",\n      ErrorKind::Escaped                   => \"Escaped\",\n      ErrorKind::EscapedTransform          => \"EscapedTransform\",\n      ErrorKind::NonEmpty                  => \"NonEmpty\",\n      ErrorKind::ManyMN                    => \"Many(m, n)\",\n      ErrorKind::HexDigit                  => \"Hexadecimal Digit\",\n      ErrorKind::OctDigit                  => \"Octal digit\",\n      ErrorKind::Not                       => \"Negation\",\n      ErrorKind::Permutation               => \"Permutation\",\n      ErrorKind::ManyTill                  => \"ManyTill\",\n      ErrorKind::Verify                    => \"predicate verification\",\n      ErrorKind::TakeTill1                 => \"TakeTill1\",\n      ErrorKind::TakeWhileMN               => \"TakeWhileMN\",\n      ErrorKind::TooLarge                  => \"Needed data size is too large\",\n      ErrorKind::Many0Count                => \"Count occurrence of >=0 patterns\",\n      ErrorKind::Many1Count                => \"Count occurrence of >=1 patterns\",\n      ErrorKind::Float                     => \"Float\",\n      ErrorKind::Satisfy                   => \"Satisfy\",\n      ErrorKind::Fail                      => \"Fail\",\n      ErrorKind::Many                      => \"Many\",\n      ErrorKind::Fold                      => \"Fold\",\n    }\n  }","Real(LocalPath(\"src/error.rs\"))"],"error::FromExternalError":["/// This trait is required by the `map_res` combinator to integrate\n/// error types from external functions, like [std::str::FromStr]\npub trait FromExternalError<I, E> {\n  /// Creates a new error from an input position, an [ErrorKind] indicating the\n  /// wrapping parser, and an external error\n  fn from_external_error(input: I, kind: ErrorKind, e: E) -> Self;\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ParseError":["/// This trait must be implemented by the error type of a nom parser.\n///\n/// There are already implementations of it for `(Input, ErrorKind)`\n/// and `VerboseError<Input>`.\n///\n/// It provides methods to create an error from some combinators,\n/// and combine existing errors in combinators like `alt`.\npub trait ParseError<I>: Sized {\n  /// Creates an error from the input position and an [ErrorKind]\n  fn from_error_kind(input: I, kind: ErrorKind) -> Self;\n\n  /// Combines an existing error with a new one created from the input\n  /// position and an [ErrorKind]. This is useful when backtracking\n  /// through a parse tree, accumulating error context on the way\n  fn append(input: I, kind: ErrorKind, other: Self) -> Self;\n\n  /// Creates an error from an input position and an expected character\n  fn from_char(input: I, _: char) -> Self {\n    Self::from_error_kind(input, ErrorKind::Char)\n  }\n\n  /// Combines two existing errors. This function is used to compare errors\n  /// generated in various branches of `alt`.\n  fn or(self, other: Self) -> Self {\n    other\n  }\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ParseError::from_char":["/// Creates an error from an input position and an expected character\nfn from_char(input: I, _: char) -> Self{\n    Self::from_error_kind(input, ErrorKind::Char)\n  }","Real(LocalPath(\"src/error.rs\"))"],"error::ParseError::or":["/// Combines two existing errors. This function is used to compare errors\n/// generated in various branches of `alt`.\nfn or(self, other: Self) -> Self{\n    other\n  }","Real(LocalPath(\"src/error.rs\"))"],"error::VerboseError":["/// This error type accumulates errors and their position when backtracking\n/// through a parse tree. With some post processing (cf `examples/json.rs`),\n/// it can be used to display user friendly error messages\n#[cfg(feature = \"alloc\")]\npub struct VerboseError<I> {\n  /// List of errors accumulated by `VerboseError`, containing the affected\n  /// part of input data, and some context\n  pub errors: crate::lib::std::vec::Vec<(I, VerboseErrorKind)>,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::VerboseErrorKind":["#[cfg(feature = \"alloc\")]\n/// Error context for `VerboseError`\npub enum VerboseErrorKind {\n  /// Static string added by the `context` function\n  Context(&'static str),\n  /// Indicates which character was expected by the `char` function\n  Char(char),\n  /// Error kind given by various nom parsers\n  Nom(ErrorKind),\n}","Real(LocalPath(\"src/error.rs\"))"],"error::append_error":["/// Combines an existing error with a new one created from the input\n/// position and an [ErrorKind]. This is useful when backtracking\n/// through a parse tree, accumulating error context on the way\npub fn append_error<I, E: ParseError<I>>(input: I, kind: ErrorKind, other: E) -> E{\n  E::append(input, kind, other)\n}","Real(LocalPath(\"src/error.rs\"))"],"error::context":["/// Create a new error from an input position, a static string and an existing error.\n/// This is used mainly in the [context] combinator, to add user friendly information\n/// to errors when backtracking through a parse tree\npub fn context<I: Clone, E: ContextError<I>, F, O>(\n  context: &'static str,\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Output = O, Error = E>,{\n  move |i: I| match f.parse(i.clone()) {\n    Ok(o) => Ok(o),\n    Err(Err::Incomplete(i)) => Err(Err::Incomplete(i)),\n    Err(Err::Error(e)) => Err(Err::Error(E::add_context(i, context, e))),\n    Err(Err::Failure(e)) => Err(Err::Failure(E::add_context(i, context, e))),\n  }\n}","Real(LocalPath(\"src/error.rs\"))"],"error::convert_error":["/// Transforms a `VerboseError` into a trace with input position information\n#[cfg(feature = \"alloc\")]\npub fn convert_error<I: core::ops::Deref<Target = str>>(\n  input: I,\n  e: VerboseError<I>,\n) -> crate::lib::std::string::String{\n  use crate::lib::std::fmt::Write;\n  use crate::traits::Offset;\n\n  let mut result = crate::lib::std::string::String::new();\n\n  for (i, (substring, kind)) in e.errors.iter().enumerate() {\n    let offset = input.offset(substring);\n\n    if input.is_empty() {\n      match kind {\n        VerboseErrorKind::Char(c) => {\n          write!(&mut result, \"{}: expected '{}', got empty input\\n\\n\", i, c)\n        }\n        VerboseErrorKind::Context(s) => write!(&mut result, \"{}: in {}, got empty input\\n\\n\", i, s),\n        VerboseErrorKind::Nom(e) => write!(&mut result, \"{}: in {:?}, got empty input\\n\\n\", i, e),\n      }\n    } else {\n      let prefix = &input.as_bytes()[..offset];\n\n      // Count the number of newlines in the first `offset` bytes of input\n      let line_number = prefix.iter().filter(|&&b| b == b'\\n').count() + 1;\n\n      // Find the line that includes the subslice:\n      // Find the *last* newline before the substring starts\n      let line_begin = prefix\n        .iter()\n        .rev()\n        .position(|&b| b == b'\\n')\n        .map(|pos| offset - pos)\n        .unwrap_or(0);\n\n      // Find the full line after that newline\n      let line = input[line_begin..]\n        .lines()\n        .next()\n        .unwrap_or(&input[line_begin..])\n        .trim_end();\n\n      // The (1-indexed) column number is the offset of our substring into that line\n      let column_number = line.offset(substring) + 1;\n\n      match kind {\n        VerboseErrorKind::Char(c) => {\n          if let Some(actual) = substring.chars().next() {\n            write!(\n              &mut result,\n              \"{i}: at line {line_number}:\\n\\\n               {line}\\n\\\n               {caret:>column$}\\n\\\n               expected '{expected}', found {actual}\\n\\n\",\n              i = i,\n              line_number = line_number,\n              line = line,\n              caret = '^',\n              column = column_number,\n              expected = c,\n              actual = actual,\n            )\n          } else {\n            write!(\n              &mut result,\n              \"{i}: at line {line_number}:\\n\\\n               {line}\\n\\\n               {caret:>column$}\\n\\\n               expected '{expected}', got end of input\\n\\n\",\n              i = i,\n              line_number = line_number,\n              line = line,\n              caret = '^',\n              column = column_number,\n              expected = c,\n            )\n          }\n        }\n        VerboseErrorKind::Context(s) => write!(\n          &mut result,\n          \"{i}: at line {line_number}, in {context}:\\n\\\n             {line}\\n\\\n             {caret:>column$}\\n\\n\",\n          i = i,\n          line_number = line_number,\n          context = s,\n          line = line,\n          caret = '^',\n          column = column_number,\n        ),\n        VerboseErrorKind::Nom(e) => write!(\n          &mut result,\n          \"{i}: at line {line_number}, in {nom_err:?}:\\n\\\n             {line}\\n\\\n             {caret:>column$}\\n\\n\",\n          i = i,\n          line_number = line_number,\n          nom_err = e,\n          line = line,\n          caret = '^',\n          column = column_number,\n        ),\n      }\n    }\n    // Because `write!` to a `String` is infallible, this `unwrap` is fine.\n    .unwrap();\n  }\n\n  result\n}","Real(LocalPath(\"src/error.rs\"))"],"error::dbg_dmp":["/// Prints a message and the input if the parser fails.\n///\n/// The message prints the `Error` or `Incomplete`\n/// and the parser's calling code.\n///\n/// It also displays the input in hexdump format\n///\n/// ```rust\n/// use nom::{IResult, error::dbg_dmp, bytes::complete::tag};\n///\n/// fn f(i: &[u8]) -> IResult<&[u8], &[u8]> {\n///   dbg_dmp(tag(\"abcd\"), \"tag\")(i)\n/// }\n///\n///   let a = &b\"efghijkl\"[..];\n///\n/// // Will print the following message:\n/// // Error(Position(0, [101, 102, 103, 104, 105, 106, 107, 108])) at l.5 by ' tag ! ( \"abcd\" ) '\n/// // 00000000        65 66 67 68 69 6a 6b 6c         efghijkl\n/// f(a);\n/// ```\n#[cfg(feature = \"std\")]\npub fn dbg_dmp<'a, F, O, E: std::fmt::Debug>(\n  f: F,\n  context: &'static str,\n) -> impl Fn(&'a [u8]) -> IResult<&'a [u8], O, E>\nwhere\n  F: Fn(&'a [u8]) -> IResult<&'a [u8], O, E>,{\n  use crate::HexDisplay;\n  move |i: &'a [u8]| match f(i) {\n    Err(e) => {\n      println!(\"{}: Error({:?}) at:\\n{}\", context, e, i.to_hex(8));\n      Err(e)\n    }\n    a => a,\n  }\n}","Real(LocalPath(\"src/error.rs\"))"],"error::error_to_u32":["#[rustfmt::skip]\n#[allow(deprecated)]\n/// Converts an ErrorKind to a number\npub fn error_to_u32(e: &ErrorKind) -> u32{\n  match *e {\n    ErrorKind::Tag                       => 1,\n    ErrorKind::MapRes                    => 2,\n    ErrorKind::MapOpt                    => 3,\n    ErrorKind::Alt                       => 4,\n    ErrorKind::IsNot                     => 5,\n    ErrorKind::IsA                       => 6,\n    ErrorKind::SeparatedList             => 7,\n    ErrorKind::SeparatedNonEmptyList     => 8,\n    ErrorKind::Many1                     => 9,\n    ErrorKind::Count                     => 10,\n    ErrorKind::TakeUntil                 => 12,\n    ErrorKind::LengthValue               => 15,\n    ErrorKind::TagClosure                => 16,\n    ErrorKind::Alpha                     => 17,\n    ErrorKind::Digit                     => 18,\n    ErrorKind::AlphaNumeric              => 19,\n    ErrorKind::Space                     => 20,\n    ErrorKind::MultiSpace                => 21,\n    ErrorKind::LengthValueFn             => 22,\n    ErrorKind::Eof                       => 23,\n    ErrorKind::Switch                    => 27,\n    ErrorKind::TagBits                   => 28,\n    ErrorKind::OneOf                     => 29,\n    ErrorKind::NoneOf                    => 30,\n    ErrorKind::Char                      => 40,\n    ErrorKind::CrLf                      => 41,\n    ErrorKind::RegexpMatch               => 42,\n    ErrorKind::RegexpMatches             => 43,\n    ErrorKind::RegexpFind                => 44,\n    ErrorKind::RegexpCapture             => 45,\n    ErrorKind::RegexpCaptures            => 46,\n    ErrorKind::TakeWhile1                => 47,\n    ErrorKind::Complete                  => 48,\n    ErrorKind::Fix                       => 49,\n    ErrorKind::Escaped                   => 50,\n    ErrorKind::EscapedTransform          => 51,\n    ErrorKind::NonEmpty                  => 56,\n    ErrorKind::ManyMN                    => 57,\n    ErrorKind::HexDigit                  => 59,\n    ErrorKind::OctDigit                  => 61,\n    ErrorKind::Many0                     => 62,\n    ErrorKind::Not                       => 63,\n    ErrorKind::Permutation               => 64,\n    ErrorKind::ManyTill                  => 65,\n    ErrorKind::Verify                    => 66,\n    ErrorKind::TakeTill1                 => 67,\n    ErrorKind::TakeWhileMN               => 69,\n    ErrorKind::TooLarge                  => 70,\n    ErrorKind::Many0Count                => 71,\n    ErrorKind::Many1Count                => 72,\n    ErrorKind::Float                     => 73,\n    ErrorKind::Satisfy                   => 74,\n    ErrorKind::Fail                      => 75,\n    ErrorKind::Many                      => 76,\n    ErrorKind::Fold                      => 77,\n  }\n}","Real(LocalPath(\"src/error.rs\"))"],"error::make_error":["/// Creates an error from the input position and an [ErrorKind]\npub fn make_error<I, E: ParseError<I>>(input: I, kind: ErrorKind) -> E{\n  E::from_error_kind(input, kind)\n}","Real(LocalPath(\"src/error.rs\"))"],"internal::And":["/// Implementation of `Parser::and`\npub struct And<F, G> {\n  f: F,\n  g: G,\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::AndThen":["/// Implementation of `Parser::and_then`\npub struct AndThen<F, G> {\n  f: F,\n  g: G,\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err":["/// The `Err` enum indicates the parser was not successful\n///\n/// It has three cases:\n///\n/// * `Incomplete` indicates that more data is needed to decide. The `Needed` enum\n/// can contain how many additional bytes are necessary. If you are sure your parser\n/// is working on full data, you can wrap your parser with the `complete` combinator\n/// to transform that case in `Error`\n/// * `Error` means some parser did not succeed, but another one might (as an example,\n/// when testing different branches of an `alt` combinator)\n/// * `Failure` indicates an unrecoverable error. For example, when a prefix has been\n/// recognised and the next parser has been confirmed, if that parser fails, then the\n/// entire process fails; there are no more parsers to try.\n///\n/// Distinguishing `Failure` this from `Error` is only relevant inside the parser's code. For\n/// external consumers, both mean that parsing failed.\n///\n/// See also: [`nom::Finish`].\n///\npub enum Err<E> {\n  /// There was not enough data\n  Incomplete(Needed),\n  /// The parser had an error (recoverable)\n  Error(E),\n  /// The parser had an unrecoverable error: we got to the right\n  /// branch and we know other branches won't work, so backtrack\n  /// as fast as possible\n  Failure(E),\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<(&[u8], error::ErrorKind)>::to_owned":["/// Obtaining ownership\npub fn to_owned(self) -> Err<(Vec<u8>, ErrorKind)>{\n    self.map_input(ToOwned::to_owned)\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<(&str, error::ErrorKind)>::to_owned":["/// Obtaining ownership\npub fn to_owned(self) -> Err<(String, ErrorKind)>{\n    self.map_input(ToOwned::to_owned)\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<(T, error::ErrorKind)>::map_input":["/// Maps `Err<(T, ErrorKind)>` to `Err<(U, ErrorKind)>` with the given `F: T -> U`\npub fn map_input<U, F>(self, f: F) -> Err<(U, ErrorKind)>\n  where\n    F: FnOnce(T) -> U,{\n    match self {\n      Err::Incomplete(n) => Err::Incomplete(n),\n      Err::Failure((input, k)) => Err::Failure((f(input), k)),\n      Err::Error((input, k)) => Err::Error((f(input), k)),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<E>::convert":["/// Automatically converts between errors if the underlying type supports it\npub fn convert<F>(e: Err<F>) -> Self\n  where\n    E: From<F>,{\n    e.map(crate::lib::std::convert::Into::into)\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<E>::is_incomplete":["/// Tests if the result is Incomplete\npub fn is_incomplete(&self) -> bool{\n    matches!(self, Err::Incomplete(..))\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<E>::map":["/// Applies the given function to the inner error\npub fn map<E2, F>(self, f: F) -> Err<E2>\n  where\n    F: FnOnce(E) -> E2,{\n    match self {\n      Err::Incomplete(n) => Err::Incomplete(n),\n      Err::Failure(t) => Err::Failure(f(t)),\n      Err::Error(t) => Err::Error(f(t)),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<error::Error<&[u8]>>::to_owned":["/// Obtaining ownership\npub fn to_owned(self) -> Err<error::Error<Vec<u8>>>{\n    self.map_input(ToOwned::to_owned)\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<error::Error<&str>>::to_owned":["/// Obtaining ownership\npub fn to_owned(self) -> Err<error::Error<String>>{\n    self.map_input(ToOwned::to_owned)\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Err::<error::Error<T>>::map_input":["/// Maps `Err<error::Error<T>>` to `Err<error::Error<U>>` with the given `F: T -> U`\npub fn map_input<U, F>(self, f: F) -> Err<error::Error<U>>\n  where\n    F: FnOnce(T) -> U,{\n    match self {\n      Err::Incomplete(n) => Err::Incomplete(n),\n      Err::Failure(error::Error { input, code }) => Err::Failure(error::Error {\n        input: f(input),\n        code,\n      }),\n      Err::Error(error::Error { input, code }) => Err::Error(error::Error {\n        input: f(input),\n        code,\n      }),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Finish":["/// Helper trait to convert a parser's result to a more manageable type\npub trait Finish<I, O, E> {\n  /// converts the parser's result to a type that is more consumable by error\n  /// management libraries. It keeps the same `Ok` branch, and merges `Err::Error`\n  /// and `Err::Failure` into the `Err` side.\n  ///\n  /// *warning*: if the result is `Err(Err::Incomplete(_))`, this method will panic.\n  /// - \"complete\" parsers: It will not be an issue, `Incomplete` is never used\n  /// - \"streaming\" parsers: `Incomplete` will be returned if there's not enough data\n  /// for the parser to decide, and you should gather more data before parsing again.\n  /// Once the parser returns either `Ok(_)`, `Err(Err::Error(_))` or `Err(Err::Failure(_))`,\n  /// you can get out of the parsing loop and call `finish()` on the parser's result\n  fn finish(self) -> Result<(I, O), E>;\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::FlatMap":["/// Implementation of `Parser::flat_map`\npub struct FlatMap<F, G> {\n  f: F,\n  g: G,\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::Into":["/// Implementation of `Parser::into`\npub struct Into<F, O2, E2> {\n  f: F,\n  phantom_out2: core::marker::PhantomData<O2>,\n  phantom_err2: core::marker::PhantomData<E2>,\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::Map":["/// Implementation of `Parser::map`\npub struct Map<F, G> {\n  f: F,\n  g: G,\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::MapOpt":["/// Implementation of `Parser::map_opt`\npub struct MapOpt<F, G> {\n  f: F,\n  g: G,\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::MapRes":["/// Implementation of `Parser::map_res`\npub struct MapRes<F, G> {\n  f: F,\n  g: G,\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::Needed":["/// Contains information on needed data if a parser returned `Incomplete`\npub enum Needed {\n  /// Needs more data, but we do not know how much\n  Unknown,\n  /// Contains the required data size in bytes\n  Size(NonZeroUsize),\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::Needed::is_known":["/// Indicates if we know how many bytes we need\npub fn is_known(&self) -> bool{\n    *self != Unknown\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Needed::map":["/// Maps a `Needed` to `Needed` by applying a function to a contained `Size` value.\n#[inline]\npub fn map<F: Fn(NonZeroUsize) -> usize>(self, f: F) -> Needed{\n    match self {\n      Unknown => Unknown,\n      Size(n) => Needed::new(f(n)),\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Needed::new":["/// Creates `Needed` instance, returns `Needed::Unknown` if the argument is zero\npub fn new(s: usize) -> Self{\n    match NonZeroUsize::new(s) {\n      Some(sz) => Needed::Size(sz),\n      None => Needed::Unknown,\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Or":["/// Implementation of `Parser::or`\npub struct Or<F, G> {\n  f: F,\n  g: G,\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser":["/// All nom parsers implement this trait\npub trait Parser<Input> {\n  /// Type of the produced value\n  type Output;\n  /// Error type of this parser\n  type Error: ParseError<Input>;\n\n  /// A parser takes in input type, and returns a `Result` containing\n  /// either the remaining input and the output value, or an error\n  fn parse(&mut self, input: Input) -> IResult<Input, Self::Output, Self::Error>;\n\n  /// Maps a function over the result of a parser\n  fn map<G, O2>(self, g: G) -> Map<Self, G>\n  where\n    G: FnMut(Self::Output) -> O2,\n    Self: core::marker::Sized,\n  {\n    Map { f: self, g }\n  }\n\n  /// Applies a function returning a `Result` over the result of a parser.\n  fn map_res<G, O2, E2>(self, g: G) -> MapRes<Self, G>\n  where\n    G: Fn(Self::Output) -> Result<O2, E2>,\n    Self::Error: FromExternalError<Input, E2>,\n    Self: core::marker::Sized,\n  {\n    MapRes { f: self, g }\n  }\n\n  /// Applies a function returning an `Option` over the result of a parser.\n  fn map_opt<G, O2>(self, g: G) -> MapOpt<Self, G>\n  where\n    G: Fn(Self::Output) -> Option<O2>,\n    Self: core::marker::Sized,\n  {\n    MapOpt { f: self, g }\n  }\n\n  /// Creates a second parser from the output of the first one, then apply over the rest of the input\n  fn flat_map<G, H>(self, g: G) -> FlatMap<Self, G>\n  where\n    G: FnMut(Self::Output) -> H,\n    H: Parser<Input, Error = Self::Error>,\n    Self: core::marker::Sized,\n  {\n    FlatMap { f: self, g }\n  }\n\n  /// Applies a second parser over the output of the first one\n  fn and_then<G>(self, g: G) -> AndThen<Self, G>\n  where\n    G: Parser<Self::Output, Error = Self::Error>,\n    Self: core::marker::Sized,\n  {\n    AndThen { f: self, g }\n  }\n\n  /// Applies a second parser after the first one, return their results as a tuple\n  fn and<G, O2>(self, g: G) -> And<Self, G>\n  where\n    G: Parser<Input, Output = O2, Error = Self::Error>,\n    Self: core::marker::Sized,\n  {\n    And { f: self, g }\n  }\n\n  /// Applies a second parser over the input if the first one failed\n  fn or<G>(self, g: G) -> Or<Self, G>\n  where\n    G: Parser<Input, Output = Self::Output, Error = Self::Error>,\n    Self: core::marker::Sized,\n  {\n    Or { f: self, g }\n  }\n\n  /// automatically converts the parser's output and error values to another type, as long as they\n  /// implement the `From` trait\n  fn into<O2: From<Self::Output>, E2: From<Self::Error>>(self) -> Into<Self, O2, E2>\n  where\n    Self: core::marker::Sized,\n  {\n    Into {\n      f: self,\n      phantom_out2: core::marker::PhantomData,\n      phantom_err2: core::marker::PhantomData,\n    }\n  }\n}","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser::and":["/// Applies a second parser after the first one, return their results as a tuple\nfn and<G, O2>(self, g: G) -> And<Self, G>\n  where\n    G: Parser<Input, Output = O2, Error = Self::Error>,\n    Self: core::marker::Sized,{\n    And { f: self, g }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser::and_then":["/// Applies a second parser over the output of the first one\nfn and_then<G>(self, g: G) -> AndThen<Self, G>\n  where\n    G: Parser<Self::Output, Error = Self::Error>,\n    Self: core::marker::Sized,{\n    AndThen { f: self, g }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser::flat_map":["/// Creates a second parser from the output of the first one, then apply over the rest of the input\nfn flat_map<G, H>(self, g: G) -> FlatMap<Self, G>\n  where\n    G: FnMut(Self::Output) -> H,\n    H: Parser<Input, Error = Self::Error>,\n    Self: core::marker::Sized,{\n    FlatMap { f: self, g }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser::into":["/// automatically converts the parser's output and error values to another type, as long as they\n/// implement the `From` trait\nfn into<O2: From<Self::Output>, E2: From<Self::Error>>(self) -> Into<Self, O2, E2>\n  where\n    Self: core::marker::Sized,{\n    Into {\n      f: self,\n      phantom_out2: core::marker::PhantomData,\n      phantom_err2: core::marker::PhantomData,\n    }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser::map":["/// Maps a function over the result of a parser\nfn map<G, O2>(self, g: G) -> Map<Self, G>\n  where\n    G: FnMut(Self::Output) -> O2,\n    Self: core::marker::Sized,{\n    Map { f: self, g }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser::map_opt":["/// Applies a function returning an `Option` over the result of a parser.\nfn map_opt<G, O2>(self, g: G) -> MapOpt<Self, G>\n  where\n    G: Fn(Self::Output) -> Option<O2>,\n    Self: core::marker::Sized,{\n    MapOpt { f: self, g }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser::map_res":["/// Applies a function returning a `Result` over the result of a parser.\nfn map_res<G, O2, E2>(self, g: G) -> MapRes<Self, G>\n  where\n    G: Fn(Self::Output) -> Result<O2, E2>,\n    Self::Error: FromExternalError<Input, E2>,\n    Self: core::marker::Sized,{\n    MapRes { f: self, g }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"internal::Parser::or":["/// Applies a second parser over the input if the first one failed\nfn or<G>(self, g: G) -> Or<Self, G>\n  where\n    G: Parser<Input, Output = Self::Output, Error = Self::Error>,\n    Self: core::marker::Sized,{\n    Or { f: self, g }\n  }","Real(LocalPath(\"src/internal.rs\"))"],"multi::count":["/// Runs the embedded parser `count` times, gathering the results in a `Vec`\n///\n/// # Arguments\n/// * `f` The parser to apply.\n/// * `count` How often to apply the parser.\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::multi::count;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   count(tag(\"abc\"), 2)(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Err(Err::Error(Error::new(\"123\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"123123\"), Err(Err::Error(Error::new(\"123123\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"abcabcabc\"), Ok((\"abc\", vec![\"abc\", \"abc\"])));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn count<I, E, F>(\n  mut f: F,\n  count: usize,\n) -> impl FnMut(I) -> IResult<I, Vec<<F as Parser<I>>::Output>, E>\nwhere\n  I: Clone + PartialEq,\n  F: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |i: I| {\n    let mut input = i.clone();\n    let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES\n      / crate::lib::std::mem::size_of::<<F as Parser<I>>::Output>().max(1);\n    let mut res = crate::lib::std::vec::Vec::with_capacity(count.min(max_initial_capacity));\n\n    for _ in 0..count {\n      let input_ = input.clone();\n      match f.parse(input_) {\n        Ok((i, o)) => {\n          res.push(o);\n          input = i;\n        }\n        Err(Err::Error(e)) => {\n          return Err(Err::Error(E::append(i, ErrorKind::Count, e)));\n        }\n        Err(e) => {\n          return Err(e);\n        }\n      }\n    }\n\n    Ok((input, res))\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::fill":["/// Runs the embedded parser repeatedly, filling the given slice with results.\n///\n/// This parser fails if the input runs out before the given slice is full.\n///\n/// # Arguments\n/// * `f` The parser to apply.\n/// * `buf` The slice to fill\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::multi::fill;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, [&str; 2]> {\n///   let mut buf = [\"\", \"\"];\n///   let (rest, ()) = fill(tag(\"abc\"), &mut buf)(s)?;\n///   Ok((rest, buf))\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", [\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Err(Err::Error(Error::new(\"123\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"123123\"), Err(Err::Error(Error::new(\"123123\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"abcabcabc\"), Ok((\"abc\", [\"abc\", \"abc\"])));\n/// ```\npub fn fill<'a, I, E, F>(\n  mut f: F,\n  buf: &'a mut [<F as Parser<I>>::Output],\n) -> impl FnMut(I) -> IResult<I, (), E> + 'a\nwhere\n  I: Clone + PartialEq,\n  F: Parser<I, Error = E> + 'a,\n  E: ParseError<I>,{\n  move |i: I| {\n    let mut input = i.clone();\n\n    for elem in buf.iter_mut() {\n      let input_ = input.clone();\n      match f.parse(input_) {\n        Ok((i, o)) => {\n          *elem = o;\n          input = i;\n        }\n        Err(Err::Error(e)) => {\n          return Err(Err::Error(E::append(i, ErrorKind::Count, e)));\n        }\n        Err(e) => {\n          return Err(e);\n        }\n      }\n    }\n\n    Ok((input, ()))\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::fold":["/// Applies a parser and accumulates the results using a given\n/// function and initial value.\n/// Fails if the amount of time the embedded parser is run is not\n/// within the specified range.\n///\n/// # Arguments\n/// * `range` Constrains the number of iterations.\n///   * A range without an upper bound `a..` allows the parser to run until it fails.\n///   * A single `usize` value is equivalent to `value..=value`.\n///   * An empty range is invalid.\n/// * `parse` The parser to apply.\n/// * `init` A function returning the initial value.\n/// * `fold` The function that combines a result of `f` with\n///       the current accumulator.\n/// ```rust\n/// # #[macro_use] extern crate nom;\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::fold;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   fold(\n///     0..=2,\n///     tag(\"abc\"),\n///     Vec::new,\n///     |mut acc: Vec<_>, item| {\n///       acc.push(item);\n///       acc\n///     }\n///   )(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", vec![\"abc\"])));\n/// assert_eq!(parser(\"123123\"), Ok((\"123123\", vec![])));\n/// assert_eq!(parser(\"\"), Ok((\"\", vec![])));\n/// assert_eq!(parser(\"abcabcabc\"), Ok((\"abc\", vec![\"abc\", \"abc\"])));\n/// ```\npub fn fold<I, E, F, G, H, J, R>(\n  range: J,\n  mut parse: F,\n  mut init: H,\n  mut fold: G,\n) -> impl FnMut(I) -> IResult<I, R, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  G: FnMut(R, <F as Parser<I>>::Output) -> R,\n  H: FnMut() -> R,\n  E: ParseError<I>,\n  J: NomRange<usize>,{\n  move |mut input: I| {\n    if range.is_inverted() {\n      return Err(Err::Failure(E::from_error_kind(input, ErrorKind::Fold)));\n    }\n\n    let mut acc = init();\n\n    for count in range.saturating_iter() {\n      let len = input.input_len();\n      match parse.parse(input.clone()) {\n        Ok((tail, value)) => {\n          // infinite loop check: the parser must always consume\n          if tail.input_len() == len {\n            return Err(Err::Error(E::from_error_kind(tail, ErrorKind::Fold)));\n          }\n\n          acc = fold(acc, value);\n          input = tail;\n        }\n        Err(Err::Error(err)) => {\n          if !range.contains(&count) {\n            return Err(Err::Error(E::append(input, ErrorKind::Fold, err)));\n          } else {\n            break;\n          }\n        }\n        Err(e) => return Err(e),\n      }\n    }\n\n    Ok((input, acc))\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::fold_many0":["/// Repeats the embedded parser, calling `g` to gather the results.\n///\n/// This stops on [`Err::Error`]. To instead chain an error up, see\n/// [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `f` The parser to apply.\n/// * `init` A function returning the initial value.\n/// * `g` The function that combines a result of `f` with\n///       the current accumulator.\n///\n/// *Note*: if the parser passed in accepts empty inputs (like `alpha0` or `digit0`), `many0` will\n/// return an error, to prevent going into an infinite loop\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::fold_many0;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   fold_many0(\n///     tag(\"abc\"),\n///     Vec::new,\n///     |mut acc: Vec<_>, item| {\n///       acc.push(item);\n///       acc\n///     }\n///   )(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", vec![\"abc\"])));\n/// assert_eq!(parser(\"123123\"), Ok((\"123123\", vec![])));\n/// assert_eq!(parser(\"\"), Ok((\"\", vec![])));\n/// ```\npub fn fold_many0<I, E, F, G, H, R>(\n  mut f: F,\n  mut init: H,\n  mut g: G,\n) -> impl FnMut(I) -> IResult<I, R, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  G: FnMut(R, <F as Parser<I>>::Output) -> R,\n  H: FnMut() -> R,\n  E: ParseError<I>,{\n  move |i: I| {\n    let mut res = init();\n    let mut input = i;\n\n    loop {\n      let i_ = input.clone();\n      let len = input.input_len();\n      match f.parse(i_) {\n        Ok((i, o)) => {\n          // infinite loop check: the parser must always consume\n          if i.input_len() == len {\n            return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0)));\n          }\n\n          res = g(res, o);\n          input = i;\n        }\n        Err(Err::Error(_)) => {\n          return Ok((input, res));\n        }\n        Err(e) => {\n          return Err(e);\n        }\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::fold_many1":["/// Repeats the embedded parser, calling `g` to gather the results.\n///\n/// This stops on [`Err::Error`] if there is at least one result. To instead chain an error up,\n/// see [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `f` The parser to apply.\n/// * `init` A function returning the initial value.\n/// * `g` The function that combines a result of `f` with\n///       the current accumulator.\n///\n/// *Note*: If the parser passed to `many1` accepts empty inputs\n/// (like `alpha0` or `digit0`), `many1` will return an error,\n/// to prevent going into an infinite loop.\n///\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::multi::fold_many1;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   fold_many1(\n///     tag(\"abc\"),\n///     Vec::new,\n///     |mut acc: Vec<_>, item| {\n///       acc.push(item);\n///       acc\n///     }\n///   )(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", vec![\"abc\"])));\n/// assert_eq!(parser(\"123123\"), Err(Err::Error(Error::new(\"123123\", ErrorKind::Many1))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Many1))));\n/// ```\npub fn fold_many1<I, E, F, G, H, R>(\n  mut f: F,\n  mut init: H,\n  mut g: G,\n) -> impl FnMut(I) -> IResult<I, R, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  G: FnMut(R, <F as Parser<I>>::Output) -> R,\n  H: FnMut() -> R,\n  E: ParseError<I>,{\n  move |i: I| {\n    let _i = i.clone();\n    let init = init();\n    match f.parse(_i) {\n      Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1))),\n      Err(e) => Err(e),\n      Ok((i1, o1)) => {\n        let mut acc = g(init, o1);\n        let mut input = i1;\n\n        loop {\n          let _input = input.clone();\n          let len = input.input_len();\n          match f.parse(_input) {\n            Err(Err::Error(_)) => {\n              break;\n            }\n            Err(e) => return Err(e),\n            Ok((i, o)) => {\n              // infinite loop check: the parser must always consume\n              if i.input_len() == len {\n                return Err(Err::Failure(E::from_error_kind(i, ErrorKind::Many1)));\n              }\n\n              acc = g(acc, o);\n              input = i;\n            }\n          }\n        }\n\n        Ok((input, acc))\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::fold_many_m_n":["/// Repeats the embedded parser `m..=n` times, calling `g` to gather the results\n///\n/// This stops before `n` when the parser returns [`Err::Error`]. To instead chain an error up, see\n/// [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `m` The minimum number of iterations.\n/// * `n` The maximum number of iterations.\n/// * `f` The parser to apply.\n/// * `init` A function returning the initial value.\n/// * `g` The function that combines a result of `f` with\n///       the current accumulator.\n///\n/// *Note*: If the parser passed to `many1` accepts empty inputs\n/// (like `alpha0` or `digit0`), `many1` will return an error,\n/// to prevent going into an infinite loop.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::fold_many_m_n;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   fold_many_m_n(\n///     0,\n///     2,\n///     tag(\"abc\"),\n///     Vec::new,\n///     |mut acc: Vec<_>, item| {\n///       acc.push(item);\n///       acc\n///     }\n///   )(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", vec![\"abc\"])));\n/// assert_eq!(parser(\"123123\"), Ok((\"123123\", vec![])));\n/// assert_eq!(parser(\"\"), Ok((\"\", vec![])));\n/// assert_eq!(parser(\"abcabcabc\"), Ok((\"abc\", vec![\"abc\", \"abc\"])));\n/// ```\npub fn fold_many_m_n<I, E, F, G, H, R>(\n  min: usize,\n  max: usize,\n  mut parse: F,\n  mut init: H,\n  mut fold: G,\n) -> impl FnMut(I) -> IResult<I, R, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  G: FnMut(R, <F as Parser<I>>::Output) -> R,\n  H: FnMut() -> R,\n  E: ParseError<I>,{\n  move |mut input: I| {\n    if min > max {\n      return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN)));\n    }\n\n    let mut acc = init();\n    for count in 0..max {\n      let len = input.input_len();\n      match parse.parse(input.clone()) {\n        Ok((tail, value)) => {\n          // infinite loop check: the parser must always consume\n          if tail.input_len() == len {\n            return Err(Err::Error(E::from_error_kind(tail, ErrorKind::ManyMN)));\n          }\n\n          acc = fold(acc, value);\n          input = tail;\n        }\n        Err(Err::Error(err)) => {\n          if count < min {\n            return Err(Err::Error(E::append(input, ErrorKind::ManyMN, err)));\n          } else {\n            break;\n          }\n        }\n        Err(e) => return Err(e),\n      }\n    }\n\n    Ok((input, acc))\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::length_count":["/// Gets a number from the first parser,\n/// then applies the second parser that many times.\n/// # Arguments\n/// * `f` The parser to apply to obtain the count.\n/// * `g` The parser to apply repeatedly.\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::number::complete::u8;\n/// use nom::multi::length_count;\n/// use nom::bytes::complete::tag;\n/// use nom::combinator::map;\n///\n/// fn parser(s: &[u8]) -> IResult<&[u8], Vec<&[u8]>> {\n///   length_count(map(u8, |i| {\n///      println!(\"got number: {}\", i);\n///      i\n///   }), tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(&b\"\\x02abcabcabc\"[..]), Ok(((&b\"abc\"[..], vec![&b\"abc\"[..], &b\"abc\"[..]]))));\n/// assert_eq!(parser(b\"\\x03123123123\"), Err(Err::Error(Error::new(&b\"123123123\"[..], ErrorKind::Tag))));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn length_count<I, E, F, G>(\n  mut f: F,\n  mut g: G,\n) -> impl FnMut(I) -> IResult<I, Vec<<G as Parser<I>>::Output>, E>\nwhere\n  I: Clone,\n  <F as Parser<I>>::Output: ToUsize,\n  F: Parser<I, Error = E>,\n  G: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |i: I| {\n    let (i, count) = f.parse(i)?;\n    let mut input = i.clone();\n    let mut res = Vec::new();\n\n    for _ in 0..count.to_usize() {\n      let input_ = input.clone();\n      match g.parse(input_) {\n        Ok((i, o)) => {\n          res.push(o);\n          input = i;\n        }\n        Err(Err::Error(e)) => {\n          return Err(Err::Error(E::append(i, ErrorKind::Count, e)));\n        }\n        Err(e) => {\n          return Err(e);\n        }\n      }\n    }\n\n    Ok((input, res))\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::length_data":["/// Gets a number from the parser and returns a\n/// subslice of the input of that size.\n/// If the parser returns `Incomplete`,\n/// `length_data` will return an error.\n/// # Arguments\n/// * `f` The parser to apply.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::number::complete::be_u16;\n/// use nom::multi::length_data;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &[u8]) -> IResult<&[u8], &[u8]> {\n///   length_data(be_u16)(s)\n/// }\n///\n/// assert_eq!(parser(b\"\\x00\\x03abcefg\"), Ok((&b\"efg\"[..], &b\"abc\"[..])));\n/// assert_eq!(parser(b\"\\x00\\x03a\"), Err(Err::Incomplete(Needed::new(2))));\n/// ```\npub fn length_data<I, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, I, E>\nwhere\n  I: Input,\n  <F as Parser<I>>::Output: ToUsize,\n  F: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |i: I| {\n    let (i, length) = f.parse(i)?;\n\n    let length: usize = length.to_usize();\n\n    if let Some(needed) = length\n      .checked_sub(i.input_len())\n      .and_then(NonZeroUsize::new)\n    {\n      Err(Err::Incomplete(Needed::Size(needed)))\n    } else {\n      Ok(i.take_split(length))\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::length_value":["/// Gets a number from the first parser,\n/// takes a subslice of the input of that size,\n/// then applies the second parser on that subslice.\n/// If the second parser returns `Incomplete`,\n/// `length_value` will return an error.\n/// # Arguments\n/// * `f` The parser to apply.\n/// * `g` The parser to apply on the subslice.\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::number::complete::be_u16;\n/// use nom::multi::length_value;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &[u8]) -> IResult<&[u8], &[u8]> {\n///   length_value(be_u16, tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(b\"\\x00\\x03abcefg\"), Ok((&b\"efg\"[..], &b\"abc\"[..])));\n/// assert_eq!(parser(b\"\\x00\\x03123123\"), Err(Err::Error(Error::new(&b\"123\"[..], ErrorKind::Tag))));\n/// assert_eq!(parser(b\"\\x00\\x03a\"), Err(Err::Incomplete(Needed::new(2))));\n/// ```\npub fn length_value<I, E, F, G>(\n  mut f: F,\n  mut g: G,\n) -> impl FnMut(I) -> IResult<I, <G as Parser<I>>::Output, E>\nwhere\n  I: Clone + Input,\n  <F as Parser<I>>::Output: ToUsize,\n  F: Parser<I, Error = E>,\n  G: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |i: I| {\n    let (i, length) = f.parse(i)?;\n\n    let length: usize = length.to_usize();\n\n    if let Some(needed) = length\n      .checked_sub(i.input_len())\n      .and_then(NonZeroUsize::new)\n    {\n      Err(Err::Incomplete(Needed::Size(needed)))\n    } else {\n      let (rest, i) = i.take_split(length);\n      match g.parse(i.clone()) {\n        Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),\n        Err(e) => Err(e),\n        Ok((_, o)) => Ok((rest, o)),\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::many":["/// Repeats the embedded parser and collects the results in a type implementing `Extend + Default`.\n/// Fails if the amount of time the embedded parser is run is not\n/// within the specified range.\n/// # Arguments\n/// * `range` Constrains the number of iterations.\n///   * A range without an upper bound `a..` is equivalent to a range of `a..=usize::MAX`.\n///   * A single `usize` value is equivalent to `value..=value`.\n///   * An empty range is invalid.\n/// * `parse` The parser to apply.\n///\n/// ```rust\n/// # #[macro_use] extern crate nom;\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::many;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   many(0..=2, tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", vec![\"abc\"])));\n/// assert_eq!(parser(\"123123\"), Ok((\"123123\", vec![])));\n/// assert_eq!(parser(\"\"), Ok((\"\", vec![])));\n/// assert_eq!(parser(\"abcabcabc\"), Ok((\"abc\", vec![\"abc\", \"abc\"])));\n/// ```\n///\n/// This is not limited to `Vec`, other collections like `HashMap`\n/// can be used:\n///\n/// ```rust\n/// # #[macro_use] extern crate nom;\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::many;\n/// use nom::bytes::complete::{tag, take_while};\n/// use nom::sequence::{separated_pair, terminated};\n/// use nom::AsChar;\n///\n/// use std::collections::HashMap;\n///\n/// fn key_value(s: &str) -> IResult<&str, HashMap<&str, &str>> {\n///   many(0.., terminated(\n///     separated_pair(\n///       take_while(AsChar::is_alpha),\n///       tag(\"=\"),\n///       take_while(AsChar::is_alpha)\n///     ),\n///     tag(\";\")\n///   ))(s)\n/// }\n///\n/// assert_eq!(\n///   key_value(\"a=b;c=d;\"),\n///   Ok((\"\", HashMap::from([(\"a\", \"b\"), (\"c\", \"d\")])))\n/// );\n/// ```\n///\n/// If more control is needed on the default value, [fold] can\n/// be used instead:\n///\n/// ```rust\n/// # #[macro_use] extern crate nom;\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::fold;\n/// use nom::bytes::complete::tag;\n///\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   fold(\n///     0..=4,\n///     tag(\"abc\"),\n///     // preallocates a vector of the max size\n///     || Vec::with_capacity(4),\n///     |mut acc: Vec<_>, item| {\n///       acc.push(item);\n///       acc\n///     }\n///   )(s)\n/// }\n///\n///\n/// assert_eq!(parser(\"abcabcabcabc\"), Ok((\"\", vec![\"abc\", \"abc\", \"abc\", \"abc\"])));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn many<I, E, Collection, F, G>(\n  range: G,\n  mut parse: F,\n) -> impl FnMut(I) -> IResult<I, Collection, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  Collection: Extend<<F as Parser<I>>::Output> + Default,\n  E: ParseError<I>,\n  G: NomRange<usize>,{\n  move |mut input: I| {\n    if range.is_inverted() {\n      return Err(Err::Failure(E::from_error_kind(input, ErrorKind::Many)));\n    }\n\n    let mut res = Collection::default();\n\n    for count in range.bounded_iter() {\n      let len = input.input_len();\n      match parse.parse(input.clone()) {\n        Ok((tail, value)) => {\n          // infinite loop check: the parser must always consume\n          if tail.input_len() == len {\n            return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many)));\n          }\n\n          res.extend(Some(value));\n          input = tail;\n        }\n        Err(Err::Error(e)) => {\n          if !range.contains(&count) {\n            return Err(Err::Error(E::append(input, ErrorKind::Many, e)));\n          } else {\n            return Ok((input, res));\n          }\n        }\n        Err(e) => {\n          return Err(e);\n        }\n      }\n    }\n\n    Ok((input, res))\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::many0":["/// Repeats the embedded parser, gathering the results in a `Vec`.\n///\n/// This stops on [`Err::Error`] and returns the results that were accumulated. To instead chain an error up, see\n/// [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `f` The parser to apply.\n///\n/// *Note*: if the parser passed in accepts empty inputs (like `alpha0` or `digit0`), `many0` will\n/// return an error, to prevent going into an infinite loop\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::many0;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   many0(tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", vec![\"abc\"])));\n/// assert_eq!(parser(\"123123\"), Ok((\"123123\", vec![])));\n/// assert_eq!(parser(\"\"), Ok((\"\", vec![])));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn many0<I, F>(\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, Vec<<F as Parser<I>>::Output>, <F as Parser<I>>::Error>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I>,{\n  move |mut i: I| {\n    let mut acc = crate::lib::std::vec::Vec::with_capacity(4);\n    loop {\n      let len = i.input_len();\n      match f.parse(i.clone()) {\n        Err(Err::Error(_)) => return Ok((i, acc)),\n        Err(e) => return Err(e),\n        Ok((i1, o)) => {\n          // infinite loop check: the parser must always consume\n          if i1.input_len() == len {\n            return Err(Err::Error(<F as Parser<I>>::Error::from_error_kind(\n              i,\n              ErrorKind::Many0,\n            )));\n          }\n\n          i = i1;\n          acc.push(o);\n        }\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::many0_count":["/// Repeats the embedded parser, counting the results\n///\n/// This stops on [`Err::Error`]. To instead chain an error up, see\n/// [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `f` The parser to apply.\n///\n/// *Note*: if the parser passed in accepts empty inputs (like `alpha0` or `digit0`), `many0` will\n/// return an error, to prevent going into an infinite loop\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::many0_count;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, usize> {\n///   many0_count(tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", 2)));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", 1)));\n/// assert_eq!(parser(\"123123\"), Ok((\"123123\", 0)));\n/// assert_eq!(parser(\"\"), Ok((\"\", 0)));\n/// ```\npub fn many0_count<I, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, usize, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |i: I| {\n    let mut input = i;\n    let mut count = 0;\n\n    loop {\n      let input_ = input.clone();\n      let len = input.input_len();\n      match f.parse(input_) {\n        Ok((i, _)) => {\n          // infinite loop check: the parser must always consume\n          if i.input_len() == len {\n            return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0Count)));\n          }\n\n          input = i;\n          count += 1;\n        }\n\n        Err(Err::Error(_)) => return Ok((input, count)),\n\n        Err(e) => return Err(e),\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::many1":["/// Runs the embedded parser, gathering the results in a `Vec`.\n///\n/// This stops on [`Err::Error`] if there is at least one result,  and returns the results that were accumulated. To instead chain an error up,\n/// see [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `f` The parser to apply.\n///\n/// *Note*: If the parser passed to `many1` accepts empty inputs\n/// (like `alpha0` or `digit0`), `many1` will return an error,\n/// to prevent going into an infinite loop.\n///\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::multi::many1;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   many1(tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", vec![\"abc\"])));\n/// assert_eq!(parser(\"123123\"), Err(Err::Error(Error::new(\"123123\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Tag))));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn many1<I, F>(\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, Vec<<F as Parser<I>>::Output>, <F as Parser<I>>::Error>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I>,{\n  move |mut i: I| match f.parse(i.clone()) {\n    Err(Err::Error(err)) => Err(Err::Error(<F as Parser<I>>::Error::append(\n      i,\n      ErrorKind::Many1,\n      err,\n    ))),\n    Err(e) => Err(e),\n    Ok((i1, o)) => {\n      let mut acc = crate::lib::std::vec::Vec::with_capacity(4);\n      acc.push(o);\n      i = i1;\n\n      loop {\n        let len = i.input_len();\n        match f.parse(i.clone()) {\n          Err(Err::Error(_)) => return Ok((i, acc)),\n          Err(e) => return Err(e),\n          Ok((i1, o)) => {\n            // infinite loop check: the parser must always consume\n            if i1.input_len() == len {\n              return Err(Err::Error(<F as Parser<I>>::Error::from_error_kind(\n                i,\n                ErrorKind::Many1,\n              )));\n            }\n\n            i = i1;\n            acc.push(o);\n          }\n        }\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::many1_count":["/// Runs the embedded parser, counting the results.\n///\n/// This stops on [`Err::Error`] if there is at least one result. To instead chain an error up,\n/// see [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `f` The parser to apply.\n///\n/// *Note*: If the parser passed to `many1` accepts empty inputs\n/// (like `alpha0` or `digit0`), `many1` will return an error,\n/// to prevent going into an infinite loop.\n///\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::multi::many1_count;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, usize> {\n///   many1_count(tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", 2)));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", 1)));\n/// assert_eq!(parser(\"123123\"), Err(Err::Error(Error::new(\"123123\", ErrorKind::Many1Count))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Many1Count))));\n/// ```\npub fn many1_count<I, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, usize, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |i: I| {\n    let i_ = i.clone();\n    match f.parse(i_) {\n      Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count))),\n      Err(i) => Err(i),\n      Ok((i1, _)) => {\n        let mut count = 1;\n        let mut input = i1;\n\n        loop {\n          let len = input.input_len();\n          let input_ = input.clone();\n          match f.parse(input_) {\n            Err(Err::Error(_)) => return Ok((input, count)),\n            Err(e) => return Err(e),\n            Ok((i, _)) => {\n              // infinite loop check: the parser must always consume\n              if i.input_len() == len {\n                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count)));\n              }\n\n              count += 1;\n              input = i;\n            }\n          }\n        }\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::many_m_n":["/// Repeats the embedded parser `m..=n` times\n///\n/// This stops before `n` when the parser returns [`Err::Error`]  and returns the results that were accumulated. To instead chain an error up, see\n/// [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `m` The minimum number of iterations.\n/// * `n` The maximum number of iterations.\n/// * `f` The parser to apply.\n///\n/// *Note*: If the parser passed to `many1` accepts empty inputs\n/// (like `alpha0` or `digit0`), `many1` will return an error,\n/// to prevent going into an infinite loop.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::many_m_n;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   many_m_n(0, 2, tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123\"), Ok((\"123\", vec![\"abc\"])));\n/// assert_eq!(parser(\"123123\"), Ok((\"123123\", vec![])));\n/// assert_eq!(parser(\"\"), Ok((\"\", vec![])));\n/// assert_eq!(parser(\"abcabcabc\"), Ok((\"abc\", vec![\"abc\", \"abc\"])));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn many_m_n<I, E, F>(\n  min: usize,\n  max: usize,\n  mut parse: F,\n) -> impl FnMut(I) -> IResult<I, Vec<<F as Parser<I>>::Output>, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |mut input: I| {\n    if min > max {\n      return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN)));\n    }\n\n    let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES\n      / crate::lib::std::mem::size_of::<<F as Parser<I>>::Output>().max(1);\n    let mut res = crate::lib::std::vec::Vec::with_capacity(min.min(max_initial_capacity));\n    for count in 0..max {\n      let len = input.input_len();\n      match parse.parse(input.clone()) {\n        Ok((tail, value)) => {\n          // infinite loop check: the parser must always consume\n          if tail.input_len() == len {\n            return Err(Err::Error(E::from_error_kind(input, ErrorKind::ManyMN)));\n          }\n\n          res.push(value);\n          input = tail;\n        }\n        Err(Err::Error(e)) => {\n          if count < min {\n            return Err(Err::Error(E::append(input, ErrorKind::ManyMN, e)));\n          } else {\n            return Ok((input, res));\n          }\n        }\n        Err(e) => {\n          return Err(e);\n        }\n      }\n    }\n\n    Ok((input, res))\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::many_till":["/// Applies the parser `f` until the parser `g` produces a result.\n///\n/// Returns a tuple of the results of `f` in a `Vec` and the result of `g`.\n///\n/// `f` keeps going so long as `g` produces [`Err::Error`]. To instead chain an error up, see [`cut`][crate::combinator::cut].\n///\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::multi::many_till;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, (Vec<&str>, &str)> {\n///   many_till(tag(\"abc\"), tag(\"end\"))(s)\n/// };\n///\n/// assert_eq!(parser(\"abcabcend\"), Ok((\"\", (vec![\"abc\", \"abc\"], \"end\"))));\n/// assert_eq!(parser(\"abc123end\"), Err(Err::Error(Error::new(\"123end\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"123123end\"), Err(Err::Error(Error::new(\"123123end\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"abcendefg\"), Ok((\"efg\", (vec![\"abc\"], \"end\"))));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn many_till<I, E, F, G>(\n  mut f: F,\n  mut g: G,\n) -> impl FnMut(I) -> IResult<I, (Vec<<F as Parser<I>>::Output>, <G as Parser<I>>::Output), E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  G: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |mut i: I| {\n    let mut res = crate::lib::std::vec::Vec::new();\n    loop {\n      let len = i.input_len();\n      match g.parse(i.clone()) {\n        Ok((i1, o)) => return Ok((i1, (res, o))),\n        Err(Err::Error(_)) => {\n          match f.parse(i.clone()) {\n            Err(Err::Error(err)) => return Err(Err::Error(E::append(i, ErrorKind::ManyTill, err))),\n            Err(e) => return Err(e),\n            Ok((i1, o)) => {\n              // infinite loop check: the parser must always consume\n              if i1.input_len() == len {\n                return Err(Err::Error(E::from_error_kind(i1, ErrorKind::ManyTill)));\n              }\n\n              res.push(o);\n              i = i1;\n            }\n          }\n        }\n        Err(e) => return Err(e),\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::separated_list0":["/// Alternates between two parsers to produce a list of elements.\n///\n/// This stops when either parser returns [`Err::Error`]  and returns the results that were accumulated. To instead chain an error up, see\n/// [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `sep` Parses the separator between list elements.\n/// * `f` Parses the elements of the list.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed, IResult};\n/// use nom::multi::separated_list0;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   separated_list0(tag(\"|\"), tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(\"abc|abc|abc\"), Ok((\"\", vec![\"abc\", \"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123abc\"), Ok((\"123abc\", vec![\"abc\"])));\n/// assert_eq!(parser(\"abc|def\"), Ok((\"|def\", vec![\"abc\"])));\n/// assert_eq!(parser(\"\"), Ok((\"\", vec![])));\n/// assert_eq!(parser(\"def|abc\"), Ok((\"def|abc\", vec![])));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn separated_list0<I, E, F, G>(\n  mut sep: G,\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, Vec<<F as Parser<I>>::Output>, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  G: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |mut i: I| {\n    let mut res = Vec::new();\n\n    match f.parse(i.clone()) {\n      Err(Err::Error(_)) => return Ok((i, res)),\n      Err(e) => return Err(e),\n      Ok((i1, o)) => {\n        res.push(o);\n        i = i1;\n      }\n    }\n\n    loop {\n      let len = i.input_len();\n      match sep.parse(i.clone()) {\n        Err(Err::Error(_)) => return Ok((i, res)),\n        Err(e) => return Err(e),\n        Ok((i1, _)) => {\n          // infinite loop check: the parser must always consume\n          if i1.input_len() == len {\n            return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList)));\n          }\n\n          match f.parse(i1.clone()) {\n            Err(Err::Error(_)) => return Ok((i, res)),\n            Err(e) => return Err(e),\n            Ok((i2, o)) => {\n              res.push(o);\n              i = i2;\n            }\n          }\n        }\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"multi::separated_list1":["/// Alternates between two parsers to produce a list of elements until [`Err::Error`].\n///\n/// Fails if the element parser does not produce at least one element.$\n///\n/// This stops when either parser returns [`Err::Error`]  and returns the results that were accumulated. To instead chain an error up, see\n/// [`cut`][crate::combinator::cut].\n///\n/// # Arguments\n/// * `sep` Parses the separator between list elements.\n/// * `f` Parses the elements of the list.\n/// ```rust\n/// # use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\n/// use nom::multi::separated_list1;\n/// use nom::bytes::complete::tag;\n///\n/// fn parser(s: &str) -> IResult<&str, Vec<&str>> {\n///   separated_list1(tag(\"|\"), tag(\"abc\"))(s)\n/// }\n///\n/// assert_eq!(parser(\"abc|abc|abc\"), Ok((\"\", vec![\"abc\", \"abc\", \"abc\"])));\n/// assert_eq!(parser(\"abc123abc\"), Ok((\"123abc\", vec![\"abc\"])));\n/// assert_eq!(parser(\"abc|def\"), Ok((\"|def\", vec![\"abc\"])));\n/// assert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"def|abc\"), Err(Err::Error(Error::new(\"def|abc\", ErrorKind::Tag))));\n/// ```\n#[cfg(feature = \"alloc\")]\npub fn separated_list1<I, E, F, G>(\n  mut sep: G,\n  mut f: F,\n) -> impl FnMut(I) -> IResult<I, Vec<<F as Parser<I>>::Output>, E>\nwhere\n  I: Clone + InputLength,\n  F: Parser<I, Error = E>,\n  G: Parser<I, Error = E>,\n  E: ParseError<I>,{\n  move |mut i: I| {\n    let mut res = Vec::new();\n\n    // Parse the first element\n    match f.parse(i.clone()) {\n      Err(e) => return Err(e),\n      Ok((i1, o)) => {\n        res.push(o);\n        i = i1;\n      }\n    }\n\n    loop {\n      let len = i.input_len();\n      match sep.parse(i.clone()) {\n        Err(Err::Error(_)) => return Ok((i, res)),\n        Err(e) => return Err(e),\n        Ok((i1, _)) => {\n          // infinite loop check: the parser must always consume\n          if i1.input_len() == len {\n            return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList)));\n          }\n\n          match f.parse(i1.clone()) {\n            Err(Err::Error(_)) => return Ok((i, res)),\n            Err(e) => return Err(e),\n            Ok((i2, o)) => {\n              res.push(o);\n              i = i2;\n            }\n          }\n        }\n      }\n    }\n  }\n}","Real(LocalPath(\"src/multi/mod.rs\"))"],"number::Endianness":["/// Configurable endianness\npub enum Endianness {\n  /// Big endian\n  Big,\n  /// Little endian\n  Little,\n  /// Will match the host's endianness\n  Native,\n}","Real(LocalPath(\"src/number/mod.rs\"))"],"number::complete::be_f32":["/// Recognizes a big endian 4 bytes floating point number.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_f32;\n///\n/// let parser = |s| {\n///   be_f32(s)\n/// };\n///\n/// assert_eq!(parser(&[0x41, 0x48, 0x00, 0x00][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(parser(&b\"abc\"[..]), Err(Err::Error((&b\"abc\"[..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E>\nwhere\n  I: Input<Item = u8>,{\n  match be_u32(input) {\n    Err(e) => Err(e),\n    Ok((i, o)) => Ok((i, f32::from_bits(o))),\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_f64":["/// Recognizes a big endian 8 bytes floating point number.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_f64;\n///\n/// let parser = |s| {\n///   be_f64(s)\n/// };\n///\n/// assert_eq!(parser(&[0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(parser(&b\"abc\"[..]), Err(Err::Error((&b\"abc\"[..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E>\nwhere\n  I: Input<Item = u8>,{\n  match be_u64(input) {\n    Err(e) => Err(e),\n    Ok((i, o)) => Ok((i, f64::from_bits(o))),\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_i128":["/// Recognizes a big endian signed 16 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_i128;\n///\n/// let parser = |s| {\n///   be_i128(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00010203040506070001020304050607)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u128.map(|x| x as i128).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_i16":["/// Recognizes a big endian signed 2 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_i16;\n///\n/// let parser = |s| {\n///   be_i16(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0003)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u16.map(|x| x as i16).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_i24":["/// Recognizes a big endian signed 3 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_i24;\n///\n/// let parser = |s| {\n///   be_i24(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x000305)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  // Same as the unsigned version but we need to sign-extend manually here\n  be_u24\n    .map(|x| {\n      if x & 0x80_00_00 != 0 {\n        (x | 0xff_00_00_00) as i32\n      } else {\n        x as i32\n      }\n    })\n    .parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_i32":["/// Recognizes a big endian signed 4 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_i32;\n///\n/// let parser = |s| {\n///   be_i32(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00030507)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u32.map(|x| x as i32).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_i64":["/// Recognizes a big endian signed 8 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_i64;\n///\n/// let parser = |s| {\n///   be_i64(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0001020304050607)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u64.map(|x| x as i64).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_i8":["/// Recognizes a signed 1 byte integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_i8;\n///\n/// let parser = |s| {\n///   be_i8(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"\\x03abcefg\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Error((&[][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u8.map(|x| x as i8).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_u128":["/// Recognizes a big endian unsigned 16 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_u128;\n///\n/// let parser = |s| {\n///   be_u128(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00010203040506070001020304050607)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 16)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_u16":["/// Recognizes a big endian unsigned 2 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_u16;\n///\n/// let parser = |s| {\n///   be_u16(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0003)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 2)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_u24":["/// Recognizes a big endian unsigned 3 byte integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_u24;\n///\n/// let parser = |s| {\n///   be_u24(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x000305)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 3)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_u32":["/// Recognizes a big endian unsigned 4 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_u32;\n///\n/// let parser = |s| {\n///   be_u32(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00030507)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 4)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_u64":["/// Recognizes a big endian unsigned 8 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_u64;\n///\n/// let parser = |s| {\n///   be_u64(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0001020304050607)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 8)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_u8":["/// Recognizes an unsigned 1 byte integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::be_u8;\n///\n/// let parser = |s| {\n///   be_u8(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"\\x03abcefg\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Error((&[][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn be_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 1)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::be_uint":["#[inline]\nfn be_uint<I, Uint, E: ParseError<I>>(input: I, bound: usize) -> IResult<I, Uint, E>\nwhere\n  I: Input<Item = u8>,\n  Uint: Default + Shl<u8, Output = Uint> + Add<Uint, Output = Uint> + From<u8>,{\n  if input.input_len() < bound {\n    Err(Err::Error(make_error(input, ErrorKind::Eof)))\n  } else {\n    let mut res = Uint::default();\n\n    // special case to avoid shift a byte with overflow\n    if bound > 1 {\n      for byte in input.iter_elements().take(bound) {\n        res = (res << 8) + byte.into();\n      }\n    } else {\n      for byte in input.iter_elements().take(bound) {\n        res = byte.into();\n      }\n    }\n\n    Ok((input.take_from(bound), res))\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::double":["/// Recognizes floating point number in text format and returns a f64.\n///\n/// *Complete version*: Can parse until the end of input.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::double;\n///\n/// let parser = |s| {\n///   double(s)\n/// };\n///\n/// assert_eq!(parser(\"11e-1\"), Ok((\"\", 1.1)));\n/// assert_eq!(parser(\"123E-02\"), Ok((\"\", 1.23)));\n/// assert_eq!(parser(\"123K-01\"), Ok((\"K-01\", 123.0)));\n/// assert_eq!(parser(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Float))));\n/// ```\npub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E>\nwhere\n  T: Clone + Offset + ParseTo<f64> + Compare<&'static str>,\n  T: Input,\n  <T as Input>::Item: AsChar,\n  <T as Input>::Iter: Clone,\n  T: AsBytes,\n  T: for<'a> Compare<&'a [u8]>,{\n  /*\n  let (i, (sign, integer, fraction, exponent)) = recognize_float_parts(input)?;\n\n  let mut float: f64 = minimal_lexical::parse_float(\n    integer.as_bytes().iter(),\n    fraction.as_bytes().iter(),\n    exponent,\n  );\n  if !sign {\n    float = -float;\n  }\n\n  Ok((i, float))\n      */\n  let (i, s) = recognize_float_or_exceptions(input)?;\n  match s.parse_to() {\n    Some(f) => Ok((i, f)),\n    None => Err(crate::Err::Error(E::from_error_kind(\n      i,\n      crate::error::ErrorKind::Float,\n    ))),\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::f32":["/// Recognizes a 4 byte floating point number\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian f32 float,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian f32 float.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::f32;\n///\n/// let be_f32 = |s| {\n///   f32(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_f32(&[0x41, 0x48, 0x00, 0x00][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(be_f32(&b\"abc\"[..]), Err(Err::Error((&b\"abc\"[..], ErrorKind::Eof))));\n///\n/// let le_f32 = |s| {\n///   f32(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_f32(&[0x00, 0x00, 0x48, 0x41][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(le_f32(&b\"abc\"[..]), Err(Err::Error((&b\"abc\"[..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn f32<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, f32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_f32,\n    crate::number::Endianness::Little => le_f32,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_f32,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_f32,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::f64":["/// Recognizes an 8 byte floating point number\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian f64 float,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian f64 float.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::f64;\n///\n/// let be_f64 = |s| {\n///   f64(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_f64(&[0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(be_f64(&b\"abc\"[..]), Err(Err::Error((&b\"abc\"[..], ErrorKind::Eof))));\n///\n/// let le_f64 = |s| {\n///   f64(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_f64(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(le_f64(&b\"abc\"[..]), Err(Err::Error((&b\"abc\"[..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn f64<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, f64, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_f64,\n    crate::number::Endianness::Little => le_f64,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_f64,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_f64,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::float":["/// Recognizes floating point number in text format and returns a f32.\n///\n/// *Complete version*: Can parse until the end of input.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::float;\n///\n/// let parser = |s| {\n///   float(s)\n/// };\n///\n/// assert_eq!(parser(\"11e-1\"), Ok((\"\", 1.1)));\n/// assert_eq!(parser(\"123E-02\"), Ok((\"\", 1.23)));\n/// assert_eq!(parser(\"123K-01\"), Ok((\"K-01\", 123.0)));\n/// assert_eq!(parser(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Float))));\n/// ```\npub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E>\nwhere\n  T: Clone + Offset + ParseTo<f32> + Compare<&'static str>,\n  T: Input,\n  <T as Input>::Item: AsChar,\n  <T as Input>::Iter: Clone,\n  T: AsBytes,\n  T: for<'a> Compare<&'a [u8]>,{\n  /*\n  let (i, (sign, integer, fraction, exponent)) = recognize_float_parts(input)?;\n\n  let mut float: f32 = minimal_lexical::parse_float(\n    integer.as_bytes().iter(),\n    fraction.as_bytes().iter(),\n    exponent,\n  );\n  if !sign {\n    float = -float;\n  }\n\n  Ok((i, float))\n      */\n  let (i, s) = recognize_float_or_exceptions(input)?;\n  match s.parse_to() {\n    Some(f) => Ok((i, f)),\n    None => Err(crate::Err::Error(E::from_error_kind(\n      i,\n      crate::error::ErrorKind::Float,\n    ))),\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::hex_u32":["/// Recognizes a hex-encoded integer.\n///\n/// *Complete version*: Will parse until the end of input if it has less than 8 bytes.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::hex_u32;\n///\n/// let parser = |s| {\n///   hex_u32(s)\n/// };\n///\n/// assert_eq!(parser(&b\"01AE\"[..]), Ok((&b\"\"[..], 0x01AE)));\n/// assert_eq!(parser(&b\"abc\"[..]), Ok((&b\"\"[..], 0x0ABC)));\n/// assert_eq!(parser(&b\"ggg\"[..]), Err(Err::Error((&b\"ggg\"[..], ErrorKind::IsA))));\n/// ```\n#[inline]\npub fn hex_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input,\n  <I as Input>::Item: AsChar,\n  I: AsBytes,{\n  let e: ErrorKind = ErrorKind::IsA;\n  let (i, o) = input.split_at_position1_complete(\n    |c| {\n      let c = c.as_char();\n      !\"0123456789abcdefABCDEF\".contains(c)\n    },\n    e,\n  )?;\n\n  // Do not parse more than 8 characters for a u32\n  let (remaining, parsed) = if o.input_len() <= 8 {\n    (i, o)\n  } else {\n    input.take_split(8)\n  };\n\n  let res = parsed\n    .as_bytes()\n    .iter()\n    .rev()\n    .enumerate()\n    .map(|(k, &v)| {\n      let digit = v as char;\n      digit.to_digit(16).unwrap_or(0) << (k * 4)\n    })\n    .sum();\n\n  Ok((remaining, res))\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::i128":["/// Recognizes a signed 16 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i128 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i128 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::i128;\n///\n/// let be_i128 = |s| {\n///   i128(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i128(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00010203040506070001020304050607)));\n/// assert_eq!(be_i128(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_i128 = |s| {\n///   i128(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i128(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07060504030201000706050403020100)));\n/// assert_eq!(le_i128(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn i128<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i128, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i128,\n    crate::number::Endianness::Little => le_i128,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i128,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i128,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::i16":["/// Recognizes a signed 2 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i16 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i16 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::i16;\n///\n/// let be_i16 = |s| {\n///   i16(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i16(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0003)));\n/// assert_eq!(be_i16(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_i16 = |s| {\n///   i16(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i16(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0300)));\n/// assert_eq!(le_i16(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn i16<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i16, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i16,\n    crate::number::Endianness::Little => le_i16,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i16,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i16,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::i24":["/// Recognizes a signed 3 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i24 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i24 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::i24;\n///\n/// let be_i24 = |s| {\n///   i24(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i24(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x000305)));\n/// assert_eq!(be_i24(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_i24 = |s| {\n///   i24(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i24(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x050300)));\n/// assert_eq!(le_i24(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn i24<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i24,\n    crate::number::Endianness::Little => le_i24,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i24,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i24,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::i32":["/// Recognizes a signed 4 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i32 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i32 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::i32;\n///\n/// let be_i32 = |s| {\n///   i32(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i32(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00030507)));\n/// assert_eq!(be_i32(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_i32 = |s| {\n///   i32(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i32(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07050300)));\n/// assert_eq!(le_i32(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn i32<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i32,\n    crate::number::Endianness::Little => le_i32,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i32,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i32,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::i64":["/// Recognizes a signed 8 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i64 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i64 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::i64;\n///\n/// let be_i64 = |s| {\n///   i64(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i64(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0001020304050607)));\n/// assert_eq!(be_i64(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_i64 = |s| {\n///   i64(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i64(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0706050403020100)));\n/// assert_eq!(le_i64(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn i64<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i64, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i64,\n    crate::number::Endianness::Little => le_i64,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i64,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i64,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::i8":["/// Recognizes a signed 1 byte integer\n///\n/// Note that endianness does not apply to 1 byte numbers.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::i8;\n///\n/// let parser = |s| {\n///   i8(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"\\x03abcefg\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Error((&[][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E>\nwhere\n  I: Input<Item = u8>,{\n  u8.map(|x| x as i8).parse(i)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_f32":["/// Recognizes a little endian 4 bytes floating point number.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_f32;\n///\n/// let parser = |s| {\n///   le_f32(s)\n/// };\n///\n/// assert_eq!(parser(&[0x00, 0x00, 0x48, 0x41][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(parser(&b\"abc\"[..]), Err(Err::Error((&b\"abc\"[..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E>\nwhere\n  I: Input<Item = u8>,{\n  match le_u32(input) {\n    Err(e) => Err(e),\n    Ok((i, o)) => Ok((i, f32::from_bits(o))),\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_f64":["/// Recognizes a little endian 8 bytes floating point number.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_f64;\n///\n/// let parser = |s| {\n///   le_f64(s)\n/// };\n///\n/// assert_eq!(parser(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(parser(&b\"abc\"[..]), Err(Err::Error((&b\"abc\"[..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E>\nwhere\n  I: Input<Item = u8>,{\n  match le_u64(input) {\n    Err(e) => Err(e),\n    Ok((i, o)) => Ok((i, f64::from_bits(o))),\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_i128":["/// Recognizes a little endian signed 16 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_i128;\n///\n/// let parser = |s| {\n///   le_i128(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07060504030201000706050403020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u128.map(|x| x as i128).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_i16":["/// Recognizes a little endian signed 2 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_i16;\n///\n/// let parser = |s| {\n///   le_i16(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0300)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u16.map(|x| x as i16).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_i24":["/// Recognizes a little endian signed 3 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_i24;\n///\n/// let parser = |s| {\n///   le_i24(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x050300)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  // Same as the unsigned version but we need to sign-extend manually here\n  le_u24\n    .map(|x| {\n      if x & 0x80_00_00 != 0 {\n        (x | 0xff_00_00_00) as i32\n      } else {\n        x as i32\n      }\n    })\n    .parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_i32":["/// Recognizes a little endian signed 4 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_i32;\n///\n/// let parser = |s| {\n///   le_i32(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07050300)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u32.map(|x| x as i32).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_i64":["/// Recognizes a little endian signed 8 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_i64;\n///\n/// let parser = |s| {\n///   le_i64(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0706050403020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u64.map(|x| x as i64).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_i8":["/// Recognizes a signed 1 byte integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_i8;\n///\n/// let parser = |s| {\n///   le_i8(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"\\x03abcefg\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Error((&[][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u8.map(|x| x as i8).parse(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_u128":["/// Recognizes a little endian unsigned 16 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_u128;\n///\n/// let parser = |s| {\n///   le_u128(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07060504030201000706050403020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 16)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_u16":["/// Recognizes a little endian unsigned 2 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_u16;\n///\n/// let parser = |s| {\n///   le_u16(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0300)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 2)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_u24":["/// Recognizes a little endian unsigned 3 byte integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_u24;\n///\n/// let parser = |s| {\n///   le_u24(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x050300)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 3)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_u32":["/// Recognizes a little endian unsigned 4 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_u32;\n///\n/// let parser = |s| {\n///   le_u32(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07050300)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 4)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_u64":["/// Recognizes a little endian unsigned 8 bytes integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_u64;\n///\n/// let parser = |s| {\n///   le_u64(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0706050403020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 8)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_u8":["/// Recognizes an unsigned 1 byte integer.\n///\n/// *Complete version*: Returns an error if there is not enough input data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::le_u8;\n///\n/// let parser = |s| {\n///   le_u8(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"\\x03abcefg\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Error((&[][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn le_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 1)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::le_uint":["#[inline]\nfn le_uint<I, Uint, E: ParseError<I>>(input: I, bound: usize) -> IResult<I, Uint, E>\nwhere\n  I: Input<Item = u8>,\n  Uint: Default + Shl<u8, Output = Uint> + Add<Uint, Output = Uint> + From<u8>,{\n  if input.input_len() < bound {\n    Err(Err::Error(make_error(input, ErrorKind::Eof)))\n  } else {\n    let mut res = Uint::default();\n    for (index, byte) in input.iter_elements().take(bound).enumerate() {\n      res = res + (Uint::from(byte) << (8 * index as u8));\n    }\n\n    Ok((input.take_from(bound), res))\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::recognize_float":["/// Recognizes floating point number in a byte string and returns the corresponding slice.\n///\n/// *Complete version*: Can parse until the end of input.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::recognize_float;\n///\n/// let parser = |s| {\n///   recognize_float(s)\n/// };\n///\n/// assert_eq!(parser(\"11e-1\"), Ok((\"\", \"11e-1\")));\n/// assert_eq!(parser(\"123E-02\"), Ok((\"\", \"123E-02\")));\n/// assert_eq!(parser(\"123K-01\"), Ok((\"K-01\", \"123\")));\n/// assert_eq!(parser(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Char))));\n/// ```\n#[rustfmt::skip]\npub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Clone + Offset,\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  recognize((\n    opt(alt((char('+'), char('-')))),\n      alt((\n        map((digit1, opt(pair(char('.'), opt(digit1)))), |_| ()),\n        map((char('.'), digit1), |_| ())\n      )),\n      opt((\n        alt((char('e'), char('E'))),\n        opt(alt((char('+'), char('-')))),\n        cut(digit1)\n      ))\n  ))(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::recognize_float_or_exceptions":["#[doc(hidden)]\npub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Clone + Offset,\n  T: Input + Compare<&'static str>,\n  <T as Input>::Item: AsChar,{\n  alt((\n    |i: T| {\n      recognize_float::<_, E>(i.clone()).map_err(|e| match e {\n        crate::Err::Error(_) => crate::Err::Error(E::from_error_kind(i, ErrorKind::Float)),\n        crate::Err::Failure(_) => crate::Err::Failure(E::from_error_kind(i, ErrorKind::Float)),\n        crate::Err::Incomplete(needed) => crate::Err::Incomplete(needed),\n      })\n    },\n    |i: T| {\n      crate::bytes::complete::tag_no_case::<_, _, E>(\"nan\")(i.clone())\n        .map_err(|_| crate::Err::Error(E::from_error_kind(i, ErrorKind::Float)))\n    },\n    |i: T| {\n      crate::bytes::complete::tag_no_case::<_, _, E>(\"inf\")(i.clone())\n        .map_err(|_| crate::Err::Error(E::from_error_kind(i, ErrorKind::Float)))\n    },\n    |i: T| {\n      crate::bytes::complete::tag_no_case::<_, _, E>(\"infinity\")(i.clone())\n        .map_err(|_| crate::Err::Error(E::from_error_kind(i, ErrorKind::Float)))\n    },\n  ))(input)\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::recognize_float_parts":["/// Recognizes a floating point number in text format\n///\n/// It returns a tuple of (`sign`, `integer part`, `fraction part` and `exponent`) of the input\n/// data.\n///\n/// *Complete version*: Can parse until the end of input.\n///\npub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E>\nwhere\n  T: Clone + Offset,\n  T: Input,\n  <T as Input>::Item: AsChar,\n  T: for<'a> Compare<&'a [u8]>,\n  T: AsBytes,{\n  let (i, sign) = sign(input.clone())?;\n\n  //let (i, zeroes) = take_while(|c: <T as Input>::Item| c.as_char() == '0')(i)?;\n  let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0') {\n    Some(index) => i.take_split(index),\n    None => i.take_split(i.input_len()),\n  };\n  //let (i, mut integer) = digit0(i)?;\n  let (i, mut integer) = match i\n    .as_bytes()\n    .iter()\n    .position(|c| !(*c >= b'0' && *c <= b'9'))\n  {\n    Some(index) => i.take_split(index),\n    None => i.take_split(i.input_len()),\n  };\n\n  if integer.input_len() == 0 && zeroes.input_len() > 0 {\n    // keep the last zero if integer is empty\n    integer = zeroes.take_from(zeroes.input_len() - 1);\n  }\n\n  let (i, opt_dot) = opt(tag(&b\".\"[..]))(i)?;\n  let (i, fraction) = if opt_dot.is_none() {\n    let i2 = i.clone();\n    (i2, i.take(0))\n  } else {\n    // match number, trim right zeroes\n    let mut zero_count = 0usize;\n    let mut position = None;\n    for (pos, c) in i.as_bytes().iter().enumerate() {\n      if *c >= b'0' && *c <= b'9' {\n        if *c == b'0' {\n          zero_count += 1;\n        } else {\n          zero_count = 0;\n        }\n      } else {\n        position = Some(pos);\n        break;\n      }\n    }\n\n    #[allow(clippy::or_fun_call)]\n    let position = position.unwrap_or(i.input_len());\n\n    let index = if zero_count == 0 {\n      position\n    } else if zero_count == position {\n      position - zero_count + 1\n    } else {\n      position - zero_count\n    };\n\n    (i.take_from(position), i.take(index))\n  };\n\n  if integer.input_len() == 0 && fraction.input_len() == 0 {\n    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float)));\n  }\n\n  let i2 = i.clone();\n  let (i, e) = match i.as_bytes().iter().next() {\n    Some(b'e') => (i.take_from(1), true),\n    Some(b'E') => (i.take_from(1), true),\n    _ => (i, false),\n  };\n\n  let (i, exp) = if e {\n    cut(crate::character::complete::i32)(i)?\n  } else {\n    (i2, 0)\n  };\n\n  Ok((i, (sign, integer, fraction, exp)))\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::u128":["/// Recognizes an unsigned 16 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u128 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u128 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::u128;\n///\n/// let be_u128 = |s| {\n///   u128(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u128(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00010203040506070001020304050607)));\n/// assert_eq!(be_u128(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_u128 = |s| {\n///   u128(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u128(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07060504030201000706050403020100)));\n/// assert_eq!(le_u128(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn u128<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u128, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u128,\n    crate::number::Endianness::Little => le_u128,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u128,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u128,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::u16":["/// Recognizes an unsigned 2 bytes integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u16 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u16 integer.\n/// *complete version*: returns an error if there is not enough input data\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::u16;\n///\n/// let be_u16 = |s| {\n///   u16(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u16(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0003)));\n/// assert_eq!(be_u16(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_u16 = |s| {\n///   u16(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u16(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0300)));\n/// assert_eq!(le_u16(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn u16<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u16, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u16,\n    crate::number::Endianness::Little => le_u16,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u16,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u16,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::u24":["/// Recognizes an unsigned 3 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u24 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u24 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::u24;\n///\n/// let be_u24 = |s| {\n///   u24(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u24(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x000305)));\n/// assert_eq!(be_u24(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_u24 = |s| {\n///   u24(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u24(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x050300)));\n/// assert_eq!(le_u24(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn u24<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u24,\n    crate::number::Endianness::Little => le_u24,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u24,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u24,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::u32":["/// Recognizes an unsigned 4 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u32 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u32 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::u32;\n///\n/// let be_u32 = |s| {\n///   u32(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u32(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00030507)));\n/// assert_eq!(be_u32(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_u32 = |s| {\n///   u32(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u32(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07050300)));\n/// assert_eq!(le_u32(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn u32<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u32,\n    crate::number::Endianness::Little => le_u32,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u32,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u32,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::u64":["/// Recognizes an unsigned 8 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u64 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u64 integer.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::u64;\n///\n/// let be_u64 = |s| {\n///   u64(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u64(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0001020304050607)));\n/// assert_eq!(be_u64(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n///\n/// let le_u64 = |s| {\n///   u64(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u64(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0706050403020100)));\n/// assert_eq!(le_u64(&b\"\\x01\"[..]), Err(Err::Error((&[0x01][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn u64<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u64, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u64,\n    crate::number::Endianness::Little => le_u64,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u64,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u64,\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::complete::u8":["/// Recognizes an unsigned 1 byte integer\n///\n/// Note that endianness does not apply to 1 byte numbers.\n/// *complete version*: returns an error if there is not enough input data\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::u8;\n///\n/// let parser = |s| {\n///   u8(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"\\x03abcefg\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Error((&[][..], ErrorKind::Eof))));\n/// ```\n#[inline]\npub fn u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E>\nwhere\n  I: Input<Item = u8>,{\n  let bound: usize = 1;\n  if input.input_len() < bound {\n    Err(Err::Error(make_error(input, ErrorKind::Eof)))\n  } else {\n    let res = input.iter_elements().next().unwrap();\n\n    Ok((input.take_from(bound), res))\n  }\n}","Real(LocalPath(\"src/number/complete.rs\"))"],"number::streaming::be_f32":["/// Recognizes a big endian 4 bytes floating point number.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_f32;\n///\n/// let parser = |s| {\n///   be_f32::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&[0x40, 0x29, 0x00, 0x00][..]), Ok((&b\"\"[..], 2.640625)));\n/// assert_eq!(parser(&[0x01][..]), Err(Err::Incomplete(Needed::new(3))));\n/// ```\n#[inline]\npub fn be_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E>\nwhere\n  I: Input<Item = u8>,{\n  match be_u32(input) {\n    Err(e) => Err(e),\n    Ok((i, o)) => Ok((i, f32::from_bits(o))),\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_f64":["/// Recognizes a big endian 8 bytes floating point number.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_f64;\n///\n/// let parser = |s| {\n///   be_f64::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&[0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(parser(&[0x01][..]), Err(Err::Incomplete(Needed::new(7))));\n/// ```\n#[inline]\npub fn be_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E>\nwhere\n  I: Input<Item = u8>,{\n  match be_u64(input) {\n    Err(e) => Err(e),\n    Ok((i, o)) => Ok((i, f64::from_bits(o))),\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_i128":["/// Recognizes a big endian signed 16 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_i128;\n///\n/// let parser = be_i128::<_, (_, ErrorKind)>;\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x10\\x11\\x12\\x13\\x14\\x15abcd\"[..]), Ok((&b\"abcd\"[..], 0x00010203040506070809101112131415)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(15))));\n/// ```\n#[inline]\npub fn be_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u128.map(|x| x as i128).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_i16":["/// Recognizes a big endian signed 2 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_i16;\n///\n/// let parser = be_i16::<_, (_, ErrorKind)>;\n///\n/// assert_eq!(parser(&b\"\\x00\\x01abcd\"[..]), Ok((&b\"abcd\"[..], 0x0001)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(2))));\n/// ```\n#[inline]\npub fn be_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u16.map(|x| x as i16).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_i24":["/// Recognizes a big endian signed 3 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_i24;\n///\n/// let parser = be_i24::<_, (_, ErrorKind)>;\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02abcd\"[..]), Ok((&b\"abcd\"[..], 0x000102)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(3))));\n/// ```\n#[inline]\npub fn be_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  // Same as the unsigned version but we need to sign-extend manually here\n  be_u24\n    .map(|x| {\n      if x & 0x80_00_00 != 0 {\n        (x | 0xff_00_00_00) as i32\n      } else {\n        x as i32\n      }\n    })\n    .parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_i32":["/// Recognizes a big endian signed 4 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_i32;\n///\n/// let parser = be_i32::<_, (_, ErrorKind)>;\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03abcd\"[..]), Ok((&b\"abcd\"[..], 0x00010203)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(4))));\n/// ```\n#[inline]\npub fn be_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u32.map(|x| x as i32).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_i64":["/// Recognizes a big endian signed 8 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_i64;\n///\n/// let parser = be_i64::<_, (_, ErrorKind)>;\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcd\"[..]), Ok((&b\"abcd\"[..], 0x0001020304050607)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(7))));\n/// ```\n#[inline]\npub fn be_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u64.map(|x| x as i64).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_i8":["/// Recognizes a signed 1 byte integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_i8;\n///\n/// let parser = be_i8::<_, (_, ErrorKind)>;\n///\n/// assert_eq!(parser(&b\"\\x00\\x01abcd\"[..]), Ok((&b\"\\x01abcd\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn be_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E>\nwhere\n  I: Input<Item = u8>,{\n  be_u8.map(|x| x as i8).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_u128":["/// Recognizes a big endian unsigned 16 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_u128;\n///\n/// let parser = |s| {\n///   be_u128::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x10\\x11\\x12\\x13\\x14\\x15abcd\"[..]), Ok((&b\"abcd\"[..], 0x00010203040506070809101112131415)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(15))));\n/// ```\n#[inline]\npub fn be_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 16)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_u16":["/// Recognizes a big endian unsigned 2 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_u16;\n///\n/// let parser = |s| {\n///   be_u16::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01abcd\"[..]), Ok((&b\"abcd\"[..], 0x0001)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn be_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 2)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_u24":["/// Recognizes a big endian unsigned 3 byte integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_u24;\n///\n/// let parser = |s| {\n///   be_u24::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02abcd\"[..]), Ok((&b\"abcd\"[..], 0x000102)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(2))));\n/// ```\n#[inline]\npub fn be_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 3)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_u32":["/// Recognizes a big endian unsigned 4 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_u32;\n///\n/// let parser = |s| {\n///   be_u32::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03abcd\"[..]), Ok((&b\"abcd\"[..], 0x00010203)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(3))));\n/// ```\n#[inline]\npub fn be_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 4)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_u64":["/// Recognizes a big endian unsigned 8 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_u64;\n///\n/// let parser = |s| {\n///   be_u64::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcd\"[..]), Ok((&b\"abcd\"[..], 0x0001020304050607)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(7))));\n/// ```\n#[inline]\npub fn be_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 8)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_u8":["/// Recognizes an unsigned 1 byte integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::be_u8;\n///\n/// let parser = |s| {\n///   be_u8::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01abcd\"[..]), Ok((&b\"\\x01abcd\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn be_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E>\nwhere\n  I: Input<Item = u8>,{\n  be_uint(input, 1)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::be_uint":["#[inline]\nfn be_uint<I, Uint, E: ParseError<I>>(input: I, bound: usize) -> IResult<I, Uint, E>\nwhere\n  I: Input<Item = u8>,\n  Uint: Default + Shl<u8, Output = Uint> + Add<Uint, Output = Uint> + From<u8>,{\n  if input.input_len() < bound {\n    Err(Err::Incomplete(Needed::new(bound - input.input_len())))\n  } else {\n    let mut res = Uint::default();\n\n    // special case to avoid shift a byte with overflow\n    if bound > 1 {\n      for byte in input.iter_elements().take(bound) {\n        res = (res << 8) + byte.into();\n      }\n    } else {\n      for byte in input.iter_elements().take(bound) {\n        res = byte.into();\n      }\n    }\n\n    Ok((input.take_from(bound), res))\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::double":["/// Recognizes floating point number in text format and returns a f64.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::double;\n///\n/// let parser = |s| {\n///   double(s)\n/// };\n///\n/// assert_eq!(parser(\"11e-1\"), Ok((\"\", 1.1)));\n/// assert_eq!(parser(\"123E-02\"), Ok((\"\", 1.23)));\n/// assert_eq!(parser(\"123K-01\"), Ok((\"K-01\", 123.0)));\n/// assert_eq!(parser(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Float))));\n/// ```\npub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E>\nwhere\n  T: Clone + Offset,\n  T: Input + crate::traits::ParseTo<f64> + Compare<&'static str>,\n  <T as Input>::Item: AsChar + Clone,\n  T: AsBytes,\n  T: for<'a> Compare<&'a [u8]>,{\n  /*\n  let (i, (sign, integer, fraction, exponent)) = recognize_float_parts(input)?;\n\n  let mut float: f64 = minimal_lexical::parse_float(\n    integer.as_bytes().iter(),\n    fraction.as_bytes().iter(),\n    exponent,\n  );\n  if !sign {\n    float = -float;\n  }\n\n  Ok((i, float))\n  */\n  let (i, s) = recognize_float_or_exceptions(input)?;\n  match s.parse_to() {\n    Some(f) => Ok((i, f)),\n    None => Err(crate::Err::Error(E::from_error_kind(\n      i,\n      crate::error::ErrorKind::Float,\n    ))),\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::f32":["/// Recognizes a 4 byte floating point number\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian f32 float,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian f32 float.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::f32;\n///\n/// let be_f32 = |s| {\n///   f32::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_f32(&[0x41, 0x48, 0x00, 0x00][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(be_f32(&b\"abc\"[..]), Err(Err::Incomplete(Needed::new(1))));\n///\n/// let le_f32 = |s| {\n///   f32::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_f32(&[0x00, 0x00, 0x48, 0x41][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(le_f32(&b\"abc\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn f32<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, f32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_f32,\n    crate::number::Endianness::Little => le_f32,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_f32,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_f32,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::f64":["/// Recognizes an 8 byte floating point number\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian f64 float,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian f64 float.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::f64;\n///\n/// let be_f64 = |s| {\n///   f64::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_f64(&[0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(be_f64(&b\"abc\"[..]), Err(Err::Incomplete(Needed::new(5))));\n///\n/// let le_f64 = |s| {\n///   f64::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_f64(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(le_f64(&b\"abc\"[..]), Err(Err::Incomplete(Needed::new(5))));\n/// ```\n#[inline]\npub fn f64<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, f64, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_f64,\n    crate::number::Endianness::Little => le_f64,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_f64,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_f64,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::float":["/// Recognizes floating point number in text format and returns a f32.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::complete::float;\n///\n/// let parser = |s| {\n///   float(s)\n/// };\n///\n/// assert_eq!(parser(\"11e-1\"), Ok((\"\", 1.1)));\n/// assert_eq!(parser(\"123E-02\"), Ok((\"\", 1.23)));\n/// assert_eq!(parser(\"123K-01\"), Ok((\"K-01\", 123.0)));\n/// assert_eq!(parser(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Float))));\n/// ```\npub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E>\nwhere\n  T: Clone + Offset,\n  T: Input + crate::traits::ParseTo<f32> + Compare<&'static str>,\n  <T as Input>::Item: AsChar + Clone,\n  T: AsBytes,\n  T: for<'a> Compare<&'a [u8]>,{\n  /*\n  let (i, (sign, integer, fraction, exponent)) = recognize_float_parts(input)?;\n\n  let mut float: f32 = minimal_lexical::parse_float(\n    integer.as_bytes().iter(),\n    fraction.as_bytes().iter(),\n    exponent,\n  );\n  if !sign {\n    float = -float;\n  }\n\n  Ok((i, float))\n  */\n  let (i, s) = recognize_float_or_exceptions(input)?;\n  match s.parse_to() {\n    Some(f) => Ok((i, f)),\n    None => Err(crate::Err::Error(E::from_error_kind(\n      i,\n      crate::error::ErrorKind::Float,\n    ))),\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::hex_u32":["/// Recognizes a hex-encoded integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::hex_u32;\n///\n/// let parser = |s| {\n///   hex_u32(s)\n/// };\n///\n/// assert_eq!(parser(&b\"01AE;\"[..]), Ok((&b\";\"[..], 0x01AE)));\n/// assert_eq!(parser(&b\"abc\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// assert_eq!(parser(&b\"ggg\"[..]), Err(Err::Error((&b\"ggg\"[..], ErrorKind::IsA))));\n/// ```\n#[inline]\npub fn hex_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input + AsBytes,\n  <I as Input>::Item: AsChar,{\n  let e: ErrorKind = ErrorKind::IsA;\n  let (i, o) = input.split_at_position1(\n    |c| {\n      let c = c.as_char();\n      !\"0123456789abcdefABCDEF\".contains(c)\n    },\n    e,\n  )?;\n\n  // Do not parse more than 8 characters for a u32\n  let (remaining, parsed) = if o.input_len() <= 8 {\n    (i, o)\n  } else {\n    input.take_split(8)\n  };\n\n  let res = parsed\n    .as_bytes()\n    .iter()\n    .rev()\n    .enumerate()\n    .map(|(k, &v)| {\n      let digit = v as char;\n      digit.to_digit(16).unwrap_or(0) << (k * 4)\n    })\n    .sum();\n\n  Ok((remaining, res))\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::i128":["/// Recognizes a signed 16 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i128 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i128 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::i128;\n///\n/// let be_i128 = |s| {\n///   i128::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i128(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00010203040506070001020304050607)));\n/// assert_eq!(be_i128(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(15))));\n///\n/// let le_i128 = |s| {\n///   i128::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i128(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07060504030201000706050403020100)));\n/// assert_eq!(le_i128(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(15))));\n/// ```\n#[inline]\npub fn i128<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i128, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i128,\n    crate::number::Endianness::Little => le_i128,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i128,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i128,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::i16":["/// Recognizes a signed 2 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i16 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i16 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::i16;\n///\n/// let be_i16 = |s| {\n///   i16::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i16(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0003)));\n/// assert_eq!(be_i16(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(1))));\n///\n/// let le_i16 = |s| {\n///   i16::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i16(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0300)));\n/// assert_eq!(le_i16(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn i16<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i16, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i16,\n    crate::number::Endianness::Little => le_i16,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i16,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i16,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::i24":["/// Recognizes a signed 3 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i24 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i24 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::i24;\n///\n/// let be_i24 = |s| {\n///   i24::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i24(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x000305)));\n/// assert_eq!(be_i24(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(2))));\n///\n/// let le_i24 = |s| {\n///   i24::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i24(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x050300)));\n/// assert_eq!(le_i24(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(2))));\n/// ```\n#[inline]\npub fn i24<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i24,\n    crate::number::Endianness::Little => le_i24,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i24,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i24,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::i32":["/// Recognizes a signed 4 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i32 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i32 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::i32;\n///\n/// let be_i32 = |s| {\n///   i32::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i32(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00030507)));\n/// assert_eq!(be_i32(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(3))));\n///\n/// let le_i32 = |s| {\n///   i32::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i32(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07050300)));\n/// assert_eq!(le_i32(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(3))));\n/// ```\n#[inline]\npub fn i32<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i32,\n    crate::number::Endianness::Little => le_i32,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i32,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i32,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::i64":["/// Recognizes a signed 8 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian i64 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian i64 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::i64;\n///\n/// let be_i64 = |s| {\n///   i64::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_i64(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0001020304050607)));\n/// assert_eq!(be_i64(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(7))));\n///\n/// let le_i64 = |s| {\n///   i64::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_i64(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0706050403020100)));\n/// assert_eq!(le_i64(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(7))));\n/// ```\n#[inline]\npub fn i64<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, i64, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_i64,\n    crate::number::Endianness::Little => le_i64,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_i64,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_i64,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::i8":["/// Recognizes a signed 1 byte integer\n///\n/// Note that endianness does not apply to 1 byte numbers.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::i8;\n///\n/// let parser = |s| {\n///   i8::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"\\x03abcefg\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E>\nwhere\n  I: Input<Item = u8>,{\n  u8.map(|x| x as i8).parse(i)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_f32":["/// Recognizes a little endian 4 bytes floating point number.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_f32;\n///\n/// let parser = |s| {\n///   le_f32::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&[0x00, 0x00, 0x48, 0x41][..]), Ok((&b\"\"[..], 12.5)));\n/// assert_eq!(parser(&[0x01][..]), Err(Err::Incomplete(Needed::new(3))));\n/// ```\n#[inline]\npub fn le_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E>\nwhere\n  I: Input<Item = u8>,{\n  match le_u32(input) {\n    Err(e) => Err(e),\n    Ok((i, o)) => Ok((i, f32::from_bits(o))),\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_f64":["/// Recognizes a little endian 8 bytes floating point number.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_f64;\n///\n/// let parser = |s| {\n///   le_f64::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x41][..]), Ok((&b\"\"[..], 3145728.0)));\n/// assert_eq!(parser(&[0x01][..]), Err(Err::Incomplete(Needed::new(7))));\n/// ```\n#[inline]\npub fn le_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E>\nwhere\n  I: Input<Item = u8>,{\n  match le_u64(input) {\n    Err(e) => Err(e),\n    Ok((i, o)) => Ok((i, f64::from_bits(o))),\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_i128":["/// Recognizes a little endian signed 16 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_i128;\n///\n/// let parser = |s| {\n///   le_i128::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x10\\x11\\x12\\x13\\x14\\x15abcd\"[..]), Ok((&b\"abcd\"[..], 0x15141312111009080706050403020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(15))));\n/// ```\n#[inline]\npub fn le_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u128.map(|x| x as i128).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_i16":["/// Recognizes a little endian signed 2 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_i16;\n///\n/// let parser = |s| {\n///   le_i16::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01abcd\"[..]), Ok((&b\"abcd\"[..], 0x0100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn le_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u16.map(|x| x as i16).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_i24":["/// Recognizes a little endian signed 3 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_i24;\n///\n/// let parser = |s| {\n///   le_i24::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02abcd\"[..]), Ok((&b\"abcd\"[..], 0x020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(2))));\n/// ```\n#[inline]\npub fn le_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  // Same as the unsigned version but we need to sign-extend manually here\n  le_u24\n    .map(|x| {\n      if x & 0x80_00_00 != 0 {\n        (x | 0xff_00_00_00) as i32\n      } else {\n        x as i32\n      }\n    })\n    .parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_i32":["/// Recognizes a little endian signed 4 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_i32;\n///\n/// let parser = |s| {\n///   le_i32::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03abcd\"[..]), Ok((&b\"abcd\"[..], 0x03020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(3))));\n/// ```\n#[inline]\npub fn le_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u32.map(|x| x as i32).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_i64":["/// Recognizes a little endian signed 8 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_i64;\n///\n/// let parser = |s| {\n///   le_i64::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcd\"[..]), Ok((&b\"abcd\"[..], 0x0706050403020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(7))));\n/// ```\n#[inline]\npub fn le_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u64.map(|x| x as i64).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_i8":["/// Recognizes a signed 1 byte integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_i8;\n///\n/// let parser = le_i8::<_, (_, ErrorKind)>;\n///\n/// assert_eq!(parser(&b\"\\x00\\x01abcd\"[..]), Ok((&b\"\\x01abcd\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn le_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E>\nwhere\n  I: Input<Item = u8>,{\n  le_u8.map(|x| x as i8).parse(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_u128":["/// Recognizes a little endian unsigned 16 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_u128;\n///\n/// let parser = |s| {\n///   le_u128::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x10\\x11\\x12\\x13\\x14\\x15abcd\"[..]), Ok((&b\"abcd\"[..], 0x15141312111009080706050403020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(15))));\n/// ```\n#[inline]\npub fn le_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 16)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_u16":["/// Recognizes a little endian unsigned 2 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_u16;\n///\n/// let parser = |s| {\n///   le_u16::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01abcd\"[..]), Ok((&b\"abcd\"[..], 0x0100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn le_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 2)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_u24":["/// Recognizes a little endian unsigned 3 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_u24;\n///\n/// let parser = |s| {\n///   le_u24::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02abcd\"[..]), Ok((&b\"abcd\"[..], 0x020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(2))));\n/// ```\n#[inline]\npub fn le_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 3)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_u32":["/// Recognizes a little endian unsigned 4 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_u32;\n///\n/// let parser = |s| {\n///   le_u32::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03abcd\"[..]), Ok((&b\"abcd\"[..], 0x03020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(3))));\n/// ```\n#[inline]\npub fn le_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 4)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_u64":["/// Recognizes a little endian unsigned 8 bytes integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_u64;\n///\n/// let parser = |s| {\n///   le_u64::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcd\"[..]), Ok((&b\"abcd\"[..], 0x0706050403020100)));\n/// assert_eq!(parser(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(7))));\n/// ```\n#[inline]\npub fn le_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 8)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_u8":["/// Recognizes an unsigned 1 byte integer.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::le_u8;\n///\n/// let parser = le_u8::<_, (_, ErrorKind)>;\n///\n/// assert_eq!(parser(&b\"\\x00\\x01abcd\"[..]), Ok((&b\"\\x01abcd\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn le_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E>\nwhere\n  I: Input<Item = u8>,{\n  le_uint(input, 1)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::le_uint":["#[inline]\nfn le_uint<I, Uint, E: ParseError<I>>(input: I, bound: usize) -> IResult<I, Uint, E>\nwhere\n  I: Input<Item = u8>,\n  Uint: Default + Shl<u8, Output = Uint> + Add<Uint, Output = Uint> + From<u8>,{\n  if input.input_len() < bound {\n    Err(Err::Incomplete(Needed::new(bound - input.input_len())))\n  } else {\n    let mut res = Uint::default();\n    for (index, byte) in input.iter_elements().take(bound).enumerate() {\n      res = res + (Uint::from(byte) << (8 * index as u8));\n    }\n\n    Ok((input.take_from(bound), res))\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::recognize_float":["/// Recognizes a floating point number in text format and returns the corresponding part of the input.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if it reaches the end of input.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// use nom::number::streaming::recognize_float;\n///\n/// let parser = |s| {\n///   recognize_float(s)\n/// };\n///\n/// assert_eq!(parser(\"11e-1;\"), Ok((\";\", \"11e-1\")));\n/// assert_eq!(parser(\"123E-02;\"), Ok((\";\", \"123E-02\")));\n/// assert_eq!(parser(\"123K-01\"), Ok((\"K-01\", \"123\")));\n/// assert_eq!(parser(\"abc\"), Err(Err::Error((\"abc\", ErrorKind::Char))));\n/// ```\n#[rustfmt::skip]\npub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Clone + Offset,\n  T: Input,\n  <T as Input>::Item: AsChar,{\n  recognize((\n      opt(alt((char('+'), char('-')))),\n      alt((\n        map((digit1, opt(pair(char('.'), opt(digit1)))), |_| ()),\n        map((char('.'), digit1), |_| ())\n      )),\n      opt((\n        alt((char('e'), char('E'))),\n        opt(alt((char('+'), char('-')))),\n        cut(digit1)\n      ))\n  ))(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::recognize_float_or_exceptions":["#[doc(hidden)]\npub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>\nwhere\n  T: Clone + Offset,\n  T: Input + Compare<&'static str>,\n  <T as Input>::Item: AsChar,{\n  alt((\n    |i: T| {\n      recognize_float::<_, E>(i.clone()).map_err(|e| match e {\n        crate::Err::Error(_) => crate::Err::Error(E::from_error_kind(i, ErrorKind::Float)),\n        crate::Err::Failure(_) => crate::Err::Failure(E::from_error_kind(i, ErrorKind::Float)),\n        crate::Err::Incomplete(needed) => crate::Err::Incomplete(needed),\n      })\n    },\n    |i: T| {\n      crate::bytes::streaming::tag_no_case::<_, _, E>(\"nan\")(i.clone())\n        .map_err(|_| crate::Err::Error(E::from_error_kind(i, ErrorKind::Float)))\n    },\n    |i: T| {\n      crate::bytes::streaming::tag_no_case::<_, _, E>(\"inf\")(i.clone())\n        .map_err(|_| crate::Err::Error(E::from_error_kind(i, ErrorKind::Float)))\n    },\n    |i: T| {\n      crate::bytes::streaming::tag_no_case::<_, _, E>(\"infinity\")(i.clone())\n        .map_err(|_| crate::Err::Error(E::from_error_kind(i, ErrorKind::Float)))\n    },\n  ))(input)\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::recognize_float_parts":["/// Recognizes a floating point number in text format\n///\n/// It returns a tuple of (`sign`, `integer part`, `fraction part` and `exponent`) of the input\n/// data.\n///\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\npub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E>\nwhere\n  T: Clone + Offset,\n  T: Input,\n  <T as Input>::Item: AsChar,\n  T: for<'a> Compare<&'a [u8]>,\n  T: AsBytes,{\n  let (i, sign) = sign(input.clone())?;\n\n  //let (i, zeroes) = take_while(|c: <T as InputTakeAtPosition>::Item| c.as_char() == '0')(i)?;\n  let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0') {\n    Some(index) => i.take_split(index),\n    None => i.take_split(i.input_len()),\n  };\n\n  //let (i, mut integer) = digit0(i)?;\n  let (i, mut integer) = match i\n    .as_bytes()\n    .iter()\n    .position(|c| !(*c >= b'0' && *c <= b'9'))\n  {\n    Some(index) => i.take_split(index),\n    None => i.take_split(i.input_len()),\n  };\n\n  if integer.input_len() == 0 && zeroes.input_len() > 0 {\n    // keep the last zero if integer is empty\n    integer = zeroes.take_from(zeroes.input_len() - 1);\n  }\n\n  let (i, opt_dot) = opt(tag(&b\".\"[..]))(i)?;\n  let (i, fraction) = if opt_dot.is_none() {\n    let i2 = i.clone();\n    (i2, i.take(0))\n  } else {\n    // match number, trim right zeroes\n    let mut zero_count = 0usize;\n    let mut position = None;\n    for (pos, c) in i.as_bytes().iter().enumerate() {\n      if *c >= b'0' && *c <= b'9' {\n        if *c == b'0' {\n          zero_count += 1;\n        } else {\n          zero_count = 0;\n        }\n      } else {\n        position = Some(pos);\n        break;\n      }\n    }\n\n    let position = match position {\n      Some(p) => p,\n      None => return Err(Err::Incomplete(Needed::new(1))),\n    };\n\n    let index = if zero_count == 0 {\n      position\n    } else if zero_count == position {\n      position - zero_count + 1\n    } else {\n      position - zero_count\n    };\n\n    (i.take_from(position), i.take(index))\n  };\n\n  if integer.input_len() == 0 && fraction.input_len() == 0 {\n    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float)));\n  }\n\n  let i2 = i.clone();\n  let (i, e) = match i.as_bytes().iter().next() {\n    Some(b'e') => (i.take_from(1), true),\n    Some(b'E') => (i.take_from(1), true),\n    _ => (i, false),\n  };\n\n  let (i, exp) = if e {\n    cut(crate::character::streaming::i32)(i)?\n  } else {\n    (i2, 0)\n  };\n\n  Ok((i, (sign, integer, fraction, exp)))\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::u128":["/// Recognizes an unsigned 16 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u128 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u128 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::u128;\n///\n/// let be_u128 = |s| {\n///   u128::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u128(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00010203040506070001020304050607)));\n/// assert_eq!(be_u128(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(15))));\n///\n/// let le_u128 = |s| {\n///   u128::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u128(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07060504030201000706050403020100)));\n/// assert_eq!(le_u128(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(15))));\n/// ```\n#[inline]\npub fn u128<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u128, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u128,\n    crate::number::Endianness::Little => le_u128,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u128,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u128,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::u16":["/// Recognizes an unsigned 2 bytes integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u16 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u16 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::u16;\n///\n/// let be_u16 = |s| {\n///   u16::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u16(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0003)));\n/// assert_eq!(be_u16(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(1))));\n///\n/// let le_u16 = |s| {\n///   u16::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u16(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0300)));\n/// assert_eq!(le_u16(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn u16<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u16, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u16,\n    crate::number::Endianness::Little => le_u16,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u16,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u16,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::u24":["/// Recognizes an unsigned 3 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u24 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u24 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::u24;\n///\n/// let be_u24 = |s| {\n///   u24::<_,(_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u24(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x000305)));\n/// assert_eq!(be_u24(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(2))));\n///\n/// let le_u24 = |s| {\n///   u24::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u24(&b\"\\x00\\x03\\x05abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x050300)));\n/// assert_eq!(le_u24(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(2))));\n/// ```\n#[inline]\npub fn u24<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u24,\n    crate::number::Endianness::Little => le_u24,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u24,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u24,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::u32":["/// Recognizes an unsigned 4 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u32 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u32 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::u32;\n///\n/// let be_u32 = |s| {\n///   u32::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u32(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x00030507)));\n/// assert_eq!(be_u32(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(3))));\n///\n/// let le_u32 = |s| {\n///   u32::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u32(&b\"\\x00\\x03\\x05\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x07050300)));\n/// assert_eq!(le_u32(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(3))));\n/// ```\n#[inline]\npub fn u32<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u32, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u32,\n    crate::number::Endianness::Little => le_u32,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u32,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u32,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::u64":["/// Recognizes an unsigned 8 byte integer\n///\n/// If the parameter is `nom::number::Endianness::Big`, parse a big endian u64 integer,\n/// otherwise if `nom::number::Endianness::Little` parse a little endian u64 integer.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::u64;\n///\n/// let be_u64 = |s| {\n///   u64::<_, (_, ErrorKind)>(nom::number::Endianness::Big)(s)\n/// };\n///\n/// assert_eq!(be_u64(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0001020304050607)));\n/// assert_eq!(be_u64(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(7))));\n///\n/// let le_u64 = |s| {\n///   u64::<_, (_, ErrorKind)>(nom::number::Endianness::Little)(s)\n/// };\n///\n/// assert_eq!(le_u64(&b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07abcefg\"[..]), Ok((&b\"abcefg\"[..], 0x0706050403020100)));\n/// assert_eq!(le_u64(&b\"\\x01\"[..]), Err(Err::Incomplete(Needed::new(7))));\n/// ```\n#[inline]\npub fn u64<I, E: ParseError<I>>(endian: crate::number::Endianness) -> fn(I) -> IResult<I, u64, E>\nwhere\n  I: Input<Item = u8>,{\n  match endian {\n    crate::number::Endianness::Big => be_u64,\n    crate::number::Endianness::Little => le_u64,\n    #[cfg(target_endian = \"big\")]\n    crate::number::Endianness::Native => be_u64,\n    #[cfg(target_endian = \"little\")]\n    crate::number::Endianness::Native => le_u64,\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"number::streaming::u8":["/// Recognizes an unsigned 1 byte integer\n///\n/// Note that endianness does not apply to 1 byte numbers.\n/// *Streaming version*: Will return `Err(nom::Err::Incomplete(_))` if there is not enough data.\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::number::streaming::u8;\n///\n/// let parser = |s| {\n///   u8::<_, (_, ErrorKind)>(s)\n/// };\n///\n/// assert_eq!(parser(&b\"\\x00\\x03abcefg\"[..]), Ok((&b\"\\x03abcefg\"[..], 0x00)));\n/// assert_eq!(parser(&b\"\"[..]), Err(Err::Incomplete(Needed::new(1))));\n/// ```\n#[inline]\npub fn u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E>\nwhere\n  I: Input<Item = u8>,{\n  let bound: usize = 1;\n  if input.input_len() < bound {\n    Err(Err::Incomplete(Needed::new(1)))\n  } else {\n    let res = input.iter_elements().next().unwrap();\n\n    Ok((input.take_from(bound), res))\n  }\n}","Real(LocalPath(\"src/number/streaming.rs\"))"],"sequence::Tuple":["/// Helper trait for the tuple combinator.\n///\n/// This trait is implemented for tuples of parsers of up to 21 elements.\n#[deprecated(since = \"8.0.0\", note = \"`Parser` is directly implemented for tuples\")]\n#[allow(deprecated)]\npub trait Tuple<I, O, E> {\n  /// Parses the input and returns a tuple of results of each parser.\n  fn parse(&mut self, input: I) -> IResult<I, O, E>;\n}","Real(LocalPath(\"src/sequence/mod.rs\"))"],"sequence::delimited":["/// Matches an object from the first parser and discards it,\n/// then gets an object from the second parser,\n/// and finally matches an object from the third parser and discards it.\n///\n/// # Arguments\n/// * `first` The first parser to apply and discard.\n/// * `second` The second parser to apply.\n/// * `third` The third parser to apply and discard.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::sequence::delimited;\n/// use nom::bytes::complete::tag;\n///\n/// let mut parser = delimited(tag(\"(\"), tag(\"abc\"), tag(\")\"));\n///\n/// assert_eq!(parser(\"(abc)\"), Ok((\"\", \"abc\")));\n/// assert_eq!(parser(\"(abc)def\"), Ok((\"def\", \"abc\")));\n/// assert_eq!(parser(\"\"), Err(Err::Error((\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"123\"), Err(Err::Error((\"123\", ErrorKind::Tag))));\n/// ```\npub fn delimited<I, O, E: ParseError<I>, F, G, H>(\n  mut first: F,\n  mut second: G,\n  mut third: H,\n) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Error = E>,\n  G: Parser<I, Output = O, Error = E>,\n  H: Parser<I, Error = E>,{\n  move |input: I| {\n    let (input, _) = first.parse(input)?;\n    let (input, o2) = second.parse(input)?;\n    third.parse(input).map(|(i, _)| (i, o2))\n  }\n}","Real(LocalPath(\"src/sequence/mod.rs\"))"],"sequence::pair":["/// Gets an object from the first parser,\n/// then gets another object from the second parser.\n///\n/// # Arguments\n/// * `first` The first parser to apply.\n/// * `second` The second parser to apply.\n///\n/// # Example\n/// ```rust\n/// use nom::sequence::pair;\n/// use nom::bytes::complete::tag;\n/// use nom::{error::ErrorKind, Err};\n///\n/// let mut parser = pair(tag(\"abc\"), tag(\"efg\"));\n///\n/// assert_eq!(parser(\"abcefg\"), Ok((\"\", (\"abc\", \"efg\"))));\n/// assert_eq!(parser(\"abcefghij\"), Ok((\"hij\", (\"abc\", \"efg\"))));\n/// assert_eq!(parser(\"\"), Err(Err::Error((\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"123\"), Err(Err::Error((\"123\", ErrorKind::Tag))));\n/// ```\npub fn pair<I, O1, O2, E: ParseError<I>, F, G>(\n  mut first: F,\n  mut second: G,\n) -> impl FnMut(I) -> IResult<I, (O1, O2), E>\nwhere\n  F: Parser<I, Output = O1, Error = E>,\n  G: Parser<I, Output = O2, Error = E>,{\n  move |input: I| {\n    let (input, o1) = first.parse(input)?;\n    second.parse(input).map(|(i, o2)| (i, (o1, o2)))\n  }\n}","Real(LocalPath(\"src/sequence/mod.rs\"))"],"sequence::preceded":["/// Matches an object from the first parser and discards it,\n/// then gets an object from the second parser.\n///\n/// # Arguments\n/// * `first` The opening parser.\n/// * `second` The second parser to get object.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::sequence::preceded;\n/// use nom::bytes::complete::tag;\n///\n/// let mut parser = preceded(tag(\"abc\"), tag(\"efg\"));\n///\n/// assert_eq!(parser(\"abcefg\"), Ok((\"\", \"efg\")));\n/// assert_eq!(parser(\"abcefghij\"), Ok((\"hij\", \"efg\")));\n/// assert_eq!(parser(\"\"), Err(Err::Error((\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"123\"), Err(Err::Error((\"123\", ErrorKind::Tag))));\n/// ```\npub fn preceded<I, O, E: ParseError<I>, F, G>(\n  mut first: F,\n  mut second: G,\n) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Error = E>,\n  G: Parser<I, Output = O, Error = E>,{\n  move |input: I| {\n    let (input, _) = first.parse(input)?;\n    second.parse(input)\n  }\n}","Real(LocalPath(\"src/sequence/mod.rs\"))"],"sequence::separated_pair":["/// Gets an object from the first parser,\n/// then matches an object from the sep_parser and discards it,\n/// then gets another object from the second parser.\n///\n/// # Arguments\n/// * `first` The first parser to apply.\n/// * `sep` The separator parser to apply.\n/// * `second` The second parser to apply.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::sequence::separated_pair;\n/// use nom::bytes::complete::tag;\n///\n/// let mut parser = separated_pair(tag(\"abc\"), tag(\"|\"), tag(\"efg\"));\n///\n/// assert_eq!(parser(\"abc|efg\"), Ok((\"\", (\"abc\", \"efg\"))));\n/// assert_eq!(parser(\"abc|efghij\"), Ok((\"hij\", (\"abc\", \"efg\"))));\n/// assert_eq!(parser(\"\"), Err(Err::Error((\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"123\"), Err(Err::Error((\"123\", ErrorKind::Tag))));\n/// ```\npub fn separated_pair<I, O1, O2, E: ParseError<I>, F, G, H>(\n  mut first: F,\n  mut sep: G,\n  mut second: H,\n) -> impl FnMut(I) -> IResult<I, (O1, O2), E>\nwhere\n  F: Parser<I, Output = O1, Error = E>,\n  G: Parser<I, Error = E>,\n  H: Parser<I, Output = O2, Error = E>,{\n  move |input: I| {\n    let (input, o1) = first.parse(input)?;\n    let (input, _) = sep.parse(input)?;\n    second.parse(input).map(|(i, o2)| (i, (o1, o2)))\n  }\n}","Real(LocalPath(\"src/sequence/mod.rs\"))"],"sequence::terminated":["/// Gets an object from the first parser,\n/// then matches an object from the second parser and discards it.\n///\n/// # Arguments\n/// * `first` The first parser to apply.\n/// * `second` The second parser to match an object.\n///\n/// ```rust\n/// # use nom::{Err, error::ErrorKind, Needed};\n/// # use nom::Needed::Size;\n/// use nom::sequence::terminated;\n/// use nom::bytes::complete::tag;\n///\n/// let mut parser = terminated(tag(\"abc\"), tag(\"efg\"));\n///\n/// assert_eq!(parser(\"abcefg\"), Ok((\"\", \"abc\")));\n/// assert_eq!(parser(\"abcefghij\"), Ok((\"hij\", \"abc\")));\n/// assert_eq!(parser(\"\"), Err(Err::Error((\"\", ErrorKind::Tag))));\n/// assert_eq!(parser(\"123\"), Err(Err::Error((\"123\", ErrorKind::Tag))));\n/// ```\npub fn terminated<I, O, E: ParseError<I>, F, G>(\n  mut first: F,\n  mut second: G,\n) -> impl FnMut(I) -> IResult<I, O, E>\nwhere\n  F: Parser<I, Output = O, Error = E>,\n  G: Parser<I, Error = E>,{\n  move |input: I| {\n    let (input, o1) = first.parse(input)?;\n    second.parse(input).map(|(i, _)| (i, o1))\n  }\n}","Real(LocalPath(\"src/sequence/mod.rs\"))"],"sequence::tuple":["///Applies a tuple of parsers one by one and returns their results as a tuple.\n///There is a maximum of 21 parsers\n/// ```rust\n/// # use nom::{Err, error::ErrorKind};\n/// use nom::sequence::tuple;\n/// use nom::character::complete::{alpha1, digit1};\n/// let mut parser = tuple((alpha1, digit1, alpha1));\n///\n/// assert_eq!(parser(\"abc123def\"), Ok((\"\", (\"abc\", \"123\", \"def\"))));\n/// assert_eq!(parser(\"123def\"), Err(Err::Error((\"123def\", ErrorKind::Alpha))));\n/// ```\n#[deprecated(since = \"8.0.0\", note = \"`Parser` is directly implemented for tuples\")]\n#[allow(deprecated)]\npub fn tuple<I, O, E: ParseError<I>, List: Tuple<I, O, E>>(\n  mut l: List,\n) -> impl FnMut(I) -> IResult<I, O, E>{\n  move |i: I| l.parse(i)\n}","Real(LocalPath(\"src/sequence/mod.rs\"))"],"traits::AsBytes":["/// Helper trait for types that can be viewed as a byte slice\npub trait AsBytes {\n  /// Casts the input type to a byte slice\n  fn as_bytes(&self) -> &[u8];\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::AsChar":["/// Transforms common types to a char for basic token parsing\n#[allow(clippy::len_without_is_empty)]\npub trait AsChar: Copy {\n  /// makes a char from self\n  fn as_char(self) -> char;\n\n  /// Tests that self is an alphabetic character\n  ///\n  /// Warning: for `&str` it recognizes alphabetic\n  /// characters outside of the 52 ASCII letters\n  fn is_alpha(self) -> bool;\n\n  /// Tests that self is an alphabetic character\n  /// or a decimal digit\n  fn is_alphanum(self) -> bool;\n  /// Tests that self is a decimal digit\n  fn is_dec_digit(self) -> bool;\n  /// Tests that self is an hex digit\n  fn is_hex_digit(self) -> bool;\n  /// Tests that self is an octal digit\n  fn is_oct_digit(self) -> bool;\n  /// Gets the len in bytes for self\n  fn len(self) -> usize;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::Compare":["/// Abstracts comparison operations\npub trait Compare<T> {\n  /// Compares self to another value for equality\n  fn compare(&self, t: T) -> CompareResult;\n  /// Compares self to another value for equality\n  /// independently of the case.\n  ///\n  /// Warning: for `&str`, the comparison is done\n  /// by lowercasing both strings and comparing\n  /// the result. This is a temporary solution until\n  /// a better one appears\n  fn compare_no_case(&self, t: T) -> CompareResult;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::CompareResult":["/// Indicates whether a comparison was successful, an error, or\n/// if more data was needed\npub enum CompareResult {\n  /// Comparison was successful\n  Ok,\n  /// We need more data to be sure\n  Incomplete,\n  /// Comparison failed\n  Error,\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::ErrorConvert":["/// Equivalent From implementation to avoid orphan rules in bits parsers\npub trait ErrorConvert<E> {\n  /// Transform to another error type\n  fn convert(self) -> E;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::ExtendInto":["/// Abstracts something which can extend an `Extend`.\n/// Used to build modified input slices in `escaped_transform`\npub trait ExtendInto {\n  /// The current input type is a sequence of that `Item` type.\n  ///\n  /// Example: `u8` for `&[u8]` or `char` for `&str`\n  type Item;\n\n  /// The type that will be produced\n  type Extender;\n\n  /// Create a new `Extend` of the correct type\n  fn new_builder(&self) -> Self::Extender;\n  /// Accumulate the input into an accumulator\n  fn extend_into(&self, acc: &mut Self::Extender);\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::FindSubstring":["/// Look for a substring in self\npub trait FindSubstring<T> {\n  /// Returns the byte position of the substring if it is found\n  fn find_substring(&self, substr: T) -> Option<usize>;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::FindToken":["/// Look for a token in self\npub trait FindToken<T> {\n  /// Returns true if self contains the token\n  fn find_token(&self, token: T) -> bool;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::HexDisplay":["#[cfg(feature = \"std\")]\n/// Helper trait to show a byte slice as a hex dump\npub trait HexDisplay {\n  /// Converts the value of `self` to a hex dump, returning the owned\n  /// `String`.\n  fn to_hex(&self, chunk_size: usize) -> String;\n\n  /// Converts the value of `self` to a hex dump beginning at `from` address, returning the owned\n  /// `String`.\n  fn to_hex_from(&self, chunk_size: usize, from: usize) -> String;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::Input":["/// Parser input types must implement this trait\npub trait Input: Clone + Sized {\n  /// The current input type is a sequence of that `Item` type.\n  ///\n  /// Example: `u8` for `&[u8]` or `char` for `&str`\n  type Item;\n\n  /// An iterator over the input type, producing the item\n  type Iter: Iterator<Item = Self::Item>;\n\n  /// An iterator over the input type, producing the item and its byte position\n  /// If we're iterating over `&str`, the position\n  /// corresponds to the byte index of the character\n  type IterIndices: Iterator<Item = (usize, Self::Item)>;\n\n  /// Calculates the input length, as indicated by its name,\n  /// and the name of the trait itself\n  fn input_len(&self) -> usize;\n\n  /// Returns a slice of `index` bytes. panics if index > length\n  fn take(&self, index: usize) -> Self;\n  /// Returns a slice starting at `index` bytes. panics if index > length\n  fn take_from(&self, index: usize) -> Self;\n  /// Split the stream at the `index` byte offset. panics if index > length\n  fn take_split(&self, index: usize) -> (Self, Self);\n\n  /// Returns the byte position of the first element satisfying the predicate\n  fn position<P>(&self, predicate: P) -> Option<usize>\n  where\n    P: Fn(Self::Item) -> bool;\n\n  /// Returns an iterator over the elements\n  fn iter_elements(&self) -> Self::Iter;\n  /// Returns an iterator over the elements and their byte offsets\n  fn iter_indices(&self) -> Self::IterIndices;\n\n  /// Get the byte offset from the element's position in the stream\n  fn slice_index(&self, count: usize) -> Result<usize, Needed>;\n\n  /// Looks for the first element of the input type for which the condition returns true,\n  /// and returns the input up to this position.\n  ///\n  /// *streaming version*: If no element is found matching the condition, this will return `Incomplete`\n  fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,\n  {\n    match self.position(predicate) {\n      Some(n) => Ok(self.take_split(n)),\n      None => Err(Err::Incomplete(Needed::new(1))),\n    }\n  }\n\n  /// Looks for the first element of the input type for which the condition returns true\n  /// and returns the input up to this position.\n  ///\n  /// Fails if the produced slice is empty.\n  ///\n  /// *streaming version*: If no element is found matching the condition, this will return `Incomplete`\n  fn split_at_position1<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n    e: ErrorKind,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,\n  {\n    match self.position(predicate) {\n      Some(0) => Err(Err::Error(E::from_error_kind(self.clone(), e))),\n      Some(n) => Ok(self.take_split(n)),\n      None => Err(Err::Incomplete(Needed::new(1))),\n    }\n  }\n\n  /// Looks for the first element of the input type for which the condition returns true,\n  /// and returns the input up to this position.\n  ///\n  /// *complete version*: If no element is found matching the condition, this will return the whole input\n  fn split_at_position_complete<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,\n  {\n    match self.split_at_position(predicate) {\n      Err(Err::Incomplete(_)) => Ok(self.take_split(self.input_len())),\n      res => res,\n    }\n  }\n\n  /// Looks for the first element of the input type for which the condition returns true\n  /// and returns the input up to this position.\n  ///\n  /// Fails if the produced slice is empty.\n  ///\n  /// *complete version*: If no element is found matching the condition, this will return the whole input\n  fn split_at_position1_complete<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n    e: ErrorKind,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,\n  {\n    match self.split_at_position1(predicate, e) {\n      Err(Err::Incomplete(_)) => {\n        if self.input_len() == 0 {\n          Err(Err::Error(E::from_error_kind(self.clone(), e)))\n        } else {\n          Ok(self.take_split(self.input_len()))\n        }\n      }\n      res => res,\n    }\n  }\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::Input::split_at_position":["/// Looks for the first element of the input type for which the condition returns true,\n/// and returns the input up to this position.\n///\n/// *streaming version*: If no element is found matching the condition, this will return `Incomplete`\nfn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.position(predicate) {\n      Some(n) => Ok(self.take_split(n)),\n      None => Err(Err::Incomplete(Needed::new(1))),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"traits::Input::split_at_position1":["/// Looks for the first element of the input type for which the condition returns true\n/// and returns the input up to this position.\n///\n/// Fails if the produced slice is empty.\n///\n/// *streaming version*: If no element is found matching the condition, this will return `Incomplete`\nfn split_at_position1<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n    e: ErrorKind,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.position(predicate) {\n      Some(0) => Err(Err::Error(E::from_error_kind(self.clone(), e))),\n      Some(n) => Ok(self.take_split(n)),\n      None => Err(Err::Incomplete(Needed::new(1))),\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"traits::Input::split_at_position1_complete":["/// Looks for the first element of the input type for which the condition returns true\n/// and returns the input up to this position.\n///\n/// Fails if the produced slice is empty.\n///\n/// *complete version*: If no element is found matching the condition, this will return the whole input\nfn split_at_position1_complete<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n    e: ErrorKind,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.split_at_position1(predicate, e) {\n      Err(Err::Incomplete(_)) => {\n        if self.input_len() == 0 {\n          Err(Err::Error(E::from_error_kind(self.clone(), e)))\n        } else {\n          Ok(self.take_split(self.input_len()))\n        }\n      }\n      res => res,\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"traits::Input::split_at_position_complete":["/// Looks for the first element of the input type for which the condition returns true,\n/// and returns the input up to this position.\n///\n/// *complete version*: If no element is found matching the condition, this will return the whole input\nfn split_at_position_complete<P, E: ParseError<Self>>(\n    &self,\n    predicate: P,\n  ) -> IResult<Self, Self, E>\n  where\n    P: Fn(Self::Item) -> bool,{\n    match self.split_at_position(predicate) {\n      Err(Err::Incomplete(_)) => Ok(self.take_split(self.input_len())),\n      res => res,\n    }\n  }","Real(LocalPath(\"src/traits.rs\"))"],"traits::InputLength":["/// Abstract method to calculate the input length\npub trait InputLength {\n  /// Calculates the input length, as indicated by its name,\n  /// and the name of the trait itself\n  fn input_len(&self) -> usize;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::NomRange":["/// Abstractions for range-like types.\npub trait NomRange<Idx> {\n  /// The saturating iterator type.\n  type Saturating: Iterator<Item = Idx>;\n  /// The bounded iterator type.\n  type Bounded: Iterator<Item = Idx>;\n\n  /// `true` if `item` is contained in the range.\n  fn contains(&self, item: &Idx) -> bool;\n\n  /// Returns the bounds of this range.\n  fn bounds(&self) -> (Bound<Idx>, Bound<Idx>);\n\n  /// `true` if the range is inverted.\n  fn is_inverted(&self) -> bool;\n\n  /// Creates a saturating iterator.\n  /// A saturating iterator counts the number of iterations starting from 0 up to the upper bound of this range.\n  /// If the upper bound is infinite the iterator saturates at the largest representable value of its type and\n  /// returns it for all further elements.\n  fn saturating_iter(&self) -> Self::Saturating;\n\n  /// Creates a bounded iterator.\n  /// A bounded iterator counts the number of iterations starting from 0 up to the upper bound of this range.\n  /// If the upper bounds is infinite the iterator counts up until the amount of iterations has reached the\n  /// largest representable value of its type and then returns `None` for all further elements.\n  fn bounded_iter(&self) -> Self::Bounded;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::Offset":["/// Useful functions to calculate the offset between slices and show a hexdump of a slice\npub trait Offset {\n  /// Offset between the first byte of self and the first byte of the argument\n  fn offset(&self, second: &Self) -> usize;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::ParseTo":["/// Used to integrate `str`'s `parse()` method\npub trait ParseTo<R> {\n  /// Succeeds if `parse()` succeeded. The byte slice implementation\n  /// will first convert it to a `&str`, then apply the `parse()` function\n  fn parse_to(&self) -> Option<R>;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::SaturatingIterator":["/// A saturating iterator for usize.\npub struct SaturatingIterator {\n  count: usize,\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::ToUsize":["/// Helper trait to convert numbers to usize.\n///\n/// By default, usize implements `From<u8>` and `From<u16>` but not\n/// `From<u32>` and `From<u64>` because that would be invalid on some\n/// platforms. This trait implements the conversion for platforms\n/// with 32 and 64 bits pointer platforms\npub trait ToUsize {\n  /// converts self to usize\n  fn to_usize(&self) -> usize;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::lowercase_byte":["fn lowercase_byte(c: u8) -> u8{\n  match c {\n    b'A'..=b'Z' => c - b'A' + b'a',\n    _ => c,\n  }\n}","Real(LocalPath(\"src/traits.rs\"))"]},"struct_constructor":{"&'a [u8]":["take","take_from"],"&'a str":["take","take_from"],"&(dyn std::error::Error + 'static)":["source"],"&[u8]":["as_bytes"],"&str":["description"],"(&'a [u8], &'a [u8])":["split_at_position","split_at_position1","split_at_position1_complete","split_at_position_complete","take_split"],"(&'a str, &'a str)":["split_at_position","split_at_position1","split_at_position1_complete","split_at_position_complete","take_split"],"((I, usize), bool)":["bool"],"((I, usize), error::ErrorKind)":["convert"],"(I, ())":["finish","parse"],"(I, (O1, O2))":["parse"],"(I, (O1, O2, O3))":["parse"],"(I, (O1, O2, O3, O4))":["parse"],"(I, (O1, O2, O3, O4, O5))":["parse"],"(I, (O1, O2, O3, O4, O5, O6))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20))":["parse"],"(I, (O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20, O21))":["parse"],"(I, (O1,))":["parse"],"(I, <internal::And<F, G> as internal::Parser<I>>::Output)":["parse"],"(I, <internal::AndThen<F, G> as internal::Parser<I>>::Output)":["parse"],"(I, <internal::FlatMap<F, G> as internal::Parser<I>>::Output)":["parse"],"(I, <internal::Into<F, O2, E2> as internal::Parser<I>>::Output)":["parse"],"(I, <internal::Or<F, G> as internal::Parser<I>>::Output)":["parse"],"(I, I)":["eof"],"(I, O)":["choice","fail","finish","parse","permutation"],"(I, O2)":["parse"],"(I, Uint)":["be_uint","le_uint"],"(I, char)":["newline","tab"],"(I, error::ErrorKind)":["convert","from_error_kind","from_external_error"],"(I, f32)":["be_f32","le_f32"],"(I, f64)":["be_f64","le_f64"],"(I, i128)":["be_i128","le_i128"],"(I, i16)":["be_i16","le_i16"],"(I, i32)":["be_i24","be_i32","le_i24","le_i32"],"(I, i64)":["be_i64","le_i64"],"(I, i8)":["be_i8","i8","le_i8"],"(I, u128)":["be_u128","le_u128"],"(I, u16)":["be_u16","le_u16"],"(I, u32)":["be_u24","be_u32","hex_u32","le_u24","le_u32"],"(I, u64)":["be_u64","le_u64"],"(I, u8)":["be_u8","le_u8","u8"],"(Input, (A, B))":["parse","permutation"],"(Input, (A, B, C))":["parse","permutation"],"(Input, (A, B, C, D))":["parse","permutation"],"(Input, (A, B, C, D, E))":["parse","permutation"],"(Input, (A, B, C, D, E, F))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T))":["parse","permutation"],"(Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U))":["parse","permutation"],"(Input, (Output,))":["parse"],"(Input, <Self as internal::Parser<Input>>::Output)":["parse"],"(Input, Output)":["choice"],"(Self, Self)":["split_at_position","split_at_position1","split_at_position1_complete","split_at_position_complete","take_split"],"(T, (bool, T, T, i32))":["recognize_float_parts"],"(T, T)":["alpha0","alpha1","alphanumeric0","alphanumeric1","crlf","digit0","digit1","hex_digit0","hex_digit1","line_ending","multispace0","multispace1","not_line_ending","oct_digit0","oct_digit1","recognize_float","recognize_float_or_exceptions","rest","space0","space1"],"(T, bool)":["sign"],"(T, char)":["anychar"],"(T, f32)":["float"],"(T, f64)":["double"],"(T, i128)":["i128"],"(T, i16)":["i16"],"(T, i32)":["i32"],"(T, i64)":["i64"],"(T, i8)":["i8"],"(T, u128)":["u128"],"(T, u16)":["u16"],"(T, u32)":["u32"],"(T, u64)":["u64"],"(T, u8)":["u8"],"(T, usize)":["rest_len"],"(std::collections::Bound<Idx>, std::collections::Bound<Idx>)":["bounds"],"(std::collections::Bound<usize>, std::collections::Bound<usize>)":["bounds"],"<&'a [u8] as traits::Input>::Iter":["iter_elements"],"<&'a [u8] as traits::Input>::IterIndices":["iter_indices"],"<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::Item":["next"],"<&'a str as traits::Input>::Iter":["iter_elements"],"<&'a str as traits::Input>::IterIndices":["iter_indices"],"<Self as traits::ExtendInto>::Extender":["new_builder"],"<Self as traits::Input>::Iter":["iter_elements"],"<Self as traits::Input>::IterIndices":["iter_indices"],"<Self as traits::NomRange<Idx>>::Bounded":["bounded_iter"],"<Self as traits::NomRange<Idx>>::Saturating":["saturating_iter"],"<std::ops::Range<usize> as traits::NomRange<usize>>::Bounded":["bounded_iter"],"<std::ops::Range<usize> as traits::NomRange<usize>>::Saturating":["saturating_iter"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::Bounded":["bounded_iter"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::Saturating":["saturating_iter"],"<std::ops::RangeFull as traits::NomRange<usize>>::Bounded":["bounded_iter"],"<std::ops::RangeFull as traits::NomRange<usize>>::Saturating":["saturating_iter"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::Bounded":["bounded_iter"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::Saturating":["saturating_iter"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::Bounded":["bounded_iter"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::Saturating":["saturating_iter"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::Bounded":["bounded_iter"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::Saturating":["saturating_iter"],"<traits::SaturatingIterator as std::iter::Iterator>::Item":["next"],"<usize as traits::NomRange<usize>>::Bounded":["bounded_iter"],"<usize as traits::NomRange<usize>>::Saturating":["saturating_iter"],"bool":["contains","eq","find_token","is_alpha","is_alphabetic","is_alphanum","is_alphanumeric","is_dec_digit","is_digit","is_hex_digit","is_incomplete","is_inverted","is_known","is_newline","is_oct_digit","is_space"],"char":["as_char"],"combinator::ParserIterator":["iterator"],"error::Error":["clone","from_error_kind","from_external_error","new"],"error::ErrorKind":["clone"],"error::VerboseError":["clone","from_char","from_error_kind","from_external_error"],"error::VerboseErrorKind":["clone"],"fn(I) -> std::result::Result<(I, f32), internal::Err<E>>":["f32"],"fn(I) -> std::result::Result<(I, f64), internal::Err<E>>":["f64"],"fn(I) -> std::result::Result<(I, i128), internal::Err<E>>":["i128"],"fn(I) -> std::result::Result<(I, i16), internal::Err<E>>":["i16"],"fn(I) -> std::result::Result<(I, i32), internal::Err<E>>":["i24","i32"],"fn(I) -> std::result::Result<(I, i64), internal::Err<E>>":["i64"],"fn(I) -> std::result::Result<(I, u128), internal::Err<E>>":["u128"],"fn(I) -> std::result::Result<(I, u16), internal::Err<E>>":["u16"],"fn(I) -> std::result::Result<(I, u32), internal::Err<E>>":["u24","u32"],"fn(I) -> std::result::Result<(I, u64), internal::Err<E>>":["u64"],"impl Fn(&'a [u8]) -> std::result::Result<(&'a [u8], O), internal::Err<E>>":["dbg_dmp"],"impl Fn((I, usize)) -> std::result::Result<((I, usize), O), internal::Err<E>>":["tag","take"],"impl Fn(I) -> std::result::Result<(I, I), internal::Err<Error>>":["is_a","is_not","tag","tag_no_case","take","take_till","take_till1","take_until","take_until1","take_while","take_while1","take_while_m_n"],"impl Fn(I) -> std::result::Result<(I, O), internal::Err<E>>":["success"],"impl Fn(I) -> std::result::Result<(I, char), internal::Err<Error>>":["char","none_of","one_of","satisfy"],"impl FnMut((I, usize)) -> std::result::Result<((I, usize), O), internal::Err<E2>>":["bytes"],"impl FnMut(I) -> std::result::Result<(I, ()), internal::Err<E>>":["not"],"impl FnMut(I) -> std::result::Result<(I, ()), internal::Err<E>> + 'a":["fill"],"impl FnMut(I) -> std::result::Result<(I, (I, <F as internal::Parser<I>>::Output)), internal::Err<E>>":["consumed"],"impl FnMut(I) -> std::result::Result<(I, (O1, O2)), internal::Err<E>>":["pair","separated_pair"],"impl FnMut(I) -> std::result::Result<(I, (std::vec::Vec<<F as internal::Parser<I>>::Output>, <G as internal::Parser<I>>::Output)), internal::Err<E>>":["many_till"],"impl FnMut(I) -> std::result::Result<(I, <F as internal::Parser<I>>::Output), internal::Err<E>>":["all_consuming","cut","peek","verify"],"impl FnMut(I) -> std::result::Result<(I, <G as internal::Parser<I>>::Output), internal::Err<E>>":["length_value"],"impl FnMut(I) -> std::result::Result<(I, Collection), internal::Err<E>>":["many"],"impl FnMut(I) -> std::result::Result<(I, I), internal::Err<E>>":["length_data","recognize"],"impl FnMut(I) -> std::result::Result<(I, I), internal::Err<Error>>":["escaped"],"impl FnMut(I) -> std::result::Result<(I, O), internal::Err<E2>>":["bits"],"impl FnMut(I) -> std::result::Result<(I, O), internal::Err<E>>":["alt","complete","context","delimited","flat_map","map","map_opt","map_parser","map_res","permutation","preceded","terminated","tuple"],"impl FnMut(I) -> std::result::Result<(I, O1), internal::Err<E>>":["value"],"impl FnMut(I) -> std::result::Result<(I, O2), internal::Err<E2>>":["into"],"impl FnMut(I) -> std::result::Result<(I, Output), internal::Err<Error>>":["escaped_transform"],"impl FnMut(I) -> std::result::Result<(I, R), internal::Err<E>>":["fold","fold_many0","fold_many1","fold_many_m_n"],"impl FnMut(I) -> std::result::Result<(I, std::option::Option<<F as internal::Parser<I>>::Output>), internal::Err<E>>":["cond","opt"],"impl FnMut(I) -> std::result::Result<(I, std::vec::Vec<<F as internal::Parser<I>>::Output>), internal::Err<<F as internal::Parser<I>>::Error>>":["many0","many1"],"impl FnMut(I) -> std::result::Result<(I, std::vec::Vec<<F as internal::Parser<I>>::Output>), internal::Err<E>>":["count","many_m_n","separated_list0","separated_list1"],"impl FnMut(I) -> std::result::Result<(I, std::vec::Vec<<G as internal::Parser<I>>::Output>), internal::Err<E>>":["length_count"],"impl FnMut(I) -> std::result::Result<(I, usize), internal::Err<E>>":["many0_count","many1_count"],"internal::And":["and"],"internal::AndThen":["and_then"],"internal::Err":["clone"],"internal::FlatMap":["flat_map"],"internal::Into":["into"],"internal::Map":["map"],"internal::MapOpt":["map_opt"],"internal::MapRes":["map_res"],"internal::Needed":["clone","new"],"internal::Or":["or"],"number::Endianness":["clone"],"std::string::String":["convert_error","new_builder","to_hex","to_hex_from"],"std::vec::Vec":["new_builder"],"traits::CompareResult":["compare","compare_no_case"],"u32":["error_to_u32"],"usize":["find_substring","input_len","len","offset","position","to_usize"]},"struct_to_trait":{"<F as internal::Parser<I>>::F":["internal::Parser"],"error::Error":["error::ContextError","error::FromExternalError","error::ParseError","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq","traits::ErrorConvert"],"error::ErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::VerboseError":["error::ContextError","error::FromExternalError","error::ParseError","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq","traits::ErrorConvert"],"error::VerboseErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"internal::And":["internal::Parser"],"internal::AndThen":["internal::Parser"],"internal::Err":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq"],"internal::FlatMap":["internal::Parser"],"internal::IResult":["internal::Finish"],"internal::Into":["internal::Parser"],"internal::Map":["internal::Parser"],"internal::MapOpt":["internal::Parser"],"internal::MapRes":["internal::Parser"],"internal::Needed":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"internal::Or":["internal::Parser"],"number::Endianness":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::boxed::Box":["internal::Parser"],"std::ops::Range":["traits::NomRange"],"std::ops::RangeFrom":["traits::NomRange"],"std::ops::RangeFull":["traits::NomRange"],"std::ops::RangeInclusive":["traits::NomRange"],"std::ops::RangeTo":["traits::NomRange"],"std::ops::RangeToInclusive":["traits::NomRange"],"traits::CompareResult":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"traits::SaturatingIterator":["std::iter::Iterator"]},"targets":{"<&'a [T] as traits::InputLength>::input_len":["input_len","Real(LocalPath(\"src/traits.rs\"))","traits::InputLength"],"<&'a [char] as traits::FindToken<char>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<&'a [u8; N] as traits::AsBytes>::as_bytes":["as_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::AsBytes"],"<&'a [u8; N] as traits::InputLength>::input_len":["input_len","Real(LocalPath(\"src/traits.rs\"))","traits::InputLength"],"<&'a [u8] as traits::AsBytes>::as_bytes":["as_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::AsBytes"],"<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare":["compare","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare_no_case":["compare_no_case","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a [u8] as traits::Compare<&'b [u8]>>::compare":["compare","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case":["compare_no_case","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a [u8] as traits::Compare<&'b str>>::compare":["compare","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a [u8] as traits::Compare<&'b str>>::compare_no_case":["compare_no_case","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a [u8] as traits::Compare<[u8; N]>>::compare":["compare","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a [u8] as traits::Compare<[u8; N]>>::compare_no_case":["compare_no_case","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring":["find_substring","Real(LocalPath(\"src/traits.rs\"))","traits::FindSubstring"],"<&'a [u8] as traits::FindSubstring<&'b str>>::find_substring":["find_substring","Real(LocalPath(\"src/traits.rs\"))","traits::FindSubstring"],"<&'a [u8] as traits::FindToken<char>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<&'a [u8] as traits::FindToken<u8>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<&'a [u8] as traits::Input>::input_len":["input_len","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::iter_elements":["iter_elements","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::iter_indices":["iter_indices","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::position":["position","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::slice_index":["slice_index","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::split_at_position":["split_at_position","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::split_at_position1":["split_at_position1","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::split_at_position1_complete":["split_at_position1_complete","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::split_at_position_complete":["split_at_position_complete","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::take":["take","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::take_from":["take_from","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Input>::take_split":["take_split","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a [u8] as traits::Offset>::offset":["offset","Real(LocalPath(\"src/traits.rs\"))","traits::Offset"],"<&'a [u8] as traits::ParseTo<R>>::parse_to":["parse_to","Real(LocalPath(\"src/traits.rs\"))","traits::ParseTo"],"<&'a char as traits::AsChar>::as_char":["as_char","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a char as traits::AsChar>::is_alpha":["is_alpha","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a char as traits::AsChar>::is_alphanum":["is_alphanum","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a char as traits::AsChar>::is_dec_digit":["is_dec_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a char as traits::AsChar>::is_hex_digit":["is_hex_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a char as traits::AsChar>::is_oct_digit":["is_oct_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a char as traits::AsChar>::len":["len","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/combinator/mod.rs\"))","std::iter::Iterator"],"<&'a str as traits::AsBytes>::as_bytes":["as_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::AsBytes"],"<&'a str as traits::Compare<&'b [u8]>>::compare":["compare","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a str as traits::Compare<&'b [u8]>>::compare_no_case":["compare_no_case","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a str as traits::Compare<&'b str>>::compare":["compare","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a str as traits::Compare<&'b str>>::compare_no_case":["compare_no_case","Real(LocalPath(\"src/traits.rs\"))","traits::Compare"],"<&'a str as traits::FindSubstring<&'b str>>::find_substring":["find_substring","Real(LocalPath(\"src/traits.rs\"))","traits::FindSubstring"],"<&'a str as traits::FindToken<char>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<&'a str as traits::FindToken<u8>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<&'a str as traits::Input>::input_len":["input_len","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::iter_elements":["iter_elements","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::iter_indices":["iter_indices","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::position":["position","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::slice_index":["slice_index","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::split_at_position":["split_at_position","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::split_at_position1":["split_at_position1","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::split_at_position1_complete":["split_at_position1_complete","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::split_at_position_complete":["split_at_position_complete","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::take":["take","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::take_from":["take_from","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::Input>::take_split":["take_split","Real(LocalPath(\"src/traits.rs\"))","traits::Input"],"<&'a str as traits::InputLength>::input_len":["input_len","Real(LocalPath(\"src/traits.rs\"))","traits::InputLength"],"<&'a str as traits::Offset>::offset":["offset","Real(LocalPath(\"src/traits.rs\"))","traits::Offset"],"<&'a str as traits::ParseTo<R>>::parse_to":["parse_to","Real(LocalPath(\"src/traits.rs\"))","traits::ParseTo"],"<&'a u8 as traits::AsChar>::as_char":["as_char","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a u8 as traits::AsChar>::is_alpha":["is_alpha","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a u8 as traits::AsChar>::is_alphanum":["is_alphanum","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a u8 as traits::AsChar>::is_dec_digit":["is_dec_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a u8 as traits::AsChar>::is_hex_digit":["is_hex_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a u8 as traits::AsChar>::is_oct_digit":["is_oct_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'a u8 as traits::AsChar>::len":["len","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<&'b [char] as traits::FindToken<&'a char>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<&'b [u8] as traits::FindToken<&'a u8>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<&'b str as traits::FindToken<&'a u8>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<&[u8] as traits::ExtendInto>::extend_into":["extend_into","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<&[u8] as traits::ExtendInto>::new_builder":["new_builder","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<&str as traits::ExtendInto>::extend_into":["extend_into","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<&str as traits::ExtendInto>::new_builder":["new_builder","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<(&'a [u8], usize) as traits::InputLength>::input_len":["input_len","Real(LocalPath(\"src/traits.rs\"))","traits::InputLength"],"<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert":["convert","Real(LocalPath(\"src/traits.rs\"))","traits::ErrorConvert"],"<() as error::FromExternalError<I, E>>::from_external_error":["from_external_error","Real(LocalPath(\"src/error.rs\"))","error::FromExternalError"],"<() as error::ParseError<I>>::append":["append","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<() as error::ParseError<I>>::from_error_kind":["from_error_kind","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<() as sequence::Tuple<I, (), E>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<() as traits::ErrorConvert<()>>::convert":["convert","Real(LocalPath(\"src/traits.rs\"))","traits::ErrorConvert"],"<(A, B) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(A,) as branch::Alt<Input, Output, Error>>::choice":["choice","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Alt"],"<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))","branch::Permutation"],"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse":["parse","Real(LocalPath(\"src/sequence/mod.rs\"))","sequence::Tuple"],"<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error":["from_external_error","Real(LocalPath(\"src/error.rs\"))","error::FromExternalError"],"<(I, error::ErrorKind) as error::ParseError<I>>::append":["append","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind":["from_error_kind","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert":["convert","Real(LocalPath(\"src/traits.rs\"))","traits::ErrorConvert"],"<(P1, P2) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<(P1,) as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<F as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<[u8; N] as traits::AsBytes>::as_bytes":["as_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::AsBytes"],"<[u8; N] as traits::FindToken<&'a u8>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<[u8; N] as traits::FindToken<u8>>::find_token":["find_token","Real(LocalPath(\"src/traits.rs\"))","traits::FindToken"],"<[u8; N] as traits::InputLength>::input_len":["input_len","Real(LocalPath(\"src/traits.rs\"))","traits::InputLength"],"<[u8] as traits::AsBytes>::as_bytes":["as_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::AsBytes"],"<[u8] as traits::ExtendInto>::extend_into":["extend_into","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<[u8] as traits::ExtendInto>::new_builder":["new_builder","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<[u8] as traits::HexDisplay>::to_hex":["to_hex","Real(LocalPath(\"src/traits.rs\"))","traits::HexDisplay"],"<[u8] as traits::HexDisplay>::to_hex_from":["to_hex_from","Real(LocalPath(\"src/traits.rs\"))","traits::HexDisplay"],"<[u8] as traits::Offset>::offset":["offset","Real(LocalPath(\"src/traits.rs\"))","traits::Offset"],"<char as traits::AsChar>::as_char":["as_char","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<char as traits::AsChar>::is_alpha":["is_alpha","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<char as traits::AsChar>::is_alphanum":["is_alphanum","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<char as traits::AsChar>::is_dec_digit":["is_dec_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<char as traits::AsChar>::is_hex_digit":["is_hex_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<char as traits::AsChar>::is_oct_digit":["is_oct_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<char as traits::AsChar>::len":["len","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<char as traits::ExtendInto>::extend_into":["extend_into","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<char as traits::ExtendInto>::new_builder":["new_builder","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert":["convert","Real(LocalPath(\"src/traits.rs\"))","traits::ErrorConvert"],"<error::Error<I> as error::FromExternalError<I, E>>::from_external_error":["from_external_error","Real(LocalPath(\"src/error.rs\"))","error::FromExternalError"],"<error::Error<I> as error::ParseError<I>>::append":["append","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<error::Error<I> as error::ParseError<I>>::from_error_kind":["from_error_kind","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<error::Error<I> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert":["convert","Real(LocalPath(\"src/traits.rs\"))","traits::ErrorConvert"],"<error::Error<std::string::String> as std::convert::From<error::Error<&str>>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error<std::vec::Vec<u8>> as std::convert::From<error::Error<&[u8]>>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert":["convert","Real(LocalPath(\"src/traits.rs\"))","traits::ErrorConvert"],"<error::VerboseError<I> as error::ContextError<I>>::add_context":["add_context","Real(LocalPath(\"src/error.rs\"))","error::ContextError"],"<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error":["from_external_error","Real(LocalPath(\"src/error.rs\"))","error::FromExternalError"],"<error::VerboseError<I> as error::ParseError<I>>::append":["append","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<error::VerboseError<I> as error::ParseError<I>>::from_char":["from_char","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<error::VerboseError<I> as error::ParseError<I>>::from_error_kind":["from_error_kind","Real(LocalPath(\"src/error.rs\"))","error::ParseError"],"<error::VerboseError<I> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert":["convert","Real(LocalPath(\"src/traits.rs\"))","traits::ErrorConvert"],"<error::VerboseError<std::string::String> as std::convert::From<error::VerboseError<&str>>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::VerboseError<std::vec::Vec<u8>> as std::convert::From<error::VerboseError<&[u8]>>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<internal::And<F, G> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<internal::AndThen<F, G> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<internal::Err<E> as std::error::Error>::source":["source","Real(LocalPath(\"src/internal.rs\"))","std::error::Error"],"<internal::Err<E> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/internal.rs\"))","std::fmt::Display"],"<internal::FlatMap<F, G> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<internal::Into<F, O2, E2> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<internal::Map<F, G> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<internal::MapOpt<F, G> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<internal::MapRes<F, G> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<internal::Or<F, G> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)> as internal::Parser<I>>::parse":["parse","Real(LocalPath(\"src/internal.rs\"))","internal::Parser"],"<std::ops::Range<usize> as traits::NomRange<usize>>::bounded_iter":["bounded_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::Range<usize> as traits::NomRange<usize>>::bounds":["bounds","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::Range<usize> as traits::NomRange<usize>>::contains":["contains","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::Range<usize> as traits::NomRange<usize>>::is_inverted":["is_inverted","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::Range<usize> as traits::NomRange<usize>>::saturating_iter":["saturating_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounded_iter":["bounded_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounds":["bounds","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::contains":["contains","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::is_inverted":["is_inverted","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::saturating_iter":["saturating_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFull as traits::NomRange<usize>>::bounded_iter":["bounded_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFull as traits::NomRange<usize>>::bounds":["bounds","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFull as traits::NomRange<usize>>::contains":["contains","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFull as traits::NomRange<usize>>::is_inverted":["is_inverted","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeFull as traits::NomRange<usize>>::saturating_iter":["saturating_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounded_iter":["bounded_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounds":["bounds","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::contains":["contains","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::is_inverted":["is_inverted","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::saturating_iter":["saturating_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounded_iter":["bounded_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounds":["bounds","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::contains":["contains","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::is_inverted":["is_inverted","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeTo<usize> as traits::NomRange<usize>>::saturating_iter":["saturating_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounded_iter":["bounded_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounds":["bounds","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::contains":["contains","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::is_inverted":["is_inverted","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::saturating_iter":["saturating_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish":["finish","Real(LocalPath(\"src/internal.rs\"))","internal::Finish"],"<str as traits::AsBytes>::as_bytes":["as_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::AsBytes"],"<str as traits::ExtendInto>::extend_into":["extend_into","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<str as traits::ExtendInto>::new_builder":["new_builder","Real(LocalPath(\"src/traits.rs\"))","traits::ExtendInto"],"<str as traits::HexDisplay>::to_hex":["to_hex","Real(LocalPath(\"src/traits.rs\"))","traits::HexDisplay"],"<str as traits::HexDisplay>::to_hex_from":["to_hex_from","Real(LocalPath(\"src/traits.rs\"))","traits::HexDisplay"],"<str as traits::Offset>::offset":["offset","Real(LocalPath(\"src/traits.rs\"))","traits::Offset"],"<traits::SaturatingIterator as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/traits.rs\"))","std::iter::Iterator"],"<u16 as traits::ToUsize>::to_usize":["to_usize","Real(LocalPath(\"src/traits.rs\"))","traits::ToUsize"],"<u32 as traits::ToUsize>::to_usize":["to_usize","Real(LocalPath(\"src/traits.rs\"))","traits::ToUsize"],"<u64 as traits::ToUsize>::to_usize":["to_usize","Real(LocalPath(\"src/traits.rs\"))","traits::ToUsize"],"<u8 as traits::AsChar>::as_char":["as_char","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<u8 as traits::AsChar>::is_alpha":["is_alpha","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<u8 as traits::AsChar>::is_alphanum":["is_alphanum","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<u8 as traits::AsChar>::is_dec_digit":["is_dec_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<u8 as traits::AsChar>::is_hex_digit":["is_hex_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<u8 as traits::AsChar>::is_oct_digit":["is_oct_digit","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<u8 as traits::AsChar>::len":["len","Real(LocalPath(\"src/traits.rs\"))","traits::AsChar"],"<u8 as traits::ToUsize>::to_usize":["to_usize","Real(LocalPath(\"src/traits.rs\"))","traits::ToUsize"],"<usize as traits::NomRange<usize>>::bounded_iter":["bounded_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<usize as traits::NomRange<usize>>::bounds":["bounds","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<usize as traits::NomRange<usize>>::contains":["contains","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<usize as traits::NomRange<usize>>::is_inverted":["is_inverted","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<usize as traits::NomRange<usize>>::saturating_iter":["saturating_iter","Real(LocalPath(\"src/traits.rs\"))","traits::NomRange"],"<usize as traits::ToUsize>::to_usize":["to_usize","Real(LocalPath(\"src/traits.rs\"))","traits::ToUsize"],"bits::bits":["bits","Real(LocalPath(\"src/bits/mod.rs\"))",""],"bits::bytes":["bytes","Real(LocalPath(\"src/bits/mod.rs\"))",""],"bits::complete::bool":["bool","Real(LocalPath(\"src/bits/complete.rs\"))",""],"bits::complete::tag":["tag","Real(LocalPath(\"src/bits/complete.rs\"))",""],"bits::complete::take":["take","Real(LocalPath(\"src/bits/complete.rs\"))",""],"bits::streaming::bool":["bool","Real(LocalPath(\"src/bits/streaming.rs\"))",""],"bits::streaming::tag":["tag","Real(LocalPath(\"src/bits/streaming.rs\"))",""],"bits::streaming::take":["take","Real(LocalPath(\"src/bits/streaming.rs\"))",""],"branch::alt":["alt","Real(LocalPath(\"src/branch/mod.rs\"))",""],"branch::permutation":["permutation","Real(LocalPath(\"src/branch/mod.rs\"))",""],"bytes::complete::escaped":["escaped","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::escaped_transform":["escaped_transform","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::is_a":["is_a","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::is_not":["is_not","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::tag":["tag","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::tag_no_case":["tag_no_case","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::take":["take","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::take_till":["take_till","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::take_till1":["take_till1","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::take_until":["take_until","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::take_until1":["take_until1","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::take_while":["take_while","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::take_while1":["take_while1","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::complete::take_while_m_n":["take_while_m_n","Real(LocalPath(\"src/bytes/complete.rs\"))",""],"bytes::streaming::escaped":["escaped","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::escaped_transform":["escaped_transform","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::is_a":["is_a","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::is_not":["is_not","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::tag":["tag","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::tag_no_case":["tag_no_case","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::take":["take","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::take_till":["take_till","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::take_till1":["take_till1","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::take_until":["take_until","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::take_until1":["take_until1","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::take_while":["take_while","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::take_while1":["take_while1","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"bytes::streaming::take_while_m_n":["take_while_m_n","Real(LocalPath(\"src/bytes/streaming.rs\"))",""],"character::complete::alpha0":["alpha0","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::alpha1":["alpha1","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::alphanumeric0":["alphanumeric0","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::alphanumeric1":["alphanumeric1","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::anychar":["anychar","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::char":["char","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::crlf":["crlf","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::digit0":["digit0","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::digit1":["digit1","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::hex_digit0":["hex_digit0","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::hex_digit1":["hex_digit1","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::i128":["i128","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::i16":["i16","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::i32":["i32","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::i64":["i64","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::i8":["i8","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::line_ending":["line_ending","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::multispace0":["multispace0","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::multispace1":["multispace1","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::newline":["newline","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::none_of":["none_of","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::not_line_ending":["not_line_ending","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::oct_digit0":["oct_digit0","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::oct_digit1":["oct_digit1","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::one_of":["one_of","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::satisfy":["satisfy","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::sign":["sign","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::space0":["space0","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::space1":["space1","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::tab":["tab","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::u128":["u128","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::u16":["u16","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::u32":["u32","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::u64":["u64","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::complete::u8":["u8","Real(LocalPath(\"src/character/complete.rs\"))",""],"character::is_alphabetic":["is_alphabetic","Real(LocalPath(\"src/character/mod.rs\"))",""],"character::is_alphanumeric":["is_alphanumeric","Real(LocalPath(\"src/character/mod.rs\"))",""],"character::is_digit":["is_digit","Real(LocalPath(\"src/character/mod.rs\"))",""],"character::is_hex_digit":["is_hex_digit","Real(LocalPath(\"src/character/mod.rs\"))",""],"character::is_newline":["is_newline","Real(LocalPath(\"src/character/mod.rs\"))",""],"character::is_oct_digit":["is_oct_digit","Real(LocalPath(\"src/character/mod.rs\"))",""],"character::is_space":["is_space","Real(LocalPath(\"src/character/mod.rs\"))",""],"character::streaming::alpha0":["alpha0","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::alpha1":["alpha1","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::alphanumeric0":["alphanumeric0","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::alphanumeric1":["alphanumeric1","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::anychar":["anychar","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::char":["char","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::crlf":["crlf","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::digit0":["digit0","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::digit1":["digit1","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::hex_digit0":["hex_digit0","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::hex_digit1":["hex_digit1","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::i128":["i128","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::i16":["i16","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::i32":["i32","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::i64":["i64","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::i8":["i8","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::line_ending":["line_ending","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::multispace0":["multispace0","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::multispace1":["multispace1","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::newline":["newline","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::none_of":["none_of","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::not_line_ending":["not_line_ending","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::oct_digit0":["oct_digit0","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::oct_digit1":["oct_digit1","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::one_of":["one_of","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::satisfy":["satisfy","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::sign":["sign","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::space0":["space0","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::space1":["space1","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::tab":["tab","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::u128":["u128","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::u16":["u16","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::u32":["u32","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::u64":["u64","Real(LocalPath(\"src/character/streaming.rs\"))",""],"character::streaming::u8":["u8","Real(LocalPath(\"src/character/streaming.rs\"))",""],"combinator::ParserIterator::<I, E, F>::finish":["finish","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::all_consuming":["all_consuming","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::complete":["complete","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::cond":["cond","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::consumed":["consumed","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::cut":["cut","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::eof":["eof","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::fail":["fail","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::flat_map":["flat_map","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::into":["into","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::iterator":["iterator","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::map":["map","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::map_opt":["map_opt","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::map_parser":["map_parser","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::map_res":["map_res","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::not":["not","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::opt":["opt","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::peek":["peek","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::recognize":["recognize","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::rest":["rest","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::rest_len":["rest_len","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::success":["success","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::value":["value","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"combinator::verify":["verify","Real(LocalPath(\"src/combinator/mod.rs\"))",""],"error::ContextError::add_context":["add_context","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::<I>::new":["new","Real(LocalPath(\"src/error.rs\"))",""],"error::ErrorKind::description":["description","Real(LocalPath(\"src/error.rs\"))",""],"error::ParseError::from_char":["from_char","Real(LocalPath(\"src/error.rs\"))",""],"error::ParseError::or":["or","Real(LocalPath(\"src/error.rs\"))",""],"error::append_error":["append_error","Real(LocalPath(\"src/error.rs\"))",""],"error::context":["context","Real(LocalPath(\"src/error.rs\"))",""],"error::convert_error":["convert_error","Real(LocalPath(\"src/error.rs\"))",""],"error::dbg_dmp":["dbg_dmp","Real(LocalPath(\"src/error.rs\"))",""],"error::error_to_u32":["error_to_u32","Real(LocalPath(\"src/error.rs\"))",""],"error::make_error":["make_error","Real(LocalPath(\"src/error.rs\"))",""],"internal::Err::<(&[u8], error::ErrorKind)>::to_owned":["to_owned","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Err::<(&str, error::ErrorKind)>::to_owned":["to_owned","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Err::<(T, error::ErrorKind)>::map_input":["map_input","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Err::<E>::convert":["convert","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Err::<E>::is_incomplete":["is_incomplete","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Err::<E>::map":["map","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Err::<error::Error<&[u8]>>::to_owned":["to_owned","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Err::<error::Error<&str>>::to_owned":["to_owned","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Err::<error::Error<T>>::map_input":["map_input","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Needed::is_known":["is_known","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Needed::map":["map","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Needed::new":["new","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Parser::and":["and","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Parser::and_then":["and_then","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Parser::flat_map":["flat_map","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Parser::into":["into","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Parser::map":["map","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Parser::map_opt":["map_opt","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Parser::map_res":["map_res","Real(LocalPath(\"src/internal.rs\"))",""],"internal::Parser::or":["or","Real(LocalPath(\"src/internal.rs\"))",""],"multi::count":["count","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::fill":["fill","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::fold":["fold","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::fold_many0":["fold_many0","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::fold_many1":["fold_many1","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::fold_many_m_n":["fold_many_m_n","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::length_count":["length_count","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::length_data":["length_data","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::length_value":["length_value","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::many":["many","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::many0":["many0","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::many0_count":["many0_count","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::many1":["many1","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::many1_count":["many1_count","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::many_m_n":["many_m_n","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::many_till":["many_till","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::separated_list0":["separated_list0","Real(LocalPath(\"src/multi/mod.rs\"))",""],"multi::separated_list1":["separated_list1","Real(LocalPath(\"src/multi/mod.rs\"))",""],"number::complete::be_f32":["be_f32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_f64":["be_f64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_i128":["be_i128","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_i16":["be_i16","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_i24":["be_i24","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_i32":["be_i32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_i64":["be_i64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_i8":["be_i8","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_u128":["be_u128","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_u16":["be_u16","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_u24":["be_u24","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_u32":["be_u32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_u64":["be_u64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_u8":["be_u8","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::be_uint":["be_uint","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::double":["double","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::f32":["f32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::f64":["f64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::float":["float","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::hex_u32":["hex_u32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::i128":["i128","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::i16":["i16","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::i24":["i24","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::i32":["i32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::i64":["i64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::i8":["i8","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_f32":["le_f32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_f64":["le_f64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_i128":["le_i128","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_i16":["le_i16","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_i24":["le_i24","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_i32":["le_i32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_i64":["le_i64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_i8":["le_i8","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_u128":["le_u128","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_u16":["le_u16","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_u24":["le_u24","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_u32":["le_u32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_u64":["le_u64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_u8":["le_u8","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::le_uint":["le_uint","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::recognize_float":["recognize_float","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::recognize_float_or_exceptions":["recognize_float_or_exceptions","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::recognize_float_parts":["recognize_float_parts","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::u128":["u128","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::u16":["u16","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::u24":["u24","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::u32":["u32","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::u64":["u64","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::complete::u8":["u8","Real(LocalPath(\"src/number/complete.rs\"))",""],"number::streaming::be_f32":["be_f32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_f64":["be_f64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_i128":["be_i128","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_i16":["be_i16","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_i24":["be_i24","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_i32":["be_i32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_i64":["be_i64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_i8":["be_i8","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_u128":["be_u128","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_u16":["be_u16","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_u24":["be_u24","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_u32":["be_u32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_u64":["be_u64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_u8":["be_u8","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::be_uint":["be_uint","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::double":["double","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::f32":["f32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::f64":["f64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::float":["float","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::hex_u32":["hex_u32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::i128":["i128","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::i16":["i16","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::i24":["i24","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::i32":["i32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::i64":["i64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::i8":["i8","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_f32":["le_f32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_f64":["le_f64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_i128":["le_i128","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_i16":["le_i16","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_i24":["le_i24","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_i32":["le_i32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_i64":["le_i64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_i8":["le_i8","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_u128":["le_u128","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_u16":["le_u16","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_u24":["le_u24","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_u32":["le_u32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_u64":["le_u64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_u8":["le_u8","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::le_uint":["le_uint","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::recognize_float":["recognize_float","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::recognize_float_or_exceptions":["recognize_float_or_exceptions","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::recognize_float_parts":["recognize_float_parts","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::u128":["u128","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::u16":["u16","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::u24":["u24","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::u32":["u32","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::u64":["u64","Real(LocalPath(\"src/number/streaming.rs\"))",""],"number::streaming::u8":["u8","Real(LocalPath(\"src/number/streaming.rs\"))",""],"sequence::delimited":["delimited","Real(LocalPath(\"src/sequence/mod.rs\"))",""],"sequence::pair":["pair","Real(LocalPath(\"src/sequence/mod.rs\"))",""],"sequence::preceded":["preceded","Real(LocalPath(\"src/sequence/mod.rs\"))",""],"sequence::separated_pair":["separated_pair","Real(LocalPath(\"src/sequence/mod.rs\"))",""],"sequence::terminated":["terminated","Real(LocalPath(\"src/sequence/mod.rs\"))",""],"sequence::tuple":["tuple","Real(LocalPath(\"src/sequence/mod.rs\"))",""],"traits::Input::split_at_position":["split_at_position","Real(LocalPath(\"src/traits.rs\"))",""],"traits::Input::split_at_position1":["split_at_position1","Real(LocalPath(\"src/traits.rs\"))",""],"traits::Input::split_at_position1_complete":["split_at_position1_complete","Real(LocalPath(\"src/traits.rs\"))",""],"traits::Input::split_at_position_complete":["split_at_position_complete","Real(LocalPath(\"src/traits.rs\"))",""],"traits::lowercase_byte":["lowercase_byte","Real(LocalPath(\"src/traits.rs\"))",""]},"trait_to_struct":{"error::ContextError":["error::Error","error::VerboseError"],"error::FromExternalError":["error::Error","error::VerboseError"],"error::ParseError":["error::Error","error::VerboseError"],"internal::Finish":["internal::IResult"],"internal::Parser":["<F as internal::Parser<I>>::F","internal::And","internal::AndThen","internal::FlatMap","internal::Into","internal::Map","internal::MapOpt","internal::MapRes","internal::Or","std::boxed::Box"],"std::clone::Clone":["error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness"],"std::cmp::Eq":["error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness","traits::CompareResult"],"std::cmp::PartialEq":["error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness","traits::CompareResult"],"std::convert::From":["error::Error","error::VerboseError"],"std::error::Error":["error::Error","error::VerboseError","internal::Err"],"std::fmt::Debug":["error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness","traits::CompareResult"],"std::fmt::Display":["error::Error","error::VerboseError","internal::Err"],"std::hash::Hash":["error::ErrorKind"],"std::iter::Iterator":["traits::SaturatingIterator"],"std::marker::Copy":["error::ErrorKind","internal::Needed","number::Endianness"],"std::marker::StructuralEq":["error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","internal::Needed","number::Endianness","traits::CompareResult"],"std::marker::StructuralPartialEq":["error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness","traits::CompareResult"],"traits::ErrorConvert":["error::Error","error::VerboseError"],"traits::NomRange":["std::ops::Range","std::ops::RangeFrom","std::ops::RangeFull","std::ops::RangeInclusive","std::ops::RangeTo","std::ops::RangeToInclusive"]},"type_to_def_path":{"combinator::ParserIterator<I, E, F>":"combinator::ParserIterator","combinator::State<E>":"combinator::State","error::Error<I>":"error::Error","error::ErrorKind":"error::ErrorKind","error::VerboseError<I>":"error::VerboseError","error::VerboseErrorKind":"error::VerboseErrorKind","internal::And<F, G>":"internal::And","internal::AndThen<F, G>":"internal::AndThen","internal::Err<E>":"internal::Err","internal::FlatMap<F, G>":"internal::FlatMap","internal::Into<F, O2, E2>":"internal::Into","internal::Map<F, G>":"internal::Map","internal::MapOpt<F, G>":"internal::MapOpt","internal::MapRes<F, G>":"internal::MapRes","internal::Needed":"internal::Needed","internal::Or<F, G>":"internal::Or","number::Endianness":"number::Endianness","traits::CompareResult":"traits::CompareResult","traits::SaturatingIterator":"traits::SaturatingIterator"}}