{"dependencies":{"<buffer::Buffer as std::clone::Clone>::clone":["buffer::Buffer","std::marker::Sized","std::mem::MaybeUninit"],"<buffer::Buffer as std::default::Default>::default":["buffer::Buffer","std::marker::Sized","std::mem::MaybeUninit"],"<f32 as buffer::Sealed>::format_nonfinite":[],"<f32 as buffer::Sealed>::is_nonfinite":[],"<f32 as buffer::Sealed>::write_to_ryu_buffer":[],"<f64 as buffer::Sealed>::format_nonfinite":[],"<f64 as buffer::Sealed>::is_nonfinite":[],"<f64 as buffer::Sealed>::write_to_ryu_buffer":[],"buffer::Buffer":["buffer::Buffer","std::marker::Sized","std::mem::MaybeUninit"],"buffer::Buffer::format":["buffer::Buffer","buffer::Float","std::marker::Sized","std::mem::MaybeUninit"],"buffer::Buffer::format_finite":["buffer::Buffer","buffer::Float","std::marker::Sized","std::mem::MaybeUninit"],"buffer::Buffer::new":["buffer::Buffer","std::marker::Sized","std::mem::MaybeUninit"],"buffer::Sealed::format_nonfinite":[],"buffer::Sealed::is_nonfinite":[],"buffer::Sealed::write_to_ryu_buffer":[],"common::ceil_log2_pow5":[],"common::decimal_length9":[],"common::log10_pow2":[],"common::log10_pow5":[],"common::log2_pow5":[],"common::pow5bits":[],"d2s::FloatingDecimal64":["d2s::FloatingDecimal64"],"d2s::d2d":["d2s::FloatingDecimal64"],"d2s::decimal_length17":[],"d2s_intrinsics::div10":[],"d2s_intrinsics::div100":[],"d2s_intrinsics::div5":[],"d2s_intrinsics::mul_shift_64":[],"d2s_intrinsics::mul_shift_all_64":[],"d2s_intrinsics::multiple_of_power_of_2":[],"d2s_intrinsics::multiple_of_power_of_5":[],"d2s_intrinsics::pow5_factor":[],"f2s::FloatingDecimal32":["f2s::FloatingDecimal32"],"f2s::f2d":["f2s::FloatingDecimal32"],"f2s_intrinsics::mul_pow5_div_pow2":[],"f2s_intrinsics::mul_pow5_inv_div_pow2":[],"f2s_intrinsics::mul_shift_32":[],"f2s_intrinsics::multiple_of_power_of_2_32":[],"f2s_intrinsics::multiple_of_power_of_5_32":[],"f2s_intrinsics::pow5factor_32":[],"pretty::exponent::write_exponent2":[],"pretty::exponent::write_exponent3":[],"pretty::format32":[],"pretty::format64":[],"pretty::mantissa::write_mantissa":[],"pretty::mantissa::write_mantissa_long":[]},"glob_path_import":{"d2s_full_table":"d2s::"},"self_to_fn":{"buffer::Buffer":["impl Buffer {\n    /// This is a cheap operation; you don't need to worry about reusing buffers\n    /// for efficiency.\n    #[inline]\n    #[cfg_attr(feature = \"no-panic\", no_panic)]\n    pub fn new() -> Self {\n        let bytes = [MaybeUninit::<u8>::uninit(); 24];\n        Buffer { bytes }\n    }\n\n    /// Print a floating point number into this buffer and return a reference to\n    /// its string representation within the buffer.\n    ///\n    /// # Special cases\n    ///\n    /// This function formats NaN as the string \"NaN\", positive infinity as\n    /// \"inf\", and negative infinity as \"-inf\" to match std::fmt.\n    ///\n    /// If your input is known to be finite, you may get better performance by\n    /// calling the `format_finite` method instead of `format` to avoid the\n    /// checks for special cases.\n    #[cfg_attr(feature = \"no-panic\", inline)]\n    #[cfg_attr(feature = \"no-panic\", no_panic)]\n    pub fn format<F: Float>(&mut self, f: F) -> &str {\n        if f.is_nonfinite() {\n            f.format_nonfinite()\n        } else {\n            self.format_finite(f)\n        }\n    }\n\n    /// Print a floating point number into this buffer and return a reference to\n    /// its string representation within the buffer.\n    ///\n    /// # Special cases\n    ///\n    /// This function **does not** check for NaN or infinity. If the input\n    /// number is not a finite float, the printed representation will be some\n    /// correctly formatted but unspecified numerical value.\n    ///\n    /// Please check [`is_finite`] yourself before calling this function, or\n    /// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n    ///\n    /// [`is_finite`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_finite\n    /// [`is_nan`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_nan\n    /// [`is_infinite`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_infinite\n    #[inline]\n    #[cfg_attr(feature = \"no-panic\", no_panic)]\n    pub fn format_finite<F: Float>(&mut self, f: F) -> &str {\n        unsafe {\n            let n = f.write_to_ryu_buffer(self.bytes.as_mut_ptr() as *mut u8);\n            debug_assert!(n <= self.bytes.len());\n            let slice = slice::from_raw_parts(self.bytes.as_ptr() as *const u8, n);\n            str::from_utf8_unchecked(slice)\n        }\n    }\n}","impl Clone for Buffer {\n    #[inline]\n    fn clone(&self) -> Self {\n        Buffer::new()\n    }\n}","impl Copy for Buffer {}","impl Default for Buffer {\n    #[inline]\n    #[cfg_attr(feature = \"no-panic\", no_panic)]\n    fn default() -> Self {\n        Buffer::new()\n    }\n}"]},"single_path_import":{"buffer::Buffer":"Buffer","buffer::Float":"Float","f2s_intrinsics::FLOAT_POW5_BITCOUNT":"f2s::FLOAT_POW5_BITCOUNT","f2s_intrinsics::FLOAT_POW5_INV_BITCOUNT":"f2s::FLOAT_POW5_INV_BITCOUNT","pretty::format32":"raw::format32","pretty::format64":"raw::format64"},"srcs":{"<buffer::Buffer as std::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n        Buffer::new()\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"<buffer::Buffer as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n        Buffer::new()\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"<f32 as buffer::Sealed>::format_nonfinite":["#[cold]\nfn format_nonfinite(self) -> &'static str{\n        const MANTISSA_MASK: u32 = 0x007fffff;\n        const SIGN_MASK: u32 = 0x80000000;\n        let bits = self.to_bits();\n        if bits & MANTISSA_MASK != 0 {\n            NAN\n        } else if bits & SIGN_MASK != 0 {\n            NEG_INFINITY\n        } else {\n            INFINITY\n        }\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"<f32 as buffer::Sealed>::is_nonfinite":["#[inline]\nfn is_nonfinite(self) -> bool{\n        const EXP_MASK: u32 = 0x7f800000;\n        let bits = self.to_bits();\n        bits & EXP_MASK == EXP_MASK\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"<f32 as buffer::Sealed>::write_to_ryu_buffer":["#[inline]\nunsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize{\n        raw::format32(self, result)\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"<f64 as buffer::Sealed>::format_nonfinite":["#[cold]\nfn format_nonfinite(self) -> &'static str{\n        const MANTISSA_MASK: u64 = 0x000fffffffffffff;\n        const SIGN_MASK: u64 = 0x8000000000000000;\n        let bits = self.to_bits();\n        if bits & MANTISSA_MASK != 0 {\n            NAN\n        } else if bits & SIGN_MASK != 0 {\n            NEG_INFINITY\n        } else {\n            INFINITY\n        }\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"<f64 as buffer::Sealed>::is_nonfinite":["#[inline]\nfn is_nonfinite(self) -> bool{\n        const EXP_MASK: u64 = 0x7ff0000000000000;\n        let bits = self.to_bits();\n        bits & EXP_MASK == EXP_MASK\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"<f64 as buffer::Sealed>::write_to_ryu_buffer":["#[inline]\nunsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize{\n        raw::format64(self, result)\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"buffer::Buffer":["/// Safe API for formatting floating point numbers to text.\n///\n/// ## Example\n///\n/// ```\n/// let mut buffer = ryu::Buffer::new();\n/// let printed = buffer.format_finite(1.234);\n/// assert_eq!(printed, \"1.234\");\n/// ```\npub struct Buffer {\n    bytes: [MaybeUninit<u8>; 24],\n}","Real(LocalPath(\"src/buffer/mod.rs\"))"],"buffer::Buffer::format":["/// Print a floating point number into this buffer and return a reference to\n/// its string representation within the buffer.\n///\n/// # Special cases\n///\n/// This function formats NaN as the string \"NaN\", positive infinity as\n/// \"inf\", and negative infinity as \"-inf\" to match std::fmt.\n///\n/// If your input is known to be finite, you may get better performance by\n/// calling the `format_finite` method instead of `format` to avoid the\n/// checks for special cases.\npub fn format<F: Float>(&mut self, f: F) -> &str{\n        if f.is_nonfinite() {\n            f.format_nonfinite()\n        } else {\n            self.format_finite(f)\n        }\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"buffer::Buffer::format_finite":["/// Print a floating point number into this buffer and return a reference to\n/// its string representation within the buffer.\n///\n/// # Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n///\n/// [`is_finite`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_finite\n/// [`is_nan`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_nan\n/// [`is_infinite`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_infinite\n#[inline]\npub fn format_finite<F: Float>(&mut self, f: F) -> &str{\n        unsafe {\n            let n = f.write_to_ryu_buffer(self.bytes.as_mut_ptr() as *mut u8);\n            debug_assert!(n <= self.bytes.len());\n            let slice = slice::from_raw_parts(self.bytes.as_ptr() as *const u8, n);\n            str::from_utf8_unchecked(slice)\n        }\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"buffer::Buffer::new":["/// This is a cheap operation; you don't need to worry about reusing buffers\n/// for efficiency.\n#[inline]\npub fn new() -> Self{\n        let bytes = [MaybeUninit::<u8>::uninit(); 24];\n        Buffer { bytes }\n    }","Real(LocalPath(\"src/buffer/mod.rs\"))"],"buffer::Float":["/// A floating point number, f32 or f64, that can be written into a\n/// [`ryu::Buffer`][Buffer].\n///\n/// This trait is sealed and cannot be implemented for types outside of the\n/// `ryu` crate.\npub trait Float: Sealed {}","Real(LocalPath(\"src/buffer/mod.rs\"))"],"buffer::Sealed":["pub trait Sealed: Copy {\n    fn is_nonfinite(self) -> bool;\n    fn format_nonfinite(self) -> &'static str;\n    unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize;\n}","Real(LocalPath(\"src/buffer/mod.rs\"))"],"common::ceil_log2_pow5":["#[allow(dead_code)]\npub fn ceil_log2_pow5(e: i32) -> i32{\n    log2_pow5(e) + 1\n}","Real(LocalPath(\"src/common.rs\"))"],"common::decimal_length9":["pub fn decimal_length9(v: u32) -> u32{\n    // Function precondition: v is not a 10-digit number.\n    // (f2s: 9 digits are sufficient for round-tripping.)\n    debug_assert!(v < 1000000000);\n\n    if v >= 100000000 {\n        9\n    } else if v >= 10000000 {\n        8\n    } else if v >= 1000000 {\n        7\n    } else if v >= 100000 {\n        6\n    } else if v >= 10000 {\n        5\n    } else if v >= 1000 {\n        4\n    } else if v >= 100 {\n        3\n    } else if v >= 10 {\n        2\n    } else {\n        1\n    }\n}","Real(LocalPath(\"src/common.rs\"))"],"common::log10_pow2":["pub fn log10_pow2(e: i32) -> u32{\n    // The first value this approximation fails for is 2^1651 which is just greater than 10^297.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 1650);\n    (e as u32 * 78913) >> 18\n}","Real(LocalPath(\"src/common.rs\"))"],"common::log10_pow5":["pub fn log10_pow5(e: i32) -> u32{\n    // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 2620);\n    (e as u32 * 732923) >> 20\n}","Real(LocalPath(\"src/common.rs\"))"],"common::log2_pow5":["#[allow(dead_code)]\npub fn log2_pow5(e: i32) -> i32{\n    // This approximation works up to the point that the multiplication\n    // overflows at e = 3529. If the multiplication were done in 64 bits, it\n    // would fail at 5^4004 which is just greater than 2^9297.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 3528);\n    ((e as u32 * 1217359) >> 19) as i32\n}","Real(LocalPath(\"src/common.rs\"))"],"common::pow5bits":["pub fn pow5bits(e: i32) -> i32{\n    // This approximation works up to the point that the multiplication\n    // overflows at e = 3529. If the multiplication were done in 64 bits, it\n    // would fail at 5^4004 which is just greater than 2^9297.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 3528);\n    (((e as u32 * 1217359) >> 19) + 1) as i32\n}","Real(LocalPath(\"src/common.rs\"))"],"d2s::FloatingDecimal64":["pub struct FloatingDecimal64 {\n    pub mantissa: u64,\n    // Decimal exponent's range is -324 to 308\n    // inclusive, and can fit in i16 if needed.\n    pub exponent: i32,\n}","Real(LocalPath(\"src/d2s.rs\"))"],"d2s::d2d":["pub fn d2d(ieee_mantissa: u64, ieee_exponent: u32) -> FloatingDecimal64{\n    let (e2, m2) = if ieee_exponent == 0 {\n        (\n            // We subtract 2 so that the bounds computation has 2 additional bits.\n            1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            ieee_mantissa,\n        )\n    } else {\n        (\n            ieee_exponent as i32 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            (1u64 << DOUBLE_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n\n    // Step 2: Determine the interval of valid decimal representations.\n    let mv = 4 * m2;\n    // Implicit bool -> int conversion. True is 1, false is 0.\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    // We would compute mp and mm like this:\n    // uint64_t mp = 4 * m2 + 2;\n    // uint64_t mm = mv - 1 - mm_shift;\n\n    // Step 3: Convert to a decimal power base using 128-bit arithmetic.\n    let mut vr: u64;\n    let mut vp: u64;\n    let mut vm: u64;\n    let mut vp_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let mut vm_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    if e2 >= 0 {\n        // I tried special-casing q == 0, but there was no effect on performance.\n        // This expression is slightly faster than max(0, log10_pow2(e2) - 1).\n        let q = log10_pow2(e2) - (e2 > 3) as u32;\n        e10 = q as i32;\n        let k = DOUBLE_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_inv_pow5(q),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(q < DOUBLE_POW5_INV_SPLIT.len() as u32);\n                    DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize)\n                },\n                i as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 21 {\n            // This should use q <= 22, but I think 21 is also safe. Smaller values\n            // may still be safe, but it's more difficult to reason about them.\n            // Only one of mp, mv, and mm can be a multiple of 5, if any.\n            let mv_mod5 = (mv as u32).wrapping_sub(5u32.wrapping_mul(div5(mv) as u32));\n            if mv_mod5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5(mv, q);\n            } else if accept_bounds {\n                // Same as min(e2 + (~mm & 1), pow5_factor(mm)) >= q\n                // <=> e2 + (~mm & 1) >= q && pow5_factor(mm) >= q\n                // <=> true && pow5_factor(mm) >= q, since e2 >= q.\n                vm_is_trailing_zeros = multiple_of_power_of_5(mv - 1 - mm_shift as u64, q);\n            } else {\n                // Same as min(e2 + 1, pow5_factor(mp)) >= q.\n                vp -= multiple_of_power_of_5(mv + 2, q) as u64;\n            }\n        }\n    } else {\n        // This expression is slightly faster than max(0, log10_pow5(-e2) - 1).\n        let q = log10_pow5(-e2) - (-e2 > 1) as u32;\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;\n        let j = q as i32 - k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_pow5(i as u32),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(i < DOUBLE_POW5_SPLIT.len() as i32);\n                    DOUBLE_POW5_SPLIT.get_unchecked(i as usize)\n                },\n                j as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 1 {\n            // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n            // mv = 4 * m2, so it always has at least two trailing 0 bits.\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                // mm = mv - 1 - mm_shift, so it has 1 trailing 0 bit iff mm_shift == 1.\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                // mp = mv + 2, so it always has at least one trailing 0 bit.\n                vp -= 1;\n            }\n        } else if q < 63 {\n            // TODO(ulfjack): Use a tighter bound here.\n            // We want to know if the full product has at least q trailing zeros.\n            // We need to compute min(p2(mv), p5(mv) - e2) >= q\n            // <=> p2(mv) >= q && p5(mv) - e2 >= q\n            // <=> p2(mv) >= q (because -e2 >= q)\n            vr_is_trailing_zeros = multiple_of_power_of_2(mv, q);\n        }\n    }\n\n    // Step 4: Find the shortest decimal representation in the interval of valid representations.\n    let mut removed = 0i32;\n    let mut last_removed_digit = 0u8;\n    // On average, we remove ~2 digits.\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        // General case, which happens rarely (~0.7%).\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            vm_is_trailing_zeros &= vm_mod10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = vr_mod10 as u8;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            loop {\n                let vm_div10 = div10(vm);\n                let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n                if vm_mod10 != 0 {\n                    break;\n                }\n                let vp_div10 = div10(vp);\n                let vr_div10 = div10(vr);\n                let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = vr_mod10 as u8;\n                vr = vr_div10;\n                vp = vp_div10;\n                vm = vm_div10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            // Round even if the exact number is .....50..0.\n            last_removed_digit = 4;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5)\n            as u64\n    } else {\n        // Specialized for the common case (~99.3%). Percentages below are relative to this.\n        let mut round_up = false;\n        let vp_div100 = div100(vp);\n        let vm_div100 = div100(vm);\n        // Optimization: remove two digits at a time (~86.2%).\n        if vp_div100 > vm_div100 {\n            let vr_div100 = div100(vr);\n            let vr_mod100 = (vr as u32).wrapping_sub(100u32.wrapping_mul(vr_div100 as u32));\n            round_up = vr_mod100 >= 50;\n            vr = vr_div100;\n            vp = vp_div100;\n            vm = vm_div100;\n            removed += 2;\n        }\n        // Loop iterations below (approximately), without optimization above:\n        // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%\n        // Loop iterations below (approximately), with optimization above:\n        // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            round_up = vr_mod10 >= 5;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + (vr == vm || round_up) as u64\n    };\n    let exp = e10 + removed;\n\n    FloatingDecimal64 {\n        exponent: exp,\n        mantissa: output,\n    }\n}","Real(LocalPath(\"src/d2s.rs\"))"],"d2s::decimal_length17":["pub fn decimal_length17(v: u64) -> u32{\n    // This is slightly faster than a loop.\n    // The average output length is 16.38 digits, so we check high-to-low.\n    // Function precondition: v is not an 18, 19, or 20-digit number.\n    // (17 digits are sufficient for round-tripping.)\n    debug_assert!(v < 100000000000000000);\n\n    if v >= 10000000000000000 {\n        17\n    } else if v >= 1000000000000000 {\n        16\n    } else if v >= 100000000000000 {\n        15\n    } else if v >= 10000000000000 {\n        14\n    } else if v >= 1000000000000 {\n        13\n    } else if v >= 100000000000 {\n        12\n    } else if v >= 10000000000 {\n        11\n    } else if v >= 1000000000 {\n        10\n    } else if v >= 100000000 {\n        9\n    } else if v >= 10000000 {\n        8\n    } else if v >= 1000000 {\n        7\n    } else if v >= 100000 {\n        6\n    } else if v >= 10000 {\n        5\n    } else if v >= 1000 {\n        4\n    } else if v >= 100 {\n        3\n    } else if v >= 10 {\n        2\n    } else {\n        1\n    }\n}","Real(LocalPath(\"src/d2s.rs\"))"],"d2s_intrinsics::div10":["pub fn div10(x: u64) -> u64{\n    x / 10\n}","Real(LocalPath(\"src/d2s_intrinsics.rs\"))"],"d2s_intrinsics::div100":["pub fn div100(x: u64) -> u64{\n    x / 100\n}","Real(LocalPath(\"src/d2s_intrinsics.rs\"))"],"d2s_intrinsics::div5":["pub fn div5(x: u64) -> u64{\n    x / 5\n}","Real(LocalPath(\"src/d2s_intrinsics.rs\"))"],"d2s_intrinsics::mul_shift_64":["pub fn mul_shift_64(m: u64, mul: &(u64, u64), j: u32) -> u64{\n    let b0 = m as u128 * mul.0 as u128;\n    let b2 = m as u128 * mul.1 as u128;\n    (((b0 >> 64) + b2) >> (j - 64)) as u64\n}","Real(LocalPath(\"src/d2s_intrinsics.rs\"))"],"d2s_intrinsics::mul_shift_all_64":["pub unsafe fn mul_shift_all_64(\n    m: u64,\n    mul: &(u64, u64),\n    j: u32,\n    vp: *mut u64,\n    vm: *mut u64,\n    mm_shift: u32,\n) -> u64{\n    ptr::write(vp, mul_shift_64(4 * m + 2, mul, j));\n    ptr::write(vm, mul_shift_64(4 * m - 1 - mm_shift as u64, mul, j));\n    mul_shift_64(4 * m, mul, j)\n}","Real(LocalPath(\"src/d2s_intrinsics.rs\"))"],"d2s_intrinsics::multiple_of_power_of_2":["pub fn multiple_of_power_of_2(value: u64, p: u32) -> bool{\n    debug_assert!(value != 0);\n    debug_assert!(p < 64);\n    // __builtin_ctzll doesn't appear to be faster here.\n    (value & ((1u64 << p) - 1)) == 0\n}","Real(LocalPath(\"src/d2s_intrinsics.rs\"))"],"d2s_intrinsics::multiple_of_power_of_5":["pub fn multiple_of_power_of_5(value: u64, p: u32) -> bool{\n    // I tried a case distinction on p, but there was no performance difference.\n    pow5_factor(value) >= p\n}","Real(LocalPath(\"src/d2s_intrinsics.rs\"))"],"d2s_intrinsics::pow5_factor":["fn pow5_factor(mut value: u64) -> u32{\n    let mut count = 0u32;\n    loop {\n        debug_assert!(value != 0);\n        let q = div5(value);\n        let r = (value as u32).wrapping_sub(5u32.wrapping_mul(q as u32));\n        if r != 0 {\n            break;\n        }\n        value = q;\n        count += 1;\n    }\n    count\n}","Real(LocalPath(\"src/d2s_intrinsics.rs\"))"],"f2s::FloatingDecimal32":["pub struct FloatingDecimal32 {\n    pub mantissa: u32,\n    // Decimal exponent's range is -45 to 38\n    // inclusive, and can fit in i16 if needed.\n    pub exponent: i32,\n}","Real(LocalPath(\"src/f2s.rs\"))"],"f2s::f2d":["pub fn f2d(ieee_mantissa: u32, ieee_exponent: u32) -> FloatingDecimal32{\n    let (e2, m2) = if ieee_exponent == 0 {\n        (\n            // We subtract 2 so that the bounds computation has 2 additional bits.\n            1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS as i32 - 2,\n            ieee_mantissa,\n        )\n    } else {\n        (\n            ieee_exponent as i32 - FLOAT_BIAS - FLOAT_MANTISSA_BITS as i32 - 2,\n            (1u32 << FLOAT_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n\n    // Step 2: Determine the interval of valid decimal representations.\n    let mv = 4 * m2;\n    let mp = 4 * m2 + 2;\n    // Implicit bool -> int conversion. True is 1, false is 0.\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    let mm = 4 * m2 - 1 - mm_shift;\n\n    // Step 3: Convert to a decimal power base using 64-bit arithmetic.\n    let mut vr: u32;\n    let mut vp: u32;\n    let mut vm: u32;\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    let mut last_removed_digit = 0u8;\n    if e2 >= 0 {\n        let q = log10_pow2(e2);\n        e10 = q as i32;\n        let k = FLOAT_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = mul_pow5_inv_div_pow2(mv, q, i);\n        vp = mul_pow5_inv_div_pow2(mp, q, i);\n        vm = mul_pow5_inv_div_pow2(mm, q, i);\n        if q != 0 && (vp - 1) / 10 <= vm / 10 {\n            // We need to know one removed digit even if we are not going to loop below. We could use\n            // q = X - 1 above, except that would require 33 bits for the result, and we've found that\n            // 32-bit arithmetic is faster even on 64-bit machines.\n            let l = FLOAT_POW5_INV_BITCOUNT + pow5bits(q as i32 - 1) - 1;\n            last_removed_digit =\n                (mul_pow5_inv_div_pow2(mv, q - 1, -e2 + q as i32 - 1 + l) % 10) as u8;\n        }\n        if q <= 9 {\n            // The largest power of 5 that fits in 24 bits is 5^10, but q <= 9 seems to be safe as well.\n            // Only one of mp, mv, and mm can be a multiple of 5, if any.\n            if mv % 5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5_32(mv, q);\n            } else if accept_bounds {\n                vm_is_trailing_zeros = multiple_of_power_of_5_32(mm, q);\n            } else {\n                vp -= multiple_of_power_of_5_32(mp, q) as u32;\n            }\n        }\n    } else {\n        let q = log10_pow5(-e2);\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - FLOAT_POW5_BITCOUNT;\n        let mut j = q as i32 - k;\n        vr = mul_pow5_div_pow2(mv, i as u32, j);\n        vp = mul_pow5_div_pow2(mp, i as u32, j);\n        vm = mul_pow5_div_pow2(mm, i as u32, j);\n        if q != 0 && (vp - 1) / 10 <= vm / 10 {\n            j = q as i32 - 1 - (pow5bits(i + 1) - FLOAT_POW5_BITCOUNT);\n            last_removed_digit = (mul_pow5_div_pow2(mv, (i + 1) as u32, j) % 10) as u8;\n        }\n        if q <= 1 {\n            // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n            // mv = 4 * m2, so it always has at least two trailing 0 bits.\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                // mm = mv - 1 - mm_shift, so it has 1 trailing 0 bit iff mm_shift == 1.\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                // mp = mv + 2, so it always has at least one trailing 0 bit.\n                vp -= 1;\n            }\n        } else if q < 31 {\n            // TODO(ulfjack): Use a tighter bound here.\n            vr_is_trailing_zeros = multiple_of_power_of_2_32(mv, q - 1);\n        }\n    }\n\n    // Step 4: Find the shortest decimal representation in the interval of valid representations.\n    let mut removed = 0i32;\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        // General case, which happens rarely (~4.0%).\n        while vp / 10 > vm / 10 {\n            vm_is_trailing_zeros &= vm - (vm / 10) * 10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = (vr % 10) as u8;\n            vr /= 10;\n            vp /= 10;\n            vm /= 10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            while vm % 10 == 0 {\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = (vr % 10) as u8;\n                vr /= 10;\n                vp /= 10;\n                vm /= 10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            // Round even if the exact number is .....50..0.\n            last_removed_digit = 4;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5)\n            as u32\n    } else {\n        // Specialized for the common case (~96.0%). Percentages below are relative to this.\n        // Loop iterations below (approximately):\n        // 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%\n        while vp / 10 > vm / 10 {\n            last_removed_digit = (vr % 10) as u8;\n            vr /= 10;\n            vp /= 10;\n            vm /= 10;\n            removed += 1;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + (vr == vm || last_removed_digit >= 5) as u32\n    };\n    let exp = e10 + removed;\n\n    FloatingDecimal32 {\n        exponent: exp,\n        mantissa: output,\n    }\n}","Real(LocalPath(\"src/f2s.rs\"))"],"f2s_intrinsics::mul_pow5_div_pow2":["pub fn mul_pow5_div_pow2(m: u32, i: u32, j: i32) -> u32{\n    #[cfg(feature = \"small\")]\n    {\n        let pow5 = unsafe { d2s::compute_pow5(i) };\n        mul_shift_32(m, pow5.1, j)\n    }\n\n    #[cfg(not(feature = \"small\"))]\n    {\n        debug_assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);\n        unsafe { mul_shift_32(m, d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1, j) }\n    }\n}","Real(LocalPath(\"src/f2s_intrinsics.rs\"))"],"f2s_intrinsics::mul_pow5_inv_div_pow2":["pub fn mul_pow5_inv_div_pow2(m: u32, q: u32, j: i32) -> u32{\n    #[cfg(feature = \"small\")]\n    {\n        // The inverse multipliers are defined as [2^x / 5^y] + 1; the upper 64\n        // bits from the double lookup table are the correct bits for [2^x /\n        // 5^y], so we have to add 1 here. Note that we rely on the fact that\n        // the added 1 that's already stored in the table never overflows into\n        // the upper 64 bits.\n        let pow5 = unsafe { d2s::compute_inv_pow5(q) };\n        mul_shift_32(m, pow5.1 + 1, j)\n    }\n\n    #[cfg(not(feature = \"small\"))]\n    {\n        debug_assert!(q < d2s::DOUBLE_POW5_INV_SPLIT.len() as u32);\n        unsafe {\n            mul_shift_32(\n                m,\n                d2s::DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize).1 + 1,\n                j,\n            )\n        }\n    }\n}","Real(LocalPath(\"src/f2s_intrinsics.rs\"))"],"f2s_intrinsics::mul_shift_32":["fn mul_shift_32(m: u32, factor: u64, shift: i32) -> u32{\n    debug_assert!(shift > 32);\n\n    // The casts here help MSVC to avoid calls to the __allmul library\n    // function.\n    let factor_lo = factor as u32;\n    let factor_hi = (factor >> 32) as u32;\n    let bits0 = m as u64 * factor_lo as u64;\n    let bits1 = m as u64 * factor_hi as u64;\n\n    let sum = (bits0 >> 32) + bits1;\n    let shifted_sum = sum >> (shift - 32);\n    debug_assert!(shifted_sum <= u32::max_value() as u64);\n    shifted_sum as u32\n}","Real(LocalPath(\"src/f2s_intrinsics.rs\"))"],"f2s_intrinsics::multiple_of_power_of_2_32":["pub fn multiple_of_power_of_2_32(value: u32, p: u32) -> bool{\n    // __builtin_ctz doesn't appear to be faster here.\n    (value & ((1u32 << p) - 1)) == 0\n}","Real(LocalPath(\"src/f2s_intrinsics.rs\"))"],"f2s_intrinsics::multiple_of_power_of_5_32":["pub fn multiple_of_power_of_5_32(value: u32, p: u32) -> bool{\n    pow5factor_32(value) >= p\n}","Real(LocalPath(\"src/f2s_intrinsics.rs\"))"],"f2s_intrinsics::pow5factor_32":["fn pow5factor_32(mut value: u32) -> u32{\n    let mut count = 0u32;\n    loop {\n        debug_assert!(value != 0);\n        let q = value / 5;\n        let r = value % 5;\n        if r != 0 {\n            break;\n        }\n        value = q;\n        count += 1;\n    }\n    count\n}","Real(LocalPath(\"src/f2s_intrinsics.rs\"))"],"pretty::exponent::write_exponent2":["pub unsafe fn write_exponent2(mut k: isize, mut result: *mut u8) -> usize{\n    let sign = k < 0;\n    if sign {\n        *result = b'-';\n        result = result.offset(1);\n        k = -k;\n    }\n\n    debug_assert!(k < 100);\n    if k >= 10 {\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result, 2);\n        sign as usize + 2\n    } else {\n        *result = b'0' + k as u8;\n        sign as usize + 1\n    }\n}","Real(LocalPath(\"src/pretty/exponent.rs\"))"],"pretty::exponent::write_exponent3":["pub unsafe fn write_exponent3(mut k: isize, mut result: *mut u8) -> usize{\n    let sign = k < 0;\n    if sign {\n        *result = b'-';\n        result = result.offset(1);\n        k = -k;\n    }\n\n    debug_assert!(k < 1000);\n    if k >= 100 {\n        *result = b'0' + (k / 100) as u8;\n        k %= 100;\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result.offset(1), 2);\n        sign as usize + 3\n    } else if k >= 10 {\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result, 2);\n        sign as usize + 2\n    } else {\n        *result = b'0' + k as u8;\n        sign as usize + 1\n    }\n}","Real(LocalPath(\"src/pretty/exponent.rs\"))"],"pretty::format32":["/// Print f32 to the given buffer and return number of bytes written.\n///\n/// At most 16 bytes will be written.\n///\n/// ## Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n///\n/// [`is_finite`]: https://doc.rust-lang.org/std/primitive.f32.html#method.is_finite\n/// [`is_nan`]: https://doc.rust-lang.org/std/primitive.f32.html#method.is_nan\n/// [`is_infinite`]: https://doc.rust-lang.org/std/primitive.f32.html#method.is_infinite\n///\n/// ## Safety\n///\n/// The `result` pointer argument must point to sufficiently many writable bytes\n/// to hold Ryū's representation of `f`.\n///\n/// ## Example\n///\n/// ```\n/// use std::{mem::MaybeUninit, slice, str};\n///\n/// let f = 1.234f32;\n///\n/// unsafe {\n///     let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n///     let len = ryu::raw::format32(f, buffer.as_mut_ptr() as *mut u8);\n///     let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n///     let print = str::from_utf8_unchecked(slice);\n///     assert_eq!(print, \"1.234\");\n/// }\n/// ```\n#[must_use]\npub unsafe fn format32(f: f32, result: *mut u8) -> usize{\n    let bits = f.to_bits();\n    let sign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) & 1) != 0;\n    let ieee_mantissa = bits & ((1u32 << FLOAT_MANTISSA_BITS) - 1);\n    let ieee_exponent = (bits >> FLOAT_MANTISSA_BITS) & ((1u32 << FLOAT_EXPONENT_BITS) - 1);\n\n    let mut index = 0isize;\n    if sign {\n        *result = b'-';\n        index += 1;\n    }\n\n    if ieee_exponent == 0 && ieee_mantissa == 0 {\n        ptr::copy_nonoverlapping(b\"0.0\".as_ptr(), result.offset(index), 3);\n        return sign as usize + 3;\n    }\n\n    let v = f2d(ieee_mantissa, ieee_exponent);\n\n    let length = common::decimal_length9(v.mantissa) as isize;\n    let k = v.exponent as isize;\n    let kk = length + k; // 10^(kk-1) <= v < 10^kk\n    debug_assert!(k >= -45);\n\n    if 0 <= k && kk <= 13 {\n        // 1234e7 -> 12340000000.0\n        write_mantissa(v.mantissa, result.offset(index + length));\n        for i in length..kk {\n            *result.offset(index + i) = b'0';\n        }\n        *result.offset(index + kk) = b'.';\n        *result.offset(index + kk + 1) = b'0';\n        index as usize + kk as usize + 2\n    } else if 0 < kk && kk <= 13 {\n        // 1234e-2 -> 12.34\n        write_mantissa(v.mantissa, result.offset(index + length + 1));\n        ptr::copy(result.offset(index + 1), result.offset(index), kk as usize);\n        *result.offset(index + kk) = b'.';\n        index as usize + length as usize + 1\n    } else if -6 < kk && kk <= 0 {\n        // 1234e-6 -> 0.001234\n        *result.offset(index) = b'0';\n        *result.offset(index + 1) = b'.';\n        let offset = 2 - kk;\n        for i in 2..offset {\n            *result.offset(index + i) = b'0';\n        }\n        write_mantissa(v.mantissa, result.offset(index + length + offset));\n        index as usize + length as usize + offset as usize\n    } else if length == 1 {\n        // 1e30\n        *result.offset(index) = b'0' + v.mantissa as u8;\n        *result.offset(index + 1) = b'e';\n        index as usize + 2 + write_exponent2(kk - 1, result.offset(index + 2))\n    } else {\n        // 1234e30 -> 1.234e33\n        write_mantissa(v.mantissa, result.offset(index + length + 1));\n        *result.offset(index) = *result.offset(index + 1);\n        *result.offset(index + 1) = b'.';\n        *result.offset(index + length + 1) = b'e';\n        index as usize\n            + length as usize\n            + 2\n            + write_exponent2(kk - 1, result.offset(index + length + 2))\n    }\n}","Real(LocalPath(\"src/pretty/mod.rs\"))"],"pretty::format64":["/// Print f64 to the given buffer and return number of bytes written.\n///\n/// At most 24 bytes will be written.\n///\n/// ## Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n///\n/// [`is_finite`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_finite\n/// [`is_nan`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_nan\n/// [`is_infinite`]: https://doc.rust-lang.org/std/primitive.f64.html#method.is_infinite\n///\n/// ## Safety\n///\n/// The `result` pointer argument must point to sufficiently many writable bytes\n/// to hold Ryū's representation of `f`.\n///\n/// ## Example\n///\n/// ```\n/// use std::{mem::MaybeUninit, slice, str};\n///\n/// let f = 1.234f64;\n///\n/// unsafe {\n///     let mut buffer = [MaybeUninit::<u8>::uninit(); 24];\n///     let len = ryu::raw::format64(f, buffer.as_mut_ptr() as *mut u8);\n///     let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n///     let print = str::from_utf8_unchecked(slice);\n///     assert_eq!(print, \"1.234\");\n/// }\n/// ```\n#[must_use]\npub unsafe fn format64(f: f64, result: *mut u8) -> usize{\n    let bits = f.to_bits();\n    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;\n    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);\n    let ieee_exponent =\n        (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);\n\n    let mut index = 0isize;\n    if sign {\n        *result = b'-';\n        index += 1;\n    }\n\n    if ieee_exponent == 0 && ieee_mantissa == 0 {\n        ptr::copy_nonoverlapping(b\"0.0\".as_ptr(), result.offset(index), 3);\n        return sign as usize + 3;\n    }\n\n    let v = d2d(ieee_mantissa, ieee_exponent);\n\n    let length = d2s::decimal_length17(v.mantissa) as isize;\n    let k = v.exponent as isize;\n    let kk = length + k; // 10^(kk-1) <= v < 10^kk\n    debug_assert!(k >= -324);\n\n    if 0 <= k && kk <= 16 {\n        // 1234e7 -> 12340000000.0\n        write_mantissa_long(v.mantissa, result.offset(index + length));\n        for i in length..kk {\n            *result.offset(index + i) = b'0';\n        }\n        *result.offset(index + kk) = b'.';\n        *result.offset(index + kk + 1) = b'0';\n        index as usize + kk as usize + 2\n    } else if 0 < kk && kk <= 16 {\n        // 1234e-2 -> 12.34\n        write_mantissa_long(v.mantissa, result.offset(index + length + 1));\n        ptr::copy(result.offset(index + 1), result.offset(index), kk as usize);\n        *result.offset(index + kk) = b'.';\n        index as usize + length as usize + 1\n    } else if -5 < kk && kk <= 0 {\n        // 1234e-6 -> 0.001234\n        *result.offset(index) = b'0';\n        *result.offset(index + 1) = b'.';\n        let offset = 2 - kk;\n        for i in 2..offset {\n            *result.offset(index + i) = b'0';\n        }\n        write_mantissa_long(v.mantissa, result.offset(index + length + offset));\n        index as usize + length as usize + offset as usize\n    } else if length == 1 {\n        // 1e30\n        *result.offset(index) = b'0' + v.mantissa as u8;\n        *result.offset(index + 1) = b'e';\n        index as usize + 2 + write_exponent3(kk - 1, result.offset(index + 2))\n    } else {\n        // 1234e30 -> 1.234e33\n        write_mantissa_long(v.mantissa, result.offset(index + length + 1));\n        *result.offset(index) = *result.offset(index + 1);\n        *result.offset(index + 1) = b'.';\n        *result.offset(index + length + 1) = b'e';\n        index as usize\n            + length as usize\n            + 2\n            + write_exponent3(kk - 1, result.offset(index + length + 2))\n    }\n}","Real(LocalPath(\"src/pretty/mod.rs\"))"],"pretty::mantissa::write_mantissa":["pub unsafe fn write_mantissa(mut output: u32, mut result: *mut u8){\n    while output >= 10_000 {\n        let c = output - 10_000 * (output / 10_000);\n        output /= 10_000;\n        let c0 = (c % 100) << 1;\n        let c1 = (c / 100) << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c0 as isize),\n            result.offset(-2),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c1 as isize),\n            result.offset(-4),\n            2,\n        );\n        result = result.offset(-4);\n    }\n    if output >= 100 {\n        let c = (output % 100) << 1;\n        output /= 100;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c as isize),\n            result.offset(-2),\n            2,\n        );\n        result = result.offset(-2);\n    }\n    if output >= 10 {\n        let c = output << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c as isize),\n            result.offset(-2),\n            2,\n        );\n    } else {\n        *result.offset(-1) = b'0' + output as u8;\n    }\n}","Real(LocalPath(\"src/pretty/mantissa.rs\"))"],"pretty::mantissa::write_mantissa_long":["pub unsafe fn write_mantissa_long(mut output: u64, mut result: *mut u8){\n    if (output >> 32) != 0 {\n        // One expensive 64-bit division.\n        let mut output2 = (output - 100_000_000 * (output / 100_000_000)) as u32;\n        output /= 100_000_000;\n\n        let c = output2 % 10_000;\n        output2 /= 10_000;\n        let d = output2 % 10_000;\n        let c0 = (c % 100) << 1;\n        let c1 = (c / 100) << 1;\n        let d0 = (d % 100) << 1;\n        let d1 = (d / 100) << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c0 as isize),\n            result.offset(-2),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c1 as isize),\n            result.offset(-4),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(d0 as isize),\n            result.offset(-6),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(d1 as isize),\n            result.offset(-8),\n            2,\n        );\n        result = result.offset(-8);\n    }\n    write_mantissa(output as u32, result);\n}","Real(LocalPath(\"src/pretty/mantissa.rs\"))"]},"struct_constructor":{"&'static str":["format_nonfinite"],"&str":["format","format_finite"],"bool":["is_nonfinite","multiple_of_power_of_2","multiple_of_power_of_2_32","multiple_of_power_of_5","multiple_of_power_of_5_32"],"buffer::Buffer":["clone","default","new"],"d2s::FloatingDecimal64":["d2d"],"f2s::FloatingDecimal32":["f2d"],"u32":["decimal_length17","log10_pow2","log10_pow5","pow5_factor"],"usize":["format32","format64","write_exponent2","write_exponent3","write_to_ryu_buffer"]},"struct_to_trait":{"buffer::Buffer":["std::clone::Clone","std::default::Default","std::marker::Copy"]},"targets":{"<buffer::Buffer as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/buffer/mod.rs\"))","std::clone::Clone"],"<buffer::Buffer as std::default::Default>::default":["default","Real(LocalPath(\"src/buffer/mod.rs\"))","std::default::Default"],"<f32 as buffer::Sealed>::format_nonfinite":["format_nonfinite","Real(LocalPath(\"src/buffer/mod.rs\"))","buffer::Sealed"],"<f32 as buffer::Sealed>::is_nonfinite":["is_nonfinite","Real(LocalPath(\"src/buffer/mod.rs\"))","buffer::Sealed"],"<f32 as buffer::Sealed>::write_to_ryu_buffer":["write_to_ryu_buffer","Real(LocalPath(\"src/buffer/mod.rs\"))","buffer::Sealed"],"<f64 as buffer::Sealed>::format_nonfinite":["format_nonfinite","Real(LocalPath(\"src/buffer/mod.rs\"))","buffer::Sealed"],"<f64 as buffer::Sealed>::is_nonfinite":["is_nonfinite","Real(LocalPath(\"src/buffer/mod.rs\"))","buffer::Sealed"],"<f64 as buffer::Sealed>::write_to_ryu_buffer":["write_to_ryu_buffer","Real(LocalPath(\"src/buffer/mod.rs\"))","buffer::Sealed"],"buffer::Buffer::format":["format","Real(LocalPath(\"src/buffer/mod.rs\"))",""],"buffer::Buffer::format_finite":["format_finite","Real(LocalPath(\"src/buffer/mod.rs\"))",""],"buffer::Buffer::new":["new","Real(LocalPath(\"src/buffer/mod.rs\"))",""],"common::ceil_log2_pow5":["ceil_log2_pow5","Real(LocalPath(\"src/common.rs\"))",""],"common::decimal_length9":["decimal_length9","Real(LocalPath(\"src/common.rs\"))",""],"common::log10_pow2":["log10_pow2","Real(LocalPath(\"src/common.rs\"))",""],"common::log10_pow5":["log10_pow5","Real(LocalPath(\"src/common.rs\"))",""],"common::log2_pow5":["log2_pow5","Real(LocalPath(\"src/common.rs\"))",""],"common::pow5bits":["pow5bits","Real(LocalPath(\"src/common.rs\"))",""],"d2s::d2d":["d2d","Real(LocalPath(\"src/d2s.rs\"))",""],"d2s::decimal_length17":["decimal_length17","Real(LocalPath(\"src/d2s.rs\"))",""],"d2s_intrinsics::div10":["div10","Real(LocalPath(\"src/d2s_intrinsics.rs\"))",""],"d2s_intrinsics::div100":["div100","Real(LocalPath(\"src/d2s_intrinsics.rs\"))",""],"d2s_intrinsics::div5":["div5","Real(LocalPath(\"src/d2s_intrinsics.rs\"))",""],"d2s_intrinsics::mul_shift_64":["mul_shift_64","Real(LocalPath(\"src/d2s_intrinsics.rs\"))",""],"d2s_intrinsics::mul_shift_all_64":["mul_shift_all_64","Real(LocalPath(\"src/d2s_intrinsics.rs\"))",""],"d2s_intrinsics::multiple_of_power_of_2":["multiple_of_power_of_2","Real(LocalPath(\"src/d2s_intrinsics.rs\"))",""],"d2s_intrinsics::multiple_of_power_of_5":["multiple_of_power_of_5","Real(LocalPath(\"src/d2s_intrinsics.rs\"))",""],"d2s_intrinsics::pow5_factor":["pow5_factor","Real(LocalPath(\"src/d2s_intrinsics.rs\"))",""],"f2s::f2d":["f2d","Real(LocalPath(\"src/f2s.rs\"))",""],"f2s_intrinsics::mul_pow5_div_pow2":["mul_pow5_div_pow2","Real(LocalPath(\"src/f2s_intrinsics.rs\"))",""],"f2s_intrinsics::mul_pow5_inv_div_pow2":["mul_pow5_inv_div_pow2","Real(LocalPath(\"src/f2s_intrinsics.rs\"))",""],"f2s_intrinsics::mul_shift_32":["mul_shift_32","Real(LocalPath(\"src/f2s_intrinsics.rs\"))",""],"f2s_intrinsics::multiple_of_power_of_2_32":["multiple_of_power_of_2_32","Real(LocalPath(\"src/f2s_intrinsics.rs\"))",""],"f2s_intrinsics::multiple_of_power_of_5_32":["multiple_of_power_of_5_32","Real(LocalPath(\"src/f2s_intrinsics.rs\"))",""],"f2s_intrinsics::pow5factor_32":["pow5factor_32","Real(LocalPath(\"src/f2s_intrinsics.rs\"))",""],"pretty::exponent::write_exponent2":["write_exponent2","Real(LocalPath(\"src/pretty/exponent.rs\"))",""],"pretty::exponent::write_exponent3":["write_exponent3","Real(LocalPath(\"src/pretty/exponent.rs\"))",""],"pretty::format32":["format32","Real(LocalPath(\"src/pretty/mod.rs\"))",""],"pretty::format64":["format64","Real(LocalPath(\"src/pretty/mod.rs\"))",""],"pretty::mantissa::write_mantissa":["write_mantissa","Real(LocalPath(\"src/pretty/mantissa.rs\"))",""],"pretty::mantissa::write_mantissa_long":["write_mantissa_long","Real(LocalPath(\"src/pretty/mantissa.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["buffer::Buffer"],"std::default::Default":["buffer::Buffer"],"std::marker::Copy":["buffer::Buffer"]},"type_to_def_path":{"buffer::Buffer":"buffer::Buffer","d2s::FloatingDecimal64":"d2s::FloatingDecimal64","f2s::FloatingDecimal32":"f2s::FloatingDecimal32"}}