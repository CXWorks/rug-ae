========================================
    use super::*;

use crate::*;
    use crate::timestamp::ClockSequence;

    struct TestClockSequence(u16);

    impl ClockSequence for TestClockSequence {
        type Output = u16;

        fn generate_sequence(&self, seconds: u64, subsec_nanos: u32) -> Self::Output {
            ((self.0 as u64 + seconds + subsec_nanos as u64) % u16::MAX as u64) as u16
        }
    }

    #[test]
    fn test_generate_sequence() {
        let test_cs = TestClockSequence(1234);

        // Basic test
        assert_eq!(
            test_cs.generate_sequence(1, 0),
            1235
        );

        // Test with subsec_nanos
        assert_eq!(
            test_cs.generate_sequence(1, 500),
            1735
        );

        // Test with wrap-around
        assert_eq!(
            test_cs.generate_sequence(u64::MAX, u32::MAX),
            ((1234 as u64 + u64::MAX + u32::MAX as u64) % u16::MAX as u64) as u16
        );
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_as_ref() {
        let uuid_bytes = [
            0x67, 0x45, 0x23, 0x01, 0xef, 0xcd, 0xab, 0x89,
            0x98, 0x76, 0x54, 0x32, 0x10, 0xfe, 0xdc, 0xba,
        ];
        let uuid = Uuid::from_bytes(uuid_bytes);
        let uuid_ref: &[u8] = uuid.as_ref();

        assert_eq!(uuid_ref, &uuid_bytes[..]);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_default() {
        let default_uuid = Uuid::default();
        let nil_uuid = Uuid::nil();
        assert_eq!(default_uuid, nil_uuid, "Default Uuid is not the nil Uuid");
    }
}
True
========================================
    use crate::fmt::Braced;
    use crate::Uuid;
    use std::borrow::Borrow;

    #[test]
    fn test_braced_borrow() {
        let uuid = Uuid::nil();
        let braced = Braced::from(uuid);
        let borrowed_uuid: &Uuid = braced.borrow();
        assert_eq!(borrowed_uuid, &uuid);
    }
}
True
========================================
    use crate::fmt::Braced;
    use crate::Uuid;
    use std::convert::AsRef;

    #[test]
    fn test_as_ref() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let braced = Braced::from_uuid(uuid);
        let uuid_ref: &Uuid = braced.as_ref();
        assert_eq!(uuid_ref, &uuid);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Braced;
    use crate::Uuid;
    use std::convert::From;

    #[test]
    fn test_braced_from_uuid() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let braced: Braced = Braced::from(uuid);
        let expected = "{550e8400-e29b-41d4-a716-446655440000}";
        assert_eq!(expected, braced.to_string());
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::borrow::Borrow;

    #[test]
    fn borrow_returns_correct_uuid() {
        let uuid = Uuid::parse_str("F4A6E058-2B4D-4A2E-9F5F-973A5E3ACAC3").unwrap();
        let hyphenated = uuid.hyphenated();
        assert_eq!(Borrow::<Uuid>::borrow(&hyphenated), &uuid);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{fmt::Hyphenated, Uuid};

    #[test]
    fn as_ref_returns_correct_uuid() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);

        assert_eq!(hyphenated.as_ref(), &uuid);
    }
}
True
========================================
    use std::convert::From;
    use crate::fmt::Hyphenated;
    use crate::Uuid;

    #[test]
    fn test_hyphenated_from_uuid() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let hyphenated: Hyphenated = Hyphenated::from(uuid);

        assert_eq!(Hyphenated::LENGTH, hyphenated.encode_lower(&mut Uuid::encode_buffer()).len());
        assert_eq!(
            "550e8400-e29b-41d4-a716-446655440000",
            hyphenated.encode_lower(&mut Uuid::encode_buffer())
        );
    }

    #[test]
    fn test_hyphenated_uppercase() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let hyphenated = Hyphenated::from(uuid);

        assert_eq!(
            "550E8400-E29B-41D4-A716-446655440000",
            hyphenated.encode_upper(&mut Uuid::encode_buffer())
        );
    }

    #[test]
    fn test_hyphenated_as_uuid() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let hyphenated = Hyphenated::from(uuid);

        assert_eq!(&uuid, hyphenated.as_uuid());
    }

    #[test]
    fn test_hyphenated_into_uuid() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let hyphenated = Hyphenated::from(uuid);

        assert_eq!(uuid, hyphenated.into_uuid());
    }
}
True
========================================
    use crate::fmt::Simple;
    use crate::Uuid;
    use std::borrow::Borrow;

    #[test]
    fn test_borrow_simple() {
        let simple = Simple::from_uuid(Uuid::nil());
        let borrowed_uuid: &Uuid = simple.borrow();
        assert_eq!(*borrowed_uuid, Uuid::nil());
    }
}
True
========================================
    use crate::fmt::Simple;
    use crate::Uuid;
    use std::convert::AsRef;

    #[test]
    fn test_as_ref_returns_correct_uuid() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let simple = Simple::from_uuid(uuid);
        let uuid_ref: &Uuid = simple.as_ref();
        assert_eq!(uuid, *uuid_ref);
    }
}
True
========================================
    use crate::fmt::Simple;
    use crate::prelude::*;
    use crate::Uuid;
    use std::str::FromStr;

    #[test]
    fn test_from_uuid_to_simple() {
        let uuid_str = "67e5504410b1426f9247bb680e5fe0c8";
        let uuid = Uuid::from_str(uuid_str).expect("Failed to parse UUID");

        let simple: Simple = uuid.into();
        let as_str = simple.to_string();

        assert_eq!(as_str, uuid_str);
    }

    #[test]
    fn test_from_uuid_to_simple_uppercase() {
        let uuid_str = "67e5504410b1426f9247bb680e5fe0c8";
        let uuid = Uuid::from_str(uuid_str).expect("Failed to parse UUID");

        let simple: Simple = uuid.into();
        let as_str = format!("{:X}", simple);

        assert_eq!(as_str, uuid_str.to_uppercase());
    }

    #[test]
    fn test_from_uuid_to_simple_default() {
        let default_uuid = Uuid::default();
        let simple: Simple = default_uuid.into();
        let as_str = simple.to_string();

        assert_eq!(as_str, "00000000000000000000000000000000");
    }

    #[test]
    fn test_from_uuid_to_simple_nil() {
        let nil_uuid = Uuid::nil();
        let simple: Simple = nil_uuid.into();
        let as_str = simple.to_string();

        assert_eq!(as_str, "00000000000000000000000000000000");
    }

    #[test]
    fn test_from_uuid_to_simple_max() {
        // `Uuid::max` is not a method. The max UUID is defined as a constant `NAMESPACE_X500`.
        // However, in the code you provided, that constant is the UUID for the X.500 namespace
        // and not the UUID consisting of all 'f's. Therefore, for the purpose of this test, I will
        // directly use a UUID consisting of all 'f's to represent the max UUID as the test seems
        // to intend this.
        let max_uuid = Uuid::from_u128(u128::MAX);
        let simple: Simple = max_uuid.into();
        let as_str = simple.to_string();

        assert_eq!(as_str, "ffffffffffffffffffffffffffffffff");
    }
}
False
========================================
    use crate::fmt::Urn;
    use crate::Uuid;
    use std::borrow::Borrow;

    #[test]
    fn test_borrow_uuid_from_urn() {
        // Create a Urn wrapper around a Uuid
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let urn = Urn::from_uuid(uuid);

        // Borrow a Uuid from Urn
        let borrowed_uuid = urn.borrow();

        // Ensure that the borrowed Uuid is the same as the original Uuid
        assert_eq!(borrowed_uuid, &uuid);
    }
}
False
========================================
    use super::*;

use crate::*;
    use std::convert::AsRef;
    use crate::fmt::Urn;
    use crate::Uuid;

    #[test]
    fn as_ref_returns_correct_uuid() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let urn = Urn::from_uuid(uuid);
        assert_eq!(AsRef::<Uuid>::as_ref(&urn), &uuid);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::From;

    #[test]
    fn test_from_uuid_to_urn() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let urn: Urn = Urn::from(uuid);
        let expected_urn_str = "urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8";
        assert_eq!(urn.to_string(), expected_urn_str);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_generate_sequence_always_zero() {
        let context = timestamp::context::NoContext;
        let sequence1 = context.generate_sequence(1_000_000, 0);
        let sequence2 = context.generate_sequence(0, 1_000_000);
        let sequence3 = context.generate_sequence(u64::MAX, u32::MAX);

        assert_eq!(sequence1, 0, "sequence should always be zero");
        assert_eq!(sequence2, 0, "sequence should always be zero");
        assert_eq!(sequence3, 0, "sequence should always be zero");
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_as_bytes() {
        let uuid_bytes: [u8; 16] = [
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
        ];
        let uuid = Uuid::from_bytes(uuid_bytes);
        assert_eq!(uuid.as_bytes(), &uuid_bytes);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;

    #[test]
    fn test_as_fields_nil_uuid() {
        let uuid = Uuid::nil();
        let (d1, d2, d3, d4) = uuid.as_fields();

        assert_eq!(d1, 0);
        assert_eq!(d2, 0);
        assert_eq!(d3, 0);
        assert_eq!(d4, &[0u8; 8]);
    }

    #[test]
    fn test_as_fields_v1_uuid() {
        let test_uuid = Uuid::from_fields(0x12345678, 0x1234, 0x1234, &[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF]);
        let expected = (0x12345678, 0x1234, 0x1234, &[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF]);
        assert_eq!(test_uuid.as_fields(), expected);
    }

    #[test]
    fn test_as_fields_v4_uuid() {
        let bytes = [
            0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
        ];
        let b = bytes.try_into().unwrap();
        let uuid = Uuid::from_bytes(b);
        let (d1, d2, d3, d4) = uuid.as_fields();

        assert_eq!(d1, 0x12345678);
        assert_eq!(d2, 0x90AB);
        assert_eq!(d3, 0xCDEF);
        assert_eq!(d4, &[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF]);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::str::FromStr;

    #[test]
    fn test_as_u128() {
        let uuid = Uuid::from_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8").unwrap();
        let expected: u128 = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8;

        assert_eq!(uuid.as_u128(), expected);
    }

    #[test]
    fn test_as_u128_nil() {
        let uuid = Uuid::nil();
        assert_eq!(uuid.as_u128(), 0);
    }

    #[test]
    fn test_as_u128_max() {
        #[cfg(uuid_unstable)]
        {
            let uuid = Uuid::max();
            assert_eq!(uuid.as_u128(), u128::MAX);
        }

        #[cfg(not(uuid_unstable))]
        {
            let uuid = Uuid::from_u128(u128::MAX);
            assert_eq!(uuid.as_u128(), u128::MAX);
        }
    }
}
True
========================================
    use crate::Uuid;

    #[test]
    fn test_as_u64_pair() {
        let uuid_str = "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8";
        let uuid = Uuid::parse_str(uuid_str).expect("Failed to parse UUID");

        let expected_high = 0xa1a2a3a4b1b2c1c2;
        let expected_low = 0xd1d2d3d4d5d6d7d8;
        let (high, low) = uuid.as_u64_pair();

        assert_eq!(high, expected_high, "High part of UUID did not match expected value");
        assert_eq!(low, expected_low, "Low part of UUID did not match expected value");
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_encode_buffer() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();

        let mut buffer = Uuid::encode_buffer();
        assert_eq!(
            uuid.simple().encode_lower(&mut buffer),
            "67e5504410b1426f9247bb680e5fe0c8"
        );

        let mut buffer = Uuid::encode_buffer();
        assert_eq!(
            uuid.hyphenated().encode_lower(&mut buffer),
            "67e55044-10b1-426f-9247-bb680e5fe0c8"
        );

        let mut buffer = Uuid::encode_buffer();
        assert_eq!(
            uuid.urn().encode_lower(&mut buffer),
            "urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8"
        );
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_get_timestamp_returns_none_for_non_v1() {
        let v4_uuid = Uuid::parse_str("936DA01F-9ABD-4D9D-80C7-02AF85C822A8").unwrap();
        assert!(v4_uuid.get_timestamp().is_none());
    }

    #[test]
    fn test_get_timestamp_returns_timestamp_for_v1() {
        // Assuming `v1::timestamp::decode_rfc4122_timestamp` and `v1::Timestamp::from_rfc4122` are correct and available, 
        // as we don't have the precise timestamp to compare due to the encoding and truncation
        let v1_uuid = Uuid::parse_str("2d255916-1c47-11ea-978f-2e728ce88125").unwrap();
        assert!(v1_uuid.get_timestamp().is_some());
    }

    #[cfg(uuid_unstable)]
    #[test]
    fn test_get_timestamp_returns_timestamp_for_v6() {
        let v6_uuid = Uuid::parse_str("1eb21a00-6eab-6a2a-8000-000000000000").unwrap();
        assert!(v6_uuid.get_timestamp().is_some());
    }

    #[cfg(uuid_unstable)]
    #[test]
    fn test_get_timestamp_returns_timestamp_for_v7() {
        let v7_uuid = Uuid::parse_str("0171696a-5fdc-7da0-8ca8-41e2c91c2e1d").unwrap();
        assert!(v7_uuid.get_timestamp().is_some());
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_variant_ncs() {
        let uuid = Uuid::from_fields(0, 0, 0, &[0, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(Variant::NCS, uuid.get_variant());
    }

    #[test]
    fn test_variant_rfc4122() {
        let uuid = Uuid::from_fields(0, 0, 0, &[0, 0, 0, 0, 0, 0, 0, 0x80]);
        assert_eq!(Variant::RFC4122, uuid.get_variant());
    }

    #[test]
    fn test_variant_microsoft() {
        let uuid = Uuid::from_fields(0, 0, 0, &[0, 0, 0, 0, 0, 0, 0, 0xC0]);
        assert_eq!(Variant::Microsoft, uuid.get_variant());
    }

    #[test]
    fn test_variant_future() {
        let uuid = Uuid::from_fields(0, 0, 0, &[0, 0, 0, 0, 0, 0, 0, 0xE0]);
        assert_eq!(Variant::Future, uuid.get_variant());
    }
}
True
========================================
    use crate::Uuid;
    use crate::Version;

    #[test]
    fn test_nil_uuid_version() {
        let nil_uuid = Uuid::nil();
        assert_eq!(nil_uuid.get_version(), Some(Version::Nil));
    }

    #[test]
    fn test_nil_uuid_version_num() {
        let nil_uuid = Uuid::nil();
        assert_eq!(nil_uuid.get_version_num(), 0);
    }

    #[test]
    fn test_v1_uuid_version() {
        let v1_uuid = Uuid::parse_str("02d81e1c-a1f4-11ec-b909-0242ac120002").unwrap();
        assert_eq!(v1_uuid.get_version(), Some(Version::Mac));
    }

    #[test]
    fn test_v2_uuid_version() {
        let v2_uuid = Uuid::parse_str("02d81e1c-a1f4-21ec-b909-0242ac120002").unwrap();
        assert_eq!(v2_uuid.get_version(), Some(Version::Dce));
    }

    #[test]
    fn test_v3_uuid_version() {
        let v3_uuid = Uuid::parse_str("02d81e1c-a1f4-31ec-b909-0242ac120002").unwrap();
        assert_eq!(v3_uuid.get_version(), Some(Version::Md5));
    }

    #[test]
    fn test_v4_uuid_version() {
        let v4_uuid = Uuid::parse_str("02d81e1c-a1f4-41ec-b909-0242ac120002").unwrap();
        assert_eq!(v4_uuid.get_version(), Some(Version::Random));
    }

    #[test]
    fn test_v5_uuid_version() {
        let v5_uuid = Uuid::parse_str("02d81e1c-a1f4-51ec-b909-0242ac120002").unwrap();
        assert_eq!(v5_uuid.get_version(), Some(Version::Sha1));
    }

    #[test]
    #[cfg(uuid_unstable)]
    fn test_v6_uuid_version() {
        let v6_uuid = Uuid::parse_str("02d81e1c-a1f4-61ec-b909-0242ac120002").unwrap();
        assert_eq!(v6_uuid.get_version(), Some(Version::SortMac));
    }

    #[test]
    #[cfg(uuid_unstable)]
    fn test_v7_uuid_version() {
        let v7_uuid = Uuid::parse_str("02d81e1c-a1f4-71ec-b909-0242ac120002").unwrap();
        assert_eq!(v7_uuid.get_version(), Some(Version::SortRand));
    }

    #[test]
    #[cfg(uuid_unstable)]
    fn test_v8_uuid_version() {
        let v8_uuid = Uuid::parse_str("02d81e1c-a1f4-81ec-b909-0242ac120002").unwrap();
        assert_eq!(v8_uuid.get_version(), Some(Version::Custom));
    }

    #[test]
    #[cfg(uuid_unstable)]
    fn test_max_uuid_version() {
        let max_uuid = Uuid::max();
        assert_eq!(max_uuid.get_version(), Some(Version::Max));
    }

    #[test]
    fn test_unrecognized_uuid_version() {
        let unrecognized_uuid = Uuid::parse_str("ffffffff-ffff-4fff-bfff-ffffffffffff").unwrap();
        assert_eq!(unrecognized_uuid.get_version(), None);
    }

    #[test]
    fn test_uuid_version_num() {
        let v3_uuid = Uuid::parse_str("02d81e1c-a1f4-31ec-b909-0242ac120002").unwrap();
        assert_eq!(v3_uuid.get_version_num(), 3);
    }

    #[test]
    fn test_uuid_version_num_unrecognized() {
        let unrecognized_uuid = Uuid::parse_str("ffffffff-ffff-4fff-bfff-ffffffffffff").unwrap();
        assert_eq!(unrecognized_uuid.get_version_num(), 4);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_get_version_num() -> Result<(), crate::Error> {
        let uuid_v1 = Uuid::parse_str("550e8400-e29b-11d4-a716-446655440000")?;
        let uuid_v2 = Uuid::parse_str("6b1e2ffd-6e05-2db9-aacb-0002b3bf3b3b")?;
        let uuid_v3 = Uuid::parse_str("ad61b8e0-8d2d-3822-9d9c-000497c6e2c4")?;
        let uuid_v4 = Uuid::parse_str("896d8a4a-4b07-4a2b-9fea-0001a3d39e1d")?;
        let uuid_v5 = Uuid::parse_str("c2419d6a-7a7b-558f-8d8e-000b2b97bd9b")?;
        let uuid_nil = Uuid::nil();

        assert_eq!(1, uuid_v1.get_version_num());
        assert_eq!(2, uuid_v2.get_version_num());
        assert_eq!(3, uuid_v3.get_version_num());
        assert_eq!(4, uuid_v4.get_version_num());
        assert_eq!(5, uuid_v5.get_version_num());
        assert_eq!(0, uuid_nil.get_version_num());

        Ok(())
    }
}
True
========================================
    use crate::Uuid;

    #[test]
    fn test_into_bytes() {
        let bytes = [
            0x12, 0x34, 0x56, 0x78, // -
            0x90, 0xAB, // -
            0xCD, 0xEF, // -
            0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE,
        ];

        let uuid = Uuid::from_bytes(bytes);
        assert_eq!(uuid.into_bytes(), bytes);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_is_nil_for_nil_uuid() {
        let nil_uuid = Uuid::nil();
        assert!(nil_uuid.is_nil());
    }

    #[test]
    fn test_is_nil_for_non_nil_uuid() {
        let uuid = Uuid::parse_str("936DA01F-9ABD-4D9D-80C7-02AF85C822A8").unwrap();
        assert!(!uuid.is_nil());
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_to_bytes_le() {
        let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8").unwrap();
        assert_eq!(
            uuid.to_bytes_le(),
            [
                0xa4, 0xa3, 0xa2, 0xa1, 0xb2, 0xb1, 0xc2, 0xc1, 
                0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8
            ]
        );

        let uuid_nil = Uuid::nil();
        assert_eq!(
            uuid_nil.to_bytes_le(),
            [0; 16]
        );

        let uuid_max = Uuid::from_slice(&[0xff; 16]).unwrap();
        assert_eq!(
            uuid_max.to_bytes_le(),
            [
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
            ]
        );
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::convert::TryInto;

    #[test]
    fn test_to_fields_le() -> Result<(), crate::Error> {
        let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8")?;
        let (d1, d2, d3, d4) = uuid.to_fields_le();

        assert_eq!(d1, 0xa4a3a2a1);
        assert_eq!(d2, 0xb2b1);
        assert_eq!(d3, 0xc2c1);
        assert_eq!(
            d4,
            &[0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8].as_ref()
        );

        Ok(())
    }
}
True
========================================
#[cfg(test)]
mod test {
    use super::*;

use crate::*;
    use std::str::FromStr;

    #[test]
    fn test_to_u128_le() {
        // UUID in simple format
        let uuid = Uuid::from_str("a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8").unwrap();
        assert_eq!(uuid.to_u128_le(), 0xd8d7d6d5d4d3d2d1c2c1b2b1a4a3a2a1);

        // UUID in hyphenated format
        let uuid = Uuid::from_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8").unwrap();
        assert_eq!(uuid.to_u128_le(), 0xd8d7d6d5d4d3d2d1c2c1b2b1a4a3a2a1);

        // Nil UUID
        let uuid = Uuid::nil();
        assert_eq!(uuid.to_u128_le(), 0);

        // Max UUID
        #[cfg(uuid_unstable)]
        {
            let uuid = Uuid::max();
            assert_eq!(uuid.to_u128_le(), 0xffffffffffffffffffffffffffffffff);
        }

        // Tests with values ensuring each byte is correctly flipped
        let uuid = Uuid::from_fields(0x12345678, 0x1234, 0x1234, &[0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0]);
        assert_eq!(uuid.to_u128_le(), 0xf0debc9a785634127834125678563412);

        let uuid = Uuid::from_fields_le(0x12345678, 0x1234, 0x1234, &[0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0]);
        assert_eq!(uuid.to_u128_le(), 0xf0debc9a785634127834125678123456);
    }
}
True
========================================
    use crate::Uuid;

    #[test]
    fn test_from_bytes() {
        let bytes = [
            0xa1, 0xa2, 0xa3, 0xa4,
            0xb1, 0xb2,
            0xc1, 0xc2,
            0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        ];

        let uuid = Uuid::from_bytes(bytes);

        let uuid_string = uuid.hyphenated().to_string();
        assert_eq!("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8", uuid_string);
    }

    #[test]
    fn test_from_bytes_round_trip() {
        let bytes = [
            0xa1, 0xa2, 0xa3, 0xa4,
            0xb1, 0xb2,
            0xc1, 0xc2,
            0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        ];

        let uuid = Uuid::from_bytes(bytes);
        let uuid_bytes = uuid.into_bytes();

        assert_eq!(bytes, uuid_bytes);
    }
}
True
========================================
    use crate::Uuid;

    #[test]
    fn test_from_bytes_le() {
        let bytes = [
            0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        ];

        let uuid = Uuid::from_bytes_le(bytes);
        assert_eq!(
            uuid.to_string(),
            "a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8"
        );
    }
}
True
========================================
    use crate::{builder::Bytes, Uuid};

    #[test]
    fn test_from_bytes_ref() {
        let bytes: Bytes = [
            0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        ];
        let uuid_ref = Uuid::from_bytes_ref(&bytes);
        let uuid = Uuid::from_bytes(bytes);
        let uuid_expected_str = "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8";
        
        assert_eq!(*uuid_ref, uuid, "The reference UUID does not match the one created from bytes directly");
        assert_eq!(uuid_ref.as_hyphenated().to_string(), uuid_expected_str, "The UUID string does not match the expected hyphenated format");
        assert_eq!(uuid_ref as *const Uuid as *const u8, &bytes as *const Bytes as *const u8, "The UUID and bytes do not point to the same address");
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_fields() {
        let d1 = 0x12345678;
        let d2 = 0x1234;
        let d3 = 0x1234;
        let d4 = [0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF];

        let uuid = Uuid::from_fields(d1, d2, d3, &d4);

        assert_eq!(
            uuid.hyphenated().to_string(),
            "12345678-1234-1234-1234-567890abcdef"
        );
    }
}
True
========================================
    use crate::Uuid;

    #[test]
    fn test_from_fields_le() {
        let d1 = 0x12345678;
        let d2 = 0x1234;
        let d3 = 0x5678;
        let d4 = [
            0x90, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
        ];

        let uuid = Uuid::from_fields_le(d1, d2, d3, &d4);

        assert_eq!(uuid.as_fields(), (
            0x78563412,
            0x3412,
            0x7856,
            &d4,
        ));

        assert_eq!(uuid.to_string(), "78563412-3412-7856-90ab-cdef01234567");
    }
}
True
========================================
    use crate::Uuid;
    use crate::Error;
    use crate::builder::ErrorKind;

    #[test]
    fn test_from_slice_valid_length() {
        let bytes = [
            0x01, 0x23, 0x45, 0x67,
            0x89, 0xAB, 
            0xCD, 0xEF, 
            0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
        ];

        assert!(Uuid::from_slice(&bytes).is_ok());
    }

    #[test]
    fn test_from_slice_exact_result() {
        let bytes = [
            0x01, 0x23, 0x45, 0x67,
            0x89, 0xAB, 
            0xCD, 0xEF, 
            0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
        ];

        let uuid = Uuid::from_slice(&bytes).unwrap();

        assert_eq!(
            uuid.hyphenated().to_string(),
            "01234567-89ab-cdef-0123-456789abcdef"
        );
    }

    #[test]
    fn test_from_slice_invalid_length_short() {
        let bytes = [0; 15]; // only 15 bytes
        let result = Uuid::from_slice(&bytes);
        assert!(result.is_err());
        assert!(matches!(result, Err(Error::ByteLength { len: 15 })));
    }

    #[test]
    fn test_from_slice_invalid_length_long() {
        let bytes = [0; 17]; // 17 bytes
        let result = Uuid::from_slice(&bytes);
        assert!(result.is_err());
        assert!(matches!(result, Err(Error::ByteLength { len: 17 })));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::error::ErrorKind::ByteLength;

    #[test]
    fn test_from_slice_le_correct_length() {
        let bytes = [
            0xa1, 0xa2, 0xa3, 0xa4,
            0xb1, 0xb2,
            0xc1, 0xc2,
            0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        ];
        let result = Uuid::from_slice_le(&bytes);
        assert!(result.is_ok());
        let uuid = result.unwrap();
        assert_eq!(
            uuid.hyphenated().to_string(),
            "a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8"
        );
    }

    #[test]
    fn test_from_slice_le_incorrect_length() {
        let bytes = [
            0xa1, 0xa2, 0xa3, 0xa4,
            0xb1, 0xb2,
            0xc1, 0xc2,
            0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, // 14 bytes, not 16
        ];
        let result = Uuid::from_slice_le(&bytes);
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert!(matches!(error, Error(ByteLength { len: 14 })));
    }
}
True
========================================
    use crate::Uuid;

    #[test]
    fn test_from_u128() {
        let uuid_val: u128 = 0x1234567890abcdef1234567890abcdef;
        let uuid = Uuid::from_u128(uuid_val);
        assert_eq!(
            uuid.hyphenated().to_string(),
            "12345678-90ab-cdef-1234-567890abcdef"
        );

        let uuid_val: u128 = 0;
        let uuid = Uuid::from_u128(uuid_val);
        assert!(uuid.is_nil());

        #[cfg(uuid_unstable)]
        {
            let uuid_val: u128 = u128::MAX;
            let uuid = Uuid::from_u128(uuid_val);
            assert!(uuid.is_max());
        }
    }

    #[test]
    fn test_from_u128_le() {
        let uuid_val: u128 = 0x1234567890abcdef1234567890abcdef;
        let uuid = Uuid::from_u128_le(uuid_val);
        assert_eq!(
            uuid.hyphenated().to_string(),
            "efcdab9078563412efcdab9078563412"
        );

        let uuid_val: u128 = 0;
        let uuid = Uuid::from_u128_le(uuid_val);
        assert!(uuid.is_nil());

        #[cfg(uuid_unstable)]
        {
            let uuid_val: u128 = u128::MAX;
            let uuid = Uuid::from_u128_le(uuid_val);
            assert!(uuid.is_max());
        }
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_u128_le() {
        let input = 0x1234567890abcdef1234567890abcdefu128;
        let expected = Uuid::from_u128(0xefcdab9078563412efcdab9078563412u128);
        let result = Uuid::from_u128_le(input);
        assert_eq!(result, expected, 
            "from_u128_le should convert a 128-bit u128 integer in little-endian to a Uuid by flipping its bytes");
    }

    #[test]
    fn test_from_u128_le_zero() {
        let input = 0u128;
        let expected = Uuid::nil();
        let result = Uuid::from_u128_le(input);
        assert_eq!(result, expected, 
            "from_u128_le should convert a 128-bit u128 zero integer to a nil Uuid");
    }

    #[test]
    fn test_from_u128_le_max() {
        let input = u128::MAX;
        let expected = Uuid::from_u128(u128::MAX);
        let result = Uuid::from_u128_le(input);
        assert_eq!(result, expected, 
            "from_u128_le should convert a 128-bit u128 max integer to max Uuid by flipping its bytes");
    }

    #[test]
    fn test_from_u128_le_endianness() {
        let bytes = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 
            0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF
        ];
        let input = u128::from_le_bytes(bytes);
        let expected = Uuid::from_bytes(bytes);
        let result = Uuid::from_u128_le(input);
        assert_eq!(result, expected,
            "from_u128_le should properly handle endianness");
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_u64_pair() {
        let high = 0xa1a2a3a4b1b2c1c2u64;
        let low = 0xd1d2d3d4d5d6d7d8u64;
        let expected = "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8";

        let uuid = Uuid::from_u64_pair(high, low);
        assert_eq!(expected, uuid.to_string());
    }

    #[test]
    fn test_from_u64_pair_zero() {
        let high = 0u64;
        let low = 0u64;
        let expected = "00000000-0000-0000-0000-000000000000";

        let uuid = Uuid::from_u64_pair(high, low);
        assert_eq!(expected, uuid.to_string());
    }

    #[test]
    fn test_from_u64_pair_max() {
        let high = u64::MAX;
        let low = u64::MAX;
        let expected = "ffffffff-ffff-ffff-ffff-ffffffffffff";

        let uuid = Uuid::from_u64_pair(high, low);
        assert_eq!(expected, uuid.to_string());
    }

    #[test]
    fn test_from_u64_pair_endianess() {
        let high = 0x0011223344556677u64;
        let low = 0x8899aabbccddeeffu64;
        let expected = "00112233-4455-6677-8899-aabbccddeeff";

        let uuid = Uuid::from_u64_pair(high, low);
        assert_eq!(expected, uuid.to_string());
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_nil_uuid() {
        let nil_uuid = Uuid::nil();
        assert_eq!(nil_uuid.to_string(), "00000000-0000-0000-0000-000000000000");
        assert!(nil_uuid.is_nil());
        assert_eq!(nil_uuid.as_bytes(), &[0; 16]);
        assert_eq!(nil_uuid.as_u128(), 0);
        assert_eq!(nil_uuid.as_u64_pair(), (0, 0));
        assert_eq!(nil_uuid.get_version(), Some(Version::Nil));
        assert_eq!(nil_uuid.get_variant(), Variant::RFC4122);
    }

    #[test]
    fn test_nil_uuid_is_default() {
        let default_uuid = Uuid::default();
        assert_eq!(default_uuid.to_string(), "00000000-0000-0000-0000-000000000000");
        assert!(default_uuid.is_nil());
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::builder::Builder;
    use crate::Uuid;

    #[test]
    fn test_as_uuid_returns_correct_uuid() {
        let bytes = [
            0x12, 0x23, 0x34, 0x45,
            0x56, 0x67,
            0x78, 0x89,
            0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0, 0x01,
        ];
        let builder = Builder::from_bytes(bytes);
        let uuid = builder.as_uuid();
        let expected_uuid = Uuid::from_bytes(bytes);

        assert_eq!(uuid, &expected_uuid);
    }

    #[test]
    fn test_as_uuid_returns_consistent_references() {
        let builder = Builder::nil();
        let uuid1 = builder.as_uuid();
        let uuid2 = builder.as_uuid();
        
        assert_eq!(uuid1, uuid2);
        assert!(std::ptr::eq(uuid1, uuid2), "References should point to the same Uuid");
    }
}
True
========================================
    use crate::Builder;

    #[test]
    fn test_from_bytes() {
        // Test input
        let bytes = [
            0xa1, 0xa2, 0xa3, 0xa4,
            0xb1, 0xb2,
            0xc1, 0xc2,
            0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        ];

        // Expected output
        let expected = "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8";

        // Perform test
        let builder = Builder::from_bytes(bytes);
        let uuid = builder.into_uuid();
        assert_eq!(expected, uuid.hyphenated().to_string());
    }
}
True
========================================
    use crate::Builder;
    use crate::Bytes;

    #[test]
    fn test_builder_from_bytes_le() {
        let bytes: Bytes = [
            0x10, 0x94, 0x01, 0x2A, 0x0B, 0xED, 0x11, 0x5F,
            0x85, 0x23, 0x27, 0xFC, 0x15, 0x6B, 0x5C, 0x5F,
        ];

        let builder = Builder::from_bytes_le(bytes);
        let uuid = builder.into_uuid();

        assert_eq!(
            uuid.hyphenated().to_string(),
            "2a019410-ed0b-5f11-8523-27fc156b5c5f"
        );
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_fields() {
        let d1 = 0xa1a2a3a4;
        let d2 = 0xb1b2;
        let d3 = 0xc1c2;
        let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];

        let builder = Builder::from_fields(d1, d2, d3, &d4);
        let uuid = builder.into_uuid();

        assert_eq!(uuid.as_fields(), (d1, d2, d3, &d4));
        assert_eq!(
            uuid.hyphenated().to_string(),
            "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8"
        );
    }
}
True
========================================
    use crate::builder::Builder;
    use crate::Uuid;

    #[test]
    fn test_from_fields_le() {
        let d1 = 0x12345678;
        let d2 = 0x1234;
        let d3 = 0x1234;
        let d4 = [0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF];

        let builder = Builder::from_fields_le(d1, d2, d3, &d4);
        let uuid = builder.into_uuid();

        assert_eq!(
            uuid.as_fields(),
            (0x78563412, 0x3412, 0x3412, &[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF])
        );
        assert_eq!(
            uuid.to_string(),
            "78563412-3412-3412-1234-567890abcdef"
        );
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_md5_bytes() {
        let md5_bytes: crate::Bytes = [
            0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04,
            0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e,
        ];
        let md5_builder = Builder::from_md5_bytes(md5_bytes);
        let uuid = md5_builder.into_uuid();

        assert_eq!(uuid.get_version(), Some(crate::Version::Md5));
        assert_eq!(uuid.get_variant(), crate::Variant::RFC4122);
        assert_eq!(
            uuid.as_bytes(),
            &[
                0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04,
                0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e,
            ]
        );
    }
}
True
========================================
    use crate::Builder;
    use crate::{Bytes, Variant, Version};

    #[test]
    fn test_builder_from_random_bytes() {
        let random_bytes: Bytes = [
            70, 235, 208, 238, 14, 109, 67, 201, 185, 13, 204, 195, 90, 145, 63, 62,
        ];

        let builder = Builder::from_random_bytes(random_bytes);
        let uuid = builder.into_uuid();

        assert_eq!(uuid.get_version(), Some(Version::Random));
        assert_eq!(uuid.get_variant(), Variant::RFC4122);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::builder::Builder;

    #[test]
    fn test_from_rfc4122_timestamp() {
        let ticks = 0x1234_5678_9ABC_DEF0;
        let counter = 0x1234;
        let node_id = [0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF];

        let builder = Builder::from_rfc4122_timestamp(ticks, counter, &node_id);
        let uuid = builder.into_uuid();

        let expected_bytes = [
            0x67, 0x89, 0xAB, 0xCD, // time_low
            0xEF, 0xF0,             // time_mid
            0x11, 0x34,             // time_high_and_version
            0x92, 0x34,             // clk_seq_and_variant
            0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, // node
        ];

        assert_eq!(uuid.as_bytes(), &expected_bytes, "UUID bytes do not match expected RFC 4122 encoding");

        let uuid_variant = uuid.get_variant();
        assert_eq!(uuid_variant, Variant::RFC4122, "UUID variant is not RFC4122");

        let uuid_version = uuid.get_version();
        assert_eq!(uuid_version, Some(Version::Mac), "UUID version is not MAC (Version 1)");
    }
}
True
========================================
    // Use the crate root to locate and import necessary items.
    use crate::{Builder, Bytes, Variant, Version};

    #[test]
    fn test_from_sha1_bytes() {
        // Use the precise correct size for the Bytes array (16 bytes).
        let sha1_bytes: Bytes = [
            0x5a, 0xfa, 0x7a, 0xb9, 0x5b, 0xef, 0x9a, 0xa2,
            0x1d, 0xf5, 0x9a, 0xf7, 0xca, 0xfa, 0x78, 0xf5,
        ];
        let builder = Builder::from_sha1_bytes(sha1_bytes);
        let uuid = builder.into_uuid();

        // Validate the created UUID has the correct version and variant.
        assert_eq!(uuid.get_version(), Some(Version::Sha1));
        assert_eq!(uuid.get_variant(), Variant::RFC4122);

        // Ensure the UUID bytes match the provided SHA1 bytes.
        assert_eq!(uuid.as_bytes(), &sha1_bytes);
    }
}
True
========================================
    use crate::builder::Builder; // Adjust the import path according to the location of your tests
    use crate::Error; // You might need to add 'uuid' to your dependencies in Cargo.toml
    use crate::fmt::Hyphenated; // Ensure 'Hyphenated' formatter is accessible
    use crate::std::string::ToString; // For `.to_string()`
    use crate::Uuid;

    #[test]
    fn test_builder_from_slice_with_correct_length() -> Result<(), Error> {
        let bytes = [
            0xa1, 0xa2, 0xa3, 0xa4,
            0xb1, 0xb2,
            0xc1, 0xc2,
            0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        ];

        let builder = Builder::from_slice(&bytes)?;
        let uuid = builder.into_uuid();

        assert_eq!(
            Uuid::from_slice(&bytes)?.to_hyphenated().to_string(),
            uuid.to_hyphenated().to_string(),
        );
        Ok(())
    }

    #[test]
    fn test_builder_from_slice_with_incorrect_length() {
        let bytes = [
            0xa1, 0xa2,
        ];

        assert!(Builder::from_slice(&bytes).is_err());
    }
}
False
========================================
  use crate::builder::Builder;
  use crate::Error;

  #[test]
  fn test_builder_from_slice_le_correct_length() -> Result<(), Error> {
      let bytes = [
          0xa1, 0xa2, 0xa3, 0xa4,
          0xb1, 0xb2,
          0xc1, 0xc2,
          0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
      ];

      let builder = Builder::from_slice_le(&bytes)?;
      let uuid = builder.into_uuid();

      assert_eq!(
          "a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8",
          uuid.hyphenated().to_string(),
      );
      Ok(())
  }

  #[test]
  fn test_builder_from_slice_le_incorrect_length() {
      let bytes = [
          0xa1, 0xa2, 0xa3, 0xa4,
          0xb1, 0xb2,
          0xc1, 0xc2,
          0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, // missing one byte
      ];

      assert!(Builder::from_slice_le(&bytes).is_err());
  }
}
True
========================================
    use super::*;

use crate::*;
    use crate::builder::Builder;
    use crate::Uuid;

    #[test]
    fn test_builder_from_u128() {
        let input: u128 = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8;
        let builder = Builder::from_u128(input);
        let uuid = builder.into_uuid();
        assert_eq!(
            uuid.hyphenated().to_string(),
            "a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8"
        );
    }
}
True
========================================
    use crate::builder::Builder;
    use crate::Uuid;

    #[test]
    fn test_from_u128_le() {
        let test_cast_values: [(u128, &str); 3] = [
            (
                0x0102030405060708090a0b0c0d0e0f10u128,
                "100f0e0d-0c0b-0a09-0807-060504030201",
            ),
            (
                0x112233445566778899aabbccddeeffffu128,
                "ffeeddcb-ccba-a998-8877-665544332211",
            ),
            (
                0xffffffffffffffffffffffffffffffffu128,
                "ffffffff-ffff-ffff-ffff-ffffffffffff",
            ),
        ];

        for (input, expected) in test_cast_values {
            let uuid = Builder::from_u128_le(input).into_uuid();
            let uuid_string = uuid.hyphenated().to_string();
            assert_eq!(uuid_string, expected);
        }
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_into_uuid_nil() {
        let builder = Builder::nil();
        let uuid = builder.into_uuid();
        assert_eq!(uuid, Uuid::nil());
    }

    #[test]
    fn test_into_uuid_from_bytes() {
        let bytes = [
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
        ];
        let builder = Builder::from_bytes(bytes);
        let uuid = builder.into_uuid();
        assert_eq!(uuid, Uuid::from_bytes(bytes));
    }

    #[test]
    fn test_into_uuid_with_variant() {
        let builder = Builder::nil().with_variant(Variant::Microsoft);
        let uuid = builder.into_uuid();
        assert_eq!(uuid.get_variant(), Variant::Microsoft);
    }

    #[test]
    fn test_into_uuid_with_version() {
        let builder = Builder::nil().with_version(Version::Md5);
        let uuid = builder.into_uuid();
        assert_eq!(uuid.get_version(), Some(Version::Md5));
    }

    #[test]
    fn test_into_uuid_from_fields() {
        let d1 = 0x12345678;
        let d2 = 0x90ab;
        let d3 = 0xcdef;
        let d4 = [0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef];

        let builder = Builder::from_fields(d1, d2, d3, &d4);
        let uuid = builder.into_uuid();
        assert_eq!(uuid, Uuid::from_fields(d1, d2, d3, &d4));
    }
}
True
========================================
    use crate::Builder;

    #[test]
    fn test_builder_nil() {
        let builder = Builder::nil();
        let uuid = builder.into_uuid();
        assert_eq!(uuid.to_string(), "00000000-0000-0000-0000-000000000000");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{builder::Builder, Variant, Version};

    #[test]
    fn test_builder_set_variant() {
        let mut builder = Builder::nil();
        builder.set_variant(Variant::RFC4122);
        let uuid = builder.into_uuid();
        assert_eq!(uuid.get_variant(), Variant::RFC4122);
    }
}
True
========================================
    use super::*;

use crate::*;

    use crate::{Builder, Version};

    #[test]
    fn test_set_version() {
        let mut builder = Builder::nil();
        builder.set_version(Version::Random);
        let uuid = builder.into_uuid();
        assert_eq!(uuid.get_version(), Some(Version::Random));
    }
}
True
========================================
    use crate::{Builder, Variant, Uuid};

    #[test]
    fn test_with_variant() {
        // Create a Uuid with known bytes
        let mut bytes: [u8; 16] = [0; 16];
        bytes[8] = 0b1011_1010; // Set the 8th byte to a known value

        // Test with_variant for NCS
        let mut builder = Builder::from_bytes(bytes);
        let uuid = builder.with_variant(Variant::NCS).into_uuid();
        assert_eq!(uuid.as_bytes()[8] & 0b1000_0000, 0b0000_0000, "NCS variant did not match");

        // Test with_variant for RFC4122
        builder = Builder::from_bytes(bytes);
        let uuid = builder.with_variant(Variant::RFC4122).into_uuid();
        assert_eq!(uuid.as_bytes()[8] & 0b1100_0000, 0b1000_0000, "RFC4122 variant did not match");

        // Test with_variant for Microsoft
        builder = Builder::from_bytes(bytes);
        let uuid = builder.with_variant(Variant::Microsoft).into_uuid();
        assert_eq!(uuid.as_bytes()[8] & 0b1110_0000, 0b1100_0000, "Microsoft variant did not match");

        // Test with_variant for Future
        builder = Builder::from_bytes(bytes);
        let uuid = builder.with_variant(Variant::Future).into_uuid();
        assert_eq!(uuid.as_bytes()[8] & 0b1110_0000, 0b1110_0000, "Future variant did not match");
    }
}
True
========================================
    use crate::{builder::Builder, Version, Variant};

    #[test]
    fn test_with_version() {
        let uuid_bytes = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];

        let builder_v1 = Builder::from_bytes(uuid_bytes).with_version(Version::Mac).with_variant(Variant::RFC4122);
        let uuid_v1 = builder_v1.into_uuid();

        let builder_v3 = Builder::from_bytes(uuid_bytes).with_version(Version::Md5).with_variant(Variant::RFC4122);
        let uuid_v3 = builder_v3.into_uuid();

        let builder_v4 = Builder::from_bytes(uuid_bytes).with_version(Version::Random).with_variant(Variant::RFC4122);
        let uuid_v4 = builder_v4.into_uuid();

        let builder_v5 = Builder::from_bytes(uuid_bytes).with_version(Version::Sha1).with_variant(Variant::RFC4122);
        let uuid_v5 = builder_v5.into_uuid();

        assert!(matches!(uuid_v1.get_version(), Some(Version::Mac)));
        assert!(matches!(uuid_v3.get_version(), Some(Version::Md5)));
        assert!(matches!(uuid_v4.get_version(), Some(Version::Random)));
        assert!(matches!(uuid_v5.get_version(), Some(Version::Sha1)));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_into_err_invalid_utf8() {
        let invalid_utf8 = b"\xff\xff";
        let invalid = InvalidUuid(invalid_utf8);
        assert_eq!(invalid.into_err(), Error(ErrorKind::InvalidUTF8));
    }

    #[test]
    fn test_into_err_invalid_character() {
        let invalid_character = "1234567890abcdef1234567890abcdeg".as_bytes();
        let invalid = InvalidUuid(invalid_character);
        assert_eq!(
            invalid.into_err(),
            Error(ErrorKind::Char {
                character: 'g',
                index: 33,
            })
        );
    }

    #[test]
    fn test_into_err_invalid_simple_length() {
        let invalid_length = "1234567890abcdef12345".as_bytes();
        let invalid = InvalidUuid(invalid_length);
        assert_eq!(
            invalid.into_err(),
            Error(ErrorKind::SimpleLength {
                len: 21,
            })
        );
    }

    #[test]
    fn test_into_err_hyphenated_group_count() {
        let invalid_group_count = "12345678-1234-1234-1234-1234567890123".as_bytes();
        let invalid = InvalidUuid(invalid_group_count);
        assert_eq!(
            invalid.into_err(),
            Error(ErrorKind::GroupCount {
                count: 4,
            })
        );
    }

    #[test]
    fn test_into_err_group_length() {
        let invalid_group_length = "12345678-1234-1234-123-123456789012".as_bytes();
        let invalid = InvalidUuid(invalid_group_length);
        assert_eq!(
            invalid.into_err(),
            Error(ErrorKind::GroupLength {
                group: 3,
                len: 3,
                index: 20,
            })
        );
    }

    #[test]
    fn test_into_err_last_group_too_long() {
        let invalid_last_group_length = "12345678-1234-1234-1234-1234567890123".as_bytes();
        let invalid = InvalidUuid(invalid_last_group_length);
        assert_eq!(
            invalid.into_err(),
            Error(ErrorKind::GroupLength {
                group: 4,
                len: 13,
                index: 25,
            })
        );
    }
}
True
========================================
#[cfg(test)]
mod as_braced_tests {
    use super::*;

use crate::*;
    use crate::fmt::Braced;
    use crate::Uuid;
    use std::str::FromStr;

    #[test]
    fn as_braced_returns_braced_formatter() {
        let uuid = Uuid::from_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let braced = uuid.as_braced();
        let expected = Braced::from_uuid(uuid);
        assert_eq!(*braced, expected);
    }

    #[test]
    fn as_braced_formatter_to_string_matches_braced_output() {
        let uuid = Uuid::from_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let braced = uuid.as_braced();
        let braced_string = braced.to_string();
        let expected = "{550e8400-e29b-41d4-a716-446655440000}";
        assert_eq!(braced_string, expected);
    }

    #[test]
    fn as_braced_references_same_uuid() {
        let uuid = Uuid::from_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let braced = uuid.as_braced();
        assert!(std::ptr::eq(braced.as_uuid(), &uuid));
    }
}
True
========================================
    use crate::fmt::Hyphenated;
    use crate::Uuid;

    #[test]
    fn test_as_hyphenated() {
        let uuid = Uuid::parse_str("a1a2a3a4a5a6a7a8a9a0b1b2b3b4b5b6").unwrap();
        let hyphenated = uuid.as_hyphenated();
        let expected_str = "a1a2a3a4-a5a6-a7a8-a9a0-b1b2b3b4b5b6";
        
        assert_eq!(hyphenated.to_string(), expected_str);
        assert_eq!(hyphenated.as_uuid(), &uuid);
        assert_eq!(*Hyphenated::from_uuid(uuid), uuid);
        
        let mut buffer = Uuid::encode_buffer();
        let encoded = hyphenated.encode_lower(&mut buffer);
        assert_eq!(encoded, expected_str.to_lowercase());
        
        let encoded_upper = hyphenated.encode_upper(&mut buffer);
        assert_eq!(encoded_upper, expected_str.to_uppercase());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::{
        fmt::{Braced, Hyphenated, Simple, Urn},
        Bytes, Uuid, Version,
    };

    // A simple consistency test to ensure the `as_simple` method returns
    // a `Simple` formatter that represents the same UUID.
    #[test]
    fn test_as_simple() {
        let uuid = Uuid::parse_str("936DA01F9ABD4D9D80C702AF85C822A8").unwrap();
        let simple_formatter = uuid.as_simple();
        let uuid_from_simple = simple_formatter.as_uuid();
        assert_eq!(&uuid, uuid_from_simple);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Urn;
    use crate::Uuid;

    #[test]
    fn test_as_urn() {
        let uuid = Uuid::nil();
        let urn = uuid.as_urn();
        assert_eq!(urn.to_string(), "urn:uuid:00000000-0000-0000-0000-000000000000");

        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let urn = uuid.as_urn();
        assert_eq!(urn.to_string(), "urn:uuid:550e8400-e29b-41d4-a716-446655440000");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Braced;
    use crate::Uuid;

    #[test]
    fn test_braced() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let braced = uuid.braced();
        assert_eq!(*braced.as_uuid(), uuid);

        let expected_str = "{67e55044-10b1-426f-9247-bb680e5fe0c8}";
        assert_eq!(braced.to_string(), expected_str);

        let mut buffer = Uuid::encode_buffer();
        assert_eq!(braced.encode_lower(&mut buffer).as_mut(), expected_str.to_lowercase().as_str());
        assert_eq!(braced.encode_upper(&mut buffer).as_mut(), expected_str.to_uppercase().as_str());
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_hyphenated() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let hyphenated = uuid.hyphenated();
        let hyphenated_str = hyphenated.to_string();

        assert_eq!(hyphenated_str, "550e8400-e29b-41d4-a716-446655440000");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Simple;
    use crate::Uuid;

    #[test]
    fn test_simple_formatter() {
        let uuid = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let simple = uuid.simple();
        assert_eq!(Simple::from_uuid(uuid), simple);
        assert_eq!(Simple::LENGTH, 32);
        assert_eq!(format!("{}", simple), "67e5504410b1426f9247bb680e5fe0c8");
        assert_eq!(format!("{:X}", simple), "67E5504410B1426F9247BB680E5FE0C8");
        assert_eq!(format!("{:x}", simple), "67e5504410b1426f9247bb680e5fe0c8");
        assert_eq!(simple.encode_lower(&mut Uuid::encode_buffer()), "67e5504410b1426f9247bb680e5fe0c8");
        assert_eq!(simple.encode_upper(&mut Uuid::encode_buffer()), "67E5504410B1426F9247BB680E5FE0C8");
        assert_eq!(simple.as_uuid(), &uuid);
        assert_eq!(simple.into_uuid(), uuid);
    }

    #[test]
    fn test_simple_formatter_length() {
        assert_eq!(Simple::LENGTH, 32);
    }

    #[test]
    fn test_simple_formatter_encode_lower() {
        let uuid = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let simple = uuid.simple();
        let mut buffer = Uuid::encode_buffer();
        assert_eq!(simple.encode_lower(&mut buffer), "67e5504410b1426f9247bb680e5fe0c8");
    }

    #[test]
    fn test_simple_formatter_encode_upper() {
        let uuid = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let simple = uuid.simple();
        let mut buffer = Uuid::encode_buffer();
        assert_eq!(simple.encode_upper(&mut buffer), "67E5504410B1426F9247BB680E5FE0C8");
    }

    #[test]
    fn test_simple_from_and_into_uuid() {
        let uuid = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let simple = Simple::from_uuid(uuid);
        assert_eq!(simple.into_uuid(), uuid);
    }

    #[test]
    fn test_simple_as_uuid() {
        let uuid = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let simple = Simple::from_uuid(uuid);
        assert_eq!(simple.as_uuid(), &uuid);
    }

    #[test]
    fn test_simple_display() {
        let uuid = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let simple = Simple::from_uuid(uuid);
        assert_eq!(format!("{}", simple), "67e5504410b1426f9247bb680e5fe0c8");
    }

    #[test]
    fn test_simple_lower_hex() {
        let uuid = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let simple = Simple::from_uuid(uuid);
        assert_eq!(format!("{:x}", simple), "67e5504410b1426f9247bb680e5fe0c8");
    }

    #[test]
    fn test_simple_upper_hex() {
        let uuid = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let simple = Simple::from_uuid(uuid);
        assert_eq!(format!("{:X}", simple), "67E5504410B1426F9247BB680E5FE0C8");
    }
}
True
========================================
    use crate::fmt::Urn;
    use crate::Uuid;
    use std::str::FromStr;

    #[test]
    fn test_urn_formatting() {
        let uuid_str = "550e8400-e29b-41d4-a716-446655440000";
        let uuid = Uuid::from_str(uuid_str).unwrap();
        let urn = uuid.urn();
        let expected_urn_str = "urn:uuid:550e8400-e29b-41d4-a716-446655440000";
        assert_eq!(urn.to_string(), expected_urn_str);
    }

    #[test]
    fn test_urn_from_uuid() {
        let uuid = Uuid::nil();
        let urn = Urn::from_uuid(uuid);
        let expected_urn_str = "urn:uuid:00000000-0000-0000-0000-000000000000";
        assert_eq!(urn.to_string(), expected_urn_str);
    }

    #[test]
    fn test_urn_as_uuid() {
        let uuid = Uuid::nil();
        let urn = uuid.urn();
        assert_eq!(*urn.as_uuid(), Uuid::nil());
    }

    #[test]
    fn test_urn_into_uuid() {
        let uuid = Uuid::nil();
        let urn = uuid.urn();
        assert_eq!(urn.into_uuid(), Uuid::nil());
    }

    #[test]
    fn test_urn_encode_lower() {
        let uuid = Uuid::nil();
        let urn = uuid.urn();
        let mut buffer = Uuid::encode_buffer();
        let result_str = urn.encode_lower(&mut buffer);
        let expected_str = "urn:uuid:00000000-0000-0000-0000-000000000000";
        assert_eq!(result_str, expected_str);
    }

    #[test]
    fn test_urn_encode_upper() {
        let uuid = Uuid::nil();
        let urn = uuid.urn();
        let mut buffer = Uuid::encode_buffer();
        let result_str = urn.encode_upper(&mut buffer);
        let expected_str = "urn:uuid:00000000-0000-0000-0000-000000000000";
        assert_eq!(result_str, expected_str.to_uppercase());
        assert_eq!(result_str, expected_str.to_uppercase().as_str());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::fmt::Braced;
    use crate::Uuid;

    // Helper function to create a Uuid from a simple string for testing.
    fn create_test_uuid() -> Uuid {
        Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap()
    }

    // Test conversion from a Uuid wrapped in the Braced adapter to a Uuid.
    #[test]
    fn test_from_braced_to_uuid() {
        let uuid = create_test_uuid();
        let braced = Braced::from_uuid(uuid);
        let uuid_from_braced = Uuid::from(braced);
        assert_eq!(uuid_from_braced, uuid);
    }

    // Test the into_uuid method for Braced.
    #[test]
    fn test_braced_into_uuid() {
        let uuid = create_test_uuid();
        let braced = Braced::from_uuid(uuid);
        let uuid_from_braced = braced.into_uuid();
        assert_eq!(uuid_from_braced, uuid);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Hyphenated;
    use crate::Uuid;
    use std::str::FromStr;

    #[test]
    fn test_from_hyphenated() {
        let hyphen_string = "550e8400-e29b-41d4-a716-446655440000";
        let hyphenated = Hyphenated::from_uuid(Uuid::from_str(hyphen_string).unwrap());
        let uuid: Uuid = Uuid::from(hyphenated);

        assert_eq!(uuid.to_string(), hyphen_string);
    }
}
True
========================================
    use crate::fmt::Simple;
    use crate::Uuid;

    #[test]
    fn test_from_simple() {
        let simple = Simple::from_uuid(Uuid::nil());
        let uuid_from_simple = Uuid::from(simple);

        assert_eq!(uuid_from_simple, Uuid::nil());
    }

    #[test]
    fn test_from_simple_hex() {
        let uuid = Uuid::parse_str("a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8").unwrap();
        let simple = Simple::from_uuid(uuid);
        let uuid_from_simple = Uuid::from(simple);

        assert_eq!(uuid_from_simple, uuid);
    }

    #[test]
    fn test_from_simple_uppercase() {
        let uuid = Uuid::parse_str("A1A2A3A4B1B2C1C2D1D2D3D4D5D6D7D8").unwrap();
        let simple = Simple::from_uuid(uuid);
        let uuid_from_simple = Uuid::from(simple);

        assert_eq!(uuid_from_simple, uuid);
    }

    #[test]
    fn test_from_simple_hyphenated() {
        let uuid = Uuid::parse_str("a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8").unwrap();
        let simple = Simple::from_uuid(uuid);
        let uuid_from_simple = Uuid::from(simple);

        assert_eq!(uuid_from_simple, uuid);
    }

    #[test]
    fn test_from_simple_braced() {
        let uuid = Uuid::parse_str("{a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8}").unwrap();
        let simple = Simple::from_uuid(uuid);
        let uuid_from_simple = Uuid::from(simple);

        assert_eq!(uuid_from_simple, uuid);
    }
}
True
========================================
    use crate::{fmt::Urn, Uuid, Error};

    #[test]
    fn test_urn_to_uuid_conversion() {
        let uuid_str = "a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8";
        let uuid = Uuid::parse_str(uuid_str).expect("Failed to parse UUID");
        let urn = Urn::from(uuid);

        let converted_uuid = Uuid::from(urn);

        assert_eq!(uuid, converted_uuid, "Converted UUID should match original");
    }

    #[test]
    fn test_uuid_from_urn() -> Result<(), Error> {
        let expected_uuid_str = "67e55044-10b1-426f-9247-bb680e5fe0c8";
        let uuid = Uuid::parse_str(expected_uuid_str)?;
        let urn = Urn::from_uuid(uuid);
        let result_uuid = Uuid::from(urn);

        assert_eq!(uuid, result_uuid);
        Ok(())
    }

    #[test]
    fn test_uuid_from_urn_default() {
        let urn = Urn::default();
        let uuid_from_urn = Uuid::from(urn);
        let default_uuid = Uuid::default();

        assert_eq!(uuid_from_urn, default_uuid, "UUID converted from default Urn should match Uuid::default()");
    }

    #[test]
    fn test_uuid_from_urn_nil() {
        let urn = Urn::from_uuid(Uuid::nil());
        let uuid_from_urn = Uuid::from(urn);

        assert!(
            uuid_from_urn.is_nil(),
            "UUID converted from Urn with NIL UUID should be nil"
        );
    }

    #[test]
    fn test_uuid_from_custom_urn() {
        let custom_uuid = Uuid::from_bytes([
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ]);
        let urn = Urn::from_uuid(custom_uuid);
        let uuid_from_urn = Uuid::from(urn);

        assert_eq!(
            custom_uuid, uuid_from_urn,
            "UUID converted from custom Urn should match original custom UUID"
        );
    }
}
True
========================================
    use crate::fmt::Braced;
    use crate::Uuid;

    #[test]
    fn as_uuid_returns_correct_uuid() {
        let uuid = Uuid::nil();
        let braced = Braced::from_uuid(uuid);
        assert_eq!(*braced.as_uuid(), uuid);
    }

    #[test]
    fn braced_as_uuid_returns_the_same_as_direct() {
        let uuid = Uuid::nil();
        let braced = Braced::from_uuid(uuid);
        assert_eq!(*braced.as_uuid(), uuid);
    }

    #[test]
    fn as_uuid_is_consistent_with_direct_uuid() {
        let uuid1 = Uuid::nil();
        let braced = Braced::from_uuid(uuid1);
        let uuid2 = braced.as_uuid();
        assert_eq!(uuid1, *uuid2);
    }

    #[test]
    fn as_uuid_is_consistent_with_from_str() {
        let uuid_str = "00000000-0000-0000-0000-000000000000";
        let uuid_direct = Uuid::parse_str(uuid_str).unwrap();
        let braced = Braced::from_uuid(uuid_direct);
        assert_eq!(*braced.as_uuid(), uuid_direct);
    }

    #[test]
    fn as_uuid_is_consistent_with_from_fields() {
        let uuid_fields = Uuid::from_fields(0, 0, 0, &[0; 8]);
        let braced = Braced::from_uuid(uuid_fields);
        assert_eq!(*braced.as_uuid(), uuid_fields);
    }

    #[test]
    fn as_uuid_returns_correct_uuid_for_non_nil() {
        let non_nil_uuid = Uuid::parse_str("936DA01F-9ABD-4D9D-80C7-02AF85C822A8").unwrap();
        let braced = Braced::from_uuid(non_nil_uuid);
        assert_eq!(*braced.as_uuid(), non_nil_uuid);
    }
}
True
========================================
    use crate::{*, fmt::Braced};
    use std::panic::AssertUnwindSafe;

    #[test]
    fn test_encode_lower() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = Uuid::encode_buffer();
        let encoded_uuid = uuid.braced().encode_lower(&mut buffer);

        assert_eq!(encoded_uuid, "{550e8400-e29b-41d4-a716-446655440000}");
    }

    #[test]
    fn test_encode_lower_buffer_too_small() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = [0u8; Braced::LENGTH - 1]; // buffer is too small by 1
        let result = std::panic::catch_unwind(AssertUnwindSafe(|| {
            uuid.braced().encode_lower(&mut buffer);
        }));

        assert!(result.is_err());
    }

    #[test]
    fn test_encode_lower_buffer_exactly_sized() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = [0u8; Braced::LENGTH]; // buffer is exactly sized
        let encoded_uuid = uuid.braced().encode_lower(&mut buffer);

        assert_eq!(encoded_uuid, "{550e8400-e29b-41d4-a716-446655440000}");
    }

    #[test]
    fn test_encode_lower_buffer_larger_than_needed() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = [0u8; Braced::LENGTH + 4]; // buffer is larger than needed
        let encoded_uuid = uuid.braced().encode_lower(&mut buffer);

        assert_eq!(encoded_uuid, "{550e8400-e29b-41d4-a716-446655440000}");
        assert_eq!(&buffer[Braced::LENGTH..], &[0u8; 4]);
    }

    #[test]
    fn test_encode_lower_with_additional_content_in_buffer() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = [b'!'; 42]; // buffer initially filled with '!'
        let encoded_uuid = uuid.braced().encode_lower(&mut buffer);

        assert_eq!(encoded_uuid, "{550e8400-e29b-41d4-a716-446655440000}");
        assert_eq!(&buffer[Braced::LENGTH..], b"!!!!");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Braced;

    #[test]
    fn test_encode_upper() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let braced = Braced::from_uuid(uuid);
        let mut buffer = Uuid::encode_buffer();
        let result = braced.encode_upper(&mut buffer);
        assert_eq!(result, "{936DA01F-9ABD-4D9D-80C7-02AF85C822A8}");
    }

    #[test]
    #[should_panic(expected = "buffer is not large enough")]
    fn test_encode_upper_panics_when_buffer_too_small() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let braced = Braced::from_uuid(uuid);
        let mut buffer = [0u8; Braced::LENGTH - 1]; // intentionally too small
        braced.encode_upper(&mut buffer);
    }

    #[test]
    fn test_encode_upper_with_sufficient_buffer() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let braced = Braced::from_uuid(uuid);
        let mut buffer = [0u8; 40]; // larger buffer
        braced.encode_upper(&mut buffer);
        // Check that the result is correct and the buffer is unchanged beyond the UUID
        assert_eq!(&buffer[..Braced::LENGTH], b"{936DA01F-9ABD-4D9D-80C7-02AF85C822A8}");
        assert_eq!(&buffer[Braced::LENGTH..], &[0u8; 40 - Braced::LENGTH]);
    }

    #[test]
    fn test_encode_upper_with_trailing_contents() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let braced = Braced::from_uuid(uuid);
        let mut buffer = [b'!'; 40];  // buffer with trailing contents
        braced.encode_upper(&mut buffer);
        // Check that the result is correct and does not overwrite the trailing contents
        assert_eq!(&buffer[..Braced::LENGTH], b"{936DA01F-9ABD-4D9D-80C7-02AF85C822A8}");
        assert_eq!(&buffer[Braced::LENGTH..], b"!!" as &[u8]);
    }
}
True
========================================
    use crate::fmt::Braced;
    use crate::Uuid;

    #[cfg(feature = "v4")]
    #[test]
    fn test_from_uuid_creates_proper_braced() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let braced = Braced::from_uuid(uuid);
        assert_eq!(braced.to_string(), "{67e55044-10b1-426f-9247-bb680e5fe0c8}");
    }

    #[cfg(feature = "v4")]
    #[test]
    fn test_from_uuid_creates_braced_with_same_uuid() {
        let uuid = Uuid::new_v4();
        let braced = Braced::from_uuid(uuid);
        assert_eq!(braced.as_uuid(), &uuid);
    }

    #[cfg(feature = "v4")]
    #[test]
    fn test_from_uuid_empty_braced() {
        let uuid = Uuid::nil();
        let braced = Braced::from_uuid(uuid);
        assert_eq!(braced.to_string(), "{00000000-0000-0000-0000-000000000000}");
    }

    #[cfg(feature = "v4")]
    #[test]
    fn test_from_uuid_uppercase_braced() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let braced = Braced::from_uuid(uuid);
        assert_eq!(format!("{:X}", braced), "{67E55044-10B1-426F-9247-BB680E5FE0C8}");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Braced;
    use crate::Uuid;
    use std::str::FromStr;

    #[test]
    fn braced_into_uuid_returns_correct_uuid() {
        // Use a known UUID
        let known_uuid_str = "67e55044-10b1-426f-9247-bb680e5fe0c8";
        let known_uuid = Uuid::from_str(known_uuid_str).unwrap();
        let braced = Braced::from_uuid(known_uuid);

        // Convert back to Uuid and check it matches
        let uuid_from_braced = braced.into_uuid();
        assert_eq!(uuid_from_braced, known_uuid);
    }

    #[test]
    fn braced_into_uuid_returns_nil_uuid() {
        let nil_uuid = Uuid::nil();
        let braced = Braced::from_uuid(nil_uuid);

        // Convert back to Uuid and ensure it is nil
        let uuid_from_braced = braced.into_uuid();
        assert!(uuid_from_braced.is_nil());
    }

    #[test]
    fn braced_into_uuid_returns_max_uuid() {
        // Will only work if uuid_unstable feature is available, otherwise this test should be skipped
        #[cfg(uuid_unstable)]
        {
            let max_uuid = Uuid::max();
            let braced = Braced::from_uuid(max_uuid);

            // Convert back to Uuid and ensure it is max
            let uuid_from_braced = braced.into_uuid();
            assert!(uuid_from_braced.is_max());
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::{fmt, Uuid};

    #[test]
    fn test_as_uuid() {
        let nil_uuid = Uuid::nil();
        let hyphenated = nil_uuid.hyphenated();
        assert_eq!(*hyphenated.as_uuid(), nil_uuid);

        let uuid_str = "550e8400-e29b-41d4-a716-446655440000";
        let uuid = Uuid::parse_str(uuid_str).unwrap();
        let hyphenated = uuid.hyphenated();
        assert_eq!(*hyphenated.as_uuid(), uuid);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Hyphenated;

    #[test]
    fn test_encode_lower() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);
        let mut buffer = [0u8; Hyphenated::LENGTH];
        let slice = hyphenated.encode_lower(&mut buffer);
        assert_eq!(slice, "550e8400-e29b-41d4-a716-446655440000");
    }

    #[test]
    #[should_panic(expected = "buffer is not large enough")]
    fn test_encode_lower_insufficient_buffer() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);
        let mut buffer = [0u8; Hyphenated::LENGTH-1];
        let _ = hyphenated.encode_lower(&mut buffer);
    }

    #[test]
    fn test_encode_lower_excess_buffer() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);
        let mut buffer = [b'!'; Hyphenated::LENGTH+4];
        let slice = hyphenated.encode_lower(&mut buffer);
        assert_eq!(slice, "550e8400-e29b-41d4-a716-446655440000");
        assert_eq!(&buffer[Hyphenated::LENGTH..], b"!!!!");
    }

    #[test]
    fn test_encode_lower_with_uppercase_input() {
        let uuid = Uuid::parse_str("550E8400E29B41D4A716446655440000").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);
        let mut buffer = [0u8; Hyphenated::LENGTH];
        let slice = hyphenated.encode_lower(&mut buffer);
        assert_eq!(slice, "550e8400-e29b-41d4-a716-446655440000");
    }

    #[test]
    fn test_encode_lower_with_hyphenated_input() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);
        let mut buffer = [0u8; Hyphenated::LENGTH];
        let slice = hyphenated.encode_lower(&mut buffer);
        assert_eq!(slice, "550e8400-e29b-41d4-a716-446655440000");
    }

    #[test]
    fn test_encode_lower_nil_uuid() {
        let uuid = Uuid::nil();
        let hyphenated = Hyphenated::from_uuid(uuid);
        let mut buffer = [0u8; Hyphenated::LENGTH];
        let slice = hyphenated.encode_lower(&mut buffer);
        assert_eq!(slice, "00000000-0000-0000-0000-000000000000");
    }
}
True
========================================
    use crate::fmt::{self, Hyphenated}; // Specify fmt path for Hyphenated

    #[test]
    fn test_encode_upper() {
        let uuid = crate::Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = crate::Uuid::encode_buffer();
        let result = uuid.hyphenated().encode_upper(&mut buffer);

        assert_eq!(result, "550E8400-E29B-41D4-A716-446655440000");
    }

    #[test]
    #[should_panic(expected = "buffer is not large enough")]
    fn test_encode_upper_buffer_too_small() {
        let uuid = crate::Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = [0u8; 10]; // smaller than required
        let _ = uuid.hyphenated().encode_upper(&mut buffer);
    }

    #[test]
    fn test_encode_upper_no_panic_on_exact_size_buffer() {
        let uuid = crate::Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = [0u8; Hyphenated::LENGTH];
        let result = uuid.hyphenated().encode_upper(&mut buffer);

        assert_eq!(result, "550E8400-E29B-41D4-A716-446655440000");
    }

    #[test]
    fn test_encode_upper_no_panic_on_larger_buffer() {
        let uuid = crate::Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = [0u8; Hyphenated::LENGTH + 10]; // larger than required
        let result = uuid.hyphenated().encode_upper(&mut buffer);

        assert_eq!(result, "550E8400-E29B-41D4-A716-446655440000");
    }

    #[test]
    fn test_encode_upper_no_panic_on_buffer_fill() {
        let uuid = crate::Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = [b'!'; Hyphenated::LENGTH + 10]; // larger than required
        let result = uuid.hyphenated().encode_upper(&mut buffer);

        assert_eq!(result, "550E8400-E29B-41D4-A716-446655440000");
        assert_eq!(&buffer[Hyphenated::LENGTH..], &[b'!'; 10]);
    }
}
True
========================================
    use crate::fmt::Hyphenated;
    use crate::Uuid;

    #[test]
    fn test_from_uuid_creates_hyphenated() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);

        assert_eq!(hyphenated.to_string(), "67e55044-10b1-426f-9247-bb680e5fe0c8");
    }

    #[test]
    fn test_from_uuid_creates_hyphenated_matches_direct_call() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let hyphenated_from_uuid = Hyphenated::from_uuid(uuid);
        let hyphenated_direct = uuid.hyphenated();

        assert_eq!(hyphenated_from_uuid, hyphenated_direct);
    }

    #[test]
    #[should_panic(expected = "buffer is not large enough")]
    fn test_from_uuid_encoding_panic_on_small_buffer() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);
        let small_buffer = &mut [0; Hyphenated::LENGTH - 1]; // buffer too small

        hyphenated.encode_lower(small_buffer);
    }

    #[test]
    fn test_from_uuid_encoding_with_buffer() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);
        let buffer = &mut [0; Hyphenated::LENGTH]; // correctly sized buffer

        assert_eq!(hyphenated.encode_lower(buffer), "67e55044-10b1-426f-9247-bb680e5fe0c8");
    }

    #[test]
    fn test_from_uuid_uppercase_encoding() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let hyphenated = Hyphenated::from_uuid(uuid);

        assert_eq!(hyphenated.encode_upper(&mut Uuid::encode_buffer()), "67E55044-10B1-426F-9247-BB680E5FE0C8");
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Hyphenated;
    use crate::Uuid;

    #[test]
    fn test_into_uuid() {
        let uuid = Uuid::nil();
        let hyphenated = uuid.hyphenated();
        let result = hyphenated.into_uuid();
        assert_eq!(result, uuid, "Hyphenated::into_uuid did not return the original Uuid");
        
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let hyphenated = uuid.hyphenated();
        let result = hyphenated.into_uuid();
        assert_eq!(result, uuid, "Hyphenated::into_uuid did not return the original Uuid for non-nil Uuid");
    }
}
True
========================================
    use crate::{fmt, Uuid};

    #[test]
    fn simple_as_uuid_test() {
        let uuid = Uuid::nil();
        let simple = fmt::Simple::from_uuid(uuid);
        assert_eq!(*simple.as_uuid(), uuid);
    }

    #[test]
    fn simple_as_uuid_non_nil_test() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let simple = fmt::Simple::from_uuid(uuid);
        assert_eq!(*simple.as_uuid(), uuid);
    }

    #[test]
    fn simple_as_uuid_equality_test() {
        let uuid1 = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let simple = fmt::Simple::from_uuid(uuid1);
        let uuid2 = *simple.as_uuid();
        assert_eq!(uuid1, uuid2);
    }

    // This test must conditionally compile only if the `v4` feature is enabled
    #[cfg(feature = "v4")]
    #[test]
    fn simple_as_uuid_into_test() {
        let uuid = Uuid::new_v4();
        let simple = fmt::Simple::from_uuid(uuid);
        assert_eq!(simple.into_uuid(), uuid);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Simple;

    #[test]
    fn test_encode_lower() {
        let uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        let mut buffer = Uuid::encode_buffer();
        let result = uuid.simple().encode_lower(&mut buffer);
        assert_eq!(result, "550e8400e29b41d4a716446655440000");
    }
}
True
========================================
    use crate::fmt::Simple;
    use crate::Uuid;

    #[test]
    fn test_encode_upper() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let mut buffer = Uuid::encode_buffer();
        let encoded = uuid.simple().encode_upper(&mut buffer);
        assert_eq!(encoded, "936DA01F9ABD4D9D80C702AF85C822A8");
    }

    #[test]
    #[should_panic(expected = "buffer is not large enough")]
    fn test_encode_upper_insufficient_buffer() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let mut buffer = [0; 16]; // intentionally too small
        let _ = uuid.simple().encode_upper(&mut buffer);
    }

    #[test]
    fn test_encode_upper_exactly_sized_buffer() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let mut buffer = [0; Simple::LENGTH]; // exactly 32 bytes
        let encoded = uuid.simple().encode_upper(&mut buffer);
        assert_eq!(encoded, "936DA01F9ABD4D9D80C702AF85C822A8");
    }

    #[test]
    fn test_encode_upper_with_trailing_space() {
        let uuid = Uuid::parse_str("936da01f9abd4d9d80c702af85c822a8").unwrap();
        let mut buffer = [0; Simple::LENGTH + 4]; // extra space for additional characters
        let encoded = uuid.simple().encode_upper(&mut buffer);
        assert_eq!(encoded, "936DA01F9ABD4D9D80C702AF85C822A8");
        // Ensure the extra space is not mutated
        assert_eq!(buffer[32..], [0; 4]);
    }

    #[test]
    fn test_encode_upper_all_lower_hex() {
        let uuid = Uuid::parse_str("00000000000000000000000000000000").unwrap();
        let mut buffer = Uuid::encode_buffer();
        let encoded = uuid.simple().encode_upper(&mut buffer);
        assert_eq!(encoded, "00000000000000000000000000000000");
    }

    #[test]
    fn test_encode_upper_all_upper_hex() {
        let uuid = Uuid::parse_str("ffffffffffffffffffffffffffffffff").unwrap();
        let mut buffer = Uuid::encode_buffer();
        let encoded = uuid.simple().encode_upper(&mut buffer);
        assert_eq!(encoded, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
    }

    #[test]
    fn test_encode_upper_mixed_case() {
        let uuid = Uuid::parse_str("fFfFfFfF000000007777777788888888").unwrap();
        let mut buffer = Uuid::encode_buffer();
        let encoded = uuid.simple().encode_upper(&mut buffer);
        assert_eq!(encoded, "FFFFFFFF000000007777777788888888");
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_simple_from_uuid() {
        let bytes = [
            0x10, 0x94, 0x1d, 0x41, 0x97, 0xee, 0x47, 0xe6,
            0x98, 0x0a, 0xd9, 0x19, 0x1a, 0x2a, 0x3a, 0x70,
        ];
        
        let uuid = Uuid::from_bytes(bytes);
        let simple = Simple::from_uuid(uuid);
        let mut buffer = Uuid::encode_buffer();
        let simple_str = simple.encode_lower(&mut buffer);
        
        assert_eq!(
            simple_str,
            "10941d4197ee47e6980ad9191a2a3a70"
        );
        assert_eq!(
            *simple.as_uuid(),
            uuid
        );
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Simple;

    #[test]
    fn test_into_uuid() {
        // Generate a sequence of tests for different UUIDs
        let test_uuids = [
            Uuid::nil(),
            Uuid::parse_str("936DA01F-9ABD-4D9D-80C7-02AF85C822A8").unwrap(),
            Uuid::parse_str("550E8400-E29B-41D4-A716-446655440000").unwrap(),
            Uuid::parse_str("F4A13929-91CE-4B1A-8F38-0C4E4BCCCAD6").unwrap(),
            Uuid::parse_str("A1A2A3A4-B1B2-C1C2-D1D2-D3D4D5D6D7D8").unwrap(),
        ];

        // Check that into_uuid for a Simple returns the same Uuid
        for &uuid in test_uuids.iter() {
            let simple = Simple::from_uuid(uuid);
            assert_eq!(simple.into_uuid(), uuid);
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Urn;
    use crate::Uuid;

    #[test]
    fn test_urn_as_uuid() {
        let uuid = Uuid::nil();
        let urn = Urn::from_uuid(uuid);

        assert_eq!(urn.as_uuid(), &uuid);
    }

    #[test]
    fn test_as_uuid_non_nil() {
        let uuid = Uuid::parse_str("936DA01F-9ABD-4D9D-80C7-02AF85C822A8").unwrap();
        let urn = Urn::from_uuid(uuid);

        assert_eq!(urn.as_uuid(), &uuid);
    }

    #[test]
    fn test_as_uuid_random() {
        #[cfg(feature = "v4")]
        {
            let uuid = Uuid::new_v4();
            let urn = Urn::from_uuid(uuid);

            assert_eq!(urn.as_uuid(), &uuid);
        }
    }
}
True
========================================
    use super::*;

use crate::*;
    
    // Since we are directly in the fmt module, we need to use its parent (crate root)
    use crate::prelude::*;
    
    // Test encoding a UUID as a lower-case URN string
    #[test]
    fn test_encode_lower() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let mut buffer = Uuid::encode_buffer();
        let result = uuid.urn().encode_lower(&mut buffer);
        assert_eq!(result, "urn:uuid:550e8400-e29b-41d4-a716-446655440000");
    }

    // Test encoding a UUID as a lower-case URN string with a buffer that has leftover contents
    #[test]
    fn test_encode_lower_with_leftover() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let mut buffer = [b'X'; 49]; // Simulate leftover contents
        uuid.urn().encode_lower(&mut buffer);
        let expected = b"urn:uuid:550e8400-e29b-41d4-a716-446655440000".to_vec();
        // Append 'X' to expected to match the leftover buffer
        let mut expected_with_leftover = expected.clone();
        expected_with_leftover.extend_from_slice(&[b'X'; 4]);
        assert_eq!(&buffer, expected_with_leftover.as_slice());
    }

    // Test that encoding a UUID as a lower-case URN string panics if the buffer is too small
    #[test]
    #[should_panic(expected = "buffer is not large enough")]
    fn test_encode_lower_insufficient_buffer() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let mut buffer = [0u8; 10]; // Intentionally too small buffer to cause panic
        let _ = uuid.urn().encode_lower(&mut buffer);
    }
}
False
========================================
    use crate::fmt::Urn;
    use crate::Uuid;

    #[test]
    fn test_encode_upper() {
        let uuid = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").unwrap();
        let mut buffer = Uuid::encode_buffer();
        assert_eq!(
            uuid.urn().encode_upper(&mut buffer),
            "urn:uuid:67E55044-10B1-426F-9247-BB680E5FE0C8"
        );
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::fmt::Urn;
    use crate::Uuid;

    #[test]
    fn test_urn_from_uuid() {
        let uuid = Uuid::nil();
        let urn = Urn::from_uuid(uuid);
        assert_eq!(urn.as_uuid(), &uuid);
    }

    #[test]
    fn test_urn_from_uuid_v4() {
        #[cfg(feature = "v4")]
        {
            let uuid = Uuid::new_v4();
            let urn = Urn::from_uuid(uuid);
            assert_eq!(urn.as_uuid(), &uuid);
        }
    }

    #[test]
    fn test_urn_from_uuid_to_string() {
        let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        let urn_string = uuid.urn().to_string();
        assert_eq!(urn_string, "urn:uuid:550e8400-e29b-41d4-a716-446655440000");
    }

    #[test]
    fn test_urn_from_fields() {
        let uuid = Uuid::from_fields(
            0x550e8400,
            0xe29b,
            0x41d4,
            &[0xa7, 0x16, 0x44, 0x66, 0x55, 0x44, 0x00, 0x00],
        );
        let urn = Urn::from_uuid(uuid);
        assert_eq!(urn.as_uuid(), &uuid);
    }

    #[test]
    #[cfg(uuid_unstable)]
    fn test_urn_from_uuid_max() {
        let uuid = Uuid::max();
        let urn = Urn::from_uuid(uuid);
        assert_eq!(urn.as_uuid(), &uuid);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_into_uuid() {
        // Test with the nil UUID
        let urn_nil = Uuid::nil().urn();
        assert_eq!(urn_nil.into_uuid(), Uuid::nil());

        // Since Uuid::new_v4() is not available in the provided context,
        // we're removing the test case for it.

        // Test with a v1 UUID
        #[cfg(feature = "v1")] // Ensure that the "v1" feature is enabled in your `Cargo.toml`
        {
            use crate::v1::{ClockSequence, Context, Timestamp, UnixTime};

            let uuid_v1 = Uuid::new_v1(
                ClockSequence::from_u16(0x1234),
                Context::new(0),
                Timestamp::from_unix(
                    UnixTime::from_unix(
                        1651884396, // Specific unix timestamp for test reproducibility,
                        0,          // Nanoseconds part
                    ),
                ),
            );
            
            let urn_v1 = uuid_v1.urn();
            assert_eq!(urn_v1.into_uuid(), uuid_v1);
        }

        // Test with a custom UUID
        {
            let custom_uuid = Uuid::from_fields(
                0x12345678,
                0x1234,
                0x1234,
                &[0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0]
            ).unwrap();
            
            let urn_custom = custom_uuid.urn();
            assert_eq!(urn_custom.into_uuid(), custom_uuid);
        }
    }
}
False
========================================
    use super::*; // Adjust the imports to use super::* to bring the required items into scope

use crate::*;

    #[test]
    fn test_encode_braced_lower() {
        let src: [u8; 16] = [ // Add type annotation for clarity
            0x10, 0x94, 0x01, 0xd2, 
            0x11, 0xe1, 0x85, 0xc7, 
            0x92, 0x2e, 0xa2, 0x3f, 
            0x03, 0x1d, 0x41, 0x97
        ];
        let mut buffer: [u8; 39] = [0; 39]; // Replace Braced::LENGTH with the actual length of the buffer
        let encoded = encode_braced(&src, &mut buffer, false).unwrap(); // Add .unwrap() to handle the Result from encode_braced
        let expected = "{109401d2-11e1-85c7-922e-a23f-031d4197}";
        assert_eq!(encoded, expected);
    }

    #[test]
    fn test_encode_braced_upper() {
        let src: [u8; 16] = [ // Add type annotation for clarity
            0x10, 0x94, 0x01, 0xd2, 
            0x11, 0xe1, 0x85, 0xc7, 
            0x92, 0x2e, 0xa2, 0x3f, 
            0x03, 0x1d, 0x41, 0x97
        ];
        let mut buffer: [u8; 39] = [0; 39]; // Replace Braced::LENGTH with the actual length of the buffer
        let encoded = encode_braced(&src, &mut buffer, true).unwrap(); // Add .unwrap() to handle the Result from encode_braced
        let expected = "{109401D2-11E1-85C7-922E-A23F-031D4197}";
        assert_eq!(encoded, expected);
    }

    #[test]
    #[should_panic]
    fn test_encode_braced_panic_on_short_buffer() {
        let src: [u8; 16] = [ // Add type annotation for clarity
            0x10, 0x94, 0x01, 0xd2, 
            0x11, 0xe1, 0x85, 0xc7, 
            0x92, 0x2e, 0xa2, 0x3f, 
            0x03, 0x1d, 0x41, 0x97
        ];
        let mut buffer: [u8; 38] = [0; 38]; // Replace Braced::LENGTH - 1 with the actual length of the buffer - 1
        encode_braced(&src, &mut buffer, false).unwrap(); // Add .unwrap to handle the Result from encode_braced
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_encode_hyphenated_lower() {
        let src = [0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88];
        let expected = "12345678-9abc-def0-1122-334455667788";
        let mut buffer = [0u8; Hyphenated::LENGTH];
        let encoded = encode_hyphenated(&src, &mut buffer, false);
        assert_eq!(encoded, expected);
    }

    #[test]
    fn test_encode_hyphenated_upper() {
        let src = [0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88];
        let expected = "12345678-9ABC-DEF0-1122-334455667788";
        let mut buffer = [0u8; Hyphenated::LENGTH];
        let encoded = encode_hyphenated(&src, &mut buffer, true);
        assert_eq!(encoded, expected);
    }
}
True
========================================
    use crate::encode_simple;
    use std::str;

    const SIMPLE_LENGTH: usize = 32;

    #[test]
    fn test_encode_simple() {
        let uuid_bytes: [u8; 16] = [
            0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
            0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
        ];

        let mut buffer = [0u8; SIMPLE_LENGTH];

        // Test lowercase encoding
        let encoded = encode_simple(&uuid_bytes, &mut buffer, false);
        assert_eq!(encoded, "1234567890abcdef1234567890abcdef");

        // Test uppercase encoding
        let encoded = encode_simple(&uuid_bytes, &mut buffer, true);
        assert_eq!(encoded, "1234567890ABCDEF1234567890ABCDEF");
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_encode_urn_lowercase() {
        let src: [u8; 16] = [
            0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
            0x77, 0x88,
        ];
        let mut buffer = [0; Urn::LENGTH]; // ensure that buffer is the correct length
        let result = encode_urn(&src, &mut buffer, false);

        assert_eq!(
            result,
            "urn:uuid:12345678-90ab-cdef-1122-334455667788"
        );
    }

    #[test]
    fn test_encode_urn_uppercase() {
        let src: [u8; 16] = [
            0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
            0x77, 0x88,
        ];
        let mut buffer = [0; Urn::LENGTH]; // ensure that buffer is the correct length
        let result = encode_urn(&src, &mut buffer, true);

        assert_eq!(
            result,
            "urn:uuid:12345678-90AB-CDEF-1122-334455667788"
        );
    }

    #[test]
    #[should_panic(expected = "buffer is the correct length")]
    fn test_encode_urn_buffer_too_small() {
        let src: [u8; 16] = [
            0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
            0x77, 0x88,
        ];
        let mut buffer = [0; Urn::LENGTH - 1]; // buffer is one byte too small
        let _ = encode_urn(&src, &mut buffer, false);
    }
}
True
========================================
    use crate::fmt::format_hyphenated;

    #[test]
    fn test_format_hyphenated_lowercase() {
        let src = [
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
        ];
        let expected = *b"deadbeef-dead-beef-dead-beefdeadbeef";
        let result = format_hyphenated(&src, false);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_format_hyphenated_uppercase() {
        let src = [
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
        ];
        let expected = *b"DEADBEEF-DEAD-BEEF-DEAD-BEEFDEADBEEF";
        let result = format_hyphenated(&src, true);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_format_hyphenated_zeroes() {
        let src = [0; 16];
        let expected = *b"00000000-0000-0000-0000-000000000000";
        let result = format_hyphenated(&src, false);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_format_hyphenated_mixed_case() {
        let src = [
            0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
            0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        ];
        let expected_lower = *b"12345678-9abc-def0-1234-56789abcdef0";
        let expected_upper = *b"12345678-9ABC-DEF0-1234-56789ABCDEF0";
        assert_eq!(format_hyphenated(&src, false), expected_lower);
        assert_eq!(format_hyphenated(&src, true), expected_upper);
    }

    #[test]
    fn test_format_hyphenated_boundary_values() {
        let src = [
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        ];
        let expected_lower = *b"00000000-ffff-ffff-0000-0000ffffffff";
        let expected_upper = *b"00000000-FFFF-FFFF-0000-0000FFFFFFFF";
        assert_eq!(format_hyphenated(&src, false), expected_lower);
        assert_eq!(format_hyphenated(&src, true), expected_upper);
    }
}
True
========================================
    use crate::format_simple;

    const UPPER: &[u8; 16] = b"0123456789ABCDEF";
    const LOWER: &[u8; 16] = b"0123456789abcdef";

    #[test]
    fn test_format_simple_lowercase() {
        let src = [0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe,
                   0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe];
        let dst = format_simple(&src, false);
        let expected = *b"deadbeefcafebabedeadbeefcafebabedeadbeefcafebabedeadbeefcafebab";
        assert_eq!(dst, expected);
    }

    #[test]
    fn test_format_simple_uppercase() {
        let src = [0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe,
                   0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe];
        let dst = format_simple(&src, true);
        let expected = *b"DEADBEEFCAFEBABEDEADBEEFCAFEBABEDEADBEEFCAFEBABEDEADBEEFCAFEBABE";
        assert_eq!(dst, expected);
    }

    #[test]
    fn test_format_simple_zero() {
        let src = [0; 16];
        let dst_lowercase = format_simple(&src, false);
        let dst_uppercase = format_simple(&src, true);
        let expected_lowercase = *b"00000000000000000000000000000000";
        let expected_uppercase = *b"00000000000000000000000000000000";
        assert_eq!(dst_lowercase, expected_lowercase);
        assert_eq!(dst_uppercase, expected_uppercase);
    }

    #[test]
    fn test_format_simple_max() {
        let src = [0xff; 16];
        let dst_lowercase = format_simple(&src, false);
        let dst_uppercase = format_simple(&src, true);
        let expected_lowercase = *b"ffffffffffffffffffffffffffffffff";
        let expected_uppercase = *b"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";
        assert_eq!(dst_lowercase, expected_lowercase);
        assert_eq!(dst_uppercase, expected_uppercase);
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_parse_valid_uuids() {
        // Test parsing a simple UUID
        let simple_uuid = Uuid::parse_str("550e8400e29b41d4a716446655440000").unwrap();
        assert_eq!(Uuid::from_bytes([0x55, 0x0e, 0x84, 0x00, 0xe2, 0x9b, 0x41, 0xd4, 0xa7, 0x16, 0x44, 0x66, 0x55, 0x44, 0x00, 0x00]), simple_uuid);
        assert_eq!(Some(Version::Random), simple_uuid.get_version());
        assert_eq!(Variant::RFC4122, simple_uuid.get_variant());

        // Test parsing a hyphenated UUID
        let hyphenated_uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000").unwrap();
        assert_eq!(Uuid::from_bytes([0x55, 0x0e, 0x84, 0x00, 0xe2, 0x9b, 0x41, 0xd4, 0xa7, 0x16, 0x44, 0x66, 0x55, 0x44, 0x00, 0x00]), hyphenated_uuid);
        assert_eq!(Some(Version::Random), hyphenated_uuid.get_version());
        assert_eq!(Variant::RFC4122, hyphenated_uuid.get_variant());

        // Test parsing a UUID with an urn prefix
        let urn_uuid = Uuid::parse_str("urn:uuid:550e8400-e29b-41d4-a716-446655440000").unwrap();
        assert_eq!(Uuid::from_bytes([0x55, 0x0e, 0x84, 0x00, 0xe2, 0x9b, 0x41, 0xd4, 0xa7, 0x16, 0x44, 0x66, 0x55, 0x44, 0x00, 0x00]), urn_uuid);
        assert_eq!(Some(Version::Random), urn_uuid.get_version());
        assert_eq!(Variant::RFC4122, urn_uuid.get_variant());
    }

    #[test]
    fn test_parse_invalid_uuids() {
        // Test parsing an invalid UUID (bad characters)
        assert!(Uuid::parse_str("550e8400-e29b41d4a716x446655440000").is_err());

        // Test parsing an invalid UUID (wrong length)
        assert!(Uuid::parse_str("550e8400-e29b-41d4-a716-4466554400").is_err());

        // Test parsing an invalid UUID (wrong hyphen placement)
        assert!(Uuid::parse_str("550e-8400-e29b-41d4-a716-446655440000").is_err());
    }

    #[test]
    fn test_parse_uuid_with_braces() {
        // Test parsing a UUID with curly braces (Microsoft GUID)
        let braced_uuid = Uuid::parse_str("{550e8400-e29b-41d4-a716-446655440000}").unwrap();
        assert_eq!(Uuid::from_bytes([0x55, 0x0e, 0x84, 0x00, 0xe2, 0x9b, 0x41, 0xd4, 0xa7, 0x16, 0x44, 0x66, 0x55, 0x44, 0x00, 0x00]), braced_uuid);
        assert_eq!(Some(Version::Random), braced_uuid.get_version());
        assert_eq!(Variant::RFC4122, braced_uuid.get_variant());
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Uuid;

    #[test]
    fn test_try_parse_valid_uuid() {
        let input = "550e8400-e29b-41d4-a716-446655440000";
        assert!(Uuid::try_parse(input).is_ok());
    }

    #[test]
    fn test_try_parse_invalid_uuid() {
        let input = "invalid-uuid";
        assert!(Uuid::try_parse(input).is_err());
    }

    #[test]
    fn test_try_parse_valid_uuid_no_hyphens() {
        let input = "550e8400e29b41d4a716446655440000";
        assert!(Uuid::try_parse(input).is_ok());
    }

    #[test]
    fn test_try_parse_invalid_uuid_wrong_length() {
        let input = "550e8400-e29b-41d4";
        assert!(Uuid::try_parse(input).is_err());
    }

    #[test]
    fn test_try_parse_valid_uuid_uppercase() {
        let input = "550E8400-E29B-41D4-A716-446655440000";
        assert!(Uuid::try_parse(input).is_ok());
    }

    #[test]
    fn test_try_parse_uuid_with_braces() {
        let input = "{550e8400-e29b-41d4-a716-446655440000}";
        assert!(Uuid::try_parse(input).is_err());
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::Error;

    #[test]
    fn test_try_parse_ascii_with_valid_hyphenated() {
        let hyphenated_uuid = b"550e8400-e29b-41d4-a716-446655440000";
        let result = Uuid::try_parse_ascii(hyphenated_uuid);

        assert!(result.is_ok());
        let uuid = result.unwrap();
        assert_eq!(uuid.hyphenated().to_string(), "550e8400-e29b-41d4-a716-446655440000");
    }

    #[test]
    fn test_try_parse_ascii_with_invalid_length() {
        let invalid_uuid = b"550e8400-e29b-41d4";
        let result = Uuid::try_parse_ascii(invalid_uuid);
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert!(matches!(error, Error(crate::ErrorKind::Other)));
    }

    #[test]
    fn test_try_parse_ascii_with_invalid_characters() {
        let invalid_uuid = b"550e8400-e29bz41d4-a716-446655440000";
        let result = Uuid::try_parse_ascii(invalid_uuid);
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert!(matches!(error, Error(crate::ErrorKind::Other)));
    }

    #[test]
    fn test_try_parse_ascii_with_valid_non_hyphenated() {
        let non_hyphenated_uuid = b"550e8400e29b41d4a716446655440000";
        let result = Uuid::try_parse_ascii(non_hyphenated_uuid);

        assert!(result.is_ok());
        let uuid = result.unwrap();
        assert_eq!(uuid.simple().to_string(), "550e8400e29b41d4a716446655440000");
    }

    #[test]
    fn test_try_parse_ascii_with_empty_slice() {
        let empty_slice = b"";
        let result = Uuid::try_parse_ascii(empty_slice);
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert!(matches!(error, Error(crate::ErrorKind::Other)));
    }
}
False
========================================
    use crate::super::TryFrom;
    use crate::super::Uuid;
    use crate::super::{Error, ParseError};

    #[test]
    fn test_try_from_valid_uuid() {
        let valid_uuid_str = "123e4567-e89b-12d3-a456-426614174000";
        let result = Uuid::try_from(valid_uuid_str);
        assert!(result.is_ok());
        let uuid = result.unwrap();
        assert_eq!(uuid.to_string(), valid_uuid_str);
    }

    #[test]
    fn test_try_from_invalid_uuid() {
        let invalid_uuid_str = "not-a-uuid";
        let result = Uuid::try_from(invalid_uuid_str);
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), ParseError::InvalidLength(_)));
    }

    #[test]
    fn test_try_from_invalid_uuid_wrong_length() {
        let invalid_uuid_str = "123e4567-e89b-12d3-a456-42661417400"; // One character short
        let result = Uuid::try_from(invalid_uuid_str);
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), ParseError::InvalidLength(_)));
    }

    // More tests can be added as needed to cover corner cases and different formats
}
False
========================================
    use super::*;

use crate::*;
    use std::str::FromStr;
    use crate::Uuid;

    #[test]
    fn test_from_str_valid_uuid() {
        let valid_uuid_str = "67e55044-10b1-426f-9247-bb680e5fe0c8";
        let uuid = Uuid::from_str(valid_uuid_str);
        assert!(uuid.is_ok());
        assert_eq!(uuid.unwrap().to_string(), valid_uuid_str);
    }

    #[test]
    fn test_from_str_invalid_uuid() {
        let invalid_uuid_str = "invalid-uuid";
        let uuid = Uuid::from_str(invalid_uuid_str);
        assert!(uuid.is_err());
    }

    #[test]
    fn test_from_str_invalid_length() {
        let invalid_uuid_length_str = "67e55044-10b1-426f-9247-bb680e5fe0c";
        let uuid = Uuid::from_str(invalid_uuid_length_str);
        assert!(uuid.is_err());
    }

    #[test]
    fn test_from_str_invalid_characters() {
        let invalid_uuid_chars_str = "g7e55044-10b1-426f-9247-bb680e5fe0c8";
        let uuid = Uuid::from_str(invalid_uuid_chars_str);
        assert!(uuid.is_err());
    }
}
True
========================================
    use crate::parser::parse_hyphenated;

    // Assuming the following tables are defined within the same parser module
    // If not, they need to be imported properly or their definitions need to be in scope
    const HEX_TABLE: [u8; 256] = include!("hex_table.in");
    const SHL4_TABLE: [u8; 16] = include!("shl4_table.in");

    // The tests assume the existence of above tables, which are fictional and for example purposes only.
    // If actual tables are not publicly accessible, they must be defined or made accessible to the tests.
    
    #[test]
    fn test_parse_hyphenated_valid_uuid() {
        let uuid_str = b"123e4567-e89b-12d3-a456-426614174000";
        let expected = [
            0x12, 0x3e, 0x45, 0x67, 0xe8, 0x9b, 0x12, 0xd3, 0xa4, 0x56, 0x42, 0x66, 0x14, 0x17, 0x40, 0x00,
        ];
        assert_eq!(parse_hyphenated(uuid_str), Ok(expected));
    }

    #[test]
    fn test_parse_hyphenated_invalid_length() {
        let uuid_str = b"123e4567-e89b-12d3-a456-42661417400"; // One byte short
        assert_eq!(parse_hyphenated(uuid_str), Err(()));
    }

    #[test]
    fn test_parse_hyphenated_invalid_hyphens() {
        let uuid_str = b"123e4567e89b-12d3-a456-426614174000"; // Missing hyphen
        assert_eq!(parse_hyphenated(uuid_str), Err(()));
    }

    #[test]
    fn test_parse_hyphenated_invalid_chars() {
        let uuid_str = b"123e4567-e89b-12d3-a456-42661417G000"; // Invalid hex character 'G'
        assert_eq!(parse_hyphenated(uuid_str), Err(()));
    }
}
False
========================================
    use crate::parse_simple;

    // Define HEX_TABLE values for use in tests
    // Assume these are the correct values as
    // they are originally defined in the crate
    const HEX_TABLE: [u8; 256] = *include!("../../tables/HEX_TABLE");
    const SHL4_TABLE: [u8; 16] = *include!("../../tables/SHL4_TABLE");

    #[test]
    fn test_parse_simple_valid_uuid() {
        let uuid_str = b"1234567890abcdef1234567890abcdef";
        let expected: [u8; 16] = [
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
        ];
        let result = parse_simple(uuid_str);
        assert_eq!(result, Ok(expected));
    }

    #[test]
    fn test_parse_simple_invalid_length() {
        let uuid_str = b"123456";
        let result = parse_simple(uuid_str);
        assert_eq!(result, Err(()));
    }

    #[test]
    fn test_parse_simple_invalid_chars() {
        let uuid_str = b"1234567890abcdef1234567890abcdeg"; // 'g' is invalid
        let result = parse_simple(uuid_str);
        assert_eq!(result, Err(()));
    }

    #[test]
    fn test_parse_simple_invalid_hex_sequence() {
        let uuid_str = b"1234567890abcdeF1234567890abcdeZ"; // 'Z' is invalid
        let result = parse_simple(uuid_str);
        assert_eq!(result, Err(()));
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::parser::InvalidUuid;

    #[test]
    fn test_try_parse_valid_non_hyphenated() {
        let uuid_bytes = b"1234567890abcdef1234567890abcdef";
        assert_eq!(
            try_parse(uuid_bytes),
            Ok([
                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
                0xcd, 0xef
            ])
        );
    }

    #[test]
    fn test_try_parse_valid_hyphenated() {
        let uuid_bytes = b"12345678-90ab-cdef-1234-567890abcdef";
        assert_eq!(
            try_parse(uuid_bytes),
            Ok([
                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
                0xcd, 0xef
            ])
        );
    }

    #[test]
    fn test_try_parse_valid_braced() {
        let uuid_bytes = b"{12345678-90ab-cdef-1234-567890abcdef}";
        assert_eq!(
            try_parse(uuid_bytes),
            Ok([
                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
                0xcd, 0xef
            ])
        );
    }

    #[test]
    fn test_try_parse_valid_urn() {
        let uuid_bytes = b"urn:uuid:12345678-90ab-cdef-1234-567890abcdef";
        assert_eq!(
            try_parse(uuid_bytes),
            Ok([
                0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,
                0xcd, 0xef
            ])
        );
    }

    #[test]
    fn test_try_parse_invalid_length() {
        let uuid_bytes = b"12345";
        assert_eq!(
            try_parse(uuid_bytes),
            Err(InvalidUuid(uuid_bytes))
        );
    }

    #[test]
    fn test_try_parse_invalid_characters() {
        let uuid_bytes = b"12345678-90ab-cdef-1234-567890abcdefg"; // extra char
        assert_eq!(
            try_parse(uuid_bytes),
            Err(InvalidUuid(uuid_bytes))
        );
    }

    #[test]
    fn test_try_parse_invalid_hyphenation() {
        let uuid_bytes = b"12345678-90ab-cdef-1234-567890abcde-"; // extra hyphen
        assert_eq!(
            try_parse(uuid_bytes),
            Err(InvalidUuid(uuid_bytes))
        );
    }
}
True
========================================
    use super::*;

use crate::*;

    // Assuming the const UUID_TICKS_BETWEEN_EPOCHS is defined appropriately
    const UUID_TICKS_BETWEEN_EPOCHS: u64 = 0;

    #[test]
    fn from_rfc4122_test() {
        let ticks = 0;
        let counter = 0;
        let timestamp = Timestamp::from_rfc4122(ticks, counter);
        assert_eq!(timestamp.seconds, 0);
        assert_eq!(timestamp.nanos, 0);
        #[cfg(any(feature = "v1", feature = "v6"))]
        assert_eq!(timestamp.counter, counter);

        let ticks = 10_000_000; // 1 second
        let counter = 1;
        let timestamp = Timestamp::from_rfc4122(ticks, counter);
        assert_eq!(timestamp.seconds, 1);
        assert_eq!(timestamp.nanos, 0);
        #[cfg(any(feature = "v1", feature = "v6"))]
        assert_eq!(timestamp.counter, counter);

        let ticks = UUID_TICKS_BETWEEN_EPOCHS + (42 * 10_000_000) + (500_000 / 100);
        let counter = 42;
        let timestamp = Timestamp::from_rfc4122(ticks, counter);
        assert_eq!(timestamp.seconds, 42);
        assert_eq!(timestamp.nanos, 500_000);
        #[cfg(any(feature = "v1", feature = "v6"))]
        assert_eq!(timestamp.counter, counter);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_unix_no_context() {
        let context = timestamp::context::NoContext;
        let seconds = 1_637_227_012_u64; // Random example values
        let nanos = 1_234_567_u32;
        let timestamp = timestamp::Timestamp::from_unix(context, seconds, nanos);

        assert_eq!(timestamp.seconds, seconds);
        assert_eq!(timestamp.nanos, nanos);
        #[cfg(any(feature = "v1", feature = "v6"))]
        assert_eq!(timestamp.counter, 0);
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::timestamp::context::NoContext;
    use crate::timestamp::ClockSequence;
    use crate::timestamp::Timestamp;
    use std::time::{SystemTime, UNIX_EPOCH};

    #[test]
    fn test_now_with_no_context() {
        // Initialize the NoContext
        let context = NoContext;

        // Get the current system time to compare with the timestamp
        let system_time = SystemTime::now().duration_since(UNIX_EPOCH).expect("SystemTime before UNIX_EPOCH!");
        let timestamp = Timestamp::now(context);

        // Assuming the time it took to get the Timestamp after the SystemTime is negligible
        let system_seconds = system_time.as_secs();
        let system_nanos = system_time.subsec_nanos();
        let (timestamp_seconds, timestamp_nanos) = timestamp.to_unix();

        // The timestamp's value should be within a close range to the system time's value
        assert!(timestamp_seconds >= system_seconds);
        assert!(timestamp_seconds <= system_seconds + 2); // allowing a difference of up to 2 seconds
        assert!(timestamp_nanos >= system_nanos);
        assert!(timestamp_nanos <= system_nanos + 1_000_000_000); // allowing a difference of up to 1 second
        // The counter should always be 0 for NoContext
        #[cfg(any(feature = "v1", feature = "v6"))]
        assert_eq!(timestamp.counter, 0);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_rfc4122_to_unix_at_unix_epoch() {
        const UUID_TICKS_BETWEEN_EPOCHS: u64 = 0x01B2_1DD2_1381_4000;
        let (secs, nsecs) = Timestamp::rfc4122_to_unix(UUID_TICKS_BETWEEN_EPOCHS);
        assert_eq!(secs, 0);
        assert_eq!(nsecs, 0);
    }

    #[test]
    fn test_rfc4122_to_unix_after_unix_epoch() {
        const UUID_TICKS_BETWEEN_EPOCHS: u64 = 0x01B2_1DD2_1381_4000;
        // 1 second after Unix epoch in UUID ticks (100ns units)
        const UUID_TICKS_ONE_SECOND_AFTER: u64 = UUID_TICKS_BETWEEN_EPOCHS + 10_000_000;
        let (secs, nsecs) = Timestamp::rfc4122_to_unix(UUID_TICKS_ONE_SECOND_AFTER);
        assert_eq!(secs, 1);
        assert_eq!(nsecs, 0);
    }

    #[test]
    fn test_rfc4122_to_unix_before_unix_epoch() {
        const UUID_TICKS_BETWEEN_EPOCHS: u64 = 0x01B2_1DD2_1381_4000;
        // 1 second before Unix epoch in UUID ticks (100ns units)
        let uuid_ticks = UUID_TICKS_BETWEEN_EPOCHS - 10_000_000;
        let (secs, nsecs) = Timestamp::rfc4122_to_unix(uuid_ticks);
        let expected_secs_before_epoch: u64 = u64::MAX; // Wrap around because of unsigned substraction
        // Correct nsecs calculation: ((10_000_000 as u32) * 100)
        let expected_nsecs: u32 = 1_000_000_000 - (10_000_000 as u32) * 100;
        assert_eq!(secs, expected_secs_before_epoch);
        assert_eq!(nsecs, expected_nsecs);
    }

    // Define additional unit tests below as needed
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_to_unix() {
        let timestamp = Timestamp { seconds: 1_627_702_118, nanos: 123_456_789 };
        let unix = timestamp.to_unix();
        assert_eq!(unix, (1_627_702_118, 123_456_789));
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    #[should_panic]
    fn test_to_unix_nanos_deprecated() {
        let timestamp = Timestamp {
            seconds: 12345,
            nanos: 6789,
            #[cfg(any(feature = "v1", feature = "v6"))]
            counter: 123,
        };

        let _ = timestamp.to_unix_nanos();
    }
}
True
========================================
    use crate::decode_rfc4122_timestamp;
    use crate::{Uuid, Version, Variant};

    #[test]
    fn test_decode_rfc4122_timestamp() {
        // Uuid with RFC4122 timestamp fields
        // The correct values for ticks and counter need to be precomputed.
        let uuid_bytes = [
            0x12, 0x34, 0x56, 0x78, // time_low
            0x34, 0x12,             // time_mid
            0x16, 0x78,             // time_hi with version 1
            0x90, 0xAB,             // clock_seq with variant RFC4122
            0xCD, 0xEF, 0xAB, 0xCD, 0xEF, 0xAB, 0xCD, // node
        ];
        let uuid = Uuid::from_slice(&uuid_bytes).unwrap();

        // Ensure the version and variant are correct for RFC4122
        assert_eq!(uuid.get_version(), Some(Version::Mac));
        assert_eq!(uuid.get_variant(), Variant::RFC4122);

        // Precomputed ticks and counter for the given UUID fields
        let expected_ticks: u64 = ((uuid_bytes[6] as u64 & 0x0F) << 56)
            | ((uuid_bytes[7] as u64) << 48)
            | ((uuid_bytes[4] as u64) << 40)
            | ((uuid_bytes[5] as u64) << 32)
            | ((uuid_bytes[0] as u64) << 24)
            | ((uuid_bytes[1] as u64) << 16)
            | ((uuid_bytes[2] as u64) << 8)
            | uuid_bytes[3] as u64;
        let expected_counter: u16 = ((uuid_bytes[8] as u16 & 0x3F) << 8) | uuid_bytes[9] as u16;

        let (ticks, counter) = decode_rfc4122_timestamp(&uuid);

        assert_eq!(ticks, expected_ticks);
        assert_eq!(counter, expected_counter);
    }
}
False
========================================
    use crate::encode_rfc4122_timestamp; // Use `super` to access the function in the parent module
    use crate::Uuid;

    #[test]
    fn test_encode_rfc4122_timestamp() {
        let ticks = 0x1234_5678_9abc_def0;
        let counter = 0x1234;
        let node_id = [0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc]; // Use an array instead of a reference to an array

        // Construct expected UUID fields
        let time_low = 0x9abc_def0 as u32;
        let time_mid = 0x5678 as u16;
        let time_high_and_version = 0x1234 | (1 << 12);

        let expected_uuid = Uuid::from_fields(
            time_low,
            time_mid,
            time_high_and_version,
            &[
                0x80 | (0x12 & 0x3f),
                0x34,
                0x12,
                0x34,
                0x56,
                0x78,
                0x9a,
                0xbc,
            ],
        );

        let test_uuid = encode_rfc4122_timestamp(ticks, counter, &node_id);

        assert_eq!(test_uuid, expected_uuid, "Encoded UUID does not match expected UUID");
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    #[cfg(all(
        feature = "std",
        any(
            not(feature = "js"),
            not(all(
                target_arch = "wasm32",
                target_vendor = "unknown",
                target_os = "unknown"
            ))
        )
    ))]
    fn test_now() {
        let before = std::time::SystemTime::now();
        let (secs, nanos) = now();
        let after = std::time::SystemTime::now();
        let before_elapsed = before.duration_since(std::time::SystemTime::UNIX_EPOCH).expect("Time went backwards");
        let after_elapsed = after.duration_since(std::time::SystemTime::UNIX_EPOCH).expect("Time went backwards");

        assert!(secs >= before_elapsed.as_secs(), "now() returned time before the test started");
        assert!(secs <= after_elapsed.as_secs(), "now() returned time after the test ended");
        // Ensures that the nanos are within a valid range, a full second has one billion (1e9) nanoseconds.
        assert!(nanos < 1_000_000_000, "now() returned more than 1 second of nanoseconds");
    }
}
True
uuid uuid 98 116
