========================================
    use crate::{Blake2bMac, digest::{Update, FixedOutput, KeyInit}};
    use crate::digest::generic_array::typenum::U64;
    use crate::digest::generic_array::GenericArray;
    use crate::digest::Output;

    #[test]
    fn test_finalize_into() {
        let key = GenericArray::from_slice(b"an example very very secret key.");
        let data = b"input data";
        let mut mac = Blake2bMac::<U64>::new_from_slice(key).unwrap();
        mac.update(data);

        let mut final_res = GenericArray::default();
        Blake2bMac::<U64>::finalize_into(mac, &mut final_res);

        // You need to use an expected hash that actually matches the test data
        let expected = [
            // This expected hash needs to be calculated for the test to be valid
            // Placeholder hash for example purpose, must be generated
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        ];

        assert_eq!(&final_res[..], &expected[..]);
    }

    #[test]
    #[should_panic(expected = "InvalidLength")]
    fn test_finalize_into_invalid_key_length() {
        let key = b"key too long key too long key too long key too long key too long key too long key too long key too long key too long key too long key too long key too long key too long key too long key too long key too long";
        let _ = Blake2bMac::<U64>::new_from_slice(key).unwrap();
    }

    #[test]
    #[should_panic(expected = "InvalidOutputSize")]
    fn test_finalize_into_invalid_output_size() {
        let _ = Blake2bMac::<U64>::new_from_slice(&[]).unwrap();
    }
}
False
========================================
    use crate::Blake2bMac;
    use digest::crypto_common::InvalidLength;
    use digest::crypto_common::Key;
    use digest::crypto_common::KeySizeUser;
    use digest::KeyInit;
    use digest::OutputSizeUser;
    use generic_array::GenericArray;
    use generic_array::typenum::U64;
    use std::vec;

    #[test]
    fn blake2bmac_new_with_correct_key_length() {
        let key_len = <Blake2bMac<U64> as KeySizeUser>::KeySize::to_usize();
        let key = vec![0u8; key_len];
        let key = Key::<Blake2bMac<U64>>::from_exact_iter(key).unwrap();
        let blake2bmac = <Blake2bMac<U64> as KeyInit>::new(&key);
        let blake2bmac2 = <Blake2bMac<U64> as KeyInit>::new(&key);
        assert_eq!(format!("{:?}", blake2bmac), format!("{:?}", blake2bmac2)); // Check that the new instance created as expected
    }

    #[test]
    fn blake2bmac_new_with_invalid_key_length() {
        let key_len = <Blake2bMac<U64> as KeySizeUser>::KeySize::to_usize();
        let invalid_key_len = key_len + 1;
        let key = vec![0u8; invalid_key_len];
        let key = Key::<Blake2bMac<U64>>::from_exact_iter(key);
        assert!(key.is_some(), "Expecting a key with an invalid length to be Some before attempting to create a new instance");
        let key = key.unwrap();
        let blake2bmac = <Blake2bMac<U64> as KeyInit>::new_from_slice(key.as_slice());
        assert!(matches!(blake2bmac, Err(InvalidLength))); // Check that a new instance with invalid key length results in an error
    }
}
False
========================================
    use crate::{Blake2b, Blake2bMac, digest};
    use digest::{InvalidLength, KeyInit, KeySizeUser, OutputSizeUser};
    use generic_array::typenum::U64;

    #[test]
    fn test_new_from_slice_valid_key() {
        let key = [0u8; 64];
        let mac = Blake2bMac::<U64>::new_from_slice(&key);
        assert!(mac.is_ok());
    }

    #[test]
    fn test_new_from_slice_key_too_long() {
        let key = [0u8; 65];
        let mac = Blake2bMac::<U64>::new_from_slice(&key);
        assert!(mac.is_err());
        assert!(matches!(mac.unwrap_err(), InvalidLength));
    }

    #[test]
    fn test_new_from_slice_empty_key() {
        let key = [];
        let mac = Blake2bMac::<U64>::new_from_slice(&key);
        assert!(mac.is_ok());
    }

    #[test]
    fn test_new_from_slice_boundary_key() {
        let key = [0u8; 64];
        let mac = Blake2bMac::<U64>::new_from_slice(&key);
        assert!(mac.is_ok());
    }

    #[test]
    fn test_new_from_slice_key_one_byte_below_boundary() {
        let key = [0u8; 63];
        let mac = Blake2bMac::<U64>::new_from_slice(&key);
        assert!(mac.is_ok());
    }
}
False
========================================
    use super::*; // Adjust import to use local definitions

use crate::*;
    use crate::digest::{Update, FixedOutput, KeyInit};
    use crate::consts::U64; // Adjust the import for the U64 typenum from `consts`

    #[test]
    fn update_functionality() {
        let key = [0u8; 64];
        let mut mac = Blake2bMac::<U64>::new_from_slice(&key).unwrap();
        let input = b"Hello, world!";
        mac.update(input);

        let expected_final = {
            let mut hasher = Blake2b::new_from_slice(&key).unwrap();
            hasher.update(input);
            let result = hasher.finalize_fixed();
            result
        };
        
        let result = mac.finalize_fixed();
        assert_eq!(result[..], expected_final[..]);
    }
}
False
========================================
    use digest::core_api::AlgorithmName;
    use super::*;

use crate::*;
    use std::fmt::Write;
    use std::string::String;

    #[test]
    fn write_alg_name_test() {
        let mut s = String::new();
        let res = write!(&mut s, "{}", crate::Blake2bVarCore);
        assert!(res.is_ok());
        assert_eq!(s, "BLAKE2bVariable"); // Replace "BLAKE2bVariable" with the actual algorithm name as a string.
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::*;
    use digest::core_api::UpdateCore;
    use digest::core_api::BlockSizeUser;
    use digest::generic_array::GenericArray;

    #[test]
    fn update_blocks_test() {
        let key_size = 0;
        let output_size = <Blake2bVarCore as BlockSizeUser>::BlockSize::USIZE;
        let salt = [0u8; 16];
        let personal = [0u8; 16];
        let mut hasher = Blake2bVarCore::new_with_params(&salt, &personal, key_size, output_size);

        let block = GenericArray::<u8, <Blake2bVarCore as BlockSizeUser>::BlockSize>::default();
        let blocks = vec![block; 1];

        hasher.update_blocks(&blocks);
        // Additional test logic if necessary
    }
}
False
========================================
    use crate::Blake2bVarCore;
    use digest::core_api::UpdateCore;
    use digest::core_api::VariableOutputCore;
    use digest::consts::{U64, U128};
    use digest::generic_array::GenericArray;
    use digest::InvalidOutputSize;

    #[test]
    fn test_finalize_variable_core() {
        let mut blake2b = match Blake2bVarCore::new(U64::to_usize()) {
            Ok(blake2b) => blake2b,
            Err(InvalidOutputSize) => panic!("Invalid output size"),
        };

        let mut buffer = blake2b.get_buffer_mut();

        // Update buffer but do not exceed the block size so no blocks get processed,
        // ensuring `t` (the number of bytes processed) is updated only in `finalize_variable_core`
        let input = [0; 64][..blake2b.block_size()].to_vec();
        buffer.update(&input, blake2b.block_size());

        let initial_state = blake2b.clone();
        let mut out = GenericArray::<u8, U128>::default();

        blake2b.finalize_variable_core(buffer, &mut out);

        let mut hasher_after_finalize = blake2b;
        hasher_after_finalize.reset();

        assert_ne!(initial_state, hasher_after_finalize, "Blake2bVarCore state should change after finalizing");
        assert_ne!(&out[..blake2b.output_size()], [0; 64][..blake2b.output_size()], "Output should not be all zeros after finalizing");
    }
}
False
========================================
    use crate::{
        Blake2bVarCore,
        digest::{
            core_api::{
                VariableOutputCore,
            },
        },
    };
    use digest::InvalidOutputSize; // Use the correct path for `InvalidOutputSize`

    #[test]
    fn new_valid_output_size() {
        // Assuming `OutputSize::USIZE` is a public associated constant for `Blake2bVarCore`
        let size = Blake2bVarCore::OutputSize::USIZE;
        assert!(Blake2bVarCore::new(size).is_ok());
    }

    #[test]
    fn new_invalid_output_size() {
        // Assuming `OutputSize::USIZE` is a public associated constant for `Blake2bVarCore`
        let size = Blake2bVarCore::OutputSize::USIZE + 1;
        assert!(matches!(
            Blake2bVarCore::new(size),
            Err(InvalidOutputSize)
        ));
    }
    
    #[test]
    fn new_output_size_zero() {
        // Assuming the minimum output size is 0, otherwise use the appropriate minimum size
        assert!(Blake2bVarCore::new(0).is_ok());
    }
}
False
========================================
    use digest::{FixedOutput, KeyInit, KeySizeUser, OutputSizeUser, Update};
    use crate::{Blake2sMac, Key};
    use digest::generic_array::typenum::U28;
    use digest::generic_array::GenericArray;

    #[test]
    fn test_finalize_into() {
        let key_size = <Blake2sMac<U28> as KeySizeUser>::KeySize::USIZE;
        let key = Key::from([0u8; 32]); // Assuming Blake2s uses 256-bit keys, adjust as necessary
        let mut mac = Blake2sMac::<U28>::new_from_slice(&key).unwrap();
        let data = b"input data";

        mac.update(data);

        let mut result = GenericArray::<u8, <Blake2sMac<U28> as OutputSizeUser>::OutputSize>::default();
        mac.finalize_into(&mut result);

        // The expected hash should be the result of hashing "input data" with Blake2s and the given key
        // This value should be computed independently and filled in here.
        let expected = [0u8; U28::USIZE];
        assert_eq!(result.as_slice(), &expected[..]);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::consts::U32;
    use digest::generic_array::GenericArray;
    use digest::InvalidLength;
    use digest::Key;
    use digest::KeyInit;
    use digest::Mac;
    use digest::Output;

    #[test]
    fn test_new() {
        let key: &[u8] = &[0x00; 32]; // Assuming KeySize::USIZE is 32 for Blake2s
        let key_block: Key<Blake2sMac<U32>> = Key::clone_from_slice(key);
        let mac = <Blake2sMac<U32> as KeyInit>::new(&key_block);
        let mut result = Output::<Blake2sMac<U32>>::default();
        mac.finalize_into(&mut result);
        assert_eq!(result.len(), 32);
    }
}
False
========================================
    use crate::{Blake2sMac, digest::{InvalidLength, KeyInit}};
    use digest::consts::{U16, U32};
    use hex_literal::hex;

    #[test]
    fn new_from_slice_valid_key_length() {
        let key = hex!("000102030405060708090a0b0c0d0e0f10111213");
        let mac = <Blake2sMac<U16> as KeyInit>::new_from_slice(&key);
        assert!(mac.is_ok());
    }

    #[test]
    fn new_from_slice_invalid_key_length() {
        let key = vec![0u8; 33]; // Exceeds U32::USIZE, which should be 32
        let mac = <Blake2sMac<U32> as KeyInit>::new_from_slice(&key);
        assert!(matches!(mac, Err(InvalidLength)));
    }
}
False
========================================
    use crate::Blake2sMac;
    use digest::{Mac, NewMac};
    use generic_array::typenum::U16;
    
    #[test]
    fn update_empty() {
        let mut mac = Blake2sMac::<U16>::new_from_slice(&[]).unwrap();
        mac.update(&[]);
        let result = mac.finalize_reset();
        let mut expected_mac = Blake2sMac::<U16>::new_from_slice(&[]).unwrap();
        expected_mac.update(&[]);
        let expected = expected_mac.finalize_reset();
        assert_eq!(result, expected);
    }
    
    #[test]
    fn update_hello_world() {
        let mut mac = Blake2sMac::<U16>::new_from_slice(&[]).unwrap();
        mac.update(b"hello world");
        let result = mac.finalize_reset();
        let mut expected_mac = Blake2sMac::<U16>::new_from_slice(&[]).unwrap();
        expected_mac.update(b"hello world");
        let expected = expected_mac.finalize_reset();
        assert_eq!(result, expected);
    }
    
    #[test]
    fn update_sequential() {
        let mut mac = Blake2sMac::<U16>::new_from_slice(&[]).unwrap();
        mac.update(b"hello");
        mac.update(b" ");
        mac.update(b"world");
        let result = mac.finalize_reset();
        let mut expected_mac = Blake2sMac::<U16>::new_from_slice(&[]).unwrap();
        expected_mac.update(b"hello world");
        let expected = expected_mac.finalize_reset();
        assert_eq!(result, expected);
    }
    
    #[test]
    fn update_with_key() {
        let key = [0u8; 16];
        let mut mac = Blake2sMac::<U16>::new_from_slice(&key).unwrap();
        mac.update(b"hello world");
        let result = mac.finalize_reset();
        let mut expected_mac = Blake2sMac::<U16>::new_from_slice(&key).unwrap();
        expected_mac.update(b"hello world");
        let expected = expected_mac.finalize_reset();
        assert_eq!(result, expected);
    }
}
False
========================================
    use crate::Blake2sVarCore;
    use digest::core_api::AlgorithmName;
    use std::fmt::Write;

    #[test]
    fn test_write_alg_name() {
        let expected = "Blake2sVarCore"; // Replace with the correct algorithm name if required
        let mut buffer = String::new();
        assert!(<Blake2sVarCore as AlgorithmName>::write_alg_name(&mut buffer).is_ok());
        assert_eq!(expected, buffer);
    }
}
False
========================================
    use crate::Blake2sVarCore;
    use crate::simd::simdty::Simd4;
    use crate::consts::U64;
    use digest::core_api::{Block, BlockSizeUser, UpdateCore};
    use generic_array::GenericArray;
    use typenum::Unsigned;

    #[test]
    fn update_blocks_empty() {
        let mut blake2s_core = Blake2sVarCore::new_with_params(&[], &[], 0, 32);
        let blocks = [];
        blake2s_core.update_blocks(&blocks);
        let expected_t = 0;
        assert_eq!(blake2s_core.t, expected_t);
    }

    #[test]
    fn update_blocks_single() {
        let mut blake2s_core = Blake2sVarCore::new_with_params(&[], &[], 0, 32);
        let block_size = Blake2sVarCore::BlockSize::to_usize();
        let block_data = [0u8; 64];  // Assuming the block size is 64 bytes
        let block_arr = GenericArray::clone_from_slice(&block_data[..block_size]);
        let block = Block::new(block_arr);
        blake2s_core.update_blocks(&[block]);
        let expected_t = block_size as u64;
        assert_eq!(blake2s_core.t, expected_t);
    }

    #[test]
    fn update_blocks_multiple() {
        let mut blake2s_core = Blake2sVarCore::new_with_params(&[], &[], 0, 32);
        let block_size = Blake2sVarCore::BlockSize::to_usize();
        let block_data = [0u8; 64];  // Assuming the block size is 64 bytes
        let block_arr = GenericArray::clone_from_slice(&block_data[..block_size]);
        let block1 = Block::new(block_arr.clone());
        let block2 = Block::new(block_arr);
        blake2s_core.update_blocks(&[block1, block2]);
        let expected_t = (block_size * 2) as u64;
        assert_eq!(blake2s_core.t, expected_t);
    }
}
False
========================================
    use crate::{Blake2sVarCore, simd, simd::simdty::Simd4, block_buffer::BlockBuffer, digest::{Digest, InvalidOutputSize, Output, OutputSizeUser, VariableOutputCore, core_api::{Buffer, UpdateCore, TruncSide}}};
    use generic_array::GenericArray;
    use core::convert::TryInto;

    #[test]
    fn test_finalize_variable_core() {
        let output_size = Blake2sVarCore::OutputSize::to_usize();
        let mut core = Blake2sVarCore::new_with_params(&[], &[], 0, output_size).unwrap();
        let mut buffer = BlockBuffer::<Blake2sVarCore::BlockSize, simd::buffer::Lazy>::default();
        let mut output = GenericArray::default();
        
        // Update the buffer with some data
        let data = b"The quick brown fox jumps over the lazy dog";
        let blocks_n = data.len() / Blake2sVarCore::BlockSize::to_usize();
        
        // Process full blocks
        core.update_blocks(&buffer.blocks(data));
        
        // Process remaining data
        let rem = &data[blocks_n * Blake2sVarCore::BlockSize::to_usize()..];
        buffer.update_blocks(rem.try_into().unwrap());
        
        // Finalize and check the output
        core.finalize_variable_core(&mut buffer, &mut output);
        
        let result = output.as_slice();
        let expected_result = GenericArray::clone_from_slice(&[
            0xF3, 0x64, 0xC5, 0x80, 0x3E, 0xC2, 0x2A, 0x21, 
            0x3A, 0x2B, 0x4A, 0x0E, 0xA5, 0x8D, 0x5B, 0xCD, 
            0xCA, 0x05, 0x2E, 0x8B, 0x92, 0x07, 0x89, 0x6F, 
            0xEF, 0xF8, 0xFD, 0xF6, 0x1F, 0x61, 0xCF, 0xE3,
        ]);

        assert_eq!(result, expected_result);
    }
}
False
========================================
    use crate::Blake2sVarCore;
    use digest::core_api::{VariableOutputCore, InvalidOutputSize};

    #[test]
    fn test_new_valid_output_size() {
        for i in 1..=Blake2sVarCore::OutputSize::USIZE {
            assert!(Blake2sVarCore::new(i).is_ok());
        }
    }

    #[test]
    fn test_new_invalid_output_size() {
        assert!(matches!(
            Blake2sVarCore::new(Blake2sVarCore::OutputSize::USIZE + 1),
            Err(InvalidOutputSize)
        ));
    }
}
False
========================================
    use crate::AsBytes; // Ensure AsBytes trait is in scope
    use std::slice;

    #[test]
    fn test_as_bytes_with_u32_slice() {
        let slice: &[u32] = &[0x12345678, 0x90ABCDEF];
        let bytes = AsBytes::as_bytes(slice);
        assert_eq!(
            bytes,
            &[0x78, 0x56, 0x34, 0x12, 0xEF, 0xCD, 0xAB, 0x90]
        );
    }

    #[test]
    fn test_as_bytes_with_empty_slice() {
        let slice: &[u32] = &[];
        let bytes = AsBytes::as_bytes(slice);
        assert_eq!(bytes, &[]);
    }
}
True
========================================
    use super::*;

use crate::*;
    use std::slice;
    use std::mem;

    #[test]
    fn test_as_mut_bytes() {
        // Create a mutable slice of T
        let mut data: [i32; 4] = [1, 2, 3, 4];
        let data_len = data.len() * mem::size_of::<i32>();

        // Use the as_mut_bytes method
        let byte_slice = data.as_mut_bytes();

        // Check the resulting slice length
        assert_eq!(byte_slice.len(), data_len);

        // Check the resulting slice contents
        let expected_bytes: [u8; 16] = [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0];
        assert_eq!(byte_slice, expected_bytes);

        // Modify the byte slice
        byte_slice[0] = 0xFF;

        // Check that the original data slice was updated
        assert_eq!(data[0], -1);
    }
}
True
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_from_le() {
        let original = simd::simdty::Simd4::new(0x11223344, 0x55667788, 0x99AABBCC, 0xDDEEFF00);
        let result = <simd::simdty::Simd4<u32> as simd::Vector4<u32>>::from_le(original);

        // Manually assert equality of each element since Simd4<u32> doesn't implement PartialEq
        assert_eq!((original.0, original.1, original.2, original.3), (result.0, result.1, result.2, result.3));
    }
}
True
========================================
    use super::*;

use crate::*;
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4;

    #[test]
    fn gather_test() {
        let src = [1u32, 2, 3, 4, 5, 6, 7, 8];
        let i0 = 1;
        let i1 = 3;
        let i2 = 5;
        let i3 = 7;
        let result = Simd4::gather(&src, i0, i1, i2, i3);
        let expected = Simd4::new(src[i0], src[i1], src[i2], src[i3]);
        assert_eq!(result, expected);
    }
}
False
========================================
    use crate::simd::{Vector4, simdty::Simd4};

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct TestSimd4(pub u32, pub u32, pub u32, pub u32);

    impl From<Simd4<u32>> for TestSimd4 {
        fn from(item: Simd4<u32>) -> Self {
            TestSimd4(item.0, item.1, item.2, item.3)
        }
    }

    #[test]
    fn test_rotate_right_const() {
        let vector = Simd4::new(0x12345678, 0x12345678, 0x12345678, 0x12345678);
        let rotation: u32 = 8;
        let expected = TestSimd4(0x78123456, 0x78123456, 0x78123456, 0x78123456);
        let result = <Simd4<u32> as Vector4<u32>>::rotate_right_const(vector, rotation).into();
        assert_eq!(result, expected);
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4;

    impl PartialEq for Simd4<u32> {
        fn eq(&self, other: &Self) -> bool {
            self.0 == other.0 && self.1 == other.1 && self.2 == other.2 && self.3 == other.3
        }
    }
    
    #[test]
    fn test_shuffle_left_1() {
        let original = Simd4::new(1u32, 2u32, 3u32, 4u32);
        let shuffled = Vector4::<u32>::shuffle_left_1(&original);
        let expected = Simd4::new(2u32, 3u32, 4u32, 1u32);
        assert_eq!(shuffled, expected);
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4; // Import the Vector4 trait to use its methods

    #[test]
    fn shuffle_left_2_test() {
        let initial_vec = Simd4::new(1u32, 2u32, 3u32, 4u32);
        let expected_vec = Simd4::new(3u32, 4u32, 1u32, 2u32);
        let result_vec = Vector4::shuffle_left_2(initial_vec);
        assert_eq!(result_vec, expected_vec);
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4; // adjust import for Vector4

    #[test]
    fn shuffle_left_3_test() {
        let original = Simd4::new(0u32, 1u32, 2u32, 3u32);
        let shuffled = Simd4::shuffle_left_3(original); // use associated function directly
        assert_eq!(shuffled, Simd4::new(3u32, 0u32, 1u32, 2u32));
    }
}
False
========================================
    use crate::simd::{simdty::Simd4, Vector4};
    
    #[cfg(target_endian = "little")] // Ensure tests only run on little-endian systems
    #[test]
    fn test_to_le() {
        let vec = Simd4::new(0x01020304, 0x05060708, 0x0A0B0C0D, 0x0E0F1011);
        let vec_le = <Simd4<u32> as Vector4<u32>>::to_le(vec);
        assert_eq!(vec, vec_le);
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4;
    
    #[derive(Debug, Clone, Copy, PartialEq)]
    struct TestWrapper(Simd4<u32>);

    #[test]
    fn test_wrapping_add() {
        let a = TestWrapper(Simd4::new(0u32, 1u32, 2u32, 3u32));
        let b = TestWrapper(Simd4::new(4u32, 3u32, 2u32, 1u32));
        let result = TestWrapper(a.0.wrapping_add(b.0));
        assert_eq!(result, TestWrapper(Simd4::new(4u32, 4u32, 4u32, 4u32)));
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4; // Trait must be in scope to use from_le

    #[test]
    fn test_from_le() {
        // Little-endian platforms only
        #[cfg(target_endian = "little")]
        {
            // Assuming that Simd4 implements PartialEq to use == operator
            // Otherwise, we'd need to manually compare each element
            let original = Simd4::new(0x0123456789ABCDEF, 0x0123456789ABCDEF, 0x0123456789ABCDEF, 0x0123456789ABCDEF);
            let converted = <Simd4<u64> as Vector4<u64>>::from_le(original); // Change from Simd4::from_le to use trait method
            assert_eq!(original, converted);
        }
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4;

    #[test]
    fn gather_test() {
        let source = [1u64, 2, 3, 4, 5, 6, 7, 8];
        let gathered = Simd4::gather(&source, 2, 4, 6, 7);
        let expected = Simd4::new(3, 5, 7, 8);
        assert!(gathered.0 == expected.0 && gathered.1 == expected.1 && gathered.2 == expected.2 && gathered.3 == expected.3);
    }
}
True
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4; // Assume Vector4 is the trait containing the `rotate_right_const` method
    use core::fmt::Debug; // Needed to use the `assert_eq!` macro with `Simd4`

    // Define the `PartialEq` trait for `Simd4` to use `assert_eq!`
    impl PartialEq for Simd4<u64> {
        fn eq(&self, other: &Self) -> bool {
            self.0 == other.0 && self.1 == other.1 && self.2 == other.2 && self.3 == other.3
        }
    }

    // Implement `Debug` manually to use the `assert_eq!` macro when the `Debug` trait is required
    impl Debug for Simd4<u64> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_tuple("Simd4")
                .field(&self.0)
                .field(&self.1)
                .field(&self.2)
                .field(&self.3)
                .finish()
        }
    }

    #[test]
    fn rotate_right_const_test() {
        let vector = Simd4::new(0x0123456789ABCDEFu64, 0xFEDCBA9876543210u64, 0x0F0F0F0F0F0F0F0Fu64, 0xF0F0F0F0F0F0F0F0u64);
        let result = vector.rotate_right_const(16);
        let expected = Simd4::new(0xEF0123456789ABCDu64, 0x10FEDCBA98765432u64, 0x0F0F0F0F0F0F0F0Fu64, 0xF0F0F0F0F0F0F0F0u64);
        assert_eq!(result, expected, "Vector should be correctly rotated");
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4;

    #[test]
    fn test_shuffle_left_1() {
        let original = Simd4::new(1u64, 2, 3, 4);
        let expected = Simd4::new(2u64, 3, 4, 1);
        let result = Vector4::shuffle_left_1(original);
        assert!(result.0 == expected.0 && result.1 == expected.1 && result.2 == expected.2 && result.3 == expected.3);
    }
}
True
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4; // Trait import for `shuffle_left_2`
    
    #[test]
    fn shuffle_left_2_works() {
        let original = Simd4::new(1u64, 2u64, 3u64, 4u64);
        let shuffled = original.shuffle_left_2();
        let expected = Simd4::new(3u64, 4u64, 1u64, 2u64);
        assert_eq!(shuffled, expected);
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4; // Add this use statement to bring Vector4 into scope

    #[test]
    fn test_shuffle_left_3() {
        let vec = Simd4::new(1u64, 2u64, 3u64, 4u64);
        let shuffled_vec = Simd4::shuffle_left_3(vec);
        assert_eq!(shuffled_vec, Simd4::new(4u64, 1u64, 2u64, 3u64));
    }
}
False
========================================
    use super::*;

use crate::*;

    #[test]
    fn test_to_le() {
        let original = simd::simdty::Simd4::new(1u64, 2u64, 3u64, 4u64);
        let converted = original.to_le();
        assert_eq!((original.0).to_le(), (converted.0).to_le());
        assert_eq!((original.1).to_le(), (converted.1).to_le());
        assert_eq!((original.2).to_le(), (converted.2).to_le());
        assert_eq!((original.3).to_le(), (converted.3).to_le());
    }
}
True
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::Vector4; // Add this use statement

    #[test]
    fn wrapping_add() {
        let a = Simd4::new(1u64, 2u64, 3u64, 4u64);
        let b = Simd4::new(u64::MAX, 1u64, u64::MAX - 2, u64::MAX - 3);
        
        let result = a.wrapping_add(b);
        let expected = Simd4::new(0u64, 3u64, 1u64, 1u64); // assuming wrapping add

        assert_eq!(result, expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::{Blake2b, Blake2bMac, Blake2s, Blake2sMac, InvalidLength};
    use generic_array::typenum::{U64, U32};
    
    #[test]
    fn test_blake2b_new_with_salt_and_personal_valid_length() {
        let key = [0u8; Blake2b::OUTBYTES];
        let salt = [0u8; Blake2b::OUTBYTES / 4];
        let personal = [0u8; Blake2b::OUTBYTES / 4];
        assert!(Blake2bMac::<U64>::new_with_salt_and_personal(&key, &salt, &personal).is_ok());
    }

    #[test]
    fn test_blake2b_new_with_salt_and_personal_invalid_key_length() {
        let key = [0u8; Blake2b::OUTBYTES + 1];
        let salt = [0u8; Blake2b::OUTBYTES / 4];
        let personal = [0u8; Blake2b::OUTBYTES / 4];
        assert!(Blake2bMac::<U64>::new_with_salt_and_personal(&key, &salt, &personal).is_err());
    }

    #[test]
    fn test_blake2b_new_with_salt_and_personal_invalid_salt_length() {
        let key = [0u8; Blake2b::OUTBYTES];
        let salt = [0u8; Blake2b::OUTBYTES / 4 + 1];
        let personal = [0u8; Blake2b::OUTBYTES / 4];
        assert!(Blake2bMac::<U64>::new_with_salt_and_personal(&key, &salt, &personal).is_err());
    }

    #[test]
    fn test_blake2b_new_with_salt_and_personal_invalid_personal_length() {
        let key = [0u8; Blake2b::OUTBYTES];
        let salt = [0u8; Blake2b::OUTBYTES / 4];
        let personal = [0u8; Blake2b::OUTBYTES / 4 + 1];
        assert!(Blake2bMac::<U64>::new_with_salt_and_personal(&key, &salt, &personal).is_err());
    }

    #[test]
    fn test_blake2s_new_with_salt_and_personal_valid_length() {
        let key = [0u8; Blake2s::OUTBYTES];
        let salt = [0u8; Blake2s::OUTBYTES / 4];
        let personal = [0u8; Blake2s::OUTBYTES / 4];
        assert!(Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &personal).is_ok());
    }

    #[test]
    fn test_blake2s_new_with_salt_and_personal_invalid_key_length() {
        let key = [0u8; Blake2s::OUTBYTES + 1];
        let salt = [0u8; Blake2s::OUTBYTES / 4];
        let personal = [0u8; Blake2s::OUTBYTES / 4];
        assert!(Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &personal).is_err());
    }

    #[test]
    fn test_blake2s_new_with_salt_and_personal_invalid_salt_length() {
        let key = [0u8; Blake2s::OUTBYTES];
        let salt = [0u8; Blake2s::OUTBYTES / 4 + 1];
        let personal = [0u8; Blake2s::OUTBYTES / 4];
        assert!(Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &personal).is_err());
    }

    #[test]
    fn test_blake2s_new_with_salt_and_personal_invalid_personal_length() {
        let key = [0u8; Blake2s::OUTBYTES];
        let salt = [0u8; Blake2s::OUTBYTES / 4];
        let personal = [0u8; Blake2s::OUTBYTES / 4 + 1];
        assert!(Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &personal).is_err());
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::Blake2bVarCore;
    use digest::{Update, VariableOutput};
    use digest::consts::U64;
    use digest::generic_array::GenericArray;
    use arrayref::array_ref;

    #[test]
    fn test_compress() {
        // Create a new Blake2bVarCore instance
        let mut engine = Blake2bVarCore::new_with_params(&[], &[], 0, 64).unwrap();

        // Create a block of data to compress
        let block_array: [u8; 128] = [0u8; 128];
        let block: &GenericArray<u8, U64> = GenericArray::from_slice(array_ref!(block_array, 0, 64));

        // Retrieve initial state for later comparison
        let initial_state = engine.clone();

        // Define dummy Block, f0, f1
        let f0 = 0;
        let f1 = 0;

        // Compress the block
        engine.compress(block, f0, f1);

        // Since f0, f1, and block are all zeros, the state should remain the same
        assert_ne!(engine, initial_state, "State should change after compression");
    }
}
False
========================================
    use super::*;

use crate::*;

    use crate::simd::simdty::Simd4;
    use crate::blake2b::Blake2bVarCore;

    #[test]
    fn test_quarter_round() {
        let mut v = [
            Simd4::new(0u32, 0u32, 0u32, 0u32),
            Simd4::new(1u32, 1u32, 1u32, 1u32),
            Simd4::new(2u32, 2u32, 2u32, 2u32),
            Simd4::new(3u32, 3u32, 3u32, 3u32),
        ];
        let m = Simd4::new(0xdeadbeefu32, 0xdeadbeefu32, 0xdeadbeefu32, 0xdeadbeefu32);
        let rd: u32 = 16;
        let rb: u32 = 12;

        // Expected outcome calculated using the quarter_round logic
        let mut expected = [
            Simd4::new(0, 0, 0, 0),
            Simd4::new(1, 1, 1, 1),
            Simd4::new(2, 2, 2, 2),
            Simd4::new(3, 3, 3, 3),
        ];
        expected[0] = expected[0].wrapping_add(expected[1]).wrapping_add(m);
        expected[3] = (expected[3] ^ expected[0]).rotate_right(rd);
        expected[2] = expected[2].wrapping_add(expected[3]);
        expected[1] = (expected[1] ^ expected[2]).rotate_right(rb);
        
        // Since we can't access the compress::quarter_round function directly,
        // the following call should be replaced with the actual testable path to quarter_round
        // As an example this could be through the Blake2bVarCore::new() function or any other
        // public interface that ultimately calls quarter_round. You'll need to adjust this
        // to the appropriate function call that provides access to quarter_round.
        
        // Blake2bVarCore::compress::quarter_round(&mut v, rd, rb, m);

        assert_eq!(v, expected, "The quarter_round function did not produce the expected result.");
    }
}
False
========================================
    use crate::Blake2bVarCore;
    use crate::simd::simdty::Simd4;
    use crate::simd::gather::gather;

    #[test]
    fn test_round() {
        const R1: usize = 16;
        const R2: usize = 12;
        const R3: usize = 8;
        const R4: usize = 7;

        fn shuffle(v: &mut [Simd4<u64>; 4]) {
            // Dummy shuffle function assuming shuffle is defined elsewhere
            // This is just for compilation purposes. Please replace with actual shuffle function.
        }

        fn unshuffle(v: &mut [Simd4<u64>; 4]) {
            // Dummy unshuffle function assuming unshuffle is defined elsewhere
            // This is just for compilation purposes. Please replace with actual unshuffle function.
        }

        fn quarter_round(v: &mut [Simd4<u64>; 4], r1: usize, r2: usize, gathered: Simd4<u64>) {
            // Dummy quarter_round function assuming quarter_round is defined elsewhere
            // This is just for compilation purposes. Please replace with actual quarter_round function.
        }

        let mut v = [
            Simd4::new(0u64, 0u64, 0u64, 0u64),
            Simd4::new(1u64, 1u64, 1u64, 1u64),
            Simd4::new(2u64, 2u64, 2u64, 2u64),
            Simd4::new(3u64, 3u64, 3u64, 3u64),
        ];
        let m = [
            0u64, 1u64, 2u64, 3u64, 4u64, 5u64, 6u64, 7u64,
            8u64, 9u64, 10u64, 11u64, 12u64, 13u64, 14u64, 15u64,
        ];
        let s = [
            0, 1, 2, 3, 4, 5, 6, 7,
            8, 9, 10, 11, 12, 13, 14, 15,
        ];

        let initial_v = v.clone();
        let initial_m = m.clone();
        let initial_s = s.clone();

        // Inline the round function for testing purposes
        {
            quarter_round(&mut v, R1, R2, gather(&m, s[0], s[2], s[4], s[6]));
            quarter_round(&mut v, R3, R4, gather(&m, s[1], s[3], s[5], s[7]));

            shuffle(&mut v);
            quarter_round(&mut v, R1, R2, gather(&m, s[8], s[10], s[12], s[14]));
            quarter_round(&mut v, R3, R4, gather(&m, s[9], s[11], s[13], s[15]));
            unshuffle(&mut v);
        }

        assert_ne!(v, initial_v, "Round function should modify the state `v`.");
        assert_eq!(m, initial_m, "The message `m` should remain unchanged.");
        assert_eq!(s, initial_s, "The schedule `s` should remain unchanged.");
    }
}
False
========================================
    use crate::Blake2bVarCore;
    use crate::simd::simdty::Simd4;
    use crate::as_bytes::Safe;
    use std::fmt::Debug;
    use std::marker::Copy;
    use std::clone::Clone;
    
    #[derive(Clone, Copy, Debug)]
    struct DummySafe(u32);

    unsafe impl Safe for DummySafe {}

    trait ShuffleLanes {
        fn shuffle_left_1(self) -> Self;
        fn shuffle_left_2(self) -> Self;
        fn shuffle_left_3(self) -> Self;
    }

    impl ShuffleLanes for Simd4<DummySafe> {
        fn shuffle_left_1(self) -> Self {
            Simd4(self.1, self.2, self.3, self.0)
        }

        fn shuffle_left_2(self) -> Self {
            Simd4(self.2, self.3, self.0, self.1)
        }

        fn shuffle_left_3(self) -> Self {
            Simd4(self.3, self.0, self.1, self.2)
        }
    }

    #[test]
    fn test_shuffle() {
        let mut vector = [
            Simd4::new(DummySafe(0), DummySafe(1), DummySafe(2), DummySafe(3)),
            Simd4::new(DummySafe(4), DummySafe(5), DummySafe(6), DummySafe(7)),
            Simd4::new(DummySafe(8), DummySafe(9), DummySafe(10), DummySafe(11)),
            Simd4::new(DummySafe(12), DummySafe(13), DummySafe(14), DummySafe(15)),
        ];

        // Since the shuffle function is part of the Blake2bVarCore::compress, we need to
        // scope the shuffle function call correctly.
        // It is important to ensure that the actual shuffle implementation is visible
        // in the scope where we use Blake2bVarCore::compress::shuffle.
        Blake2bVarCore::compress::shuffle(&mut vector);

        assert_eq!(vector[0], Simd4::new(DummySafe(0), DummySafe(1), DummySafe(2), DummySafe(3)));
        assert_eq!(vector[1], Simd4::new(DummySafe(5), DummySafe(6), DummySafe(7), DummySafe(4)));
        assert_eq!(vector[2], Simd4::new(DummySafe(10), DummySafe(11), DummySafe(8), DummySafe(9)));
        assert_eq!(vector[3], Simd4::new(DummySafe(15), DummySafe(12), DummySafe(13), DummySafe(14)));
    }
}
False
========================================
    use crate::blake2b::Blake2bVarCore;
    use crate::simd::simdty::Simd4;

    #[test]
    fn test_unshuffle() {
        let mut v = [
            Simd4::new(0, 1, 2, 3),
            Simd4::new(4, 5, 6, 7),
            Simd4::new(8, 9, 10, 11),
            Simd4::new(12, 13, 14, 15),
        ];
        let expected = [
            Simd4::new(0, 1, 2, 3), // unchanged
            Simd4::new(7, 4, 5, 6), // right rotated by 1
            Simd4::new(10, 11, 8, 9), // right rotated by 2
            Simd4::new(13, 14, 15, 12), // right rotated by 3
        ];

        // Apply the `unshuffle` operation
        Blake2bVarCore::compress::unshuffle(&mut v);

        // Ensure that each element in the array `v` matches the expected value
        assert_eq!(v, expected, "unshuffle did not produce the expected output");
    }
}
False
========================================
    use crate::{Blake2bVarCore, UpdateCore, VariableOutputCore};
    use digest::{
        generic_array::typenum::Unsigned, generic_array::GenericArray, Digest, FixedOutput,
        HashMarker, Update
    };
    use simd::simdty::Simd4;

    #[test]
    fn test_finalize_with_flag() {
        let mut blake2b = Blake2bVarCore::<Simd4<u64>>::new_with_params(&[], &[], 0, 64);

        let data = [0; 64];
        let mut hasher = blake2b.clone();
        hasher.update(&data);

        let expected = hasher.finalize_fixed();

        let flag = Simd4::<u64>::new(0, 0, !0, !0);
        let mut final_block = GenericArray::clone_from_slice(&data);
        let mut output = GenericArray::default();
        blake2b.finalize_with_flag(&final_block, flag, &mut output);

        assert_eq!(output.as_slice(), expected.as_slice());
    }
}
False
========================================
    use crate::Blake2bVarCore;
    use crate::simd::simdty::Simd4;

    const IV: [u64; 4] = [
        0x6A09E667F3BCC908,
        0xBB67AE8584CAA73B,
        0x3C6EF372FE94F82B,
        0xA54FF53A5F1D36F1,
    ];

    #[test]
    fn test_iv0() {
        let iv0 = Blake2bVarCore::iv0();
        assert_eq!(iv0, Simd4::new(IV[0], IV[1], IV[2], IV[3]));
    }
}
False
========================================
    use crate::Blake2bVarCore;
    use crate::simd::simdty::Simd4;

    const IV: [u64; 8] = [
        0x6a09e667f3bcc908,
        0xbb67ae8584caa73b,
        0x3c6ef372fe94f82b,
        0xa54ff53a5f1d36f1,
        0x510e527fade682d1,
        0x9b05688c2b3e6c1f,
        0x1f83d9abfb41bd6b,
        0x5be0cd19137e2179,
    ];

    #[test]
    fn test_iv1() {
        let expected = Simd4(IV[4], IV[5], IV[6], IV[7]);
        let result = Blake2bVarCore::iv1();

        assert_eq!(result.0, expected.0);
        assert_eq!(result.1, expected.1);
        assert_eq!(result.2, expected.2);
        assert_eq!(result.3, expected.3);
    }
}
False
========================================
    use super::*;

use crate::*;
    use digest::Digest;
    use typenum::U64;

    #[test]
    fn test_new_with_params() {
        let salt = b"my salt";
        let persona = b"personalization";
        let key_size = 32;
        let output_size = 64;
        let blake = Blake2bVarCore::<U64>::new_with_params(salt, persona, key_size, output_size);

        let expected_output_size = <Blake2bVarCore<U64> as digest::OutputSizeUser>::output_size();
        assert_eq!(expected_output_size, output_size);

        let mut hasher1 = Blake2bVarCore::<U64>::new_with_params(salt, persona, key_size, output_size);
        let mut hasher2 = Blake2bVarCore::<U64>::new_with_params(b"other salt", persona, key_size, output_size);

        hasher1.update(b"some message");
        hasher2.update(b"some message");

        let result1 = hasher1.finalize();
        let result2 = hasher2.finalize();

        assert_ne!(result1, result2);
    }
}
False
========================================
    use crate::digest::InvalidLength;
    use crate::Blake2sMac;
    use crate::digest::KeyInit;
    use typenum::U32;

    // Successful creation test
    #[test]
    fn test_new_with_salt_and_personal_success() {
        let key = [0u8; 16];
        let salt = [0u8; 8];
        let persona = [0u8; 8];
        let _mac = Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &persona).unwrap();
    }

    // Key too long test
    #[test]
    fn test_new_with_salt_and_personal_key_too_long() {
        let key = [0u8; 32 + 1]; // Blake2s block size is 64 bytes, but max key length is 32
        let salt = [0u8; 8];
        let persona = [0u8; 8];
        assert!(Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &persona).is_err());
    }

    // Salt too long test
    #[test]
    fn test_new_with_salt_and_personal_salt_too_long() {
        let key = [0u8; 16];
        let salt = [0u8; 8 + 1]; // Quarter of block size is 16 bytes, so max salt is 8 bytes
        let persona = [0u8; 8];
        assert!(Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &persona).is_err());
    }

    // Persona too long test
    #[test]
    fn test_new_with_salt_and_personal_persona_too_long() {
        let key = [0u8; 16];
        let salt = [0u8; 8];
        let persona = [0u8; 8 + 1]; // Quarter of block size is 16 bytes, so max persona is 8 bytes
        assert!(Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &persona).is_err());
    }

    // All parameters too long test
    #[test]
    fn test_new_with_salt_and_personal_all_too_long() {
        let key = [0u8; 32 + 1]; // Blake2s block size is 64 bytes, but max key length is 32
        let salt = [0u8; 8 + 1]; // Quarter of block size is 16 bytes, so max salt is 8 bytes
        let persona = [0u8; 8 + 1]; // Quarter of block size is 16 bytes, so max persona is 8 bytes
        assert!(Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &persona).is_err());
    }

    // Test with valid lengths but non-zero values
    #[test]
    fn test_new_with_salt_and_personal_valid_non_zero() {
        let key = [1u8; 16];
        let salt = [1u8; 8];
        let persona = [1u8; 8];
        let _mac = Blake2sMac::<U32>::new_with_salt_and_personal(&key, &salt, &persona).unwrap();
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::simd::simdty::Simd4;
    use crate::consts::{SIGMA, IV};
    use crate::{Block, BlockSizeUser, VariableOutputCore};
    use digest::generic_array::GenericArray;
    use digest::Digest;

    #[test]
    fn test_compress() {
        let block = Block::<Blake2sVarCore>::default();
        let mut hasher = Blake2sVarCore::new_with_params(&[], &[], 0, Blake2sVarCore::OutputSize::to_usize()).unwrap();
        let initial_hash = hasher.clone();

        let f0: u32 = 0;
        let f1: u32 = 0;
        hasher.compress(&block, f0, f1);

        // Provide expected hash values or logic to derive expected values
        let expected_hash = initial_hash; // Replace with expected hash calculation or values
        assert_ne!(hasher, expected_hash, "Hasher states should be different after compression");
        // Extend with additional assertions and test cases as needed
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::Blake2sVarCore;

    #[test]
    fn test_quarter_round() {
        let mut v: [Simd4<u32>; 4] = [
            Simd4::new(0, 0, 0, 0),
            Simd4::new(1, 1, 1, 1),
            Simd4::new(2, 2, 2, 2),
            Simd4::new(3, 3, 3, 3),
        ];

        let rd: u32 = 16;
        let rb: u32 = 12;
        let m: Simd4<u32> = Simd4::new(13, 13, 13, 13);

        let expected_v0 = Simd4::new(
            v[0].0.wrapping_add(v[1].0).wrapping_add(m.0),
            v[0].1.wrapping_add(v[1].1).wrapping_add(m.1),
            v[0].2.wrapping_add(v[1].2).wrapping_add(m.2),
            v[0].3.wrapping_add(v[1].3).wrapping_add(m.3),
        );

        let expected_v3 = Simd4::new(
            (v[3].0 ^ expected_v0.0).rotate_right(rd),
            (v[3].1 ^ expected_v0.1).rotate_right(rd),
            (v[3].2 ^ expected_v0.2).rotate_right(rd),
            (v[3].3 ^ expected_v0.3).rotate_right(rd),
        );

        let expected_v2 = Simd4::new(
            v[2].0.wrapping_add(expected_v3.0),
            v[2].1.wrapping_add(expected_v3.1),
            v[2].2.wrapping_add(expected_v3.2),
            v[2].3.wrapping_add(expected_v3.3),
        );

        let expected_v1 = Simd4::new(
            (v[1].0 ^ expected_v2.0).rotate_right(rb),
            (v[1].1 ^ expected_v2.1).rotate_right(rb),
            (v[1].2 ^ expected_v2.2).rotate_right(rb),
            (v[1].3 ^ expected_v2.3).rotate_right(rb),
        );

        Blake2sVarCore::compress::quarter_round(&mut v, rd, rb, m);

        assert_eq!(v[0], expected_v0, "v[0] did not match expected value");
        assert_eq!(v[1], expected_v1, "v[1] did not match expected value");
        assert_eq!(v[2], expected_v2, "v[2] did not match expected value");
        assert_eq!(v[3], expected_v3, "v[3] did not match expected value");
    }
}
False
========================================
    use crate::Blake2sVarCore;

    #[test]
    fn test_round() {
        let mut v = [
            crate::simd::simdty::Simd4::new(1u32, 2u32, 3u32, 4u32),
            crate::simd::simdty::Simd4::new(5u32, 6u32, 7u32, 8u32),
            crate::simd::simdty::Simd4::new(9u32, 10u32, 11u32, 12u32),
            crate::simd::simdty::Simd4::new(13u32, 14u32, 15u32, 16u32),
        ];
        let m = [
            0u32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        ];
        let s = [
            0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
        ];

        Blake2sVarCore::compress::round(&mut v, &m, &s);

        // Expected values should be determined based on actual functionality
        // These assertions should be replaced with actual expected values
        assert_eq!(v[0], crate::simd::simdty::Simd4::new(1u32, 2u32, 3u32, 4u32));
        assert_eq!(v[1], crate::simd::simdty::Simd4::new(5u32, 6u32, 7u32, 8u32));
        assert_eq!(v[2], crate::simd::simdty::Simd4::new(9u32, 10u32, 11u32, 12u32));
        assert_eq!(v[3], crate::simd::simdty::Simd4::new(13u32, 14u32, 15u32, 16u32));
    }
}
False
========================================
    use crate::blake2s::Blake2sVarCore;
    use crate::simd::simdty::Simd4;
    use crate::as_bytes::Safe;

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    struct TestSafe(u32);

    unsafe impl Safe for TestSafe {}

    #[inline(always)]
    fn shuffle_left_1(v: TestSafe) -> TestSafe {
        TestSafe(v.0.rotate_left(8))
    }

    #[inline(always)]
    fn shuffle_left_2(v: TestSafe) -> TestSafe {
        TestSafe(v.0.rotate_left(16))
    }

    #[inline(always)]
    fn shuffle_left_3(v: TestSafe) -> TestSafe {
        TestSafe(v.0.rotate_left(24))
    }

    impl Simd4<TestSafe> {
        #[inline(always)]
        pub fn shuffle_left_1(&self) -> Simd4<TestSafe> {
            Simd4(shuffle_left_1(self.0), shuffle_left_1(self.1), shuffle_left_1(self.2), shuffle_left_1(self.3))
        }

        #[inline(always)]
        pub fn shuffle_left_2(&self) -> Simd4<TestSafe> {
            Simd4(shuffle_left_2(self.0), shuffle_left_2(self.1), shuffle_left_2(self.2), shuffle_left_2(self.3))
        }
        #[inline(always)]
        pub fn shuffle_left_3(&self) -> Simd4<TestSafe> {
            Simd4(shuffle_left_3(self.0), shuffle_left_3(self.1), shuffle_left_3(self.2), shuffle_left_3(self.3))
        }
    }

    #[test]
    fn test_shuffle() {
        let mut data: [Simd4<TestSafe>; 4] = [
            Simd4::new(TestSafe(0), TestSafe(1), TestSafe(2), TestSafe(3)),
            Simd4::new(TestSafe(4), TestSafe(5), TestSafe(6), TestSafe(7)),
            Simd4::new(TestSafe(8), TestSafe(9), TestSafe(10), TestSafe(11)),
            Simd4::new(TestSafe(12), TestSafe(13), TestSafe(14), TestSafe(15)),
        ];

        Blake2sVarCore::compress::shuffle(&mut data);

        assert_eq!(
            data,
            [
                Simd4::new(TestSafe(0), TestSafe(1), TestSafe(2), TestSafe(3)),
                Simd4::new(TestSafe(5), TestSafe(6), TestSafe(7), TestSafe(4)),
                Simd4::new(TestSafe(10), TestSafe(11), TestSafe(8), TestSafe(9)),
                Simd4::new(TestSafe(15), TestSafe(12), TestSafe(13), TestSafe(14))
            ]
        );
    }
}
False
========================================
    use super::*; // Adjusted import to use super::* to import items from the parent module

use crate::*;

    #[test]
    fn test_unshuffle() {
        // Adjust the definitions to match the types used in the `unshuffle` function
        // Assuming `Simd4` is defined in the `simd` module, and elements are of `u32` type
        let mut v = [
            Simd4::<u32>::new(0x00, 0x01, 0x02, 0x03),
            Simd4::<u32>::new(0x10, 0x11, 0x12, 0x13),
            Simd4::<u32>::new(0x20, 0x21, 0x22, 0x23),
            Simd4::<u32>::new(0x30, 0x31, 0x32, 0x33),
        ];

        // Assuming the `shuffle_right_` methods perform a circular shift
        let expected = [
            Simd4::<u32>::new(0x00, 0x01, 0x02, 0x03),
            Simd4::<u32>::new(0x11, 0x12, 0x13, 0x10),
            Simd4::<u32>::new(0x22, 0x23, 0x20, 0x21),
            Simd4::<u32>::new(0x33, 0x30, 0x31, 0x32),
        ];

        // Adjusted the call to match the function's signature
        // Assuming `unshuffle` is a method of the `Blake2sVarCore::compress` module
        Blake2sVarCore::compress::unshuffle(&mut v);

        assert_eq!(v, expected, "unshuffle does not produce the expected result");
    }
}
False
========================================
    use super::*;

use crate::*;
    use digest::generic_array::GenericArray;
    use digest::generic_array::typenum::U32;
    use digest::generic_array::typenum::U64;
    use digest::Output;

    type BlockSize = U64;
    type OutputSize = U32;
    type Word = u32;

    #[test]
    fn test_finalize_with_flag() {
        let key = [];
        let salt = [];
        let personal = [];
        let key_size = 0;
        let output_size = 32;

        let mut hasher = Blake2sVarCore::new_with_params(&salt, &personal, key_size, output_size);
        let data = b"some data to hash";
        hasher.update(&data[..]);

        let final_block = GenericArray::<u8, BlockSize>::default();
        let flag: Word = 1;
        let mut output = GenericArray::<u8, OutputSize>::default();

        hasher.finalize_with_flag(&final_block, flag, &mut output);
        
        let expected_output = GenericArray::<u8, OutputSize>::default();
        for i in 0..OutputSize::USIZE {
            assert_eq!(output[i], expected_output[i], "Mismatch at byte {}", i);
        }
    }
}
False
========================================
    // Ensure that the simd crate is available; otherwise, the test should import the correct path/module.
    use crate::simd::simdty::Simd4;
    use crate::Blake2sVarCore;

    // To access `$IV`, the test must either define the constant array `IV` or use the one from the `Blake2sVarCore`.
    // For the purpose of this example, let's define it directly in the test module.
    // You should replace it with the appropriate import or definition from `Blake2sVarCore`.
    const IV: [u32; 4] = [
        0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
    ];

    // Because `Simd4` does not implement `PartialEq` by default, we need a manual equality check.
    // We will implement a helper function for the equality check.
    impl<T: PartialEq> PartialEq for Simd4<T> {
        fn eq(&self, other: &Self) -> bool {
            self.0 == other.0 && self.1 == other.1 && self.2 == other.2 && self.3 == other.3
        }
    }

    // Implement `Debug` for `Simd4` to use the `assert_eq!` macro, this is just for the purpose of testing.
    impl<T: std::fmt::Debug> std::fmt::Debug for Simd4<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_tuple("Simd4")
                .field(&self.0)
                .field(&self.1)
                .field(&self.2)
                .field(&self.3)
                .finish()
        }
    }

    #[test]
    fn test_iv0() {
        let iv0_result = Blake2sVarCore::iv0();
        let iv0_expected = Simd4::new(IV[0], IV[1], IV[2], IV[3]);
        assert_eq!(iv0_result, iv0_expected, "iv0 did not return the expected Simd4 value.");
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::consts::IV;

    #[test]
    fn test_iv1() {
        let expected = Simd4::new(IV[4], IV[5], IV[6], IV[7]);
        assert_eq!(super::Blake2sVarCore::iv1(), expected);
    }
}
False
========================================
    use super::*;

use crate::*;
    use crate::simd::simdty::Simd4 as Vec;
    use crate::simd::Simd;
    use digest::generic_array::GenericArray;
    use digest::typenum::U32 as Bytes;
    use digest::{InvalidOutputSize, UpdateCore, VariableOutputCore};

    #[test]
    fn test_new_with_params() {
        let salt = [1, 2, 3, 4, 5, 6, 7, 8];
        let persona = [1, 2, 3, 4, 5, 6, 7, 8];
        let key_size = 32; // Maximum key size
        let output_size = 32; // Maximum output size
        let instance = Blake2sVarCore::new_with_params(&salt, &persona, key_size, output_size);

        // Verify the initial values set by `new_with_params`.
        // These will have to be adjusted based on the actual initial vectors.
        let iv0 = Blake2sVarCore::iv0();
        let iv1 = Blake2sVarCore::iv1();
        assert_eq!(instance.h[0].0, iv0 .0^ 0x0101_0020); // Check parameter block is set
        // Add more assertions based on the exact behavior that needs to be verified
        // ...
    }

    #[test]
    fn test_new_with_params_small_salt_and_persona() {
        let salt = [1, 2, 3, 4];
        let persona = [1, 2];
        let key_size = 16; // Smaller than maximum
        let output_size = 16; // Smaller than maximum
        let instance = Blake2sVarCore::new_with_params(&salt, &persona, key_size, output_size);

        // Verify the initial values set by `new_with_params` with smaller inputs.
        // Adjust assertions based on actual behavior and requirements.
        // ...
    }

    #[test]
    #[should_panic]
    fn test_new_with_params_invalid_key_size() {
        let salt = [1, 2, 3, 4];
        let persona = [1, 2];
        let key_size = 33; // Invalid key size
        let output_size = 16;
        let _instance = Blake2sVarCore::new_with_params(&salt, &persona, key_size, output_size);
    }

    #[test]
    #[should_panic]
    fn test_new_with_params_invalid_output_size() {
        let salt = [1, 2, 3, 4];
        let persona = [1, 2];
        let key_size = 32;
        let output_size = 33; // Invalid output size
        let _instance = Blake2sVarCore::new_with_params(&salt, &persona, key_size, output_size);
    }

    #[test]
    #[should_panic]
    fn test_new_with_params_invalid_salt_length() {
        let salt = [0; 33]; // More than 32 bytes
        let persona = [1, 2];
        let key_size = 32;
        let output_size = 32;
        let _instance = Blake2sVarCore::new_with_params(&salt, &persona, key_size, output_size);
    }

    #[test]
    #[should_panic]
    fn test_new_with_params_invalid_persona_length() {
        let salt = [1, 2, 3, 4];
        let persona = [0; 33]; // More than 32 bytes
        let key_size = 32;
        let output_size = 32;
        let _instance = Blake2sVarCore::new_with_params(&salt, &persona, key_size, output_size);
    }
}
False
========================================
    use crate::simd::Vector4;

    #[test]
    fn test_shuffle_right_1() {
        let vec = Vector4::new(1, 2, 3, 4);
        let shuffled_vec = vec.shuffle_right_1();
        let expected_vec = Vector4::new(4, 1, 2, 3);
        assert_eq!(shuffled_vec, expected_vec);
    }
}
False
========================================
    use crate::Vector4; // Correctly bring Vector4 into scope

    #[test]
    fn test_shuffle_right_2() {
        // Assume Vector4 is a concrete type with a specific size type, e.g., u32
        // Example test case for shuffle_right_2
        let input = Vector4::<u32>::new(1, 2, 3, 4); // Assuming u32 is the type Vector4 uses

        // Call the method to be tested
        let result = input.shuffle_right_2();

        // Expected result after shuffle_right_2, assuming it is similar to shuffle_left_2 but reversed
        let expected = Vector4::<u32>::new(3, 4, 1, 2); // Assuming u32 is the type Vector4 uses

        // Check that the result matches the expected output
        assert_eq!(result, expected, "Vector values after shuffle_right_2 should be the expected ones");
    }
}
False
========================================
    use crate::simd::Vector4; // Assumed use path based on file structure

    #[test]
    fn test_shuffle_right_3() {
        let vec4 = Vector4::<u32>::new(1, 2, 3, 4); // Adjusted to use a concrete type, assuming Vector4 is generic over some type like u32
        let shuffled_vec4 = vec4.shuffle_right_3();
        let expected_vec4 = Vector4::<u32>::new(4, 1, 2, 3); // Adjusted expected values to match proper shuffle_right_3 behavior
        assert_eq!(shuffled_vec4, expected_vec4);
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::simd_opt::u32x4::rotate_right_const;
    use crate::as_bytes::Safe;

    #[derive(PartialEq, Debug)]
    struct TestWrapper(Simd4<u32>);

    impl TestWrapper {
        fn new(e0: u32, e1: u32, e2: u32, e3: u32) -> Self {
            TestWrapper(Simd4::new(e0, e1, e2, e3))
        }
    }

    #[test]
    fn test_rotate_right_const() {
        let original = TestWrapper::new(0x12345678, 0x9abcdef0, 0x0fedcba9, 0x87654321);
        let rotated = TestWrapper(rotate_right_const(original.0, 8));

        assert_eq!(rotated, TestWrapper::new(0x78123456, 0xf09abcde, 0xa90fedcb, 0x21876543));
    }
}
False
========================================
    use crate::simd::simd_opt::u64x4::rotate_right_const;
    use crate::simd::simdty::Simd4;

    #[test]
    fn test_rotate_right_func() {
        let vec = Simd4::new(0x1234567890ABCDEF, 0x1234567890ABCDEF, 0x1234567890ABCDEF, 0x1234567890ABCDEF);
        let rotated_by_16 = Simd4::new(0xEF90ABCD56781234, 0xEF90ABCD56781234, 0xEF90ABCD56781234, 0xEF90ABCD56781234);
        let rotated_by_32 = Simd4::new(0x7890ABCDEF123456, 0x7890ABCDEF123456, 0x7890ABCDEF123456, 0x7890ABCDEF123456);
        let rotated_by_48 = Simd4::new(0xCDEF567890AB1234, 0xCDEF567890AB1234, 0xCDEF567890AB1234, 0xCDEF567890AB1234);
        let rotated_by_64 = vec;

        assert!(rotate_right_const(vec, 16).0.rotate_right(16) == rotated_by_16.0);
        assert!(rotate_right_const(vec, 32).0.rotate_right(32) == rotated_by_32.0);
        assert!(rotate_right_const(vec, 48).0.rotate_right(48) == rotated_by_48.0);
        assert!(rotate_right_const(vec, 64).0.rotate_right(64) == rotated_by_64.0);
        assert!(rotate_right_const(vec, 0).0 == vec.0);
    }
}
True
========================================
    use crate::simd::simdty::Simd4;
    use core::ops::Add;

    #[test]
    fn test_add() {
        let a = Simd4::new(1u32, 2u32, 3u32, 4u32);
        let b = Simd4::new(5u32, 6u32, 7u32, 8u32);
        let result = a.add(b);
        assert_eq!(result, Simd4::new(6u32, 8u32, 10u32, 12u32));
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::simdop;

    #[test]
    fn test_add() {
        let a = simdop::Simd4::new(1u64, 2u64, 3u64, 4u64);
        let b = simdop::Simd4::new(5u64, 6u64, 7u64, 8u64);
        let result = simdop::Simd4::add(a, b);
        assert_eq!(result, Simd4::new(6u64, 8u64, 10u64, 12u64));
    }
}
False
========================================
    use crate::simd::simdty::Simd4;

    #[test]
    fn test_bitxor() {
        let a = Simd4::new(1u32, 2u32, 4u32, 8u32);
        let b = Simd4::new(2u32, 3u32, 1u32, 15u32);
        let expected = Simd4::new(1u32 ^ 2u32, 2u32 ^ 3u32, 4u32 ^ 1u32, 8u32 ^ 15u32);
        let result = a.bitxor(b);
        assert_eq!(expected.0, result.0);
        assert_eq!(expected.1, result.1);
        assert_eq!(expected.2, result.2);
        assert_eq!(expected.3, result.3);
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::simdop::BitXor;
    use core::ops::BitXor;

    #[test]
    fn bitxor_test() {
        let a = Simd4::new(0u64, 1u64, 2u64, 3u64);
        let b = Simd4::new(0u64, 0u64, 0u64, 0u64);
        let c = Simd4::new(0u64, 1u64, 2u64, 3u64);
        let result = a.bitxor(b);

        assert_eq!(result.0, c.0);
        assert_eq!(result.1, c.1);
        assert_eq!(result.2, c.2);
        assert_eq!(result.3, c.3);
    }
}
False
========================================
    use super::*; // assuming the simdop module includes the required use statements for Simd4 and shl

use crate::*;

    // Helper function to compare Simd4 values as the PartialEq trait may not be implemented
    fn assert_simd4_eq<T: core::cmp::Eq + core::fmt::Debug>(
        a: simd::simdty::Simd4<T>,
        b: simd::simdty::Simd4<T>,
    ) {
        assert_eq!(a.0, b.0);
        assert_eq!(a.1, b.1);
        assert_eq!(a.2, b.2);
        assert_eq!(a.3, b.3);
    }

    #[test]
    fn test_shl() {
        let a = simd::simdty::Simd4::new(1u32, 2u32, 4u32, 8u32);
        let b = simd::simdty::Simd4::new(1u32, 1u32, 2u32, 3u32);
        let result = a.shl(b);
        assert_simd4_eq(result, simd::simdty::Simd4::new(2u32, 4u32, 16u32, 64u32));
    }
}
True
========================================
    use crate::simdty::Simd4;
    use core::ops::Shl;

    #[test]
    fn shl_simd4_u64() {
        let a = Simd4::new(1u64, 2u64, 3u64, 4u64);
        let b = Simd4::new(1u64, 1u64, 1u64, 1u64);
        let result = a.shl(b);
        assert_eq!(result, Simd4::new(2u64, 4u64, 6u64, 8u64));

        let a = Simd4::new(4u64, 8u64, 12u64, 16u64);
        let b = Simd4::new(2u64, 2u64, 2u64, 2u64);
        let result = a.shl(b);
        assert_eq!(result, Simd4::new(16u64, 32u64, 48u64, 64u64));

        let a = Simd4::new(1u64, 1u64, 1u64, 1u64);
        let b = Simd4::new(0u64, 0u64, 0u64, 0u64);
        let result = a.shl(b);
        assert_eq!(result, Simd4::new(1u64, 1u64, 1u64, 1u64));

        // Test bitwise left shifting by a large number
        let a = Simd4::new(0x1u64, 0x1u64, 0x1u64, 0x1u64);
        let b = Simd4::new(63u64, 62u64, 61u64, 60u64);
        let result = a.shl(b);
        assert_eq!(
            result,
            Simd4::new(0x8000000000000000u64, 0x4000000000000000u64, 0x2000000000000000u64, 0x1000000000000000u64)
        );
    }
}
False
========================================
    use crate::simd::simdty::Simd4;
    use crate::simd::simdop::Shr; // Corrected import path with proper trait name

    #[test]
    fn test_shr() {
        let a = Simd4::new(8u32, 16u32, 32u32, 64u32);
        let b = Simd4::new(1u32, 2u32, 3u32, 4u32);
        let result = a.shr(b);
        assert_eq!(result, Simd4::new(8u32 >> 1, 16u32 >> 2, 32u32 >> 3, 64u32 >> 4));
    }
}
False
========================================
    use crate::simd::simdop::Shr;
    use crate::simd::simdty::Simd4;

    #[test]
    fn test_shr() {
        let a = Simd4::new(0xFFFF_FFFF_FFFF_FFFFu64, 0xFFFF_FFFF_FFFF_FFFFu64, 0xFFFF_FFFF_FFFF_FFFFu64, 0xFFFF_FFFF_FFFF_FFFFu64);
        let b = Simd4::new(1u64, 2u64, 4u64, 8u64);
        let result = a.shr(b);
        assert_eq!(result, Simd4::new(0x7FFF_FFFF_FFFF_FFFFu64, 0x3FFF_FFFF_FFFF_FFFFu64, 0x0FFF_FFFF_FFFF_FFFFu64, 0x00FF_FFFF_FFFF_FFFFu64));
    }
}
False
========================================
    use crate::simd::simdty::Simd4;

    #[test]
    fn test_simd4_new() {
        let e0 = 1;
        let e1 = 2;
        let e2 = 3;
        let e3 = 4;
        let simd = Simd4::new(e0, e1, e2, e3);

        assert_eq!(simd.0, e0);
        assert_eq!(simd.1, e1);
        assert_eq!(simd.2, e2);
        assert_eq!(simd.3, e3);
    }
}
True
hashes blake2 9 68
