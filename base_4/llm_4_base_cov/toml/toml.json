{"dependencies":{"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"<&'s T as value::Index>::index":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<&'s T as value::Index>::index_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::MapAccess","std::marker::Sized","std::option::Option","std::result::Result","value::MapDeserializer"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","serde::de::Error","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","std::marker::Sized","std::result::Result"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","std::marker::Sized","std::result::Result"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i32":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","std::marker::Sized","std::result::Result"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","std::marker::Sized","std::result::Result"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","serde::de::MapAccess","std::marker::Sized","std::option::Option","std::result::Result","value::MapDeserializer"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","serde::de::SeqAccess","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::IntoIter","value::SeqDeserializer"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","de::Deserializer","serde::Deserializer","std::marker::Sized","std::result::Result"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","std::marker::Sized","std::result::Result"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","std::marker::Sized","std::result::Result","std::string::String"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u32":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","std::marker::Sized","std::result::Result"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","de::Error","serde::de::Error","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::Error as serde::de::Error>::custom":["de::Error","std::fmt::Display","std::marker::Sized","toml_edit::de::Error"],"<de::Error as std::clone::Clone>::clone":["de::Error","toml_edit::de::Error"],"<de::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["de::Error","toml_edit::de::Error"],"<de::Error as std::cmp::PartialEq>::eq":["de::Error","toml_edit::de::Error"],"<de::Error as std::fmt::Debug>::fmt":["de::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"<de::Error as std::fmt::Display>::fmt":["de::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ValueDeserializer","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<fmt::DocumentFormatter as std::clone::Clone>::clone":["fmt::DocumentFormatter"],"<fmt::DocumentFormatter as std::default::Default>::default":["fmt::DocumentFormatter"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_array_mut":["fmt::DocumentFormatter","toml_edit::Array"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_document_mut":["fmt::DocumentFormatter","toml_edit::Document"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_item_mut":["fmt::DocumentFormatter","toml_edit::Item"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_table_mut":["fmt::DocumentFormatter","toml_edit::Table"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_value_mut":["fmt::DocumentFormatter","toml_edit::Value"],"<map::IntoIter as std::iter::DoubleEndedIterator>::next_back":["de::Error","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized","std::option::Option","toml_edit::de::Error"],"<map::IntoIter as std::iter::ExactSizeIterator>::len":["de::Error","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized","toml_edit::de::Error"],"<map::IntoIter as std::iter::Iterator>::next":["de::Error","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized","std::option::Option","toml_edit::de::Error"],"<map::IntoIter as std::iter::Iterator>::size_hint":["de::Error","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized","std::option::Option","toml_edit::de::Error"],"<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized","std::option::Option"],"<map::Iter<'a> as std::iter::ExactSizeIterator>::len":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized"],"<map::Iter<'a> as std::iter::Iterator>::next":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized","std::option::Option"],"<map::Iter<'a> as std::iter::Iterator>::size_hint":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized","std::option::Option"],"<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized","std::option::Option"],"<map::IterMut<'a> as std::iter::ExactSizeIterator>::len":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized"],"<map::IterMut<'a> as std::iter::Iterator>::next":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized","std::option::Option"],"<map::IterMut<'a> as std::iter::Iterator>::size_hint":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized","std::option::Option"],"<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized","std::option::Option"],"<map::Keys<'a> as std::iter::ExactSizeIterator>::len":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized"],"<map::Keys<'a> as std::iter::Iterator>::next":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized","std::option::Option"],"<map::Keys<'a> as std::iter::Iterator>::size_hint":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized","std::option::Option"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":["de::Deserializer","serde::Deserializer","std::marker::Sized","std::result::Result"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"],"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":["de::Error","fmt::DocumentFormatter","map::Map","ser::Serializer","serde::Serializer","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"<map::Map<std::string::String, value::Value> as std::default::Default>::default":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::iter::IntoIterator","std::marker::Sized","toml_edit::de::Error"],"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::iter::IntoIterator","std::marker::Sized","toml_edit::de::Error"],"<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["map::Values","std::collections::btree_map::Values","std::marker::Sized","std::option::Option"],"<map::Values<'a> as std::iter::ExactSizeIterator>::len":["map::Values","std::collections::btree_map::Values","std::marker::Sized"],"<map::Values<'a> as std::iter::Iterator>::next":["map::Values","std::collections::btree_map::Values","std::marker::Sized","std::option::Option"],"<map::Values<'a> as std::iter::Iterator>::size_hint":["map::Values","std::collections::btree_map::Values","std::marker::Sized","std::option::Option"],"<ser::Error as serde::ser::Error>::custom":["de::Error","ser::Error","std::fmt::Display","std::marker::Sized","toml_edit::de::Error","toml_edit::ser::Error"],"<ser::Error as std::clone::Clone>::clone":["ser::Error","toml_edit::ser::Error"],"<ser::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["ser::Error","toml_edit::ser::Error"],"<ser::Error as std::cmp::PartialEq>::eq":["ser::Error","toml_edit::ser::Error"],"<ser::Error as std::fmt::Debug>::fmt":["ser::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","toml_edit::ser::Error"],"<ser::Error as std::fmt::Display>::fmt":["ser::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","toml_edit::ser::Error"],"<ser::Serializer<'d> as serde::Serializer>::serialize_bool":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_bytes":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_char":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_f32":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_f64":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i16":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i32":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i64":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i8":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_map":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_struct":["de::Error","fmt::DocumentFormatter","map::Map","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_variant":["de::Error","fmt::DocumentFormatter","map::Map","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::Serializer<'d> as serde::Serializer>::serialize_none":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_seq":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_some":["de::Error","fmt::DocumentFormatter","map::Map","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::Serializer<'d> as serde::Serializer>::serialize_str":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_struct":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_struct_variant":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_struct":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_variant":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u16":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u32":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u64":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u8":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit_struct":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit_variant":["fmt::DocumentFormatter","ser::Serializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bool":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bytes":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_char":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f32":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f64":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i16":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i32":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i64":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i8":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_map":["ser::ValueSerializer","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_struct":["de::Error","map::Map","ser::ValueSerializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_variant":["de::Error","map::Map","ser::ValueSerializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_none":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_seq":["ser::ValueSerializer","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_some":["de::Error","map::Map","ser::ValueSerializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_str":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct_variant":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_struct":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_variant":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u16":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u32":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u64":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u8":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_struct":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_variant":["ser::ValueSerializer","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::end":["fmt::DocumentFormatter","ser::internal::SerializeDocumentArray","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::serialize_element":["de::Error","fmt::DocumentFormatter","map::Map","ser::internal::SerializeDocumentArray","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::end":["fmt::DocumentFormatter","ser::internal::SerializeDocumentArray","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::serialize_element":["de::Error","fmt::DocumentFormatter","map::Map","ser::internal::SerializeDocumentArray","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::end":["fmt::DocumentFormatter","ser::internal::SerializeDocumentArray","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":["de::Error","fmt::DocumentFormatter","map::Map","ser::internal::SerializeDocumentArray","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::end":["fmt::DocumentFormatter","ser::internal::SerializeDocumentArray","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":["de::Error","fmt::DocumentFormatter","map::Map","ser::internal::SerializeDocumentArray","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::end":["fmt::DocumentFormatter","ser::internal::SerializeDocumentTable","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_key":["de::Error","fmt::DocumentFormatter","map::Map","ser::internal::SerializeDocumentTable","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_value":["de::Error","fmt::DocumentFormatter","map::Map","ser::internal::SerializeDocumentTable","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::end":["fmt::DocumentFormatter","ser::internal::SerializeDocumentTable","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::serialize_field":["de::Error","fmt::DocumentFormatter","map::Map","ser::internal::SerializeDocumentTable","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::end":["ser::internal::SerializeValueArray","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::serialize_element":["de::Error","map::Map","ser::internal::SerializeValueArray","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::end":["ser::internal::SerializeValueArray","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::serialize_element":["de::Error","map::Map","ser::internal::SerializeValueArray","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::end":["ser::internal::SerializeValueArray","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":["de::Error","map::Map","ser::internal::SerializeValueArray","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::end":["ser::internal::SerializeValueArray","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":["de::Error","map::Map","ser::internal::SerializeValueArray","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::end":["ser::internal::SerializeValueTable","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_key":["de::Error","map::Map","ser::internal::SerializeValueTable","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_value":["de::Error","map::Map","ser::internal::SerializeValueTable","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::end":["ser::internal::SerializeValueTable","std::marker::Sized","std::result::Result","std::string::String"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::serialize_field":["de::Error","map::Map","ser::internal::SerializeValueTable","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error"],"<std::string::String as value::Index>::index":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<std::string::String as value::Index>::index_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<str as value::Index>::index":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<str as value::Index>::index_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<usize as value::Index>::index":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<usize as value::Index>::index_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::deserialize":["de::Deserializer","serde::Deserializer","std::marker::Sized","std::result::Result","std::string::String","value::DatetimeOrTable"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","value::DatetimeOrTable"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_str":["de::Error","serde::de::Error","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error","value::DatetimeOrTable"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_string":["de::Error","serde::de::Error","std::marker::Sized","std::result::Result","std::string::String","toml_edit::de::Error","value::DatetimeOrTable"],"<value::MapDeserializer as serde::de::EnumAccess<'de>>::variant_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","value::DatetimeOrTable","value::MapDeserializer"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","value::DatetimeOrTable","value::MapDeserializer"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","value::DatetimeOrTable","value::MapDeserializer"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::size_hint":["std::marker::Sized","std::option::Option","value::MapDeserializer"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":["de::Error","map::Map","serde::de::DeserializeSeed","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::DatetimeOrTable","value::MapEnumDeserializer","value::Value"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::MapEnumDeserializer","value::Value"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::MapEnumDeserializer","value::Value"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::MapEnumDeserializer","value::Value"],"<value::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":["serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::string::String","std::vec::IntoIter","value::DatetimeOrTable","value::SeqDeserializer"],"<value::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::IntoIter","value::SeqDeserializer"],"<value::SerializeMap as serde::ser::SerializeMap>::end":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap"],"<value::SerializeMap as serde::ser::SerializeMap>::serialize_key":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap"],"<value::SerializeMap as serde::ser::SerializeMap>::serialize_value":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap"],"<value::SerializeMap as serde::ser::SerializeStruct>::end":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap"],"<value::SerializeMap as serde::ser::SerializeStruct>::serialize_field":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap"],"<value::TableSerializer as serde::Serializer>::serialize_bool":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_bytes":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_char":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_f32":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_f64":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_i16":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_i32":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_i64":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_i8":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_map":["std::marker::Sized","std::option::Option","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_newtype_struct":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_newtype_variant":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_none":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_seq":["std::marker::Sized","std::option::Option","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_some":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_str":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_struct":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_struct_variant":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_tuple":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_tuple_struct":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_tuple_variant":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_u16":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_u32":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_u64":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_u8":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_unit":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_unit_struct":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::TableSerializer as serde::Serializer>::serialize_unit_variant":["std::marker::Sized","std::result::Result","value::TableSerializer"],"<value::Value as serde::Deserialize<'de>>::deserialize":["de::Deserializer","serde::Deserializer","std::marker::Sized","std::result::Result"],"<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor":["<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor"],"<value::Value as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::Serialize>::serialize":["de::Error","fmt::DocumentFormatter","map::Map","ser::Serializer","serde::Serializer","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::clone::Clone>::clone":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::cmp::PartialEq>::eq":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<&'a str>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<bool>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<f32>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<f64>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<i32>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<i64>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<i8>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<map::Map<std::string::String, value::Value>>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<std::collections::BTreeMap<S, V>>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<std::collections::HashMap<S, V>>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::HashMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<std::string::String>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<std::vec::Vec<V>>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<toml_datetime::Datetime>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<u32>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::convert::From<u8>>::from":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::fmt::Debug>::fmt":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::fmt::Display>::fmt":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::ops::Index<I>>::index":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::ops::IndexMut<I>>::index_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"<value::Value as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::end":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap","value::ValueSerializeMap"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_key":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap","value::ValueSerializeMap"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_value":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap","value::ValueSerializeMap"],"<value::ValueSerializeMap as serde::ser::SerializeStruct>::end":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap","value::ValueSerializeMap"],"<value::ValueSerializeMap as serde::ser::SerializeStruct>::serialize_field":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","toml_edit::de::Error","value::SerializeMap","value::ValueSerializeMap"],"<value::ValueSerializeVec as serde::ser::SerializeSeq>::end":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::ValueSerializeVec"],"<value::ValueSerializeVec as serde::ser::SerializeSeq>::serialize_element":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::vec::Vec","toml_edit::de::Error","value::ValueSerializeVec"],"<value::ValueSerializeVec as serde::ser::SerializeTuple>::end":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::ValueSerializeVec"],"<value::ValueSerializeVec as serde::ser::SerializeTuple>::serialize_element":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::vec::Vec","toml_edit::de::Error","value::ValueSerializeVec"],"<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::end":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::ValueSerializeVec"],"<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::vec::Vec","toml_edit::de::Error","value::ValueSerializeVec"],"<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::end":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::ValueSerializeVec"],"<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::serialize_field":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::vec::Vec","toml_edit::de::Error","value::ValueSerializeVec"],"<value::ValueSerializer as serde::Serializer>::serialize_bool":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_bytes":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_char":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_f32":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_f64":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_i16":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_i32":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_i64":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_i8":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_map":["std::marker::Sized","std::option::Option","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_newtype_struct":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_newtype_variant":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_none":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_seq":["std::marker::Sized","std::option::Option","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_some":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_str":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_struct":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_struct_variant":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple_struct":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple_variant":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_u16":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_u32":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_u64":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_u8":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_unit":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_unit_struct":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"<value::ValueSerializer as serde::Serializer>::serialize_unit_variant":["std::marker::Sized","std::result::Result","value::ValueSerializer"],"de::Deserializer":["de::Deserializer"],"de::Deserializer::<'a>::new":["de::Deserializer"],"de::Error":["de::Error","toml_edit::de::Error"],"de::Error::add_key":["de::Error","std::string::String","toml_edit::de::Error"],"de::Error::message":["de::Error","toml_edit::de::Error"],"de::Error::new":["de::Error","toml_edit::de::Error"],"de::Error::span":["de::Error","std::marker::Sized","std::option::Option","toml_edit::de::Error"],"de::ValueDeserializer":["de::ValueDeserializer"],"de::ValueDeserializer::<'a>::new":["de::ValueDeserializer"],"de::from_str":["serde::de::DeserializeOwned","std::marker::Sized","std::result::Result"],"fmt::DocumentFormatter":["fmt::DocumentFormatter"],"macros::insert_toml":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"macros::push_toml":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"macros::traverse":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::Entry":["de::Error","map::Entry","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized","toml_edit::de::Error"],"map::Entry::<'a>::key":["de::Error","map::Entry","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized","std::string::String","toml_edit::de::Error"],"map::Entry::<'a>::or_insert":["de::Error","map::Entry","map::Map","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::Entry::<'a>::or_insert_with":["de::Error","map::Entry","map::Map","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized","std::ops::FnOnce","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::IntoIter":["de::Error","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized","toml_edit::de::Error"],"map::Iter":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized"],"map::IterMut":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized"],"map::Keys":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized"],"map::Map":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::clear":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::contains_key":["de::Error","map::Map","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::entry":["de::Error","map::Entry","map::Map","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::convert::Into","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::get":["de::Error","map::Map","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","std::option::Option","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::get_mut":["de::Error","map::Map","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","std::option::Option","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::insert":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::Map::<std::string::String, value::Value>::is_empty":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::iter":["de::Error","map::Iter","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::Iter","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::iter_mut":["de::Error","map::IterMut","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::IterMut","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::keys":["de::Error","map::Keys","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::Keys","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::len":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::new":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::remove":["de::Error","map::Map","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","std::option::Option","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::values":["de::Error","map::Map","map::Values","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::Values","std::marker::Sized","toml_edit::de::Error"],"map::Map::<std::string::String, value::Value>::with_capacity":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"map::OccupiedEntry":["de::Error","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::marker::Sized","toml_edit::de::Error"],"map::OccupiedEntry::<'a>::get":["de::Error","map::Map","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::OccupiedEntry::<'a>::get_mut":["de::Error","map::Map","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::OccupiedEntry::<'a>::insert":["de::Error","map::Map","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::OccupiedEntry::<'a>::into_mut":["de::Error","map::Map","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::OccupiedEntry::<'a>::key":["de::Error","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","toml_edit::de::Error"],"map::OccupiedEntry::<'a>::remove":["de::Error","map::Map","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::VacantEntry":["de::Error","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::VacantEntry","std::marker::Sized","toml_edit::de::Error"],"map::VacantEntry::<'a>::insert":["de::Error","map::Map","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::VacantEntry","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"map::VacantEntry::<'a>::key":["de::Error","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::VacantEntry","std::marker::Sized","std::string::String","toml_edit::de::Error"],"map::Values":["map::Values","std::collections::btree_map::Values","std::marker::Sized"],"ser::Error":["ser::Error","toml_edit::ser::Error"],"ser::Error::key_not_string":["ser::Error","toml_edit::ser::Error"],"ser::Error::new":["de::Error","ser::Error","std::fmt::Display","std::marker::Sized","toml_edit::de::Error","toml_edit::ser::Error"],"ser::Error::unsupported_none":["ser::Error","toml_edit::ser::Error"],"ser::Error::unsupported_type":["ser::Error","std::marker::Sized","std::option::Option","toml_edit::ser::Error"],"ser::Error::wrap":["ser::Error","toml_edit::ser::Error"],"ser::Serializer":["fmt::DocumentFormatter","ser::Serializer","std::string::String"],"ser::Serializer::<'d>::new":["fmt::DocumentFormatter","ser::Serializer","std::string::String"],"ser::Serializer::<'d>::pretty":["fmt::DocumentFormatter","ser::Serializer","std::string::String"],"ser::ValueSerializer":["ser::ValueSerializer","std::string::String"],"ser::ValueSerializer::<'d>::new":["ser::ValueSerializer","std::string::String"],"ser::internal::SerializeDocumentArray":["fmt::DocumentFormatter","ser::internal::SerializeDocumentArray","std::string::String"],"ser::internal::SerializeDocumentArray::<'d>::new":["fmt::DocumentFormatter","ser::Serializer","ser::internal::SerializeDocumentArray","std::string::String"],"ser::internal::SerializeDocumentTable":["fmt::DocumentFormatter","ser::internal::SerializeDocumentTable","std::string::String"],"ser::internal::SerializeDocumentTable::<'d>::new":["fmt::DocumentFormatter","ser::Serializer","ser::internal::SerializeDocumentTable","std::string::String"],"ser::internal::SerializeValueArray":["ser::internal::SerializeValueArray","std::string::String"],"ser::internal::SerializeValueArray::<'d>::new":["ser::ValueSerializer","ser::internal::SerializeValueArray","std::string::String"],"ser::internal::SerializeValueTable":["ser::internal::SerializeValueTable","std::string::String"],"ser::internal::SerializeValueTable::<'d>::new":["ser::ValueSerializer","ser::internal::SerializeValueTable","std::string::String"],"ser::internal::write_document":["fmt::DocumentFormatter","std::marker::Sized","std::result::Result","std::string::String"],"ser::internal::write_value":["std::marker::Sized","std::result::Result","std::string::String"],"ser::to_string":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"ser::to_string_pretty":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl map::Map<std::string::String, value::Value>>::try_from":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl map::Map<std::string::String, value::Value>>::try_into":["de::Error","map::Map","serde::Deserialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Error","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl serde::de::IntoDeserializer<'de, de::Error> for map::Map<std::string::String, value::Value>>::into_deserializer":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","toml_edit::de::Error"],"table::<impl std::fmt::Display for map::Map<std::string::String, value::Value>>::fmt":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"table::<impl std::str::FromStr for map::Map<std::string::String, value::Value>>::from_str":["std::marker::Sized","std::result::Result"],"value::DatetimeOrTable":["std::string::String","value::DatetimeOrTable"],"value::Index::index":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Index::index_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::MapDeserializer":["std::marker::Sized","std::option::Option","value::MapDeserializer"],"value::MapDeserializer::new":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","toml_edit::de::Error","value::MapDeserializer"],"value::MapEnumDeserializer":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::MapEnumDeserializer","value::Value"],"value::MapEnumDeserializer::new":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::MapEnumDeserializer","value::Value"],"value::SeqDeserializer":["std::alloc::Allocator","std::marker::Sized","std::vec::IntoIter","value::SeqDeserializer"],"value::SeqDeserializer::new":["std::alloc::Allocator","std::marker::Sized","std::vec::IntoIter","std::vec::Vec","value::SeqDeserializer"],"value::SerializeMap":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","toml_edit::de::Error","value::SerializeMap"],"value::TableSerializer":["value::TableSerializer"],"value::Value":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_array":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_array_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_bool":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_datetime":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_float":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_integer":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_str":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_table":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::as_table_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::get":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Index","value::Value"],"value::Value::get_mut":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Index","value::Value"],"value::Value::is_array":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::is_bool":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::is_datetime":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::is_float":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::is_integer":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::is_str":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::is_table":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::same_type":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::try_from":["de::Error","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","toml_edit::de::Error"],"value::Value::try_into":["de::Error","map::Map","serde::Deserialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::Value::type_str":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","toml_datetime::Datetime","toml_edit::de::Error","value::Value"],"value::ValueSerializeMap":["de::Error","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","toml_edit::de::Error","value::SerializeMap","value::ValueSerializeMap"],"value::ValueSerializeVec":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","value::ValueSerializeVec"],"value::ValueSerializer":["value::ValueSerializer"]},"glob_path_import":{},"self_to_fn":{"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":["impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = visitor.next_entry()? {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }"],"<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor":["impl<'de> de::Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"any valid TOML value\")\n            }\n\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Boolean(value))\n            }\n\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Integer(value))\n            }\n\n            fn visit_u64<E: de::Error>(self, value: u64) -> Result<Value, E> {\n                if value <= i64::max_value() as u64 {\n                    Ok(Value::Integer(value as i64))\n                } else {\n                    Err(de::Error::custom(\"u64 value was too large\"))\n                }\n            }\n\n            fn visit_u32<E>(self, value: u32) -> Result<Value, E> {\n                Ok(Value::Integer(value.into()))\n            }\n\n            fn visit_i32<E>(self, value: i32) -> Result<Value, E> {\n                Ok(Value::Integer(value.into()))\n            }\n\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Value::Float(value))\n            }\n\n            fn visit_str<E>(self, value: &str) -> Result<Value, E> {\n                Ok(Value::String(value.into()))\n            }\n\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: de::Deserializer<'de>,\n            {\n                de::Deserialize::deserialize(deserializer)\n            }\n\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n                while let Some(elem) = visitor.next_element()? {\n                    vec.push(elem);\n                }\n                Ok(Value::Array(vec))\n            }\n\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut key = String::new();\n                let datetime = visitor.next_key_seed(DatetimeOrTable { key: &mut key })?;\n                match datetime {\n                    Some(true) => {\n                        let date: datetime::DatetimeFromString = visitor.next_value()?;\n                        return Ok(Value::Datetime(date.value));\n                    }\n                    None => return Ok(Value::Table(Table::new())),\n                    Some(false) => {}\n                }\n                let mut map = Table::new();\n                map.insert(key, visitor.next_value()?);\n                while let Some(key) = visitor.next_key::<String>()? {\n                    if let crate::map::Entry::Vacant(vacant) = map.entry(&key) {\n                        vacant.insert(visitor.next_value()?);\n                    } else {\n                        let msg = format!(\"duplicate key: `{}`\", key);\n                        return Err(de::Error::custom(msg));\n                    }\n                }\n                Ok(Value::Table(map))\n            }\n        }"],"de::Deserializer":["impl<'a> Deserializer<'a> {\n    /// Deserialization implementation for TOML.\n    pub fn new(input: &'a str) -> Self {\n        Self { input }\n    }\n}","impl<'de, 'a> serde::Deserializer<'de> for Deserializer<'a> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner.deserialize_any(visitor).map_err(Error::new)\n    }\n\n    // `None` is interpreted as a missing field so be sure to implement `Some`\n    // as a present field.\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner.deserialize_option(visitor).map_err(Error::new)\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_newtype_struct(name, visitor)\n            .map_err(Error::new)\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_struct(name, fields, visitor)\n            .map_err(Error::new)\n    }\n\n    // Called when the type to deserialize is an enum, as opposed to a field in the type.\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_enum(name, variants, visitor)\n            .map_err(Error::new)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string seq\n        bytes byte_buf map unit\n        ignored_any unit_struct tuple_struct tuple identifier\n    }\n}"],"de::Error":["Clone","Debug","Eq","PartialEq","impl Error {\n    fn new(inner: crate::edit::de::Error) -> Self {\n        Self { inner }\n    }\n\n    pub(crate) fn add_key(&mut self, key: String) {\n        self.inner.add_key(key)\n    }\n\n    /// What went wrong\n    pub fn message(&self) -> &str {\n        self.inner.message()\n    }\n\n    /// The start/end index into the original document where the error occurred\n    #[cfg(feature = \"parse\")]\n    pub fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.inner.span()\n    }\n}","impl serde::de::Error for Error {\n    fn custom<T>(msg: T) -> Self\n    where\n        T: std::fmt::Display,\n    {\n        Error::new(crate::edit::de::Error::custom(msg))\n    }\n}","impl std::error::Error for Error {}","impl std::fmt::Display for Error {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.inner.fmt(f)\n    }\n}"],"de::ValueDeserializer":["impl<'a> ValueDeserializer<'a> {\n    /// Deserialization implementation for TOML.\n    pub fn new(input: &'a str) -> Self {\n        Self { input }\n    }\n}","impl<'de, 'a> serde::Deserializer<'de> for ValueDeserializer<'a> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner.deserialize_any(visitor).map_err(Error::new)\n    }\n\n    // `None` is interpreted as a missing field so be sure to implement `Some`\n    // as a present field.\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner.deserialize_option(visitor).map_err(Error::new)\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_newtype_struct(name, visitor)\n            .map_err(Error::new)\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_struct(name, fields, visitor)\n            .map_err(Error::new)\n    }\n\n    // Called when the type to deserialize is an enum, as opposed to a field in the type.\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_enum(name, variants, visitor)\n            .map_err(Error::new)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string seq\n        bytes byte_buf map unit\n        ignored_any unit_struct tuple_struct tuple identifier\n    }\n}"],"fmt::DocumentFormatter":["Clone","Copy","Default","impl toml_edit::visit_mut::VisitMut for DocumentFormatter {\n    fn visit_document_mut(&mut self, node: &mut toml_edit::Document) {\n        toml_edit::visit_mut::visit_document_mut(self, node);\n    }\n\n    fn visit_item_mut(&mut self, node: &mut toml_edit::Item) {\n        let other = std::mem::take(node);\n        let other = match other.into_table().map(toml_edit::Item::Table) {\n            Ok(i) => i,\n            Err(i) => i,\n        };\n        let other = match other\n            .into_array_of_tables()\n            .map(toml_edit::Item::ArrayOfTables)\n        {\n            Ok(i) => i,\n            Err(i) => i,\n        };\n        *node = other;\n\n        toml_edit::visit_mut::visit_item_mut(self, node);\n    }\n\n    fn visit_table_mut(&mut self, node: &mut toml_edit::Table) {\n        node.decor_mut().clear();\n\n        // Empty tables could be semantically meaningful, so make sure they are not implicit\n        if !node.is_empty() {\n            node.set_implicit(true);\n        }\n\n        toml_edit::visit_mut::visit_table_mut(self, node);\n    }\n\n    fn visit_value_mut(&mut self, node: &mut toml_edit::Value) {\n        node.decor_mut().clear();\n\n        toml_edit::visit_mut::visit_value_mut(self, node);\n    }\n\n    fn visit_array_mut(&mut self, node: &mut toml_edit::Array) {\n        toml_edit::visit_mut::visit_array_mut(self, node);\n\n        if !self.multiline_array || (0..=1).contains(&node.len()) {\n            node.set_trailing(\"\");\n            node.set_trailing_comma(false);\n        } else {\n            for item in node.iter_mut() {\n                item.decor_mut().set_prefix(\"\\n    \");\n            }\n            node.set_trailing(\"\\n\");\n            node.set_trailing_comma(true);\n        }\n    }\n}"],"map::Entry":["impl<'a> Entry<'a> {\n    /// Returns a reference to this entry's key.\n    pub fn key(&self) -> &String {\n        match *self {\n            Entry::Vacant(ref e) => e.key(),\n            Entry::Occupied(ref e) => e.key(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and\n    /// returns a mutable reference to the value in the entry.\n    pub fn or_insert(self, default: Value) -> &'a mut Value {\n        match self {\n            Entry::Vacant(entry) => entry.insert(default),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty, and returns a mutable reference to the value in the\n    /// entry.\n    pub fn or_insert_with<F>(self, default: F) -> &'a mut Value\n    where\n        F: FnOnce() -> Value,\n    {\n        match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }\n}"],"map::IntoIter":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::Iter":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::IterMut":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::Keys":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::Map":["impl Clone for Map<String, Value> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Map {\n            map: self.map.clone(),\n        }\n    }\n}","impl Debug for Map<String, Value> {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        self.map.fmt(formatter)\n    }\n}","impl Default for Map<String, Value> {\n    #[inline]\n    fn default() -> Self {\n        Map {\n            map: MapImpl::new(),\n        }\n    }\n}","impl Extend<(String, Value)> for Map<String, Value> {\n    fn extend<T>(&mut self, iter: T)\n    where\n        T: IntoIterator<Item = (String, Value)>,\n    {\n        self.map.extend(iter);\n    }\n}","impl FromIterator<(String, Value)> for Map<String, Value> {\n    fn from_iter<T>(iter: T) -> Self\n    where\n        T: IntoIterator<Item = (String, Value)>,\n    {\n        Map {\n            map: FromIterator::from_iter(iter),\n        }\n    }\n}","impl IntoIterator for Map<String, Value> {\n    type Item = (String, Value);\n    type IntoIter = IntoIter;\n    #[inline]\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }\n}","impl Map<String, Value> {\n    /// Makes a new empty Map.\n    #[inline]\n    pub fn new() -> Self {\n        Map {\n            map: MapImpl::new(),\n        }\n    }\n\n    #[cfg(not(feature = \"preserve_order\"))]\n    /// Makes a new empty Map with the given initial capacity.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n        // does not support with_capacity\n        let _ = capacity;\n        Map {\n            map: BTreeMap::new(),\n        }\n    }\n\n    #[cfg(feature = \"preserve_order\")]\n    /// Makes a new empty Map with the given initial capacity.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Map {\n            map: IndexMap::with_capacity(capacity),\n        }\n    }\n\n    /// Clears the map, removing all values.\n    #[inline]\n    pub fn clear(&mut self) {\n        self.map.clear()\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }\n\n    /// Returns true if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,\n    {\n        self.map.contains_key(key)\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,\n    {\n        self.map.get_mut(key)\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, `None` is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned. The key is not updated, though; this matters for\n    /// types that can be `==` without being identical.\n    #[inline]\n    pub fn insert(&mut self, k: String, v: Value) -> Option<Value> {\n        self.map.insert(k, v)\n    }\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,\n    {\n        self.map.remove(key)\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place\n    /// manipulation.\n    pub fn entry<S>(&mut self, key: S) -> Entry<'_>\n    where\n        S: Into<String>,\n    {\n        #[cfg(feature = \"preserve_order\")]\n        use indexmap::map::Entry as EntryImpl;\n        #[cfg(not(feature = \"preserve_order\"))]\n        use std::collections::btree_map::Entry as EntryImpl;\n\n        match self.map.entry(key.into()) {\n            EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),\n            EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),\n        }\n    }\n\n    /// Returns the number of elements in the map.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.map.len()\n    }\n\n    /// Returns true if the map contains no elements.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.map.is_empty()\n    }\n\n    /// Gets an iterator over the entries of the map.\n    #[inline]\n    pub fn iter(&self) -> Iter<'_> {\n        Iter {\n            iter: self.map.iter(),\n        }\n    }\n\n    /// Gets a mutable iterator over the entries of the map.\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut<'_> {\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }\n\n    /// Gets an iterator over the keys of the map.\n    #[inline]\n    pub fn keys(&self) -> Keys<'_> {\n        Keys {\n            iter: self.map.keys(),\n        }\n    }\n\n    /// Gets an iterator over the values of the map.\n    #[inline]\n    pub fn values(&self) -> Values<'_> {\n        Values {\n            iter: self.map.values(),\n        }\n    }\n}","impl PartialEq for Map<String, Value> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.map.eq(&other.map)\n    }\n}","impl ser::Serialize for Map<String, Value> {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n        use serde::ser::SerializeMap;\n        let mut map = serializer.serialize_map(Some(self.len()))?;\n        for (k, v) in self {\n            map.serialize_key(k)?;\n            map.serialize_value(v)?;\n        }\n        map.end()\n    }\n}","impl<'a, Q: ?Sized> ops::Index<&'a Q> for Map<String, Value>\nwhere\n    String: Borrow<Q>,\n    Q: Ord + Eq + Hash,\n{\n    type Output = Value;\n\n    fn index(&self, index: &Q) -> &Value {\n        self.map.index(index)\n    }\n}","impl<'a, Q: ?Sized> ops::IndexMut<&'a Q> for Map<String, Value>\nwhere\n    String: Borrow<Q>,\n    Q: Ord + Eq + Hash,\n{\n    fn index_mut(&mut self, index: &Q) -> &mut Value {\n        self.map.get_mut(index).expect(\"no entry found for key\")\n    }\n}","impl<'de> de::Deserialize<'de> for Map<String, Value> {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = visitor.next_entry()? {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        deserializer.deserialize_map(Visitor)\n    }\n}"],"map::OccupiedEntry":["impl<'a> OccupiedEntry<'a> {\n    /// Gets a reference to the key in the entry.\n    #[inline]\n    pub fn key(&self) -> &String {\n        self.occupied.key()\n    }\n\n    /// Gets a reference to the value in the entry.\n    #[inline]\n    pub fn get(&self) -> &Value {\n        self.occupied.get()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    #[inline]\n    pub fn get_mut(&mut self) -> &mut Value {\n        self.occupied.get_mut()\n    }\n\n    /// Converts the entry into a mutable reference to its value.\n    #[inline]\n    pub fn into_mut(self) -> &'a mut Value {\n        self.occupied.into_mut()\n    }\n\n    /// Sets the value of the entry with the `OccupiedEntry`'s key, and returns\n    /// the entry's old value.\n    #[inline]\n    pub fn insert(&mut self, value: Value) -> Value {\n        self.occupied.insert(value)\n    }\n\n    /// Takes the value of the entry out of the map, and returns it.\n    #[inline]\n    pub fn remove(self) -> Value {\n        self.occupied.remove()\n    }\n}"],"map::VacantEntry":["impl<'a> VacantEntry<'a> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the VacantEntry.\n    #[inline]\n    pub fn key(&self) -> &String {\n        self.vacant.key()\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key, and returns a\n    /// mutable reference to it.\n    #[inline]\n    pub fn insert(self, value: Value) -> &'a mut Value {\n        self.vacant.insert(value)\n    }\n}"],"map::Values":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"ser::Error":["Clone","Debug","Eq","PartialEq","impl Error {\n    pub(crate) fn new(inner: impl std::fmt::Display) -> Self {\n        Self {\n            inner: crate::edit::ser::Error::Custom(inner.to_string()),\n        }\n    }\n\n    #[cfg(feature = \"display\")]\n    pub(crate) fn wrap(inner: crate::edit::ser::Error) -> Self {\n        Self { inner }\n    }\n\n    pub(crate) fn unsupported_type(t: Option<&'static str>) -> Self {\n        Self {\n            inner: crate::edit::ser::Error::UnsupportedType(t),\n        }\n    }\n\n    pub(crate) fn unsupported_none() -> Self {\n        Self {\n            inner: crate::edit::ser::Error::UnsupportedNone,\n        }\n    }\n\n    pub(crate) fn key_not_string() -> Self {\n        Self {\n            inner: crate::edit::ser::Error::KeyNotString,\n        }\n    }\n}","impl serde::ser::Error for Error {\n    fn custom<T>(msg: T) -> Self\n    where\n        T: std::fmt::Display,\n    {\n        Error::new(msg)\n    }\n}","impl std::error::Error for Error {}","impl std::fmt::Display for Error {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.inner.fmt(f)\n    }\n}"],"ser::Serializer":["impl<'d> Serializer<'d> {\n    /// Creates a new serializer which will emit TOML into the buffer provided.\n    ///\n    /// The serializer can then be used to serialize a type after which the data\n    /// will be present in `dst`.\n    pub fn new(dst: &'d mut String) -> Self {\n        Self {\n            dst,\n            settings: Default::default(),\n        }\n    }\n\n    /// Apply a default \"pretty\" policy to the document\n    ///\n    /// For greater customization, instead serialize to a\n    /// [`toml_edit::Document`](https://docs.rs/toml_edit/latest/toml_edit/struct.Document.html).\n    pub fn pretty(dst: &'d mut String) -> Self {\n        let mut ser = Serializer::new(dst);\n        ser.settings.multiline_array = true;\n        ser\n    }\n}","impl<'d> serde::ser::Serializer for Serializer<'d> {\n    type Ok = ();\n    type Error = Error;\n    type SerializeSeq = SerializeDocumentArray<'d>;\n    type SerializeTuple = SerializeDocumentArray<'d>;\n    type SerializeTupleStruct = SerializeDocumentArray<'d>;\n    type SerializeTupleVariant = SerializeDocumentArray<'d>;\n    type SerializeMap = SerializeDocumentTable<'d>;\n    type SerializeStruct = SerializeDocumentTable<'d>;\n    type SerializeStructVariant = serde::ser::Impossible<Self::Ok, Self::Error>;\n\n    fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_bool(v),\n        )\n    }\n\n    fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_i8(v),\n        )\n    }\n\n    fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_i16(v),\n        )\n    }\n\n    fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_i32(v),\n        )\n    }\n\n    fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_i64(v),\n        )\n    }\n\n    fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_u8(v),\n        )\n    }\n\n    fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_u16(v),\n        )\n    }\n\n    fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_u32(v),\n        )\n    }\n\n    fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_u64(v),\n        )\n    }\n\n    fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_f32(v),\n        )\n    }\n\n    fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_f64(v),\n        )\n    }\n\n    fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_char(v),\n        )\n    }\n\n    fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_str(v),\n        )\n    }\n\n    fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_bytes(v),\n        )\n    }\n\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_none(),\n        )\n    }\n\n    fn serialize_some<T: ?Sized>(self, v: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,\n    {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_some(v),\n        )\n    }\n\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_unit(),\n        )\n    }\n\n    fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_unit_struct(name),\n        )\n    }\n\n    fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error> {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_unit_variant(\n                name,\n                variant_index,\n                variant,\n            ),\n        )\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        name: &'static str,\n        v: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,\n    {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_newtype_struct(name, v),\n        )\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,\n    {\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_newtype_variant(\n                name,\n                variant_index,\n                variant,\n                value,\n            ),\n        )\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        let ser = toml_edit::ser::ValueSerializer::new()\n            .serialize_seq(len)\n            .map_err(Error::wrap)?;\n        let ser = SerializeDocumentArray::new(self, ser);\n        Ok(ser)\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        let ser = toml_edit::ser::ValueSerializer::new()\n            .serialize_map(len)\n            .map_err(Error::wrap)?;\n        let ser = SerializeDocumentTable::new(self, ser);\n        Ok(ser)\n    }\n\n    fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        self.serialize_map(Some(len))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        Err(Error::unsupported_type(Some(name)))\n    }\n}"],"ser::ValueSerializer":["impl<'d> ValueSerializer<'d> {\n    /// Creates a new serializer which will emit TOML into the buffer provided.\n    ///\n    /// The serializer can then be used to serialize a type after which the data\n    /// will be present in `dst`.\n    pub fn new(dst: &'d mut String) -> Self {\n        Self { dst }\n    }\n}","impl<'d> serde::ser::Serializer for ValueSerializer<'d> {\n    type Ok = ();\n    type Error = Error;\n    type SerializeSeq = SerializeValueArray<'d>;\n    type SerializeTuple = SerializeValueArray<'d>;\n    type SerializeTupleStruct = SerializeValueArray<'d>;\n    type SerializeTupleVariant = SerializeValueArray<'d>;\n    type SerializeMap = SerializeValueTable<'d>;\n    type SerializeStruct = SerializeValueTable<'d>;\n    type SerializeStructVariant = serde::ser::Impossible<Self::Ok, Self::Error>;\n\n    fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_bool(v),\n        )\n    }\n\n    fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_i8(v),\n        )\n    }\n\n    fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_i16(v),\n        )\n    }\n\n    fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_i32(v),\n        )\n    }\n\n    fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_i64(v),\n        )\n    }\n\n    fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_u8(v),\n        )\n    }\n\n    fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_u16(v),\n        )\n    }\n\n    fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_u32(v),\n        )\n    }\n\n    fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_u64(v),\n        )\n    }\n\n    fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_f32(v),\n        )\n    }\n\n    fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_f64(v),\n        )\n    }\n\n    fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_char(v),\n        )\n    }\n\n    fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_str(v),\n        )\n    }\n\n    fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_bytes(v),\n        )\n    }\n\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_none(),\n        )\n    }\n\n    fn serialize_some<T: ?Sized>(self, v: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,\n    {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_some(v),\n        )\n    }\n\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_unit(),\n        )\n    }\n\n    fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_unit_struct(name),\n        )\n    }\n\n    fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error> {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_unit_variant(\n                name,\n                variant_index,\n                variant,\n            ),\n        )\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        name: &'static str,\n        v: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,\n    {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_newtype_struct(name, v),\n        )\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,\n    {\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_newtype_variant(\n                name,\n                variant_index,\n                variant,\n                value,\n            ),\n        )\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        let ser = toml_edit::ser::ValueSerializer::new()\n            .serialize_seq(len)\n            .map_err(Error::wrap)?;\n        let ser = SerializeValueArray::new(self, ser);\n        Ok(ser)\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        let ser = toml_edit::ser::ValueSerializer::new()\n            .serialize_map(len)\n            .map_err(Error::wrap)?;\n        let ser = SerializeValueTable::new(self, ser);\n        Ok(ser)\n    }\n\n    fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        self.serialize_map(Some(len))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        Err(Error::unsupported_type(Some(name)))\n    }\n}"],"ser::internal::SerializeDocumentArray":["impl<'d> SerializeDocumentArray<'d> {\n        pub(crate) fn new(ser: Serializer<'d>, inner: InnerSerializeDocumentSeq) -> Self {\n            Self {\n                inner,\n                dst: ser.dst,\n                settings: ser.settings,\n            }\n        }\n    }","impl<'d> serde::ser::SerializeSeq for SerializeDocumentArray<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_element(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_document(self.dst, self.settings, self.inner.end())\n        }\n    }","impl<'d> serde::ser::SerializeTuple for SerializeDocumentArray<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_element(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_document(self.dst, self.settings, self.inner.end())\n        }\n    }","impl<'d> serde::ser::SerializeTupleStruct for SerializeDocumentArray<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_field(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_document(self.dst, self.settings, self.inner.end())\n        }\n    }","impl<'d> serde::ser::SerializeTupleVariant for SerializeDocumentArray<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_field(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_document(self.dst, self.settings, self.inner.end())\n        }\n    }"],"ser::internal::SerializeDocumentTable":["impl<'d> SerializeDocumentTable<'d> {\n        pub(crate) fn new(ser: Serializer<'d>, inner: InnerSerializeDocumentTable) -> Self {\n            Self {\n                inner,\n                dst: ser.dst,\n                settings: ser.settings,\n            }\n        }\n    }","impl<'d> serde::ser::SerializeMap for SerializeDocumentTable<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_key<T: ?Sized>(&mut self, input: &T) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_key(input).map_err(Error::wrap)\n        }\n\n        fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_value(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_document(self.dst, self.settings, self.inner.end())\n        }\n    }","impl<'d> serde::ser::SerializeStruct for SerializeDocumentTable<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_field<T: ?Sized>(\n            &mut self,\n            key: &'static str,\n            value: &T,\n        ) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_field(key, value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_document(self.dst, self.settings, self.inner.end())\n        }\n    }"],"ser::internal::SerializeValueArray":["impl<'d> SerializeValueArray<'d> {\n        pub(crate) fn new(ser: ValueSerializer<'d>, inner: InnerSerializeValueSeq) -> Self {\n            Self {\n                inner,\n                dst: ser.dst,\n            }\n        }\n    }","impl<'d> serde::ser::SerializeSeq for SerializeValueArray<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_element(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_value(self.dst, self.inner.end())\n        }\n    }","impl<'d> serde::ser::SerializeTuple for SerializeValueArray<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_element(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_value(self.dst, self.inner.end())\n        }\n    }","impl<'d> serde::ser::SerializeTupleStruct for SerializeValueArray<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_field(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_value(self.dst, self.inner.end())\n        }\n    }","impl<'d> serde::ser::SerializeTupleVariant for SerializeValueArray<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_field(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_value(self.dst, self.inner.end())\n        }\n    }"],"ser::internal::SerializeValueTable":["impl<'d> SerializeValueTable<'d> {\n        pub(crate) fn new(ser: ValueSerializer<'d>, inner: InnerSerializeValueTable) -> Self {\n            Self {\n                inner,\n                dst: ser.dst,\n            }\n        }\n    }","impl<'d> serde::ser::SerializeMap for SerializeValueTable<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_key<T: ?Sized>(&mut self, input: &T) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_key(input).map_err(Error::wrap)\n        }\n\n        fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_value(value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_value(self.dst, self.inner.end())\n        }\n    }","impl<'d> serde::ser::SerializeStruct for SerializeValueTable<'d> {\n        type Ok = ();\n        type Error = Error;\n\n        fn serialize_field<T: ?Sized>(\n            &mut self,\n            key: &'static str,\n            value: &T,\n        ) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,\n        {\n            self.inner.serialize_field(key, value).map_err(Error::wrap)\n        }\n\n        fn end(self) -> Result<Self::Ok, Self::Error> {\n            write_value(self.dst, self.inner.end())\n        }\n    }"],"std::string::String":["impl Index for String {\n    fn index<'a>(&self, val: &'a Value) -> Option<&'a Value> {\n        self[..].index(val)\n    }\n\n    fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value> {\n        self[..].index_mut(val)\n    }\n}","impl Sealed for String {}"],"table::Table":["impl Table {\n    /// Convert a `T` into `toml::Table`.\n    ///\n    /// This conversion can fail if `T`'s implementation of `Serialize` decides to\n    /// fail, or if `T` contains a map with non-string keys.\n    pub fn try_from<T>(value: T) -> Result<Self, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(crate::value::TableSerializer)\n    }\n\n    /// Interpret a `toml::Table` as an instance of type `T`.\n    ///\n    /// This conversion can fail if the structure of the `Table` does not match the structure\n    /// expected by `T`, for example if `T` is a bool which can't be mapped to a `Table`. It can\n    /// also fail if the structure is correct but `T`'s implementation of `Deserialize` decides\n    /// that something is wrong with the data, for example required struct fields are missing from\n    /// the TOML map or some number is too big to fit in the expected primitive type.\n    pub fn try_into<'de, T>(self) -> Result<T, crate::de::Error>\n    where\n        T: de::Deserialize<'de>,\n    {\n        de::Deserialize::deserialize(self)\n    }\n}","impl fmt::Display for Table {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        crate::ser::to_string(self)\n            .expect(\"Unable to represent value as string\")\n            .fmt(f)\n    }\n}","impl std::str::FromStr for Table {\n    type Err = crate::de::Error;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        crate::from_str(s)\n    }\n}","impl<'de> de::Deserializer<'de> for Table {\n    type Error = crate::de::Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Value::Table(self).deserialize_any(visitor)\n    }\n\n    #[inline]\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Value::Table(self).deserialize_enum(name, variants, visitor)\n    }\n\n    // `None` is interpreted as a missing field so be sure to implement `Some`\n    // as a present field.\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Value::Table(self).deserialize_option(visitor)\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Value::Table(self).deserialize_newtype_struct(name, visitor)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n        bytes byte_buf map unit_struct tuple_struct struct\n        tuple ignored_any identifier\n    }\n}","impl<'de> de::IntoDeserializer<'de, crate::de::Error> for Table {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self {\n        self\n    }\n}"],"value::DatetimeOrTable":["impl<'a, 'de> de::DeserializeSeed<'de> for DatetimeOrTable<'a> {\n    type Value = bool;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        deserializer.deserialize_any(self)\n    }\n}","impl<'a, 'de> de::Visitor<'de> for DatetimeOrTable<'a> {\n    type Value = bool;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        formatter.write_str(\"a string key\")\n    }\n\n    fn visit_str<E>(self, s: &str) -> Result<bool, E>\n    where\n        E: de::Error,\n    {\n        if s == datetime::FIELD {\n            Ok(true)\n        } else {\n            self.key.push_str(s);\n            Ok(false)\n        }\n    }\n\n    fn visit_string<E>(self, s: String) -> Result<bool, E>\n    where\n        E: de::Error,\n    {\n        if s == datetime::FIELD {\n            Ok(true)\n        } else {\n            *self.key = s;\n            Ok(false)\n        }\n    }\n}"],"value::MapDeserializer":["impl MapDeserializer {\n    fn new(map: Table) -> Self {\n        MapDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }\n}","impl<'de> de::EnumAccess<'de> for MapDeserializer {\n    type Error = crate::de::Error;\n    type Variant = MapEnumDeserializer;\n\n    fn variant_seed<V>(mut self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: serde::de::DeserializeSeed<'de>,\n    {\n        use de::Error;\n        let (key, value) = match self.iter.next() {\n            Some(pair) => pair,\n            None => {\n                return Err(Error::custom(\n                    \"expected table with exactly 1 entry, found empty table\",\n                ));\n            }\n        };\n\n        let val = seed.deserialize(key.into_deserializer())?;\n\n        let variant = MapEnumDeserializer::new(value);\n\n        Ok((val, variant))\n    }\n}","impl<'de> de::MapAccess<'de> for MapDeserializer {\n    type Error = crate::de::Error;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some((key.clone(), value));\n                seed.deserialize(Value::String(key)).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        let (key, res) = match self.value.take() {\n            Some((key, value)) => (key, seed.deserialize(value)),\n            None => return Err(de::Error::custom(\"value is missing\")),\n        };\n        res.map_err(|mut error| {\n            error.add_key(key);\n            error\n        })\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}"],"value::MapEnumDeserializer":["impl MapEnumDeserializer {\n    pub(crate) fn new(value: Value) -> Self {\n        MapEnumDeserializer { value }\n    }\n}","impl<'de> serde::de::VariantAccess<'de> for MapEnumDeserializer {\n    type Error = crate::de::Error;\n\n    fn unit_variant(self) -> Result<(), Self::Error> {\n        use de::Error;\n        match self.value {\n            Value::Table(values) => {\n                if values.is_empty() {\n                    Ok(())\n                } else {\n                    Err(Error::custom(\"expected empty table\"))\n                }\n            }\n            e => Err(Error::custom(format!(\n                \"expected table, found {}\",\n                e.type_str()\n            ))),\n        }\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: serde::de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self.value.into_deserializer())\n    }\n\n    fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        use de::Error;\n        match self.value {\n            Value::Table(values) => {\n                let tuple_values = values\n                    .into_iter()\n                    .enumerate()\n                    .map(|(index, (key, value))| match key.parse::<usize>() {\n                        Ok(key_index) if key_index == index => Ok(value),\n                        Ok(_) | Err(_) => Err(Error::custom(format!(\n                            \"expected table key `{}`, but was `{}`\",\n                            index, key\n                        ))),\n                    })\n                    // Fold all values into a `Vec`, or return the first error.\n                    .fold(Ok(Vec::with_capacity(len)), |result, value_result| {\n                        result.and_then(move |mut tuple_values| match value_result {\n                            Ok(value) => {\n                                tuple_values.push(value);\n                                Ok(tuple_values)\n                            }\n                            // `Result<de::Value, Self::Error>` to `Result<Vec<_>, Self::Error>`\n                            Err(e) => Err(e),\n                        })\n                    })?;\n\n                if tuple_values.len() == len {\n                    serde::de::Deserializer::deserialize_seq(\n                        tuple_values.into_deserializer(),\n                        visitor,\n                    )\n                } else {\n                    Err(Error::custom(format!(\"expected tuple with length {}\", len)))\n                }\n            }\n            e => Err(Error::custom(format!(\n                \"expected table, found {}\",\n                e.type_str()\n            ))),\n        }\n    }\n\n    fn struct_variant<V>(\n        self,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        serde::de::Deserializer::deserialize_struct(\n            self.value.into_deserializer(),\n            \"\", // TODO: this should be the variant name\n            fields,\n            visitor,\n        )\n    }\n}"],"value::SeqDeserializer":["impl SeqDeserializer {\n    fn new(vec: Vec<Value>) -> Self {\n        SeqDeserializer {\n            iter: vec.into_iter(),\n        }\n    }\n}","impl<'de> de::SeqAccess<'de> for SeqDeserializer {\n    type Error = crate::de::Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}"],"value::SerializeMap":["impl ser::SerializeMap for SerializeMap {\n    type Ok = Table;\n    type Error = crate::ser::Error;\n\n    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        match Value::try_from(key)? {\n            Value::String(s) => self.next_key = Some(s),\n            _ => return Err(crate::ser::Error::key_not_string()),\n        };\n        Ok(())\n    }\n\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        let key = self.next_key.take();\n        let key = key.expect(\"serialize_value called before serialize_key\");\n        match Value::try_from(value) {\n            Ok(value) => {\n                self.map.insert(key, value);\n            }\n            Err(crate::ser::Error {\n                inner: crate::edit::ser::Error::UnsupportedNone,\n            }) => {}\n            Err(e) => return Err(e),\n        }\n        Ok(())\n    }\n\n    fn end(self) -> Result<Table, crate::ser::Error> {\n        Ok(self.map)\n    }\n}","impl ser::SerializeStruct for SerializeMap {\n    type Ok = Table;\n    type Error = crate::ser::Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeMap::serialize_key(self, key)?;\n        ser::SerializeMap::serialize_value(self, value)\n    }\n\n    fn end(self) -> Result<Table, crate::ser::Error> {\n        ser::SerializeMap::end(self)\n    }\n}"],"value::TableSerializer":["impl ser::Serializer for TableSerializer {\n    type Ok = Table;\n    type Error = crate::ser::Error;\n\n    type SerializeSeq = ser::Impossible<Table, crate::ser::Error>;\n    type SerializeTuple = ser::Impossible<Table, crate::ser::Error>;\n    type SerializeTupleStruct = ser::Impossible<Table, crate::ser::Error>;\n    type SerializeTupleVariant = ser::Impossible<Table, crate::ser::Error>;\n    type SerializeMap = SerializeMap;\n    type SerializeStruct = SerializeMap;\n    type SerializeStructVariant = ser::Impossible<Table, crate::ser::Error>;\n\n    fn serialize_bool(self, _value: bool) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_i8(self, _value: i8) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_i16(self, _value: i16) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_i32(self, _value: i32) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_i64(self, _value: i64) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_u8(self, _value: u8) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_u16(self, _value: u16) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_u32(self, _value: u32) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_u64(self, _value: u64) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_f32(self, _value: f32) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_f64(self, _value: f64) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_char(self, _value: char) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_str(self, _value: &str) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_bytes(self, _value: &[u8]) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_unit(self) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n    ) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _name: &'static str,\n        value: &T,\n    ) -> Result<Table, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Table, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        let value = value.serialize(ValueSerializer)?;\n        let mut table = Table::new();\n        table.insert(variant.to_owned(), value);\n        Ok(table)\n    }\n\n    fn serialize_none(self) -> Result<Table, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_none())\n    }\n\n    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Table, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(None))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, crate::ser::Error> {\n        Ok(SerializeMap {\n            map: Table::new(),\n            next_key: None,\n        })\n    }\n\n    fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, crate::ser::Error> {\n        self.serialize_map(Some(len))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }\n}"],"value::Value":["Clone","Debug","PartialEq","impl From<$T> for Value {\n            #[inline]\n            fn from(val: $T) -> Value {\n                Value::$variant(val.into())\n            }\n        }","impl Value {\n    /// Convert a `T` into `toml::Value` which is an enum that can represent\n    /// any valid TOML data.\n    ///\n    /// This conversion can fail if `T`'s implementation of `Serialize` decides to\n    /// fail, or if `T` contains a map with non-string keys.\n    pub fn try_from<T>(value: T) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(ValueSerializer)\n    }\n\n    /// Interpret a `toml::Value` as an instance of type `T`.\n    ///\n    /// This conversion can fail if the structure of the `Value` does not match the\n    /// structure expected by `T`, for example if `T` is a struct type but the\n    /// `Value` contains something other than a TOML table. It can also fail if the\n    /// structure is correct but `T`'s implementation of `Deserialize` decides that\n    /// something is wrong with the data, for example required struct fields are\n    /// missing from the TOML map or some number is too big to fit in the expected\n    /// primitive type.\n    pub fn try_into<'de, T>(self) -> Result<T, crate::de::Error>\n    where\n        T: de::Deserialize<'de>,\n    {\n        de::Deserialize::deserialize(self)\n    }\n\n    /// Index into a TOML array or map. A string index can be used to access a\n    /// value in a map, and a usize index can be used to access an element of an\n    /// array.\n    ///\n    /// Returns `None` if the type of `self` does not match the type of the\n    /// index, for example if the index is a string and `self` is an array or a\n    /// number. Also returns `None` if the given key does not exist in the map\n    /// or the given index is not within the bounds of the array.\n    pub fn get<I: Index>(&self, index: I) -> Option<&Value> {\n        index.index(self)\n    }\n\n    /// Mutably index into a TOML array or map. A string index can be used to\n    /// access a value in a map, and a usize index can be used to access an\n    /// element of an array.\n    ///\n    /// Returns `None` if the type of `self` does not match the type of the\n    /// index, for example if the index is a string and `self` is an array or a\n    /// number. Also returns `None` if the given key does not exist in the map\n    /// or the given index is not within the bounds of the array.\n    pub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value> {\n        index.index_mut(self)\n    }\n\n    /// Extracts the integer value if it is an integer.\n    pub fn as_integer(&self) -> Option<i64> {\n        match *self {\n            Value::Integer(i) => Some(i),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is an integer.\n    pub fn is_integer(&self) -> bool {\n        self.as_integer().is_some()\n    }\n\n    /// Extracts the float value if it is a float.\n    pub fn as_float(&self) -> Option<f64> {\n        match *self {\n            Value::Float(f) => Some(f),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is a float.\n    pub fn is_float(&self) -> bool {\n        self.as_float().is_some()\n    }\n\n    /// Extracts the boolean value if it is a boolean.\n    pub fn as_bool(&self) -> Option<bool> {\n        match *self {\n            Value::Boolean(b) => Some(b),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is a boolean.\n    pub fn is_bool(&self) -> bool {\n        self.as_bool().is_some()\n    }\n\n    /// Extracts the string of this value if it is a string.\n    pub fn as_str(&self) -> Option<&str> {\n        match *self {\n            Value::String(ref s) => Some(&**s),\n            _ => None,\n        }\n    }\n\n    /// Tests if this value is a string.\n    pub fn is_str(&self) -> bool {\n        self.as_str().is_some()\n    }\n\n    /// Extracts the datetime value if it is a datetime.\n    ///\n    /// Note that a parsed TOML value will only contain ISO 8601 dates. An\n    /// example date is:\n    ///\n    /// ```notrust\n    /// 1979-05-27T07:32:00Z\n    /// ```\n    pub fn as_datetime(&self) -> Option<&Datetime> {\n        match *self {\n            Value::Datetime(ref s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is a datetime.\n    pub fn is_datetime(&self) -> bool {\n        self.as_datetime().is_some()\n    }\n\n    /// Extracts the array value if it is an array.\n    pub fn as_array(&self) -> Option<&Vec<Value>> {\n        match *self {\n            Value::Array(ref s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Extracts the array value if it is an array.\n    pub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>> {\n        match *self {\n            Value::Array(ref mut s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is an array.\n    pub fn is_array(&self) -> bool {\n        self.as_array().is_some()\n    }\n\n    /// Extracts the table value if it is a table.\n    pub fn as_table(&self) -> Option<&Table> {\n        match *self {\n            Value::Table(ref s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Extracts the table value if it is a table.\n    pub fn as_table_mut(&mut self) -> Option<&mut Table> {\n        match *self {\n            Value::Table(ref mut s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Tests whether this value is a table.\n    pub fn is_table(&self) -> bool {\n        self.as_table().is_some()\n    }\n\n    /// Tests whether this and another value have the same type.\n    pub fn same_type(&self, other: &Value) -> bool {\n        discriminant(self) == discriminant(other)\n    }\n\n    /// Returns a human-readable representation of the type of this value.\n    pub fn type_str(&self) -> &'static str {\n        match *self {\n            Value::String(..) => \"string\",\n            Value::Integer(..) => \"integer\",\n            Value::Float(..) => \"float\",\n            Value::Boolean(..) => \"boolean\",\n            Value::Datetime(..) => \"datetime\",\n            Value::Array(..) => \"array\",\n            Value::Table(..) => \"table\",\n        }\n    }\n}","impl fmt::Display for Value {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use serde::Serialize as _;\n\n        let mut output = String::new();\n        let serializer = crate::ser::ValueSerializer::new(&mut output);\n        self.serialize(serializer).unwrap();\n        output.fmt(f)\n    }\n}","impl ser::Serialize for Value {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n        use serde::ser::SerializeMap;\n\n        match *self {\n            Value::String(ref s) => serializer.serialize_str(s),\n            Value::Integer(i) => serializer.serialize_i64(i),\n            Value::Float(f) => serializer.serialize_f64(f),\n            Value::Boolean(b) => serializer.serialize_bool(b),\n            Value::Datetime(ref s) => s.serialize(serializer),\n            Value::Array(ref a) => a.serialize(serializer),\n            Value::Table(ref t) => {\n                let mut map = serializer.serialize_map(Some(t.len()))?;\n                // Be sure to visit non-tables first (and also non\n                // array-of-tables) as all keys must be emitted first.\n                for (k, v) in t {\n                    if !v.is_table() && !v.is_array()\n                        || (v\n                            .as_array()\n                            .map(|a| !a.iter().any(|v| v.is_table()))\n                            .unwrap_or(false))\n                    {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                for (k, v) in t {\n                    if v.as_array()\n                        .map(|a| a.iter().any(|v| v.is_table()))\n                        .unwrap_or(false)\n                    {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                for (k, v) in t {\n                    if v.is_table() {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                map.end()\n            }\n        }\n    }\n}","impl std::str::FromStr for Value {\n    type Err = crate::de::Error;\n    fn from_str(s: &str) -> Result<Value, Self::Err> {\n        crate::from_str(s)\n    }\n}","impl<'a> From<&'a str> for Value {\n    #[inline]\n    fn from(val: &'a str) -> Value {\n        Value::String(val.to_string())\n    }\n}","impl<'de> de::Deserialize<'de> for Value {\n    fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct ValueVisitor;\n\n        impl<'de> de::Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"any valid TOML value\")\n            }\n\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Boolean(value))\n            }\n\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Integer(value))\n            }\n\n            fn visit_u64<E: de::Error>(self, value: u64) -> Result<Value, E> {\n                if value <= i64::max_value() as u64 {\n                    Ok(Value::Integer(value as i64))\n                } else {\n                    Err(de::Error::custom(\"u64 value was too large\"))\n                }\n            }\n\n            fn visit_u32<E>(self, value: u32) -> Result<Value, E> {\n                Ok(Value::Integer(value.into()))\n            }\n\n            fn visit_i32<E>(self, value: i32) -> Result<Value, E> {\n                Ok(Value::Integer(value.into()))\n            }\n\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Value::Float(value))\n            }\n\n            fn visit_str<E>(self, value: &str) -> Result<Value, E> {\n                Ok(Value::String(value.into()))\n            }\n\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: de::Deserializer<'de>,\n            {\n                de::Deserialize::deserialize(deserializer)\n            }\n\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n                while let Some(elem) = visitor.next_element()? {\n                    vec.push(elem);\n                }\n                Ok(Value::Array(vec))\n            }\n\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut key = String::new();\n                let datetime = visitor.next_key_seed(DatetimeOrTable { key: &mut key })?;\n                match datetime {\n                    Some(true) => {\n                        let date: datetime::DatetimeFromString = visitor.next_value()?;\n                        return Ok(Value::Datetime(date.value));\n                    }\n                    None => return Ok(Value::Table(Table::new())),\n                    Some(false) => {}\n                }\n                let mut map = Table::new();\n                map.insert(key, visitor.next_value()?);\n                while let Some(key) = visitor.next_key::<String>()? {\n                    if let crate::map::Entry::Vacant(vacant) = map.entry(&key) {\n                        vacant.insert(visitor.next_value()?);\n                    } else {\n                        let msg = format!(\"duplicate key: `{}`\", key);\n                        return Err(de::Error::custom(msg));\n                    }\n                }\n                Ok(Value::Table(map))\n            }\n        }\n\n        deserializer.deserialize_any(ValueVisitor)\n    }\n}","impl<'de> de::Deserializer<'de> for Value {\n    type Error = crate::de::Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self {\n            Value::Boolean(v) => visitor.visit_bool(v),\n            Value::Integer(n) => visitor.visit_i64(n),\n            Value::Float(n) => visitor.visit_f64(n),\n            Value::String(v) => visitor.visit_string(v),\n            Value::Datetime(v) => visitor.visit_string(v.to_string()),\n            Value::Array(v) => {\n                let len = v.len();\n                let mut deserializer = SeqDeserializer::new(v);\n                let seq = visitor.visit_seq(&mut deserializer)?;\n                let remaining = deserializer.iter.len();\n                if remaining == 0 {\n                    Ok(seq)\n                } else {\n                    Err(de::Error::invalid_length(len, &\"fewer elements in array\"))\n                }\n            }\n            Value::Table(v) => {\n                let len = v.len();\n                let mut deserializer = MapDeserializer::new(v);\n                let map = visitor.visit_map(&mut deserializer)?;\n                let remaining = deserializer.iter.len();\n                if remaining == 0 {\n                    Ok(map)\n                } else {\n                    Err(de::Error::invalid_length(len, &\"fewer elements in map\"))\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn deserialize_enum<V>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self {\n            Value::String(variant) => visitor.visit_enum(variant.into_deserializer()),\n            Value::Table(variant) => {\n                use de::Error;\n                if variant.is_empty() {\n                    Err(crate::de::Error::custom(\n                        \"wanted exactly 1 element, found 0 elements\",\n                    ))\n                } else if variant.len() != 1 {\n                    Err(crate::de::Error::custom(\n                        \"wanted exactly 1 element, more than 1 element\",\n                    ))\n                } else {\n                    let deserializer = MapDeserializer::new(variant);\n                    visitor.visit_enum(deserializer)\n                }\n            }\n            _ => Err(de::Error::invalid_type(\n                de::Unexpected::UnitVariant,\n                &\"string only\",\n            )),\n        }\n    }\n\n    // `None` is interpreted as a missing field so be sure to implement `Some`\n    // as a present field.\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_some(self)\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n        bytes byte_buf map unit_struct tuple_struct struct\n        tuple ignored_any identifier\n    }\n}","impl<'de> de::IntoDeserializer<'de, crate::de::Error> for Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self {\n        self\n    }\n}","impl<I> ops::Index<I> for Value\nwhere\n    I: Index,\n{\n    type Output = Value;\n\n    fn index(&self, index: I) -> &Value {\n        self.get(index).expect(\"index not found\")\n    }\n}","impl<I> ops::IndexMut<I> for Value\nwhere\n    I: Index,\n{\n    fn index_mut(&mut self, index: I) -> &mut Value {\n        self.get_mut(index).expect(\"index not found\")\n    }\n}","impl<S: Into<String> + Hash + Eq, V: Into<Value>> From<HashMap<S, V>> for Value {\n    fn from(val: HashMap<S, V>) -> Value {\n        let table = val.into_iter().map(|(s, v)| (s.into(), v.into())).collect();\n\n        Value::Table(table)\n    }\n}","impl<S: Into<String>, V: Into<Value>> From<BTreeMap<S, V>> for Value {\n    fn from(val: BTreeMap<S, V>) -> Value {\n        let table = val.into_iter().map(|(s, v)| (s.into(), v.into())).collect();\n\n        Value::Table(table)\n    }\n}","impl<V: Into<Value>> From<Vec<V>> for Value {\n    fn from(val: Vec<V>) -> Value {\n        Value::Array(val.into_iter().map(|v| v.into()).collect())\n    }\n}"],"value::ValueSerializeMap":["impl ser::SerializeMap for ValueSerializeMap {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        self.ser.serialize_key(key)\n    }\n\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        self.ser.serialize_value(value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        self.ser.end().map(Value::Table)\n    }\n}","impl ser::SerializeStruct for ValueSerializeMap {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeMap::serialize_key(self, key)?;\n        ser::SerializeMap::serialize_value(self, value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        ser::SerializeMap::end(self)\n    }\n}"],"value::ValueSerializeVec":["impl ser::SerializeSeq for ValueSerializeVec {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        self.vec.push(Value::try_from(value)?);\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Array(self.vec))\n    }\n}","impl ser::SerializeTuple for ValueSerializeVec {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}","impl ser::SerializeTupleStruct for ValueSerializeVec {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}","impl ser::SerializeTupleVariant for ValueSerializeVec {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value, crate::ser::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}"],"value::ValueSerializer":["impl ser::Serializer for ValueSerializer {\n    type Ok = Value;\n    type Error = crate::ser::Error;\n\n    type SerializeSeq = ValueSerializeVec;\n    type SerializeTuple = ValueSerializeVec;\n    type SerializeTupleStruct = ValueSerializeVec;\n    type SerializeTupleVariant = ValueSerializeVec;\n    type SerializeMap = ValueSerializeMap;\n    type SerializeStruct = ValueSerializeMap;\n    type SerializeStructVariant = ser::Impossible<Value, crate::ser::Error>;\n\n    fn serialize_bool(self, value: bool) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Boolean(value))\n    }\n\n    fn serialize_i8(self, value: i8) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_i16(self, value: i16) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_i32(self, value: i32) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_i64(self, value: i64) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Integer(value))\n    }\n\n    fn serialize_u8(self, value: u8) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_u16(self, value: u16) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_u32(self, value: u32) -> Result<Value, crate::ser::Error> {\n        self.serialize_i64(value.into())\n    }\n\n    fn serialize_u64(self, value: u64) -> Result<Value, crate::ser::Error> {\n        if value <= i64::max_value() as u64 {\n            self.serialize_i64(value as i64)\n        } else {\n            Err(ser::Error::custom(\"u64 value was too large\"))\n        }\n    }\n\n    fn serialize_f32(self, value: f32) -> Result<Value, crate::ser::Error> {\n        self.serialize_f64(value.into())\n    }\n\n    fn serialize_f64(self, value: f64) -> Result<Value, crate::ser::Error> {\n        Ok(Value::Float(value))\n    }\n\n    fn serialize_char(self, value: char) -> Result<Value, crate::ser::Error> {\n        let mut s = String::new();\n        s.push(value);\n        self.serialize_str(&s)\n    }\n\n    fn serialize_str(self, value: &str) -> Result<Value, crate::ser::Error> {\n        Ok(Value::String(value.to_owned()))\n    }\n\n    fn serialize_bytes(self, value: &[u8]) -> Result<Value, crate::ser::Error> {\n        let vec = value.iter().map(|&b| Value::Integer(b.into())).collect();\n        Ok(Value::Array(vec))\n    }\n\n    fn serialize_unit(self) -> Result<Value, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(Some(\"unit\")))\n    }\n\n    fn serialize_unit_struct(self, name: &'static str) -> Result<Value, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n    ) -> Result<Value, crate::ser::Error> {\n        self.serialize_str(_variant)\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _name: &'static str,\n        value: &T,\n    ) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        let value = value.serialize(ValueSerializer)?;\n        let mut table = Table::new();\n        table.insert(variant.to_owned(), value);\n        Ok(table.into())\n    }\n\n    fn serialize_none(self) -> Result<Value, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_none())\n    }\n\n    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, crate::ser::Error> {\n        Ok(ValueSerializeVec {\n            vec: Vec::with_capacity(len.unwrap_or(0)),\n        })\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, crate::ser::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, crate::ser::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, crate::ser::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, crate::ser::Error> {\n        Ok(ValueSerializeMap {\n            ser: SerializeMap {\n                map: Table::new(),\n                next_key: None,\n            },\n        })\n    }\n\n    fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, crate::ser::Error> {\n        self.serialize_map(Some(len))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, crate::ser::Error> {\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }\n}"]},"single_path_import":{"de::Deserializer":"Deserializer","de::from_str":"from_str","ser::Serializer":"Serializer","ser::to_string":"to_string","ser::to_string_pretty":"to_string_pretty","serde::Deserialize":"macros::Deserialize","serde::de::IntoDeserializer":"macros::IntoDeserializer","serde_spanned::Spanned":"Spanned","table::Table":"Table","toml_datetime::Date":"value::Date","toml_datetime::Datetime":"value::Datetime","toml_datetime::DatetimeParseError":"value::DatetimeParseError","toml_datetime::Offset":"value::Offset","toml_datetime::Time":"value::Time","value::Value":"Value"},"srcs":{"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        Iter {\n            iter: self.map.iter(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<&'s T as value::Index>::index":["fn index<'a>(&self, val: &'a Value) -> Option<&'a Value>{\n        (**self).index(val)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<&'s T as value::Index>::index_mut":["fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value>{\n        (**self).index_mut(val)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result{\n                formatter.write_str(\"a map\")\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":["#[inline]\nfn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,{\n                let mut values = Map::new();\n\n                while let Some((key, value)) = visitor.next_entry()? {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":["#[inline]\nfn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,{\n                Ok(Map::new())\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result{\n                formatter.write_str(\"any valid TOML value\")\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":["fn visit_bool<E>(self, value: bool) -> Result<Value, E>{\n                Ok(Value::Boolean(value))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":["fn visit_f64<E>(self, value: f64) -> Result<Value, E>{\n                Ok(Value::Float(value))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i32":["fn visit_i32<E>(self, value: i32) -> Result<Value, E>{\n                Ok(Value::Integer(value.into()))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":["fn visit_i64<E>(self, value: i64) -> Result<Value, E>{\n                Ok(Value::Integer(value))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":["fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::MapAccess<'de>,{\n                let mut key = String::new();\n                let datetime = visitor.next_key_seed(DatetimeOrTable { key: &mut key })?;\n                match datetime {\n                    Some(true) => {\n                        let date: datetime::DatetimeFromString = visitor.next_value()?;\n                        return Ok(Value::Datetime(date.value));\n                    }\n                    None => return Ok(Value::Table(Table::new())),\n                    Some(false) => {}\n                }\n                let mut map = Table::new();\n                map.insert(key, visitor.next_value()?);\n                while let Some(key) = visitor.next_key::<String>()? {\n                    if let crate::map::Entry::Vacant(vacant) = map.entry(&key) {\n                        vacant.insert(visitor.next_value()?);\n                    } else {\n                        let msg = format!(\"duplicate key: `{}`\", key);\n                        return Err(de::Error::custom(msg));\n                    }\n                }\n                Ok(Value::Table(map))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":["fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::SeqAccess<'de>,{\n                let mut vec = Vec::new();\n                while let Some(elem) = visitor.next_element()? {\n                    vec.push(elem);\n                }\n                Ok(Value::Array(vec))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":["fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: de::Deserializer<'de>,{\n                de::Deserialize::deserialize(deserializer)\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":["fn visit_str<E>(self, value: &str) -> Result<Value, E>{\n                Ok(Value::String(value.into()))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":["fn visit_string<E>(self, value: String) -> Result<Value, E>{\n                Ok(Value::String(value))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u32":["fn visit_u32<E>(self, value: u32) -> Result<Value, E>{\n                Ok(Value::Integer(value.into()))\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":["fn visit_u64<E: de::Error>(self, value: u64) -> Result<Value, E>{\n                if value <= i64::max_value() as u64 {\n                    Ok(Value::Integer(value as i64))\n                } else {\n                    Err(de::Error::custom(\"u64 value was too large\"))\n                }\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_any":["fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner.deserialize_any(visitor).map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":["fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_enum(name, variants, visitor)\n            .map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":["fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_newtype_struct(name, visitor)\n            .map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_option":["fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner.deserialize_option(visitor).map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":["fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::Deserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_struct(name, fields, visitor)\n            .map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::Error as serde::de::Error>::custom":["fn custom<T>(msg: T) -> Self\n    where\n        T: std::fmt::Display,{\n        Error::new(crate::edit::de::Error::custom(msg))\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        self.inner.fmt(f)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_any":["fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner.deserialize_any(visitor).map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":["fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_enum(name, variants, visitor)\n            .map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":["fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_newtype_struct(name, visitor)\n            .map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_option":["fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner.deserialize_option(visitor).map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":["fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        let inner = self\n            .input\n            .parse::<toml_edit::de::ValueDeserializer>()\n            .map_err(Error::new)?;\n        inner\n            .deserialize_struct(name, fields, visitor)\n            .map_err(Error::new)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_array_mut":["fn visit_array_mut(&mut self, node: &mut toml_edit::Array){\n        toml_edit::visit_mut::visit_array_mut(self, node);\n\n        if !self.multiline_array || (0..=1).contains(&node.len()) {\n            node.set_trailing(\"\");\n            node.set_trailing_comma(false);\n        } else {\n            for item in node.iter_mut() {\n                item.decor_mut().set_prefix(\"\\n    \");\n            }\n            node.set_trailing(\"\\n\");\n            node.set_trailing_comma(true);\n        }\n    }","Real(LocalPath(\"crates/toml/src/fmt.rs\"))"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_document_mut":["fn visit_document_mut(&mut self, node: &mut toml_edit::Document){\n        toml_edit::visit_mut::visit_document_mut(self, node);\n    }","Real(LocalPath(\"crates/toml/src/fmt.rs\"))"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_item_mut":["fn visit_item_mut(&mut self, node: &mut toml_edit::Item){\n        let other = std::mem::take(node);\n        let other = match other.into_table().map(toml_edit::Item::Table) {\n            Ok(i) => i,\n            Err(i) => i,\n        };\n        let other = match other\n            .into_array_of_tables()\n            .map(toml_edit::Item::ArrayOfTables)\n        {\n            Ok(i) => i,\n            Err(i) => i,\n        };\n        *node = other;\n\n        toml_edit::visit_mut::visit_item_mut(self, node);\n    }","Real(LocalPath(\"crates/toml/src/fmt.rs\"))"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_table_mut":["fn visit_table_mut(&mut self, node: &mut toml_edit::Table){\n        node.decor_mut().clear();\n\n        // Empty tables could be semantically meaningful, so make sure they are not implicit\n        if !node.is_empty() {\n            node.set_implicit(true);\n        }\n\n        toml_edit::visit_mut::visit_table_mut(self, node);\n    }","Real(LocalPath(\"crates/toml/src/fmt.rs\"))"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_value_mut":["fn visit_value_mut(&mut self, node: &mut toml_edit::Value){\n        node.decor_mut().clear();\n\n        toml_edit::visit_mut::visit_value_mut(self, node);\n    }","Real(LocalPath(\"crates/toml/src/fmt.rs\"))"],"<map::IntoIter as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::IntoIter as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::IntoIter as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::IntoIter as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Iter<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Iter<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Iter<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::IterMut<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::IterMut<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::IterMut<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Keys<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Keys<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Keys<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":["#[inline]\nfn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,{\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = visitor.next_entry()? {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        deserializer.deserialize_map(Visitor)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":["struct Visitor;","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":["#[inline]\nfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,{\n        use serde::ser::SerializeMap;\n        let mut map = serializer.serialize_map(Some(self.len()))?;\n        for (k, v) in self {\n            map.serialize_key(k)?;\n            map.serialize_value(v)?;\n        }\n        map.end()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n        Map {\n            map: self.map.clone(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &Self) -> bool{\n        self.map.eq(&other.map)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n        Map {\n            map: MapImpl::new(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error>{\n        self.map.fmt(formatter)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":["fn extend<T>(&mut self, iter: T)\n    where\n        T: IntoIterator<Item = (String, Value)>,{\n        self.map.extend(iter);\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":["fn from_iter<T>(iter: T) -> Self\n    where\n        T: IntoIterator<Item = (String, Value)>,{\n        Map {\n            map: FromIterator::from_iter(iter),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":["fn index(&self, index: &Q) -> &Value{\n        self.map.index(index)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":["fn index_mut(&mut self, index: &Q) -> &mut Value{\n        self.map.get_mut(index).expect(\"no entry found for key\")\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Values<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Values<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<map::Values<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"<ser::Error as serde::ser::Error>::custom":["fn custom<T>(msg: T) -> Self\n    where\n        T: std::fmt::Display,{\n        Error::new(msg)\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        self.inner.fmt(f)\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_bool":["fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_bool(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_bytes(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_char":["fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_char(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_f32":["fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_f32(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_f64":["fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_f64(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i16":["fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_i16(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i32":["fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_i32(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i64":["fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_i64(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i8":["fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_i8(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_map":["fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error>{\n        let ser = toml_edit::ser::ValueSerializer::new()\n            .serialize_map(len)\n            .map_err(Error::wrap)?;\n        let ser = SerializeDocumentTable::new(self, ser);\n        Ok(ser)\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_struct":["fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        name: &'static str,\n        v: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_newtype_struct(name, v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_newtype_variant(\n                name,\n                variant_index,\n                variant,\n                value,\n            ),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_none":["fn serialize_none(self) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_none(),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_seq":["fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error>{\n        let ser = toml_edit::ser::ValueSerializer::new()\n            .serialize_seq(len)\n            .map_err(Error::wrap)?;\n        let ser = SerializeDocumentArray::new(self, ser);\n        Ok(ser)\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_some":["fn serialize_some<T: ?Sized>(self, v: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_some(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_str":["fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_str(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_struct":["fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error>{\n        self.serialize_map(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error>{\n        Err(Error::unsupported_type(Some(name)))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple":["fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u16":["fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_u16(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u32":["fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_u32(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u64":["fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_u64(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u8":["fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_u8(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit":["fn serialize_unit(self) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_unit(),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit_struct":["fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_unit_struct(name),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit_variant":["fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error>{\n        write_document(\n            self.dst,\n            self.settings,\n            toml_edit::ser::ValueSerializer::new().serialize_unit_variant(\n                name,\n                variant_index,\n                variant,\n            ),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bool":["fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_bool(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_bytes(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_char":["fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_char(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f32":["fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_f32(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f64":["fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_f64(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i16":["fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_i16(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i32":["fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_i32(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i64":["fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_i64(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i8":["fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_i8(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_map":["fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error>{\n        let ser = toml_edit::ser::ValueSerializer::new()\n            .serialize_map(len)\n            .map_err(Error::wrap)?;\n        let ser = SerializeValueTable::new(self, ser);\n        Ok(ser)\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_struct":["fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        name: &'static str,\n        v: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_newtype_struct(name, v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_newtype_variant(\n                name,\n                variant_index,\n                variant,\n                value,\n            ),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_none":["fn serialize_none(self) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_none(),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_seq":["fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error>{\n        let ser = toml_edit::ser::ValueSerializer::new()\n            .serialize_seq(len)\n            .map_err(Error::wrap)?;\n        let ser = SerializeValueArray::new(self, ser);\n        Ok(ser)\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_some":["fn serialize_some<T: ?Sized>(self, v: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: serde::ser::Serialize,{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_some(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_str":["fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_str(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct":["fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error>{\n        self.serialize_map(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error>{\n        Err(Error::unsupported_type(Some(name)))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple":["fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u16":["fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_u16(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u32":["fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_u32(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u64":["fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_u64(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u8":["fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_u8(v),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit":["fn serialize_unit(self) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_unit(),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_struct":["fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_unit_struct(name),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_variant":["fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error>{\n        write_value(\n            self.dst,\n            toml_edit::ser::ValueSerializer::new().serialize_unit_variant(\n                name,\n                variant_index,\n                variant,\n            ),\n        )\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_document(self.dst, self.settings, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::serialize_element":["fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_element(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_document(self.dst, self.settings, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::serialize_element":["fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_element(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_document(self.dst, self.settings, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":["fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_field(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_document(self.dst, self.settings, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":["fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_field(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_document(self.dst, self.settings, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_key":["fn serialize_key<T: ?Sized>(&mut self, input: &T) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_key(input).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_value":["fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_value(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_document(self.dst, self.settings, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::serialize_field":["fn serialize_field<T: ?Sized>(\n            &mut self,\n            key: &'static str,\n            value: &T,\n        ) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_field(key, value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_value(self.dst, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::serialize_element":["fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_element(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_value(self.dst, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::serialize_element":["fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_element(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_value(self.dst, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":["fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_field(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_value(self.dst, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":["fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_field(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_value(self.dst, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_key":["fn serialize_key<T: ?Sized>(&mut self, input: &T) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_key(input).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_value":["fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_value(value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n            write_value(self.dst, self.inner.end())\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::serialize_field":["fn serialize_field<T: ?Sized>(\n            &mut self,\n            key: &'static str,\n            value: &T,\n        ) -> Result<(), Self::Error>\n        where\n            T: serde::ser::Serialize,{\n            self.inner.serialize_field(key, value).map_err(Error::wrap)\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"<std::string::String as value::Index>::index":["fn index<'a>(&self, val: &'a Value) -> Option<&'a Value>{\n        self[..].index(val)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<std::string::String as value::Index>::index_mut":["fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value>{\n        self[..].index_mut(val)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<str as value::Index>::index":["fn index<'a>(&self, val: &'a Value) -> Option<&'a Value>{\n        match *val {\n            Value::Table(ref a) => a.get(self),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<str as value::Index>::index_mut":["fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value>{\n        match *val {\n            Value::Table(ref mut a) => a.get_mut(self),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<usize as value::Index>::index":["fn index<'a>(&self, val: &'a Value) -> Option<&'a Value>{\n        match *val {\n            Value::Array(ref a) => a.get(*self),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<usize as value::Index>::index_mut":["fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value>{\n        match *val {\n            Value::Array(ref mut a) => a.get_mut(*self),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::deserialize":["fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: de::Deserializer<'de>,{\n        deserializer.deserialize_any(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result{\n        formatter.write_str(\"a string key\")\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_str":["fn visit_str<E>(self, s: &str) -> Result<bool, E>\n    where\n        E: de::Error,{\n        if s == datetime::FIELD {\n            Ok(true)\n        } else {\n            self.key.push_str(s);\n            Ok(false)\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_string":["fn visit_string<E>(self, s: String) -> Result<bool, E>\n    where\n        E: de::Error,{\n        if s == datetime::FIELD {\n            Ok(true)\n        } else {\n            *self.key = s;\n            Ok(false)\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::MapDeserializer as serde::de::EnumAccess<'de>>::variant_seed":["fn variant_seed<V>(mut self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: serde::de::DeserializeSeed<'de>,{\n        use de::Error;\n        let (key, value) = match self.iter.next() {\n            Some(pair) => pair,\n            None => {\n                return Err(Error::custom(\n                    \"expected table with exactly 1 entry, found empty table\",\n                ));\n            }\n        };\n\n        let val = seed.deserialize(key.into_deserializer())?;\n\n        let variant = MapEnumDeserializer::new(value);\n\n        Ok((val, variant))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":["fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some((key.clone(), value));\n                seed.deserialize(Value::String(key)).map(Some)\n            }\n            None => Ok(None),\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":["fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,{\n        let (key, res) = match self.value.take() {\n            Some((key, value)) => (key, seed.deserialize(value)),\n            None => return Err(de::Error::custom(\"value is missing\")),\n        };\n        res.map_err(|mut error| {\n            error.add_key(key);\n            error\n        })\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::size_hint":["fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":["fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: serde::de::DeserializeSeed<'de>,{\n        seed.deserialize(self.value.into_deserializer())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant":["fn struct_variant<V>(\n        self,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        serde::de::Deserializer::deserialize_struct(\n            self.value.into_deserializer(),\n            \"\", // TODO: this should be the variant name\n            fields,\n            visitor,\n        )\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":["fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,{\n        use de::Error;\n        match self.value {\n            Value::Table(values) => {\n                let tuple_values = values\n                    .into_iter()\n                    .enumerate()\n                    .map(|(index, (key, value))| match key.parse::<usize>() {\n                        Ok(key_index) if key_index == index => Ok(value),\n                        Ok(_) | Err(_) => Err(Error::custom(format!(\n                            \"expected table key `{}`, but was `{}`\",\n                            index, key\n                        ))),\n                    })\n                    // Fold all values into a `Vec`, or return the first error.\n                    .fold(Ok(Vec::with_capacity(len)), |result, value_result| {\n                        result.and_then(move |mut tuple_values| match value_result {\n                            Ok(value) => {\n                                tuple_values.push(value);\n                                Ok(tuple_values)\n                            }\n                            // `Result<de::Value, Self::Error>` to `Result<Vec<_>, Self::Error>`\n                            Err(e) => Err(e),\n                        })\n                    })?;\n\n                if tuple_values.len() == len {\n                    serde::de::Deserializer::deserialize_seq(\n                        tuple_values.into_deserializer(),\n                        visitor,\n                    )\n                } else {\n                    Err(Error::custom(format!(\"expected tuple with length {}\", len)))\n                }\n            }\n            e => Err(Error::custom(format!(\n                \"expected table, found {}\",\n                e.type_str()\n            ))),\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant":["fn unit_variant(self) -> Result<(), Self::Error>{\n        use de::Error;\n        match self.value {\n            Value::Table(values) => {\n                if values.is_empty() {\n                    Ok(())\n                } else {\n                    Err(Error::custom(\"expected empty table\"))\n                }\n            }\n            e => Err(Error::custom(format!(\n                \"expected table, found {}\",\n                e.type_str()\n            ))),\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":["fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, crate::de::Error>\n    where\n        T: de::DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint":["fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::SerializeMap as serde::ser::SerializeMap>::end":["fn end(self) -> Result<Table, crate::ser::Error>{\n        Ok(self.map)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::SerializeMap as serde::ser::SerializeMap>::serialize_key":["fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        match Value::try_from(key)? {\n            Value::String(s) => self.next_key = Some(s),\n            _ => return Err(crate::ser::Error::key_not_string()),\n        };\n        Ok(())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::SerializeMap as serde::ser::SerializeMap>::serialize_value":["fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        let key = self.next_key.take();\n        let key = key.expect(\"serialize_value called before serialize_key\");\n        match Value::try_from(value) {\n            Ok(value) => {\n                self.map.insert(key, value);\n            }\n            Err(crate::ser::Error {\n                inner: crate::edit::ser::Error::UnsupportedNone,\n            }) => {}\n            Err(e) => return Err(e),\n        }\n        Ok(())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::SerializeMap as serde::ser::SerializeStruct>::end":["fn end(self) -> Result<Table, crate::ser::Error>{\n        ser::SerializeMap::end(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::SerializeMap as serde::ser::SerializeStruct>::serialize_field":["fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        ser::SerializeMap::serialize_key(self, key)?;\n        ser::SerializeMap::serialize_value(self, value)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_bool":["fn serialize_bool(self, _value: bool) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, _value: &[u8]) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_char":["fn serialize_char(self, _value: char) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_f32":["fn serialize_f32(self, _value: f32) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_f64":["fn serialize_f64(self, _value: f64) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_i16":["fn serialize_i16(self, _value: i16) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_i32":["fn serialize_i32(self, _value: i32) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_i64":["fn serialize_i64(self, _value: i64) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_i8":["fn serialize_i8(self, _value: i8) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_map":["fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, crate::ser::Error>{\n        Ok(SerializeMap {\n            map: Table::new(),\n            next_key: None,\n        })\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_newtype_struct":["fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _name: &'static str,\n        value: &T,\n    ) -> Result<Table, crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Table, crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        let value = value.serialize(ValueSerializer)?;\n        let mut table = Table::new();\n        table.insert(variant.to_owned(), value);\n        Ok(table)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_none":["fn serialize_none(self) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_none())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_seq":["fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_some":["fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Table, crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_str":["fn serialize_str(self, _value: &str) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_struct":["fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, crate::ser::Error>{\n        self.serialize_map(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_tuple":["fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_u16":["fn serialize_u16(self, _value: u16) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_u32":["fn serialize_u32(self, _value: u32) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_u64":["fn serialize_u64(self, _value: u64) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_u8":["fn serialize_u8(self, _value: u8) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_unit":["fn serialize_unit(self) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_unit_struct":["fn serialize_unit_struct(self, _name: &'static str) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(None))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::TableSerializer as serde::Serializer>::serialize_unit_variant":["fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n    ) -> Result<Table, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>\n    where\n        D: de::Deserializer<'de>,{\n        struct ValueVisitor;\n\n        impl<'de> de::Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"any valid TOML value\")\n            }\n\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Boolean(value))\n            }\n\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Integer(value))\n            }\n\n            fn visit_u64<E: de::Error>(self, value: u64) -> Result<Value, E> {\n                if value <= i64::max_value() as u64 {\n                    Ok(Value::Integer(value as i64))\n                } else {\n                    Err(de::Error::custom(\"u64 value was too large\"))\n                }\n            }\n\n            fn visit_u32<E>(self, value: u32) -> Result<Value, E> {\n                Ok(Value::Integer(value.into()))\n            }\n\n            fn visit_i32<E>(self, value: i32) -> Result<Value, E> {\n                Ok(Value::Integer(value.into()))\n            }\n\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Value::Float(value))\n            }\n\n            fn visit_str<E>(self, value: &str) -> Result<Value, E> {\n                Ok(Value::String(value.into()))\n            }\n\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: de::Deserializer<'de>,\n            {\n                de::Deserialize::deserialize(deserializer)\n            }\n\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n                while let Some(elem) = visitor.next_element()? {\n                    vec.push(elem);\n                }\n                Ok(Value::Array(vec))\n            }\n\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut key = String::new();\n                let datetime = visitor.next_key_seed(DatetimeOrTable { key: &mut key })?;\n                match datetime {\n                    Some(true) => {\n                        let date: datetime::DatetimeFromString = visitor.next_value()?;\n                        return Ok(Value::Datetime(date.value));\n                    }\n                    None => return Ok(Value::Table(Table::new())),\n                    Some(false) => {}\n                }\n                let mut map = Table::new();\n                map.insert(key, visitor.next_value()?);\n                while let Some(key) = visitor.next_key::<String>()? {\n                    if let crate::map::Entry::Vacant(vacant) = map.entry(&key) {\n                        vacant.insert(visitor.next_value()?);\n                    } else {\n                        let msg = format!(\"duplicate key: `{}`\", key);\n                        return Err(de::Error::custom(msg));\n                    }\n                }\n                Ok(Value::Table(map))\n            }\n        }\n\n        deserializer.deserialize_any(ValueVisitor)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor":["struct ValueVisitor;","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_any":["fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,{\n        match self {\n            Value::Boolean(v) => visitor.visit_bool(v),\n            Value::Integer(n) => visitor.visit_i64(n),\n            Value::Float(n) => visitor.visit_f64(n),\n            Value::String(v) => visitor.visit_string(v),\n            Value::Datetime(v) => visitor.visit_string(v.to_string()),\n            Value::Array(v) => {\n                let len = v.len();\n                let mut deserializer = SeqDeserializer::new(v);\n                let seq = visitor.visit_seq(&mut deserializer)?;\n                let remaining = deserializer.iter.len();\n                if remaining == 0 {\n                    Ok(seq)\n                } else {\n                    Err(de::Error::invalid_length(len, &\"fewer elements in array\"))\n                }\n            }\n            Value::Table(v) => {\n                let len = v.len();\n                let mut deserializer = MapDeserializer::new(v);\n                let map = visitor.visit_map(&mut deserializer)?;\n                let remaining = deserializer.iter.len();\n                if remaining == 0 {\n                    Ok(map)\n                } else {\n                    Err(de::Error::invalid_length(len, &\"fewer elements in map\"))\n                }\n            }\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_bytes":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_enum":["#[inline]\nfn deserialize_enum<V>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,{\n        match self {\n            Value::String(variant) => visitor.visit_enum(variant.into_deserializer()),\n            Value::Table(variant) => {\n                use de::Error;\n                if variant.is_empty() {\n                    Err(crate::de::Error::custom(\n                        \"wanted exactly 1 element, found 0 elements\",\n                    ))\n                } else if variant.len() != 1 {\n                    Err(crate::de::Error::custom(\n                        \"wanted exactly 1 element, more than 1 element\",\n                    ))\n                } else {\n                    let deserializer = MapDeserializer::new(variant);\n                    visitor.visit_enum(deserializer)\n                }\n            }\n            _ => Err(de::Error::invalid_type(\n                de::Unexpected::UnitVariant,\n                &\"string only\",\n            )),\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_f32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_f64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_i16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_i32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_i64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_i8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_newtype_struct":["fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,{\n        visitor.visit_newtype_struct(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_option":["fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,{\n        visitor.visit_some(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_u16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_u32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_u64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_u8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Deserializer<'de>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"<value::Value as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,{\n        use serde::ser::SerializeMap;\n\n        match *self {\n            Value::String(ref s) => serializer.serialize_str(s),\n            Value::Integer(i) => serializer.serialize_i64(i),\n            Value::Float(f) => serializer.serialize_f64(f),\n            Value::Boolean(b) => serializer.serialize_bool(b),\n            Value::Datetime(ref s) => s.serialize(serializer),\n            Value::Array(ref a) => a.serialize(serializer),\n            Value::Table(ref t) => {\n                let mut map = serializer.serialize_map(Some(t.len()))?;\n                // Be sure to visit non-tables first (and also non\n                // array-of-tables) as all keys must be emitted first.\n                for (k, v) in t {\n                    if !v.is_table() && !v.is_array()\n                        || (v\n                            .as_array()\n                            .map(|a| !a.iter().any(|v| v.is_table()))\n                            .unwrap_or(false))\n                    {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                for (k, v) in t {\n                    if v.as_array()\n                        .map(|a| a.iter().any(|v| v.is_table()))\n                        .unwrap_or(false)\n                    {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                for (k, v) in t {\n                    if v.is_table() {\n                        map.serialize_entry(k, v)?;\n                    }\n                }\n                map.end()\n            }\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer":["fn into_deserializer(self) -> Self{\n        self\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<&'a str>>::from":["#[inline]\nfn from(val: &'a str) -> Value{\n        Value::String(val.to_string())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<bool>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<f32>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<f64>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<i32>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<i64>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<i8>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<map::Map<std::string::String, value::Value>>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<std::collections::BTreeMap<S, V>>>::from":["fn from(val: BTreeMap<S, V>) -> Value{\n        let table = val.into_iter().map(|(s, v)| (s.into(), v.into())).collect();\n\n        Value::Table(table)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<std::collections::HashMap<S, V>>>::from":["fn from(val: HashMap<S, V>) -> Value{\n        let table = val.into_iter().map(|(s, v)| (s.into(), v.into())).collect();\n\n        Value::Table(table)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<std::string::String>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<std::vec::Vec<V>>>::from":["fn from(val: Vec<V>) -> Value{\n        Value::Array(val.into_iter().map(|v| v.into()).collect())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<toml_datetime::Datetime>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<u32>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::convert::From<u8>>::from":["#[inline]\nfn from(val: $T) -> Value{\n                Value::$variant(val.into())\n            }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        use serde::Serialize as _;\n\n        let mut output = String::new();\n        let serializer = crate::ser::ValueSerializer::new(&mut output);\n        self.serialize(serializer).unwrap();\n        output.fmt(f)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::ops::Index<I>>::index":["fn index(&self, index: I) -> &Value{\n        self.get(index).expect(\"index not found\")\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::ops::IndexMut<I>>::index_mut":["fn index_mut(&mut self, index: I) -> &mut Value{\n        self.get_mut(index).expect(\"index not found\")\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::Value as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Value, Self::Err>{\n        crate::from_str(s)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::end":["fn end(self) -> Result<Value, crate::ser::Error>{\n        self.ser.end().map(Value::Table)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_key":["fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        self.ser.serialize_key(key)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_value":["fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        self.ser.serialize_value(value)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeMap as serde::ser::SerializeStruct>::end":["fn end(self) -> Result<Value, crate::ser::Error>{\n        ser::SerializeMap::end(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeMap as serde::ser::SerializeStruct>::serialize_field":["fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        ser::SerializeMap::serialize_key(self, key)?;\n        ser::SerializeMap::serialize_value(self, value)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeVec as serde::ser::SerializeSeq>::end":["fn end(self) -> Result<Value, crate::ser::Error>{\n        Ok(Value::Array(self.vec))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeVec as serde::ser::SerializeSeq>::serialize_element":["fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        self.vec.push(Value::try_from(value)?);\n        Ok(())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeVec as serde::ser::SerializeTuple>::end":["fn end(self) -> Result<Value, crate::ser::Error>{\n        ser::SerializeSeq::end(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeVec as serde::ser::SerializeTuple>::serialize_element":["fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::end":["fn end(self) -> Result<Value, crate::ser::Error>{\n        ser::SerializeSeq::end(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":["fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::end":["fn end(self) -> Result<Value, crate::ser::Error>{\n        ser::SerializeSeq::end(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::serialize_field":["fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_bool":["fn serialize_bool(self, value: bool) -> Result<Value, crate::ser::Error>{\n        Ok(Value::Boolean(value))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, value: &[u8]) -> Result<Value, crate::ser::Error>{\n        let vec = value.iter().map(|&b| Value::Integer(b.into())).collect();\n        Ok(Value::Array(vec))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_char":["fn serialize_char(self, value: char) -> Result<Value, crate::ser::Error>{\n        let mut s = String::new();\n        s.push(value);\n        self.serialize_str(&s)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_f32":["fn serialize_f32(self, value: f32) -> Result<Value, crate::ser::Error>{\n        self.serialize_f64(value.into())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_f64":["fn serialize_f64(self, value: f64) -> Result<Value, crate::ser::Error>{\n        Ok(Value::Float(value))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_i16":["fn serialize_i16(self, value: i16) -> Result<Value, crate::ser::Error>{\n        self.serialize_i64(value.into())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_i32":["fn serialize_i32(self, value: i32) -> Result<Value, crate::ser::Error>{\n        self.serialize_i64(value.into())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_i64":["fn serialize_i64(self, value: i64) -> Result<Value, crate::ser::Error>{\n        Ok(Value::Integer(value))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_i8":["fn serialize_i8(self, value: i8) -> Result<Value, crate::ser::Error>{\n        self.serialize_i64(value.into())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_map":["fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, crate::ser::Error>{\n        Ok(ValueSerializeMap {\n            ser: SerializeMap {\n                map: Table::new(),\n                next_key: None,\n            },\n        })\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_newtype_struct":["fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _name: &'static str,\n        value: &T,\n    ) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        let value = value.serialize(ValueSerializer)?;\n        let mut table = Table::new();\n        table.insert(variant.to_owned(), value);\n        Ok(table.into())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_none":["fn serialize_none(self) -> Result<Value, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_none())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_seq":["fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, crate::ser::Error>{\n        Ok(ValueSerializeVec {\n            vec: Vec::with_capacity(len.unwrap_or(0)),\n        })\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_some":["fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_str":["fn serialize_str(self, value: &str) -> Result<Value, crate::ser::Error>{\n        Ok(Value::String(value.to_owned()))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_struct":["fn serialize_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, crate::ser::Error>{\n        self.serialize_map(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple":["fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, crate::ser::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, crate::ser::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, crate::ser::Error>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_u16":["fn serialize_u16(self, value: u16) -> Result<Value, crate::ser::Error>{\n        self.serialize_i64(value.into())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_u32":["fn serialize_u32(self, value: u32) -> Result<Value, crate::ser::Error>{\n        self.serialize_i64(value.into())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_u64":["fn serialize_u64(self, value: u64) -> Result<Value, crate::ser::Error>{\n        if value <= i64::max_value() as u64 {\n            self.serialize_i64(value as i64)\n        } else {\n            Err(ser::Error::custom(\"u64 value was too large\"))\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_u8":["fn serialize_u8(self, value: u8) -> Result<Value, crate::ser::Error>{\n        self.serialize_i64(value.into())\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_unit":["fn serialize_unit(self) -> Result<Value, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(Some(\"unit\")))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_unit_struct":["fn serialize_unit_struct(self, name: &'static str) -> Result<Value, crate::ser::Error>{\n        Err(crate::ser::Error::unsupported_type(Some(name)))\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"<value::ValueSerializer as serde::Serializer>::serialize_unit_variant":["fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n    ) -> Result<Value, crate::ser::Error>{\n        self.serialize_str(_variant)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"de::Deserializer":["/// Deserialization TOML document\n///\n/// To deserializes TOML values, instead of documents, see [`ValueDeserializer`].\n#[cfg(feature = \"parse\")]\npub struct Deserializer<'a> {\n    input: &'a str,\n}","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::Deserializer::<'a>::new":["/// Deserialization implementation for TOML.\npub fn new(input: &'a str) -> Self{\n        Self { input }\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::Error":["/// Errors that can occur when deserializing a type.\npub struct Error {\n    inner: crate::edit::de::Error,\n}","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::Error::add_key":["pub(crate) fn add_key(&mut self, key: String){\n        self.inner.add_key(key)\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::Error::message":["/// What went wrong\npub fn message(&self) -> &str{\n        self.inner.message()\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::Error::new":["fn new(inner: crate::edit::de::Error) -> Self{\n        Self { inner }\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::Error::span":["/// The start/end index into the original document where the error occurred\n#[cfg(feature = \"parse\")]\npub fn span(&self) -> Option<std::ops::Range<usize>>{\n        self.inner.span()\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::ValueDeserializer":["/// Deserialization TOML [value][crate::Value]\n///\n/// # Example\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize)]\n/// struct Config {\n///     title: String,\n///     owner: Owner,\n/// }\n///\n/// #[derive(Deserialize)]\n/// struct Owner {\n///     name: String,\n/// }\n///\n/// let config = Config::deserialize(toml::de::ValueDeserializer::new(\n///     r#\"{ title = 'TOML Example', owner = { name = 'Lisa' } }\"#\n/// )).unwrap();\n///\n/// assert_eq!(config.title, \"TOML Example\");\n/// assert_eq!(config.owner.name, \"Lisa\");\n/// ```\n#[cfg(feature = \"parse\")]\npub struct ValueDeserializer<'a> {\n    input: &'a str,\n}","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::ValueDeserializer::<'a>::new":["/// Deserialization implementation for TOML.\npub fn new(input: &'a str) -> Self{\n        Self { input }\n    }","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"de::from_str":["/// Deserializes a string into a type.\n///\n/// This function will attempt to interpret `s` as a TOML document and\n/// deserialize `T` from the document.\n///\n/// To deserializes TOML values, instead of documents, see [`ValueDeserializer`].\n///\n/// # Examples\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize)]\n/// struct Config {\n///     title: String,\n///     owner: Owner,\n/// }\n///\n/// #[derive(Deserialize)]\n/// struct Owner {\n///     name: String,\n/// }\n///\n/// let config: Config = toml::from_str(r#\"\n///     title = 'TOML Example'\n///\n///     [owner]\n///     name = 'Lisa'\n/// \"#).unwrap();\n///\n/// assert_eq!(config.title, \"TOML Example\");\n/// assert_eq!(config.owner.name, \"Lisa\");\n/// ```\n#[cfg(feature = \"parse\")]\npub fn from_str<T>(s: &'_ str) -> Result<T, Error>\nwhere\n    T: serde::de::DeserializeOwned,{\n    T::deserialize(Deserializer::new(s))\n}","Real(LocalPath(\"crates/toml/src/de.rs\"))"],"fmt::DocumentFormatter":["pub(crate) struct DocumentFormatter {\n    pub(crate) multiline_array: bool,\n}","Real(LocalPath(\"crates/toml/src/fmt.rs\"))"],"macros::insert_toml":["pub fn insert_toml(root: &mut Value, path: &[&str], value: Value){\n    *traverse(root, path) = value;\n}","Real(LocalPath(\"crates/toml/src/macros.rs\"))"],"macros::push_toml":["pub fn push_toml(root: &mut Value, path: &[&str]){\n    let target = traverse(root, path);\n    if !target.is_array() {\n        *target = Value::Array(Array::new());\n    }\n    target\n        .as_array_mut()\n        .unwrap()\n        .push(Value::Table(Table::new()));\n}","Real(LocalPath(\"crates/toml/src/macros.rs\"))"],"macros::traverse":["fn traverse<'a>(root: &'a mut Value, path: &[&str]) -> &'a mut Value{\n    let mut cur = root;\n    for &key in path {\n        // Lexical lifetimes :D\n        let cur1 = cur;\n\n        // From the TOML spec:\n        //\n        // > Each double-bracketed sub-table will belong to the most recently\n        // > defined table element above it.\n        let cur2 = if cur1.is_array() {\n            cur1.as_array_mut().unwrap().last_mut().unwrap()\n        } else {\n            cur1\n        };\n\n        // We are about to index into this value, so it better be a table.\n        if !cur2.is_table() {\n            *cur2 = Value::Table(Table::new());\n        }\n\n        if !cur2.as_table().unwrap().contains_key(key) {\n            // Insert an empty table for the next loop iteration to point to.\n            let empty = Value::Table(Table::new());\n            cur2.as_table_mut().unwrap().insert(key.to_owned(), empty);\n        }\n\n        // Step into the current table.\n        cur = cur2.as_table_mut().unwrap().get_mut(key).unwrap();\n    }\n    cur\n}","Real(LocalPath(\"crates/toml/src/macros.rs\"))"],"map::Entry":["/// A view into a single entry in a map, which may either be vacant or occupied.\n/// This enum is constructed from the [`entry`] method on [`Map`].\n///\n/// [`entry`]: struct.Map.html#method.entry\n/// [`Map`]: struct.Map.html\npub enum Entry<'a> {\n    /// A vacant Entry.\n    Vacant(VacantEntry<'a>),\n    /// An occupied Entry.\n    Occupied(OccupiedEntry<'a>),\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Entry::<'a>::key":["/// Returns a reference to this entry's key.\npub fn key(&self) -> &String{\n        match *self {\n            Entry::Vacant(ref e) => e.key(),\n            Entry::Occupied(ref e) => e.key(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Entry::<'a>::or_insert":["/// Ensures a value is in the entry by inserting the default if empty, and\n/// returns a mutable reference to the value in the entry.\npub fn or_insert(self, default: Value) -> &'a mut Value{\n        match self {\n            Entry::Vacant(entry) => entry.insert(default),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Entry::<'a>::or_insert_with":["/// Ensures a value is in the entry by inserting the result of the default\n/// function if empty, and returns a mutable reference to the value in the\n/// entry.\npub fn or_insert_with<F>(self, default: F) -> &'a mut Value\n    where\n        F: FnOnce() -> Value,{\n        match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::IntoIter":["/// An owning iterator over a toml::Map's entries.\npub struct IntoIter {\n    iter: IntoIterImpl,\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Iter":["/// An iterator over a toml::Map's entries.\npub struct Iter<'a> {\n    iter: IterImpl<'a>,\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::IterMut":["/// A mutable iterator over a toml::Map's entries.\npub struct IterMut<'a> {\n    iter: IterMutImpl<'a>,\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Keys":["/// An iterator over a toml::Map's keys.\npub struct Keys<'a> {\n    iter: KeysImpl<'a>,\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map":["/// Represents a TOML key/value type.\npub struct Map<K, V> {\n    map: MapImpl<K, V>,\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::clear":["/// Clears the map, removing all values.\n#[inline]\npub fn clear(&mut self){\n        self.map.clear()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::contains_key":["/// Returns true if the map contains a value for the specified key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,{\n        self.map.contains_key(key)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::entry":["/// Gets the given key's corresponding entry in the map for in-place\n/// manipulation.\npub fn entry<S>(&mut self, key: S) -> Entry<'_>\n    where\n        S: Into<String>,{\n        #[cfg(feature = \"preserve_order\")]\n        use indexmap::map::Entry as EntryImpl;\n        #[cfg(not(feature = \"preserve_order\"))]\n        use std::collections::btree_map::Entry as EntryImpl;\n\n        match self.map.entry(key.into()) {\n            EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),\n            EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::get":["/// Returns a reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,{\n        self.map.get(key)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::get_mut":["/// Returns a mutable reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,{\n        self.map.get_mut(key)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::insert":["/// Inserts a key-value pair into the map.\n///\n/// If the map did not have this key present, `None` is returned.\n///\n/// If the map did have this key present, the value is updated, and the old\n/// value is returned. The key is not updated, though; this matters for\n/// types that can be `==` without being identical.\n#[inline]\npub fn insert(&mut self, k: String, v: Value) -> Option<Value>{\n        self.map.insert(k, v)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::is_empty":["/// Returns true if the map contains no elements.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.map.is_empty()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::iter":["/// Gets an iterator over the entries of the map.\n#[inline]\npub fn iter(&self) -> Iter<'_>{\n        Iter {\n            iter: self.map.iter(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::iter_mut":["/// Gets a mutable iterator over the entries of the map.\n#[inline]\npub fn iter_mut(&mut self) -> IterMut<'_>{\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::keys":["/// Gets an iterator over the keys of the map.\n#[inline]\npub fn keys(&self) -> Keys<'_>{\n        Keys {\n            iter: self.map.keys(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::len":["/// Returns the number of elements in the map.\n#[inline]\npub fn len(&self) -> usize{\n        self.map.len()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::new":["/// Makes a new empty Map.\n#[inline]\npub fn new() -> Self{\n        Map {\n            map: MapImpl::new(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::remove":["/// Removes a key from the map, returning the value at the key if the key\n/// was previously in the map.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: Ord + Eq + Hash,{\n        self.map.remove(key)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::values":["/// Gets an iterator over the values of the map.\n#[inline]\npub fn values(&self) -> Values<'_>{\n        Values {\n            iter: self.map.values(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::with_capacity":["#[cfg(not(feature = \"preserve_order\"))]\n/// Makes a new empty Map with the given initial capacity.\n#[inline]\npub fn with_capacity(capacity: usize) -> Self{\n        // does not support with_capacity\n        let _ = capacity;\n        Map {\n            map: BTreeMap::new(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::OccupiedEntry":["/// An occupied Entry. It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\npub struct OccupiedEntry<'a> {\n    occupied: OccupiedEntryImpl<'a>,\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::OccupiedEntry::<'a>::get":["/// Gets a reference to the value in the entry.\n#[inline]\npub fn get(&self) -> &Value{\n        self.occupied.get()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::OccupiedEntry::<'a>::get_mut":["/// Gets a mutable reference to the value in the entry.\n#[inline]\npub fn get_mut(&mut self) -> &mut Value{\n        self.occupied.get_mut()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::OccupiedEntry::<'a>::insert":["/// Sets the value of the entry with the `OccupiedEntry`'s key, and returns\n/// the entry's old value.\n#[inline]\npub fn insert(&mut self, value: Value) -> Value{\n        self.occupied.insert(value)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::OccupiedEntry::<'a>::into_mut":["/// Converts the entry into a mutable reference to its value.\n#[inline]\npub fn into_mut(self) -> &'a mut Value{\n        self.occupied.into_mut()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::OccupiedEntry::<'a>::key":["/// Gets a reference to the key in the entry.\n#[inline]\npub fn key(&self) -> &String{\n        self.occupied.key()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::OccupiedEntry::<'a>::remove":["/// Takes the value of the entry out of the map, and returns it.\n#[inline]\npub fn remove(self) -> Value{\n        self.occupied.remove()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::VacantEntry":["/// A vacant Entry. It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\npub struct VacantEntry<'a> {\n    vacant: VacantEntryImpl<'a>,\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::VacantEntry::<'a>::insert":["/// Sets the value of the entry with the VacantEntry's key, and returns a\n/// mutable reference to it.\n#[inline]\npub fn insert(self, value: Value) -> &'a mut Value{\n        self.vacant.insert(value)\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::VacantEntry::<'a>::key":["/// Gets a reference to the key that would be used when inserting a value\n/// through the VacantEntry.\n#[inline]\npub fn key(&self) -> &String{\n        self.vacant.key()\n    }","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"map::Values":["/// An iterator over a toml::Map's values.\npub struct Values<'a> {\n    iter: ValuesImpl<'a>,\n}","Real(LocalPath(\"crates/toml/src/map.rs\"))"],"ser::Error":["/// Errors that can occur when serializing a type.\npub struct Error {\n    pub(crate) inner: crate::edit::ser::Error,\n}","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::Error::key_not_string":["pub(crate) fn key_not_string() -> Self{\n        Self {\n            inner: crate::edit::ser::Error::KeyNotString,\n        }\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::Error::new":["pub(crate) fn new(inner: impl std::fmt::Display) -> Self{\n        Self {\n            inner: crate::edit::ser::Error::Custom(inner.to_string()),\n        }\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::Error::unsupported_none":["pub(crate) fn unsupported_none() -> Self{\n        Self {\n            inner: crate::edit::ser::Error::UnsupportedNone,\n        }\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::Error::unsupported_type":["pub(crate) fn unsupported_type(t: Option<&'static str>) -> Self{\n        Self {\n            inner: crate::edit::ser::Error::UnsupportedType(t),\n        }\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::Error::wrap":["#[cfg(feature = \"display\")]\npub(crate) fn wrap(inner: crate::edit::ser::Error) -> Self{\n        Self { inner }\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::Serializer":["/// Serialization for TOML documents.\n///\n/// This structure implements serialization support for TOML to serialize an\n/// arbitrary type to TOML. Note that the TOML format does not support all\n/// datatypes in Rust, such as enums, tuples, and tuple structs. These types\n/// will generate an error when serialized.\n///\n/// Currently a serializer always writes its output to an in-memory `String`,\n/// which is passed in when creating the serializer itself.\n///\n/// To serialize TOML values, instead of documents, see [`ValueSerializer`].\n#[non_exhaustive]\n#[cfg(feature = \"display\")]\npub struct Serializer<'d> {\n    dst: &'d mut String,\n    settings: crate::fmt::DocumentFormatter,\n}","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::Serializer::<'d>::new":["/// Creates a new serializer which will emit TOML into the buffer provided.\n///\n/// The serializer can then be used to serialize a type after which the data\n/// will be present in `dst`.\npub fn new(dst: &'d mut String) -> Self{\n        Self {\n            dst,\n            settings: Default::default(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::Serializer::<'d>::pretty":["/// Apply a default \"pretty\" policy to the document\n///\n/// For greater customization, instead serialize to a\n/// [`toml_edit::Document`](https://docs.rs/toml_edit/latest/toml_edit/struct.Document.html).\npub fn pretty(dst: &'d mut String) -> Self{\n        let mut ser = Serializer::new(dst);\n        ser.settings.multiline_array = true;\n        ser\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::ValueSerializer":["/// Serialization for TOML [values][crate::Value].\n///\n/// This structure implements serialization support for TOML to serialize an\n/// arbitrary type to TOML. Note that the TOML format does not support all\n/// datatypes in Rust, such as enums, tuples, and tuple structs. These types\n/// will generate an error when serialized.\n///\n/// Currently a serializer always writes its output to an in-memory `String`,\n/// which is passed in when creating the serializer itself.\n///\n/// # Examples\n///\n/// ```\n/// use serde::Serialize;\n///\n/// #[derive(Serialize)]\n/// struct Config {\n///     database: Database,\n/// }\n///\n/// #[derive(Serialize)]\n/// struct Database {\n///     ip: String,\n///     port: Vec<u16>,\n///     connection_max: u32,\n///     enabled: bool,\n/// }\n///\n/// let config = Config {\n///     database: Database {\n///         ip: \"192.168.1.1\".to_string(),\n///         port: vec![8001, 8002, 8003],\n///         connection_max: 5000,\n///         enabled: false,\n///     },\n/// };\n///\n/// let mut value = String::new();\n/// serde::Serialize::serialize(\n///     &config,\n///     toml::ser::ValueSerializer::new(&mut value)\n/// ).unwrap();\n/// println!(\"{}\", value)\n/// ```\n#[non_exhaustive]\n#[cfg(feature = \"display\")]\npub struct ValueSerializer<'d> {\n    dst: &'d mut String,\n}","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::ValueSerializer::<'d>::new":["/// Creates a new serializer which will emit TOML into the buffer provided.\n///\n/// The serializer can then be used to serialize a type after which the data\n/// will be present in `dst`.\npub fn new(dst: &'d mut String) -> Self{\n        Self { dst }\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::SerializeDocumentArray":["#[doc(hidden)]\npub struct SerializeDocumentArray<'d> {\n        inner: InnerSerializeDocumentSeq,\n        dst: &'d mut String,\n        settings: DocumentFormatter,\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::SerializeDocumentArray::<'d>::new":["pub(crate) fn new(ser: Serializer<'d>, inner: InnerSerializeDocumentSeq) -> Self{\n            Self {\n                inner,\n                dst: ser.dst,\n                settings: ser.settings,\n            }\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::SerializeDocumentTable":["#[doc(hidden)]\npub struct SerializeDocumentTable<'d> {\n        inner: InnerSerializeDocumentTable,\n        dst: &'d mut String,\n        settings: DocumentFormatter,\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::SerializeDocumentTable::<'d>::new":["pub(crate) fn new(ser: Serializer<'d>, inner: InnerSerializeDocumentTable) -> Self{\n            Self {\n                inner,\n                dst: ser.dst,\n                settings: ser.settings,\n            }\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::SerializeValueArray":["#[doc(hidden)]\npub struct SerializeValueArray<'d> {\n        inner: InnerSerializeValueSeq,\n        dst: &'d mut String,\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::SerializeValueArray::<'d>::new":["pub(crate) fn new(ser: ValueSerializer<'d>, inner: InnerSerializeValueSeq) -> Self{\n            Self {\n                inner,\n                dst: ser.dst,\n            }\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::SerializeValueTable":["#[doc(hidden)]\npub struct SerializeValueTable<'d> {\n        inner: InnerSerializeValueTable,\n        dst: &'d mut String,\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::SerializeValueTable::<'d>::new":["pub(crate) fn new(ser: ValueSerializer<'d>, inner: InnerSerializeValueTable) -> Self{\n            Self {\n                inner,\n                dst: ser.dst,\n            }\n        }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::write_document":["pub(crate) fn write_document(\n        dst: &mut String,\n        mut settings: DocumentFormatter,\n        value: Result<toml_edit::Value, crate::edit::ser::Error>,\n    ) -> Result<(), Error>{\n        use std::fmt::Write;\n\n        let value = value.map_err(Error::wrap)?;\n        let mut table = match toml_edit::Item::Value(value).into_table() {\n            Ok(i) => i,\n            Err(_) => {\n                return Err(Error::unsupported_type(None));\n            }\n        };\n\n        use toml_edit::visit_mut::VisitMut as _;\n        settings.visit_table_mut(&mut table);\n\n        let doc: toml_edit::Document = table.into();\n        write!(dst, \"{}\", doc).unwrap();\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::internal::write_value":["pub(crate) fn write_value(\n        dst: &mut String,\n        value: Result<toml_edit::Value, crate::edit::ser::Error>,\n    ) -> Result<(), Error>{\n        use std::fmt::Write;\n\n        let value = value.map_err(Error::wrap)?;\n\n        write!(dst, \"{}\", value).unwrap();\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::to_string":["/// Serialize the given data structure as a String of TOML.\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, if `T` contains a map with non-string keys, or if `T` attempts to\n/// serialize an unsupported datatype such as an enum, tuple, or tuple struct.\n///\n/// To serialize TOML values, instead of documents, see [`ValueSerializer`].\n///\n/// # Examples\n///\n/// ```\n/// use serde::Serialize;\n///\n/// #[derive(Serialize)]\n/// struct Config {\n///     database: Database,\n/// }\n///\n/// #[derive(Serialize)]\n/// struct Database {\n///     ip: String,\n///     port: Vec<u16>,\n///     connection_max: u32,\n///     enabled: bool,\n/// }\n///\n/// let config = Config {\n///     database: Database {\n///         ip: \"192.168.1.1\".to_string(),\n///         port: vec![8001, 8002, 8003],\n///         connection_max: 5000,\n///         enabled: false,\n///     },\n/// };\n///\n/// let toml = toml::to_string(&config).unwrap();\n/// println!(\"{}\", toml)\n/// ```\n#[cfg(feature = \"display\")]\npub fn to_string<T: ?Sized>(value: &T) -> Result<String, Error>\nwhere\n    T: serde::ser::Serialize,{\n    let mut output = String::new();\n    let serializer = Serializer::new(&mut output);\n    value.serialize(serializer)?;\n    Ok(output)\n}","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"ser::to_string_pretty":["/// Serialize the given data structure as a \"pretty\" String of TOML.\n///\n/// This is identical to `to_string` except the output string has a more\n/// \"pretty\" output. See `Serializer::pretty` for more details.\n///\n/// To serialize TOML values, instead of documents, see [`ValueSerializer`].\n///\n/// For greater customization, instead serialize to a\n/// [`toml_edit::Document`](https://docs.rs/toml_edit/latest/toml_edit/struct.Document.html).\n#[cfg(feature = \"display\")]\npub fn to_string_pretty<T: ?Sized>(value: &T) -> Result<String, Error>\nwhere\n    T: serde::ser::Serialize,{\n    let mut output = String::new();\n    let serializer = Serializer::pretty(&mut output);\n    value.serialize(serializer)?;\n    Ok(output)\n}","Real(LocalPath(\"crates/toml/src/ser.rs\"))"],"table::<impl map::Map<std::string::String, value::Value>>::try_from":["/// Convert a `T` into `toml::Table`.\n///\n/// This conversion can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\npub fn try_from<T>(value: T) -> Result<Self, crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        value.serialize(crate::value::TableSerializer)\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"table::<impl map::Map<std::string::String, value::Value>>::try_into":["/// Interpret a `toml::Table` as an instance of type `T`.\n///\n/// This conversion can fail if the structure of the `Table` does not match the structure\n/// expected by `T`, for example if `T` is a bool which can't be mapped to a `Table`. It can\n/// also fail if the structure is correct but `T`'s implementation of `Deserialize` decides\n/// that something is wrong with the data, for example required struct fields are missing from\n/// the TOML map or some number is too big to fit in the expected primitive type.\npub fn try_into<'de, T>(self) -> Result<T, crate::de::Error>\n    where\n        T: de::Deserialize<'de>,{\n        de::Deserialize::deserialize(self)\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_any":["fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,{\n        Value::Table(self).deserialize_any(visitor)\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_byte_buf":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bytes":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_enum":["#[inline]\nfn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,{\n        Value::Table(self).deserialize_enum(name, variants, visitor)\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_newtype_struct":["fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,{\n        Value::Table(self).deserialize_newtype_struct(name, visitor)\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_option":["fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, crate::de::Error>\n    where\n        V: de::Visitor<'de>,{\n        Value::Table(self).deserialize_option(visitor)\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))"],"table::<impl serde::de::IntoDeserializer<'de, de::Error> for map::Map<std::string::String, value::Value>>::into_deserializer":["fn into_deserializer(self) -> Self{\n        self\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"table::<impl std::fmt::Display for map::Map<std::string::String, value::Value>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        crate::ser::to_string(self)\n            .expect(\"Unable to represent value as string\")\n            .fmt(f)\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"table::<impl std::str::FromStr for map::Map<std::string::String, value::Value>>::from_str":["fn from_str(s: &str) -> Result<Self, Self::Err>{\n        crate::from_str(s)\n    }","Real(LocalPath(\"crates/toml/src/table.rs\"))"],"value::DatetimeOrTable":["struct DatetimeOrTable<'a> {\n    key: &'a mut String,\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Index":["/// Types that can be used to index a `toml::Value`\n///\n/// Currently this is implemented for `usize` to index arrays and `str` to index\n/// tables.\n///\n/// This trait is sealed and not intended for implementation outside of the\n/// `toml` crate.\npub trait Index: Sealed {\n    #[doc(hidden)]\n    fn index<'a>(&self, val: &'a Value) -> Option<&'a Value>;\n    #[doc(hidden)]\n    fn index_mut<'a>(&self, val: &'a mut Value) -> Option<&'a mut Value>;\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::MapDeserializer":["struct MapDeserializer {\n    iter: <Table as IntoIterator>::IntoIter,\n    value: Option<(String, Value)>,\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::MapDeserializer::new":["fn new(map: Table) -> Self{\n        MapDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::MapEnumDeserializer":["/// Deserializes table values into enum variants.\npub(crate) struct MapEnumDeserializer {\n    value: Value,\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::MapEnumDeserializer::new":["pub(crate) fn new(value: Value) -> Self{\n        MapEnumDeserializer { value }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Sealed":["/// An implementation detail that should not be implemented, this will change in\n/// the future and break code otherwise.\n#[doc(hidden)]\npub trait Sealed {}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::SeqDeserializer":["struct SeqDeserializer {\n    iter: vec::IntoIter<Value>,\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::SeqDeserializer::new":["fn new(vec: Vec<Value>) -> Self{\n        SeqDeserializer {\n            iter: vec.into_iter(),\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::SerializeMap":["pub(crate) struct SerializeMap {\n    map: Table,\n    next_key: Option<String>,\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::TableSerializer":["pub(crate) struct TableSerializer;","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value":["/// Representation of a TOML value.\npub enum Value {\n    /// Represents a TOML string\n    String(String),\n    /// Represents a TOML integer\n    Integer(i64),\n    /// Represents a TOML float\n    Float(f64),\n    /// Represents a TOML boolean\n    Boolean(bool),\n    /// Represents a TOML datetime\n    Datetime(Datetime),\n    /// Represents a TOML array\n    Array(Array),\n    /// Represents a TOML table\n    Table(Table),\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_array":["/// Extracts the array value if it is an array.\npub fn as_array(&self) -> Option<&Vec<Value>>{\n        match *self {\n            Value::Array(ref s) => Some(s),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_array_mut":["/// Extracts the array value if it is an array.\npub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>>{\n        match *self {\n            Value::Array(ref mut s) => Some(s),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_bool":["/// Extracts the boolean value if it is a boolean.\npub fn as_bool(&self) -> Option<bool>{\n        match *self {\n            Value::Boolean(b) => Some(b),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_datetime":["/// Extracts the datetime value if it is a datetime.\n///\n/// Note that a parsed TOML value will only contain ISO 8601 dates. An\n/// example date is:\n///\n/// ```notrust\n/// 1979-05-27T07:32:00Z\n/// ```\npub fn as_datetime(&self) -> Option<&Datetime>{\n        match *self {\n            Value::Datetime(ref s) => Some(s),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_float":["/// Extracts the float value if it is a float.\npub fn as_float(&self) -> Option<f64>{\n        match *self {\n            Value::Float(f) => Some(f),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_integer":["/// Extracts the integer value if it is an integer.\npub fn as_integer(&self) -> Option<i64>{\n        match *self {\n            Value::Integer(i) => Some(i),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_str":["/// Extracts the string of this value if it is a string.\npub fn as_str(&self) -> Option<&str>{\n        match *self {\n            Value::String(ref s) => Some(&**s),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_table":["/// Extracts the table value if it is a table.\npub fn as_table(&self) -> Option<&Table>{\n        match *self {\n            Value::Table(ref s) => Some(s),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::as_table_mut":["/// Extracts the table value if it is a table.\npub fn as_table_mut(&mut self) -> Option<&mut Table>{\n        match *self {\n            Value::Table(ref mut s) => Some(s),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::get":["/// Index into a TOML array or map. A string index can be used to access a\n/// value in a map, and a usize index can be used to access an element of an\n/// array.\n///\n/// Returns `None` if the type of `self` does not match the type of the\n/// index, for example if the index is a string and `self` is an array or a\n/// number. Also returns `None` if the given key does not exist in the map\n/// or the given index is not within the bounds of the array.\npub fn get<I: Index>(&self, index: I) -> Option<&Value>{\n        index.index(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::get_mut":["/// Mutably index into a TOML array or map. A string index can be used to\n/// access a value in a map, and a usize index can be used to access an\n/// element of an array.\n///\n/// Returns `None` if the type of `self` does not match the type of the\n/// index, for example if the index is a string and `self` is an array or a\n/// number. Also returns `None` if the given key does not exist in the map\n/// or the given index is not within the bounds of the array.\npub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value>{\n        index.index_mut(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::is_array":["/// Tests whether this value is an array.\npub fn is_array(&self) -> bool{\n        self.as_array().is_some()\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::is_bool":["/// Tests whether this value is a boolean.\npub fn is_bool(&self) -> bool{\n        self.as_bool().is_some()\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::is_datetime":["/// Tests whether this value is a datetime.\npub fn is_datetime(&self) -> bool{\n        self.as_datetime().is_some()\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::is_float":["/// Tests whether this value is a float.\npub fn is_float(&self) -> bool{\n        self.as_float().is_some()\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::is_integer":["/// Tests whether this value is an integer.\npub fn is_integer(&self) -> bool{\n        self.as_integer().is_some()\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::is_str":["/// Tests if this value is a string.\npub fn is_str(&self) -> bool{\n        self.as_str().is_some()\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::is_table":["/// Tests whether this value is a table.\npub fn is_table(&self) -> bool{\n        self.as_table().is_some()\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::same_type":["/// Tests whether this and another value have the same type.\npub fn same_type(&self, other: &Value) -> bool{\n        discriminant(self) == discriminant(other)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::try_from":["/// Convert a `T` into `toml::Value` which is an enum that can represent\n/// any valid TOML data.\n///\n/// This conversion can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\npub fn try_from<T>(value: T) -> Result<Value, crate::ser::Error>\n    where\n        T: ser::Serialize,{\n        value.serialize(ValueSerializer)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::try_into":["/// Interpret a `toml::Value` as an instance of type `T`.\n///\n/// This conversion can fail if the structure of the `Value` does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the\n/// `Value` contains something other than a TOML table. It can also fail if the\n/// structure is correct but `T`'s implementation of `Deserialize` decides that\n/// something is wrong with the data, for example required struct fields are\n/// missing from the TOML map or some number is too big to fit in the expected\n/// primitive type.\npub fn try_into<'de, T>(self) -> Result<T, crate::de::Error>\n    where\n        T: de::Deserialize<'de>,{\n        de::Deserialize::deserialize(self)\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::Value::type_str":["/// Returns a human-readable representation of the type of this value.\npub fn type_str(&self) -> &'static str{\n        match *self {\n            Value::String(..) => \"string\",\n            Value::Integer(..) => \"integer\",\n            Value::Float(..) => \"float\",\n            Value::Boolean(..) => \"boolean\",\n            Value::Datetime(..) => \"datetime\",\n            Value::Array(..) => \"array\",\n            Value::Table(..) => \"table\",\n        }\n    }","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::ValueSerializeMap":["struct ValueSerializeMap {\n    ser: SerializeMap,\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::ValueSerializeVec":["struct ValueSerializeVec {\n    vec: Vec<Value>,\n}","Real(LocalPath(\"crates/toml/src/value.rs\"))"],"value::ValueSerializer":["struct ValueSerializer;","Real(LocalPath(\"crates/toml/src/value.rs\"))"]},"struct_constructor":{"&'a mut value::Value":["insert","into_mut","or_insert","or_insert_with"],"&'static str":["type_str"],"&mut value::Value":["get_mut","index_mut"],"&std::string::String":["key"],"&str":["as_str","message"],"&toml_datetime::Datetime":["as_datetime"],"&value::Value":["get","index"],"(<V as serde::de::DeserializeSeed<'de>>::Value, <value::MapDeserializer as serde::de::EnumAccess<'de>>::Variant)":["variant_seed"],"(usize, std::option::Option<usize>)":["size_hint"],"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::Value":["visit_map","visit_unit"],"<S as serde::Serializer>::Ok":["serialize"],"<T as serde::de::DeserializeSeed<'de>>::Value":["newtype_variant_seed","next_element_seed","next_key_seed","next_value_seed"],"<V as serde::de::Visitor<'de>>::Value":["deserialize_any","deserialize_bool","deserialize_byte_buf","deserialize_bytes","deserialize_char","deserialize_enum","deserialize_f32","deserialize_f64","deserialize_i16","deserialize_i32","deserialize_i64","deserialize_i8","deserialize_identifier","deserialize_ignored_any","deserialize_map","deserialize_newtype_struct","deserialize_option","deserialize_seq","deserialize_str","deserialize_string","deserialize_struct","deserialize_tuple","deserialize_tuple_struct","deserialize_u16","deserialize_u32","deserialize_u64","deserialize_u8","deserialize_unit","deserialize_unit_struct","struct_variant","tuple_variant"],"<map::IntoIter as std::iter::Iterator>::Item":["next","next_back"],"<map::Iter<'a> as std::iter::Iterator>::Item":["next","next_back"],"<map::IterMut<'a> as std::iter::Iterator>::Item":["next","next_back"],"<map::Keys<'a> as std::iter::Iterator>::Item":["next","next_back"],"<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<map::Values<'a> as std::iter::Iterator>::Item":["next","next_back"],"<ser::Serializer<'d> as serde::Serializer>::Ok":["serialize_bool","serialize_bytes","serialize_char","serialize_f32","serialize_f64","serialize_i16","serialize_i32","serialize_i64","serialize_i8","serialize_newtype_struct","serialize_newtype_variant","serialize_none","serialize_some","serialize_str","serialize_u16","serialize_u32","serialize_u64","serialize_u8","serialize_unit","serialize_unit_struct","serialize_unit_variant"],"<ser::Serializer<'d> as serde::Serializer>::SerializeMap":["serialize_map"],"<ser::Serializer<'d> as serde::Serializer>::SerializeSeq":["serialize_seq"],"<ser::Serializer<'d> as serde::Serializer>::SerializeStruct":["serialize_struct"],"<ser::Serializer<'d> as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<ser::Serializer<'d> as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<ser::Serializer<'d> as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<ser::Serializer<'d> as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"<ser::ValueSerializer<'d> as serde::Serializer>::Ok":["serialize_bool","serialize_bytes","serialize_char","serialize_f32","serialize_f64","serialize_i16","serialize_i32","serialize_i64","serialize_i8","serialize_newtype_struct","serialize_newtype_variant","serialize_none","serialize_some","serialize_str","serialize_u16","serialize_u32","serialize_u64","serialize_u8","serialize_unit","serialize_unit_struct","serialize_unit_variant"],"<ser::ValueSerializer<'d> as serde::Serializer>::SerializeMap":["serialize_map"],"<ser::ValueSerializer<'d> as serde::Serializer>::SerializeSeq":["serialize_seq"],"<ser::ValueSerializer<'d> as serde::Serializer>::SerializeStruct":["serialize_struct"],"<ser::ValueSerializer<'d> as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<ser::ValueSerializer<'d> as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<ser::ValueSerializer<'d> as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<ser::ValueSerializer<'d> as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::Ok":["end"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::Ok":["end"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::Ok":["end"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::Ok":["end"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::Ok":["end"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::Ok":["end"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::Ok":["end"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::Ok":["end"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::Ok":["end"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::Ok":["end"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::Ok":["end"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::Ok":["end"],"<value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<value::TableSerializer as serde::Serializer>::SerializeMap":["serialize_map"],"<value::TableSerializer as serde::Serializer>::SerializeSeq":["serialize_seq"],"<value::TableSerializer as serde::Serializer>::SerializeStruct":["serialize_struct"],"<value::TableSerializer as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<value::TableSerializer as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<value::TableSerializer as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<value::TableSerializer as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"<value::ValueSerializer as serde::Serializer>::SerializeMap":["serialize_map"],"<value::ValueSerializer as serde::Serializer>::SerializeSeq":["serialize_seq"],"<value::ValueSerializer as serde::Serializer>::SerializeStruct":["serialize_struct"],"<value::ValueSerializer as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<value::ValueSerializer as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<value::ValueSerializer as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<value::ValueSerializer as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"bool":["as_bool","contains_key","eq","is_array","is_bool","is_datetime","is_empty","is_float","is_integer","is_str","is_table","same_type","visit_str","visit_string"],"de::Deserializer":["new"],"de::Error":["clone","custom","new"],"de::ValueDeserializer":["new"],"f64":["as_float"],"fmt::DocumentFormatter":["clone","default"],"i64":["as_integer"],"map::Entry":["entry"],"map::Iter":["iter"],"map::IterMut":["iter_mut"],"map::Keys":["keys"],"map::Map":["clone","default","deserialize","end","from_iter","from_str","new","serialize_bool","serialize_bytes","serialize_char","serialize_f32","serialize_f64","serialize_i16","serialize_i32","serialize_i64","serialize_i8","serialize_newtype_struct","serialize_newtype_variant","serialize_none","serialize_some","serialize_str","serialize_u16","serialize_u32","serialize_u64","serialize_u8","serialize_unit","serialize_unit_struct","serialize_unit_variant","try_from","with_capacity"],"map::Values":["values"],"ser::Error":["clone","custom","key_not_string","new","unsupported_none","unsupported_type","wrap"],"ser::Serializer":["new","pretty"],"ser::ValueSerializer":["new"],"ser::internal::SerializeDocumentArray":["new"],"ser::internal::SerializeDocumentTable":["new"],"ser::internal::SerializeValueArray":["new"],"ser::internal::SerializeValueTable":["new"],"std::ops::Range":["span"],"std::string::String":["to_string","to_string_pretty"],"usize":["len","size_hint"],"value::MapDeserializer":["new"],"value::MapEnumDeserializer":["new"],"value::SeqDeserializer":["new"],"value::Value":["clone","deserialize","end","from","from_str","remove","serialize_bool","serialize_bytes","serialize_char","serialize_f32","serialize_f64","serialize_i16","serialize_i32","serialize_i64","serialize_i8","serialize_newtype_struct","serialize_newtype_variant","serialize_none","serialize_some","serialize_str","serialize_u16","serialize_u32","serialize_u64","serialize_u8","serialize_unit","serialize_unit_struct","serialize_unit_variant","try_from","visit_bool","visit_f64","visit_i32","visit_i64","visit_map","visit_seq","visit_some","visit_str","visit_string","visit_u32","visit_u64"]},"struct_to_trait":{"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":["serde::de::Visitor"],"<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor":["serde::de::Visitor"],"de::Deserializer":["serde::Deserializer"],"de::Error":["serde::de::Error","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"de::ValueDeserializer":["serde::Deserializer"],"fmt::DocumentFormatter":["std::clone::Clone","std::default::Default","std::marker::Copy","toml_edit::visit_mut::VisitMut"],"map::IntoIter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"map::Iter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"map::IterMut":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"map::Keys":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"map::Map":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::ops::Index","std::ops::IndexMut"],"map::Values":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"ser::Error":["serde::ser::Error","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ser::Serializer":["serde::Serializer"],"ser::ValueSerializer":["serde::Serializer"],"ser::internal::SerializeDocumentArray":["serde::ser::SerializeSeq","serde::ser::SerializeTuple","serde::ser::SerializeTupleStruct","serde::ser::SerializeTupleVariant"],"ser::internal::SerializeDocumentTable":["serde::ser::SerializeMap","serde::ser::SerializeStruct"],"ser::internal::SerializeValueArray":["serde::ser::SerializeSeq","serde::ser::SerializeTuple","serde::ser::SerializeTupleStruct","serde::ser::SerializeTupleVariant"],"ser::internal::SerializeValueTable":["serde::ser::SerializeMap","serde::ser::SerializeStruct"],"std::string::String":["value::Index","value::Sealed"],"table::Table":["serde::Deserializer","serde::de::IntoDeserializer","std::fmt::Display","std::str::FromStr"],"value::DatetimeOrTable":["serde::de::DeserializeSeed","serde::de::Visitor"],"value::MapDeserializer":["serde::de::EnumAccess","serde::de::MapAccess"],"value::MapEnumDeserializer":["serde::de::VariantAccess"],"value::SeqDeserializer":["serde::de::SeqAccess"],"value::SerializeMap":["serde::ser::SerializeMap","serde::ser::SerializeStruct"],"value::TableSerializer":["serde::Serializer"],"value::Value":["serde::Deserialize","serde::Deserializer","serde::Serialize","serde::de::IntoDeserializer","std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq","std::ops::Index","std::ops::IndexMut","std::str::FromStr"],"value::ValueSerializeMap":["serde::ser::SerializeMap","serde::ser::SerializeStruct"],"value::ValueSerializeVec":["serde::ser::SerializeSeq","serde::ser::SerializeTuple","serde::ser::SerializeTupleStruct","serde::ser::SerializeTupleVariant"],"value::ValueSerializer":["serde::Serializer"]},"targets":{"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::IntoIterator"],"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::IntoIterator"],"<&'s T as value::Index>::index":["index","Real(LocalPath(\"crates/toml/src/value.rs\"))","value::Index"],"<&'s T as value::Index>::index_mut":["index_mut","Real(LocalPath(\"crates/toml/src/value.rs\"))","value::Index"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"crates/toml/src/map.rs\"))","serde::de::Visitor"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":["visit_map","Real(LocalPath(\"crates/toml/src/map.rs\"))","serde::de::Visitor"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":["visit_unit","Real(LocalPath(\"crates/toml/src/map.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":["visit_bool","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":["visit_f64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i32":["visit_i32","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":["visit_i64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":["visit_map","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":["visit_seq","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":["visit_some","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":["visit_str","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":["visit_string","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u32":["visit_u32","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":["visit_u64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Deserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::Error as serde::de::Error>::custom":["custom","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::de::Error"],"<de::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml/src/de.rs\"))","std::fmt::Display"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"crates/toml/src/de.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<de::ValueDeserializer<'a> as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_array_mut":["visit_array_mut","Real(LocalPath(\"crates/toml/src/fmt.rs\"))","toml_edit::visit_mut::VisitMut"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_document_mut":["visit_document_mut","Real(LocalPath(\"crates/toml/src/fmt.rs\"))","toml_edit::visit_mut::VisitMut"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_item_mut":["visit_item_mut","Real(LocalPath(\"crates/toml/src/fmt.rs\"))","toml_edit::visit_mut::VisitMut"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_table_mut":["visit_table_mut","Real(LocalPath(\"crates/toml/src/fmt.rs\"))","toml_edit::visit_mut::VisitMut"],"<fmt::DocumentFormatter as toml_edit::visit_mut::VisitMut>::visit_value_mut":["visit_value_mut","Real(LocalPath(\"crates/toml/src/fmt.rs\"))","toml_edit::visit_mut::VisitMut"],"<map::IntoIter as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::IntoIter as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::IntoIter as std::iter::Iterator>::next":["next","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::IntoIter as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::Iter<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::Iter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::Iter<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::IterMut<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::IterMut<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::IterMut<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::Keys<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::Keys<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::Keys<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"crates/toml/src/map.rs\"))","serde::Deserialize"],"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"crates/toml/src/map.rs\"))","serde::Serialize"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::clone::Clone"],"<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::cmp::PartialEq"],"<map::Map<std::string::String, value::Value> as std::default::Default>::default":["default","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::default::Default"],"<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::fmt::Debug"],"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":["extend","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Extend"],"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":["from_iter","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::FromIterator"],"<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::IntoIterator"],"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":["index","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::ops::Index"],"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":["index_mut","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::ops::IndexMut"],"<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::Values<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::Values<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<map::Values<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"crates/toml/src/map.rs\"))","std::iter::Iterator"],"<ser::Error as serde::ser::Error>::custom":["custom","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::Error"],"<ser::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml/src/ser.rs\"))","std::fmt::Display"],"<ser::Serializer<'d> as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::Serializer<'d> as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::ValueSerializer<'d> as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::Serializer"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeSeq"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeSeq>::serialize_element":["serialize_element","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeSeq"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTuple"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTuple>::serialize_element":["serialize_element","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTuple"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTupleStruct"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTupleStruct"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTupleVariant"],"<ser::internal::SerializeDocumentArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTupleVariant"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_key":["serialize_key","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeMap>::serialize_value":["serialize_value","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeStruct"],"<ser::internal::SerializeDocumentTable<'d> as serde::ser::SerializeStruct>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeStruct"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeSeq"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeSeq>::serialize_element":["serialize_element","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeSeq"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTuple"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTuple>::serialize_element":["serialize_element","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTuple"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTupleStruct"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleStruct>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTupleStruct"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTupleVariant"],"<ser::internal::SerializeValueArray<'d> as serde::ser::SerializeTupleVariant>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeTupleVariant"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_key":["serialize_key","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeMap>::serialize_value":["serialize_value","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::end":["end","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeStruct"],"<ser::internal::SerializeValueTable<'d> as serde::ser::SerializeStruct>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/ser.rs\"))","serde::ser::SerializeStruct"],"<std::string::String as value::Index>::index":["index","Real(LocalPath(\"crates/toml/src/value.rs\"))","value::Index"],"<std::string::String as value::Index>::index_mut":["index_mut","Real(LocalPath(\"crates/toml/src/value.rs\"))","value::Index"],"<str as value::Index>::index":["index","Real(LocalPath(\"crates/toml/src/value.rs\"))","value::Index"],"<str as value::Index>::index_mut":["index_mut","Real(LocalPath(\"crates/toml/src/value.rs\"))","value::Index"],"<usize as value::Index>::index":["index","Real(LocalPath(\"crates/toml/src/value.rs\"))","value::Index"],"<usize as value::Index>::index_mut":["index_mut","Real(LocalPath(\"crates/toml/src/value.rs\"))","value::Index"],"<value::DatetimeOrTable<'a> as serde::de::DeserializeSeed<'de>>::deserialize":["deserialize","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::DeserializeSeed"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_str":["visit_str","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<value::DatetimeOrTable<'a> as serde::de::Visitor<'de>>::visit_string":["visit_string","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::Visitor"],"<value::MapDeserializer as serde::de::EnumAccess<'de>>::variant_seed":["variant_seed","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::EnumAccess"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":["next_key_seed","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::MapAccess"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":["next_value_seed","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::MapAccess"],"<value::MapDeserializer as serde::de::MapAccess<'de>>::size_hint":["size_hint","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::MapAccess"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":["newtype_variant_seed","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::VariantAccess"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::struct_variant":["struct_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::VariantAccess"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":["tuple_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::VariantAccess"],"<value::MapEnumDeserializer as serde::de::VariantAccess<'de>>::unit_variant":["unit_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::VariantAccess"],"<value::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":["next_element_seed","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::SeqAccess"],"<value::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint":["size_hint","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::SeqAccess"],"<value::SerializeMap as serde::ser::SerializeMap>::end":["end","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeMap"],"<value::SerializeMap as serde::ser::SerializeMap>::serialize_key":["serialize_key","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeMap"],"<value::SerializeMap as serde::ser::SerializeMap>::serialize_value":["serialize_value","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeMap"],"<value::SerializeMap as serde::ser::SerializeStruct>::end":["end","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeStruct"],"<value::SerializeMap as serde::ser::SerializeStruct>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeStruct"],"<value::TableSerializer as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::TableSerializer as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::Value as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Deserialize"],"<value::Value as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"<value::Value as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serialize"],"<value::Value as serde::de::IntoDeserializer<'de, de::Error>>::into_deserializer":["into_deserializer","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::de::IntoDeserializer"],"<value::Value as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<bool>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<f32>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<f64>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<i32>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<i64>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<i8>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<map::Map<std::string::String, value::Value>>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<std::collections::BTreeMap<S, V>>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<std::collections::HashMap<S, V>>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<std::vec::Vec<V>>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<toml_datetime::Datetime>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<u32>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<u8>>::from":["from","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::convert::From"],"<value::Value as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::fmt::Display"],"<value::Value as std::ops::Index<I>>::index":["index","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::ops::Index"],"<value::Value as std::ops::IndexMut<I>>::index_mut":["index_mut","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::ops::IndexMut"],"<value::Value as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"crates/toml/src/value.rs\"))","std::str::FromStr"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::end":["end","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeMap"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_key":["serialize_key","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeMap"],"<value::ValueSerializeMap as serde::ser::SerializeMap>::serialize_value":["serialize_value","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeMap"],"<value::ValueSerializeMap as serde::ser::SerializeStruct>::end":["end","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeStruct"],"<value::ValueSerializeMap as serde::ser::SerializeStruct>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeStruct"],"<value::ValueSerializeVec as serde::ser::SerializeSeq>::end":["end","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeSeq"],"<value::ValueSerializeVec as serde::ser::SerializeSeq>::serialize_element":["serialize_element","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeSeq"],"<value::ValueSerializeVec as serde::ser::SerializeTuple>::end":["end","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeTuple"],"<value::ValueSerializeVec as serde::ser::SerializeTuple>::serialize_element":["serialize_element","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeTuple"],"<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::end":["end","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeTupleStruct"],"<value::ValueSerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeTupleStruct"],"<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::end":["end","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeTupleVariant"],"<value::ValueSerializeVec as serde::ser::SerializeTupleVariant>::serialize_field":["serialize_field","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::ser::SerializeTupleVariant"],"<value::ValueSerializer as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"<value::ValueSerializer as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"crates/toml/src/value.rs\"))","serde::Serializer"],"de::Deserializer::<'a>::new":["new","Real(LocalPath(\"crates/toml/src/de.rs\"))",""],"de::Error::add_key":["add_key","Real(LocalPath(\"crates/toml/src/de.rs\"))",""],"de::Error::message":["message","Real(LocalPath(\"crates/toml/src/de.rs\"))",""],"de::Error::new":["new","Real(LocalPath(\"crates/toml/src/de.rs\"))",""],"de::Error::span":["span","Real(LocalPath(\"crates/toml/src/de.rs\"))",""],"de::ValueDeserializer::<'a>::new":["new","Real(LocalPath(\"crates/toml/src/de.rs\"))",""],"de::from_str":["from_str","Real(LocalPath(\"crates/toml/src/de.rs\"))",""],"macros::insert_toml":["insert_toml","Real(LocalPath(\"crates/toml/src/macros.rs\"))",""],"macros::push_toml":["push_toml","Real(LocalPath(\"crates/toml/src/macros.rs\"))",""],"macros::traverse":["traverse","Real(LocalPath(\"crates/toml/src/macros.rs\"))",""],"map::Entry::<'a>::key":["key","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Entry::<'a>::or_insert":["or_insert","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Entry::<'a>::or_insert_with":["or_insert_with","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::clear":["clear","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::contains_key":["contains_key","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::entry":["entry","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::get":["get","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::get_mut":["get_mut","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::insert":["insert","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::is_empty":["is_empty","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::iter":["iter","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::iter_mut":["iter_mut","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::keys":["keys","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::len":["len","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::new":["new","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::remove":["remove","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::values":["values","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::with_capacity":["with_capacity","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::OccupiedEntry::<'a>::get":["get","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::OccupiedEntry::<'a>::get_mut":["get_mut","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::OccupiedEntry::<'a>::insert":["insert","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::OccupiedEntry::<'a>::into_mut":["into_mut","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::OccupiedEntry::<'a>::key":["key","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::OccupiedEntry::<'a>::remove":["remove","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::VacantEntry::<'a>::insert":["insert","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"map::VacantEntry::<'a>::key":["key","Real(LocalPath(\"crates/toml/src/map.rs\"))",""],"ser::Error::key_not_string":["key_not_string","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::Error::new":["new","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::Error::unsupported_none":["unsupported_none","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::Error::unsupported_type":["unsupported_type","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::Error::wrap":["wrap","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::Serializer::<'d>::new":["new","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::Serializer::<'d>::pretty":["pretty","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::ValueSerializer::<'d>::new":["new","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::internal::SerializeDocumentArray::<'d>::new":["new","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::internal::SerializeDocumentTable::<'d>::new":["new","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::internal::SerializeValueArray::<'d>::new":["new","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::internal::SerializeValueTable::<'d>::new":["new","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::internal::write_document":["write_document","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::internal::write_value":["write_value","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::to_string":["to_string","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"ser::to_string_pretty":["to_string_pretty","Real(LocalPath(\"crates/toml/src/ser.rs\"))",""],"table::<impl map::Map<std::string::String, value::Value>>::try_from":["try_from","Real(LocalPath(\"crates/toml/src/table.rs\"))",""],"table::<impl map::Map<std::string::String, value::Value>>::try_into":["try_into","Real(LocalPath(\"crates/toml/src/table.rs\"))",""],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_any":["deserialize_any","Real(LocalPath(\"crates/toml/src/table.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"crates/toml/src/table.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"crates/toml/src/table.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_option":["deserialize_option","Real(LocalPath(\"crates/toml/src/table.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::Deserializer<'de> for map::Map<std::string::String, value::Value>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.160/src/macros.rs\"))","serde::Deserializer"],"table::<impl serde::de::IntoDeserializer<'de, de::Error> for map::Map<std::string::String, value::Value>>::into_deserializer":["into_deserializer","Real(LocalPath(\"crates/toml/src/table.rs\"))","serde::de::IntoDeserializer"],"table::<impl std::fmt::Display for map::Map<std::string::String, value::Value>>::fmt":["fmt","Real(LocalPath(\"crates/toml/src/table.rs\"))","std::fmt::Display"],"table::<impl std::str::FromStr for map::Map<std::string::String, value::Value>>::from_str":["from_str","Real(LocalPath(\"crates/toml/src/table.rs\"))","std::str::FromStr"],"value::MapDeserializer::new":["new","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::MapEnumDeserializer::new":["new","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::SeqDeserializer::new":["new","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_array":["as_array","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_array_mut":["as_array_mut","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_bool":["as_bool","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_datetime":["as_datetime","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_float":["as_float","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_integer":["as_integer","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_str":["as_str","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_table":["as_table","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::as_table_mut":["as_table_mut","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::get":["get","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::get_mut":["get_mut","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::is_array":["is_array","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::is_bool":["is_bool","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::is_datetime":["is_datetime","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::is_float":["is_float","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::is_integer":["is_integer","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::is_str":["is_str","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::is_table":["is_table","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::same_type":["same_type","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::try_from":["try_from","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::try_into":["try_into","Real(LocalPath(\"crates/toml/src/value.rs\"))",""],"value::Value::type_str":["type_str","Real(LocalPath(\"crates/toml/src/value.rs\"))",""]},"trait_to_struct":{"serde::Deserialize":["map::Map","value::Value"],"serde::Deserializer":["de::Deserializer","de::ValueDeserializer","table::Table","value::Value"],"serde::Serialize":["map::Map","value::Value"],"serde::Serializer":["ser::Serializer","ser::ValueSerializer","value::TableSerializer","value::ValueSerializer"],"serde::de::DeserializeSeed":["value::DatetimeOrTable"],"serde::de::EnumAccess":["value::MapDeserializer"],"serde::de::Error":["de::Error"],"serde::de::IntoDeserializer":["table::Table","value::Value"],"serde::de::MapAccess":["value::MapDeserializer"],"serde::de::SeqAccess":["value::SeqDeserializer"],"serde::de::VariantAccess":["value::MapEnumDeserializer"],"serde::de::Visitor":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","value::DatetimeOrTable"],"serde::ser::Error":["ser::Error"],"serde::ser::SerializeMap":["ser::internal::SerializeDocumentTable","ser::internal::SerializeValueTable","value::SerializeMap","value::ValueSerializeMap"],"serde::ser::SerializeSeq":["ser::internal::SerializeDocumentArray","ser::internal::SerializeValueArray","value::ValueSerializeVec"],"serde::ser::SerializeStruct":["ser::internal::SerializeDocumentTable","ser::internal::SerializeValueTable","value::SerializeMap","value::ValueSerializeMap"],"serde::ser::SerializeTuple":["ser::internal::SerializeDocumentArray","ser::internal::SerializeValueArray","value::ValueSerializeVec"],"serde::ser::SerializeTupleStruct":["ser::internal::SerializeDocumentArray","ser::internal::SerializeValueArray","value::ValueSerializeVec"],"serde::ser::SerializeTupleVariant":["ser::internal::SerializeDocumentArray","ser::internal::SerializeValueArray","value::ValueSerializeVec"],"std::clone::Clone":["de::Error","fmt::DocumentFormatter","map::Map","ser::Error","value::Value"],"std::cmp::Eq":["de::Error","ser::Error"],"std::cmp::PartialEq":["de::Error","map::Map","ser::Error","value::Value"],"std::convert::From":["value::Value"],"std::default::Default":["fmt::DocumentFormatter","map::Map"],"std::error::Error":["de::Error","ser::Error"],"std::fmt::Debug":["de::Error","map::Map","ser::Error","value::Value"],"std::fmt::Display":["de::Error","ser::Error","table::Table","value::Value"],"std::iter::DoubleEndedIterator":["map::IntoIter","map::Iter","map::IterMut","map::Keys","map::Values"],"std::iter::ExactSizeIterator":["map::IntoIter","map::Iter","map::IterMut","map::Keys","map::Values"],"std::iter::Extend":["map::Map"],"std::iter::FromIterator":["map::Map"],"std::iter::IntoIterator":["map::Map"],"std::iter::Iterator":["map::IntoIter","map::Iter","map::IterMut","map::Keys","map::Values"],"std::marker::Copy":["fmt::DocumentFormatter"],"std::marker::StructuralEq":["de::Error","ser::Error"],"std::marker::StructuralPartialEq":["de::Error","ser::Error","value::Value"],"std::ops::Index":["map::Map","value::Value"],"std::ops::IndexMut":["map::Map","value::Value"],"std::str::FromStr":["table::Table","value::Value"],"toml_edit::visit_mut::VisitMut":["fmt::DocumentFormatter"],"value::Index":["std::string::String"],"value::Sealed":["std::string::String"]},"type_to_def_path":{"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor":"<value::Value as serde::Deserialize<'de>>::deserialize::ValueVisitor","de::Deserializer<'a>":"de::Deserializer","de::Error":"de::Error","de::ValueDeserializer<'a>":"de::ValueDeserializer","fmt::DocumentFormatter":"fmt::DocumentFormatter","map::Entry<'a>":"map::Entry","map::IntoIter":"map::IntoIter","map::Iter<'a>":"map::Iter","map::IterMut<'a>":"map::IterMut","map::Keys<'a>":"map::Keys","map::Map<K, V>":"map::Map","map::OccupiedEntry<'a>":"map::OccupiedEntry","map::VacantEntry<'a>":"map::VacantEntry","map::Values<'a>":"map::Values","ser::Error":"ser::Error","ser::Serializer<'d>":"ser::Serializer","ser::ValueSerializer<'d>":"ser::ValueSerializer","ser::internal::SerializeDocumentArray<'d>":"ser::internal::SerializeDocumentArray","ser::internal::SerializeDocumentTable<'d>":"ser::internal::SerializeDocumentTable","ser::internal::SerializeValueArray<'d>":"ser::internal::SerializeValueArray","ser::internal::SerializeValueTable<'d>":"ser::internal::SerializeValueTable","value::DatetimeOrTable<'a>":"value::DatetimeOrTable","value::MapDeserializer":"value::MapDeserializer","value::MapEnumDeserializer":"value::MapEnumDeserializer","value::SeqDeserializer":"value::SeqDeserializer","value::SerializeMap":"value::SerializeMap","value::TableSerializer":"value::TableSerializer","value::Value":"value::Value","value::ValueSerializeMap":"value::ValueSerializeMap","value::ValueSerializeVec":"value::ValueSerializeVec","value::ValueSerializer":"value::ValueSerializer"}}