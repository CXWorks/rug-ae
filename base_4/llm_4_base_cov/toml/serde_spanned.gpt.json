{"<spanned::Spanned<T> as std::cmp::Ord>::cmp": "```rust\n#[cfg(test)]\nmod tests_llm_16_1 {\n    use crate::spanned::Spanned;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_cmp() {\n        let span_a = std::ops::Range { start: 0, end: 5 };\n        let span_b = std::ops::Range { start: 5, end: 10 };\n        let spanned_value_a = Spanned { span: span_a.clone(), value: 10 };\n        let spanned_value_b = Spanned { span: span_b, value: 20 };\n        let spanned_value_c = Spanned { span: span_a, value: 10 };\n\n        assert_eq!(spanned_value_a.cmp(&spanned_value_b), Ordering::Less);\n        assert_eq!(spanned_value_b.cmp(&spanned_value_a), Ordering::Greater);\n        assert_eq!(spanned_value_a.cmp(&spanned_value_c), Ordering::Equal);\n    }\n}\n```", "<spanned::Spanned<T> as std::cmp::PartialEq>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Spanned;\n    use std::cmp::PartialEq;\n\n    #[test]\n    fn test_eq() {\n        let span_a = Spanned {\n            span: 0..5,\n            value: \"hello\".to_string(),\n        };\n        let span_b = Spanned {\n            span: 5..10,\n            value: \"hello\".to_string(),\n        };\n        let span_c = Spanned {\n            span: 0..5,\n            value: \"world\".to_string(),\n        };\n        let span_d = Spanned {\n            span: 5..10,\n            value: \"world\".to_string(),\n        };\n\n        assert!(span_a.eq(&span_b), \"Values are equal but spans are different\");\n        assert!(!span_a.eq(&span_c), \"Values are different and spans are equal\");\n        assert!(!span_c.eq(&span_d), \"Values are equal but spans are different\");\n        assert!(span_b.eq(&span_d), \"Values are equal and spans are different\");\n    }\n}\n```", "<spanned::Spanned<T> as std::cmp::PartialOrd>::partial_cmp": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Spanned;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let span_a = Spanned { span: 0..5, value: 10 };\n        let span_b = Spanned { span: 3..8, value: 10 };\n\n        assert_eq!(span_a.partial_cmp(&span_b), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let span_a = Spanned { span: 0..5, value: 5 };\n        let span_b = Spanned { span: 3..8, value: 10 };\n\n        assert_eq!(span_a.partial_cmp(&span_b), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let span_a = Spanned { span: 0..5, value: 10 };\n        let span_b = Spanned { span: 3..8, value: 5 };\n\n        assert_eq!(span_a.partial_cmp(&span_b), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_none() {\n        let span_a = Spanned { span: 0..5, value: std::f64::NAN };\n        let span_b = Spanned { span: 3..8, value: 5.0 };\n\n        assert_eq!(span_a.partial_cmp(&span_b), None);\n    }\n}\n```", "<spanned::Spanned<T> as std::convert::AsMut<T>>::as_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Spanned;\n    use std::convert::AsMut;\n\n    #[test]\n    fn test_as_mut() {\n        let mut spanned_value = Spanned {\n            span: 0..10,\n            value: 42,\n        };\n\n        let value_mut: &mut i32 = spanned_value.as_mut();\n        *value_mut = 10;\n\n        assert_eq!(*spanned_value.get_ref(), 10);\n    }\n}\n```", "<spanned::Spanned<T> as std::convert::AsRef<T>>::as_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Spanned;\n    use std::convert::AsRef;\n\n    #[test]\n    fn test_as_ref() {\n        let spanned_value = Spanned { span: 0..10, value: 42 };\n        let value_ref: &i32 = spanned_value.as_ref();\n        assert_eq!(value_ref, &spanned_value.value);\n    }\n}\n```", "<spanned::Spanned<T> as std::hash::Hash>::hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Spanned;\n    use std::hash::{Hash, Hasher};\n\n    // Dummy hasher that just accumulates the raw bytes.\n    struct DummyHasher(u64);\n    impl Hasher for DummyHasher {\n        fn finish(&self) -> u64 {\n            self.0\n        }\n        fn write(&mut self, bytes: &[u8]) {\n            for byte in bytes {\n                self.0 = self.0.wrapping_add(u64::from(*byte));\n            }\n        }\n    }\n\n    #[test]\n    fn hash_spanned_value() {\n        let spanned_a = Spanned {\n            span: 0..0, // span should not affect the hash\n            value: \"Test Value A\",\n        };\n        let spanned_b = Spanned {\n            span: 100..100, // span should not affect the hash\n            value: \"Test Value A\",\n        };\n\n        // Hasher instances\n        let mut hasher_a = DummyHasher(0);\n        let mut hasher_b = DummyHasher(0);\n\n        // Hash spanned values\n        spanned_a.hash(&mut hasher_a);\n        spanned_b.hash(&mut hasher_b);\n\n        // Hashes should match as values are the same\n        assert_eq!(hasher_a.finish(), hasher_b.finish());\n    }\n\n    #[test]\n    fn hash_different_spanned_values() {\n        let spanned_a = Spanned {\n            span: 0..0, // span should not affect the hash\n            value: \"Test Value A\",\n        };\n        let spanned_b = Spanned {\n            span: 100..100, // span should not affect the hash\n            value: \"Test Value B\",\n        };\n\n        // Hasher instances\n        let mut hasher_a = DummyHasher(0);\n        let mut hasher_b = DummyHasher(0);\n\n        // Hash spanned values\n        spanned_a.hash(&mut hasher_a);\n        spanned_b.hash(&mut hasher_b);\n\n        // Hashes should not match as the values inside Spanned are different\n        assert_ne!(hasher_a.finish(), hasher_b.finish());\n    }\n}\n```", "<spanned::Spanned<std::string::String> as std::borrow::Borrow<str>>::borrow": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::borrow::Borrow;\n\n    #[test]\n    fn spanned_borrow_returns_correct_str_slice() {\n        let spanned = Spanned {\n            span: 0..10,\n            value: \"Hello, World!\".to_string(),\n        };\n        let borrowed: &str = spanned.borrow();\n        assert_eq!(borrowed, \"Hello, World!\");\n    }\n}\n```", "spanned::Spanned::<T>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_mut() {\n        let mut spanned_value = Spanned {\n            span: 0..10,\n            value: 42,\n        };\n\n        *spanned_value.get_mut() = 100;\n\n        assert_eq!(spanned_value.value, 100);\n    }\n}\n```", "spanned::Spanned::<T>::get_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Spanned;\n\n    #[test]\n    fn test_get_ref() {\n        // Example for a simple type like i32\n        let spanned_i32 = Spanned {\n            span: 0..10,\n            value: 42,\n        };\n        assert_eq!(spanned_i32.get_ref(), &42);\n        \n        // Example for a heap-allocated type like String\n        let spanned_string = Spanned {\n            span: 10..20,\n            value: \"Hello, World!\".to_string(),\n        };\n        assert_eq!(spanned_string.get_ref(), \"Hello, World!\");\n        \n        // Example for a complex type like Vec\n        let spanned_vec = Spanned {\n            span: 20..30,\n            value: vec![1, 2, 3],\n        };\n        assert_eq!(spanned_vec.get_ref(), &vec![1, 2, 3]);\n    }\n}\n```", "spanned::Spanned::<T>::into_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_into_inner() {\n        // Test with a simple primitive type\n        let spanned_int = Spanned {\n            span: 0..10,\n            value: 42,\n        };\n        let value_int = spanned_int.into_inner();\n        assert_eq!(value_int, 42);\n\n        // Test with a more complex type, like a String\n        let spanned_string = Spanned {\n            span: 10..20,\n            value: String::from(\"Hello, World!\"),\n        };\n        let value_string = spanned_string.into_inner();\n        assert_eq!(value_string, \"Hello, World!\");\n\n        // Test with a type that implements Eq but not Copy\n        let spanned_vec = Spanned {\n            span: 20..30,\n            value: vec![1, 2, 3],\n        };\n        let value_vec = spanned_vec.into_inner();\n        assert_eq!(value_vec, vec![1, 2, 3]);\n    }\n}\n```", "spanned::Spanned::<T>::span": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Spanned;\n    use std::ops::Range;\n\n    #[test]\n    fn test_span() {\n        let spanned_value: Spanned<String> = Spanned {\n            span: Range { start: 5, end: 10 },\n            value: \"example\".to_string(),\n        };\n\n        let span = spanned_value.span();\n        assert_eq!(5, span.start);\n        assert_eq!(10, span.end);\n    }\n}\n```"}