{"dependencies":{"<datetime::Date as std::clone::Clone>::clone":["datetime::Date"],"<datetime::Date as std::cmp::Eq>::assert_receiver_is_total_eq":["datetime::Date"],"<datetime::Date as std::cmp::Ord>::cmp":["datetime::Date","std::cmp::Ordering"],"<datetime::Date as std::cmp::PartialEq>::eq":["datetime::Date"],"<datetime::Date as std::cmp::PartialOrd>::partial_cmp":["datetime::Date","std::marker::Sized","std::option::Option"],"<datetime::Date as std::fmt::Debug>::fmt":["datetime::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::Date as std::fmt::Display>::fmt":["datetime::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::Datetime as std::clone::Clone>::clone":["datetime::Datetime","std::marker::Sized","std::option::Option"],"<datetime::Datetime as std::cmp::Eq>::assert_receiver_is_total_eq":["datetime::Datetime","std::marker::Sized","std::option::Option"],"<datetime::Datetime as std::cmp::Ord>::cmp":["datetime::Datetime","std::cmp::Ordering","std::marker::Sized","std::option::Option"],"<datetime::Datetime as std::cmp::PartialEq>::eq":["datetime::Datetime","std::marker::Sized","std::option::Option"],"<datetime::Datetime as std::cmp::PartialOrd>::partial_cmp":["datetime::Datetime","std::marker::Sized","std::option::Option"],"<datetime::Datetime as std::convert::From<datetime::Date>>::from":["datetime::Date","datetime::Datetime","std::marker::Sized","std::option::Option"],"<datetime::Datetime as std::convert::From<datetime::Time>>::from":["datetime::Datetime","datetime::Time","std::marker::Sized","std::option::Option"],"<datetime::Datetime as std::fmt::Debug>::fmt":["datetime::Datetime","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<datetime::Datetime as std::fmt::Display>::fmt":["datetime::Datetime","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<datetime::Datetime as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<datetime::DatetimeParseError as std::clone::Clone>::clone":["datetime::DatetimeParseError"],"<datetime::DatetimeParseError as std::fmt::Debug>::fmt":["datetime::DatetimeParseError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::DatetimeParseError as std::fmt::Display>::fmt":["datetime::DatetimeParseError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::Offset as std::clone::Clone>::clone":["datetime::Offset"],"<datetime::Offset as std::cmp::Eq>::assert_receiver_is_total_eq":["datetime::Offset"],"<datetime::Offset as std::cmp::Ord>::cmp":["datetime::Offset","std::cmp::Ordering"],"<datetime::Offset as std::cmp::PartialEq>::eq":["datetime::Offset"],"<datetime::Offset as std::cmp::PartialOrd>::partial_cmp":["datetime::Offset","std::marker::Sized","std::option::Option"],"<datetime::Offset as std::fmt::Debug>::fmt":["datetime::Offset","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::Offset as std::fmt::Display>::fmt":["datetime::Offset","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::Time as std::clone::Clone>::clone":["datetime::Time"],"<datetime::Time as std::cmp::Eq>::assert_receiver_is_total_eq":["datetime::Time"],"<datetime::Time as std::cmp::Ord>::cmp":["datetime::Time","std::cmp::Ordering"],"<datetime::Time as std::cmp::PartialEq>::eq":["datetime::Time"],"<datetime::Time as std::cmp::PartialOrd>::partial_cmp":["datetime::Time","std::marker::Sized","std::option::Option"],"<datetime::Time as std::fmt::Debug>::fmt":["datetime::Time","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::Time as std::fmt::Display>::fmt":["datetime::Time","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"datetime::Date":["datetime::Date"],"datetime::Datetime":["datetime::Datetime","std::marker::Sized","std::option::Option"],"datetime::DatetimeParseError":["datetime::DatetimeParseError"],"datetime::Offset":["datetime::Offset"],"datetime::Time":["datetime::Time"],"datetime::digit":["std::marker::Sized","std::result::Result","std::str::Chars"]},"glob_path_import":{},"self_to_fn":{"datetime::Date":["Clone","Copy","Debug","Eq","Ord","PartialEq","PartialOrd","impl fmt::Display for Date {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:04}-{:02}-{:02}\", self.year, self.month, self.day)\n    }\n}"],"datetime::Datetime":["Clone","Copy","Debug","Eq","Ord","PartialEq","PartialOrd","impl From<Date> for Datetime {\n    fn from(other: Date) -> Self {\n        Datetime {\n            date: Some(other),\n            time: None,\n            offset: None,\n        }\n    }\n}","impl From<Time> for Datetime {\n    fn from(other: Time) -> Self {\n        Datetime {\n            date: None,\n            time: Some(other),\n            offset: None,\n        }\n    }\n}","impl FromStr for Datetime {\n    type Err = DatetimeParseError;\n\n    fn from_str(date: &str) -> Result<Datetime, DatetimeParseError> {\n        // Accepted formats:\n        //\n        // 0000-00-00T00:00:00.00Z\n        // 0000-00-00T00:00:00.00\n        // 0000-00-00\n        // 00:00:00.00\n        if date.len() < 3 {\n            return Err(DatetimeParseError {});\n        }\n        let mut offset_allowed = true;\n        let mut chars = date.chars();\n\n        // First up, parse the full date if we can\n        let full_date = if chars.clone().nth(2) == Some(':') {\n            offset_allowed = false;\n            None\n        } else {\n            let y1 = u16::from(digit(&mut chars)?);\n            let y2 = u16::from(digit(&mut chars)?);\n            let y3 = u16::from(digit(&mut chars)?);\n            let y4 = u16::from(digit(&mut chars)?);\n\n            match chars.next() {\n                Some('-') => {}\n                _ => return Err(DatetimeParseError {}),\n            }\n\n            let m1 = digit(&mut chars)?;\n            let m2 = digit(&mut chars)?;\n\n            match chars.next() {\n                Some('-') => {}\n                _ => return Err(DatetimeParseError {}),\n            }\n\n            let d1 = digit(&mut chars)?;\n            let d2 = digit(&mut chars)?;\n\n            let date = Date {\n                year: y1 * 1000 + y2 * 100 + y3 * 10 + y4,\n                month: m1 * 10 + m2,\n                day: d1 * 10 + d2,\n            };\n\n            if date.month < 1 || date.month > 12 {\n                return Err(DatetimeParseError {});\n            }\n            if date.day < 1 || date.day > 31 {\n                return Err(DatetimeParseError {});\n            }\n\n            Some(date)\n        };\n\n        // Next parse the \"partial-time\" if available\n        let next = chars.clone().next();\n        let partial_time = if full_date.is_some()\n            && (next == Some('T') || next == Some('t') || next == Some(' '))\n        {\n            chars.next();\n            true\n        } else {\n            full_date.is_none()\n        };\n\n        let time = if partial_time {\n            let h1 = digit(&mut chars)?;\n            let h2 = digit(&mut chars)?;\n            match chars.next() {\n                Some(':') => {}\n                _ => return Err(DatetimeParseError {}),\n            }\n            let m1 = digit(&mut chars)?;\n            let m2 = digit(&mut chars)?;\n            match chars.next() {\n                Some(':') => {}\n                _ => return Err(DatetimeParseError {}),\n            }\n            let s1 = digit(&mut chars)?;\n            let s2 = digit(&mut chars)?;\n\n            let mut nanosecond = 0;\n            if chars.clone().next() == Some('.') {\n                chars.next();\n                let whole = chars.as_str();\n\n                let mut end = whole.len();\n                for (i, byte) in whole.bytes().enumerate() {\n                    match byte {\n                        b'0'..=b'9' => {\n                            if i < 9 {\n                                let p = 10_u32.pow(8 - i as u32);\n                                nanosecond += p * u32::from(byte - b'0');\n                            }\n                        }\n                        _ => {\n                            end = i;\n                            break;\n                        }\n                    }\n                }\n                if end == 0 {\n                    return Err(DatetimeParseError {});\n                }\n                chars = whole[end..].chars();\n            }\n\n            let time = Time {\n                hour: h1 * 10 + h2,\n                minute: m1 * 10 + m2,\n                second: s1 * 10 + s2,\n                nanosecond,\n            };\n\n            if time.hour > 24 {\n                return Err(DatetimeParseError {});\n            }\n            if time.minute > 59 {\n                return Err(DatetimeParseError {});\n            }\n            if time.second > 59 {\n                return Err(DatetimeParseError {});\n            }\n            if time.nanosecond > 999_999_999 {\n                return Err(DatetimeParseError {});\n            }\n\n            Some(time)\n        } else {\n            offset_allowed = false;\n            None\n        };\n\n        // And finally, parse the offset\n        let offset = if offset_allowed {\n            let next = chars.clone().next();\n            if next == Some('Z') || next == Some('z') {\n                chars.next();\n                Some(Offset::Z)\n            } else if next.is_none() {\n                None\n            } else {\n                let sign = match next {\n                    Some('+') => 1,\n                    Some('-') => -1,\n                    _ => return Err(DatetimeParseError {}),\n                };\n                chars.next();\n                let h1 = digit(&mut chars)? as i16;\n                let h2 = digit(&mut chars)? as i16;\n                match chars.next() {\n                    Some(':') => {}\n                    _ => return Err(DatetimeParseError {}),\n                }\n                let m1 = digit(&mut chars)? as i16;\n                let m2 = digit(&mut chars)? as i16;\n\n                let hours = h1 * 10 + h2;\n                let minutes = m1 * 10 + m2;\n\n                let total_minutes = sign * (hours * 60 + minutes);\n\n                if !((-24 * 60)..=(24 * 60)).contains(&total_minutes) {\n                    return Err(DatetimeParseError {});\n                }\n\n                Some(Offset::Custom {\n                    minutes: total_minutes,\n                })\n            }\n        } else {\n            None\n        };\n\n        // Return an error if we didn't hit eof, otherwise return our parsed\n        // date\n        if chars.next().is_some() {\n            return Err(DatetimeParseError {});\n        }\n\n        Ok(Datetime {\n            date: full_date,\n            time,\n            offset,\n        })\n    }\n}","impl fmt::Display for Datetime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(ref date) = self.date {\n            write!(f, \"{}\", date)?;\n        }\n        if let Some(ref time) = self.time {\n            if self.date.is_some() {\n                write!(f, \"T\")?;\n            }\n            write!(f, \"{}\", time)?;\n        }\n        if let Some(ref offset) = self.offset {\n            write!(f, \"{}\", offset)?;\n        }\n        Ok(())\n    }\n}"],"datetime::DatetimeParseError":["Clone","Debug","impl error::Error for DatetimeParseError {}","impl fmt::Display for DatetimeParseError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"failed to parse datetime\".fmt(f)\n    }\n}"],"datetime::Offset":["Clone","Copy","Debug","Eq","Ord","PartialEq","PartialOrd","impl fmt::Display for Offset {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Offset::Z => write!(f, \"Z\"),\n            Offset::Custom { mut minutes } => {\n                let mut sign = '+';\n                if minutes < 0 {\n                    minutes *= -1;\n                    sign = '-';\n                }\n                let hours = minutes / 60;\n                let minutes = minutes % 60;\n                write!(f, \"{}{:02}:{:02}\", sign, hours, minutes)\n            }\n        }\n    }\n}"],"datetime::Time":["Clone","Copy","Debug","Eq","Ord","PartialEq","PartialOrd","impl fmt::Display for Time {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:02}:{:02}:{:02}\", self.hour, self.minute, self.second)?;\n        if self.nanosecond != 0 {\n            let s = format!(\"{:09}\", self.nanosecond);\n            write!(f, \".{}\", s.trim_end_matches('0'))?;\n        }\n        Ok(())\n    }\n}"]},"single_path_import":{"datetime::Date":"Date","datetime::Datetime":"Datetime","datetime::DatetimeParseError":"DatetimeParseError","datetime::Offset":"Offset","datetime::Time":"Time"},"srcs":{"<datetime::Date as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{:04}-{:02}-{:02}\", self.year, self.month, self.day)\n    }","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"<datetime::Datetime as std::convert::From<datetime::Date>>::from":["fn from(other: Date) -> Self{\n        Datetime {\n            date: Some(other),\n            time: None,\n            offset: None,\n        }\n    }","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"<datetime::Datetime as std::convert::From<datetime::Time>>::from":["fn from(other: Time) -> Self{\n        Datetime {\n            date: None,\n            time: Some(other),\n            offset: None,\n        }\n    }","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"<datetime::Datetime as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        if let Some(ref date) = self.date {\n            write!(f, \"{}\", date)?;\n        }\n        if let Some(ref time) = self.time {\n            if self.date.is_some() {\n                write!(f, \"T\")?;\n            }\n            write!(f, \"{}\", time)?;\n        }\n        if let Some(ref offset) = self.offset {\n            write!(f, \"{}\", offset)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"<datetime::Datetime as std::str::FromStr>::from_str":["fn from_str(date: &str) -> Result<Datetime, DatetimeParseError>{\n        // Accepted formats:\n        //\n        // 0000-00-00T00:00:00.00Z\n        // 0000-00-00T00:00:00.00\n        // 0000-00-00\n        // 00:00:00.00\n        if date.len() < 3 {\n            return Err(DatetimeParseError {});\n        }\n        let mut offset_allowed = true;\n        let mut chars = date.chars();\n\n        // First up, parse the full date if we can\n        let full_date = if chars.clone().nth(2) == Some(':') {\n            offset_allowed = false;\n            None\n        } else {\n            let y1 = u16::from(digit(&mut chars)?);\n            let y2 = u16::from(digit(&mut chars)?);\n            let y3 = u16::from(digit(&mut chars)?);\n            let y4 = u16::from(digit(&mut chars)?);\n\n            match chars.next() {\n                Some('-') => {}\n                _ => return Err(DatetimeParseError {}),\n            }\n\n            let m1 = digit(&mut chars)?;\n            let m2 = digit(&mut chars)?;\n\n            match chars.next() {\n                Some('-') => {}\n                _ => return Err(DatetimeParseError {}),\n            }\n\n            let d1 = digit(&mut chars)?;\n            let d2 = digit(&mut chars)?;\n\n            let date = Date {\n                year: y1 * 1000 + y2 * 100 + y3 * 10 + y4,\n                month: m1 * 10 + m2,\n                day: d1 * 10 + d2,\n            };\n\n            if date.month < 1 || date.month > 12 {\n                return Err(DatetimeParseError {});\n            }\n            if date.day < 1 || date.day > 31 {\n                return Err(DatetimeParseError {});\n            }\n\n            Some(date)\n        };\n\n        // Next parse the \"partial-time\" if available\n        let next = chars.clone().next();\n        let partial_time = if full_date.is_some()\n            && (next == Some('T') || next == Some('t') || next == Some(' '))\n        {\n            chars.next();\n            true\n        } else {\n            full_date.is_none()\n        };\n\n        let time = if partial_time {\n            let h1 = digit(&mut chars)?;\n            let h2 = digit(&mut chars)?;\n            match chars.next() {\n                Some(':') => {}\n                _ => return Err(DatetimeParseError {}),\n            }\n            let m1 = digit(&mut chars)?;\n            let m2 = digit(&mut chars)?;\n            match chars.next() {\n                Some(':') => {}\n                _ => return Err(DatetimeParseError {}),\n            }\n            let s1 = digit(&mut chars)?;\n            let s2 = digit(&mut chars)?;\n\n            let mut nanosecond = 0;\n            if chars.clone().next() == Some('.') {\n                chars.next();\n                let whole = chars.as_str();\n\n                let mut end = whole.len();\n                for (i, byte) in whole.bytes().enumerate() {\n                    match byte {\n                        b'0'..=b'9' => {\n                            if i < 9 {\n                                let p = 10_u32.pow(8 - i as u32);\n                                nanosecond += p * u32::from(byte - b'0');\n                            }\n                        }\n                        _ => {\n                            end = i;\n                            break;\n                        }\n                    }\n                }\n                if end == 0 {\n                    return Err(DatetimeParseError {});\n                }\n                chars = whole[end..].chars();\n            }\n\n            let time = Time {\n                hour: h1 * 10 + h2,\n                minute: m1 * 10 + m2,\n                second: s1 * 10 + s2,\n                nanosecond,\n            };\n\n            if time.hour > 24 {\n                return Err(DatetimeParseError {});\n            }\n            if time.minute > 59 {\n                return Err(DatetimeParseError {});\n            }\n            if time.second > 59 {\n                return Err(DatetimeParseError {});\n            }\n            if time.nanosecond > 999_999_999 {\n                return Err(DatetimeParseError {});\n            }\n\n            Some(time)\n        } else {\n            offset_allowed = false;\n            None\n        };\n\n        // And finally, parse the offset\n        let offset = if offset_allowed {\n            let next = chars.clone().next();\n            if next == Some('Z') || next == Some('z') {\n                chars.next();\n                Some(Offset::Z)\n            } else if next.is_none() {\n                None\n            } else {\n                let sign = match next {\n                    Some('+') => 1,\n                    Some('-') => -1,\n                    _ => return Err(DatetimeParseError {}),\n                };\n                chars.next();\n                let h1 = digit(&mut chars)? as i16;\n                let h2 = digit(&mut chars)? as i16;\n                match chars.next() {\n                    Some(':') => {}\n                    _ => return Err(DatetimeParseError {}),\n                }\n                let m1 = digit(&mut chars)? as i16;\n                let m2 = digit(&mut chars)? as i16;\n\n                let hours = h1 * 10 + h2;\n                let minutes = m1 * 10 + m2;\n\n                let total_minutes = sign * (hours * 60 + minutes);\n\n                if !((-24 * 60)..=(24 * 60)).contains(&total_minutes) {\n                    return Err(DatetimeParseError {});\n                }\n\n                Some(Offset::Custom {\n                    minutes: total_minutes,\n                })\n            }\n        } else {\n            None\n        };\n\n        // Return an error if we didn't hit eof, otherwise return our parsed\n        // date\n        if chars.next().is_some() {\n            return Err(DatetimeParseError {});\n        }\n\n        Ok(Datetime {\n            date: full_date,\n            time,\n            offset,\n        })\n    }","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"<datetime::DatetimeParseError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        \"failed to parse datetime\".fmt(f)\n    }","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"<datetime::Offset as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            Offset::Z => write!(f, \"Z\"),\n            Offset::Custom { mut minutes } => {\n                let mut sign = '+';\n                if minutes < 0 {\n                    minutes *= -1;\n                    sign = '-';\n                }\n                let hours = minutes / 60;\n                let minutes = minutes % 60;\n                write!(f, \"{}{:02}:{:02}\", sign, hours, minutes)\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"<datetime::Time as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{:02}:{:02}:{:02}\", self.hour, self.minute, self.second)?;\n        if self.nanosecond != 0 {\n            let s = format!(\"{:09}\", self.nanosecond);\n            write!(f, \".{}\", s.trim_end_matches('0'))?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"datetime::Date":["/// A parsed TOML date value\n///\n/// May be part of a [`Datetime`]. Alone, `Date` corresponds to a [Local Date].\n/// From the TOML v1.0.0 spec:\n///\n/// > If you include only the date portion of an RFC 3339 formatted date-time,\n/// > it will represent that entire day without any relation to an offset or\n/// > timezone.\n/// >\n/// > ```toml\n/// > ld1 = 1979-05-27\n/// > ```\n///\n/// [Local Date]: https://toml.io/en/v1.0.0#local-date\npub struct Date {\n    /// Year: four digits\n    pub year: u16,\n    /// Month: 1 to 12\n    pub month: u8,\n    /// Day: 1 to {28, 29, 30, 31} (based on month/year)\n    pub day: u8,\n}","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"datetime::Datetime":["/// A parsed TOML datetime value\n///\n/// This structure is intended to represent the datetime primitive type that can\n/// be encoded into TOML documents. This type is a parsed version that contains\n/// all metadata internally.\n///\n/// Currently this type is intentionally conservative and only supports\n/// `to_string` as an accessor. Over time though it's intended that it'll grow\n/// more support!\n///\n/// Note that if you're using `Deserialize` to deserialize a TOML document, you\n/// can use this as a placeholder for where you're expecting a datetime to be\n/// specified.\n///\n/// Also note though that while this type implements `Serialize` and\n/// `Deserialize` it's only recommended to use this type with the TOML format,\n/// otherwise encoded in other formats it may look a little odd.\n///\n/// Depending on how the option values are used, this struct will correspond\n/// with one of the following four datetimes from the [TOML v1.0.0 spec]:\n///\n/// | `date`    | `time`    | `offset`  | TOML type          |\n/// | --------- | --------- | --------- | ------------------ |\n/// | `Some(_)` | `Some(_)` | `Some(_)` | [Offset Date-Time] |\n/// | `Some(_)` | `Some(_)` | `None`    | [Local Date-Time]  |\n/// | `Some(_)` | `None`    | `None`    | [Local Date]       |\n/// | `None`    | `Some(_)` | `None`    | [Local Time]       |\n///\n/// **1. Offset Date-Time**: If all the optional values are used, `Datetime`\n/// corresponds to an [Offset Date-Time]. From the TOML v1.0.0 spec:\n///\n/// > To unambiguously represent a specific instant in time, you may use an\n/// > RFC 3339 formatted date-time with offset.\n/// >\n/// > ```toml\n/// > odt1 = 1979-05-27T07:32:00Z\n/// > odt2 = 1979-05-27T00:32:00-07:00\n/// > odt3 = 1979-05-27T00:32:00.999999-07:00\n/// > ```\n/// >\n/// > For the sake of readability, you may replace the T delimiter between date\n/// > and time with a space character (as permitted by RFC 3339 section 5.6).\n/// >\n/// > ```toml\n/// > odt4 = 1979-05-27 07:32:00Z\n/// > ```\n///\n/// **2. Local Date-Time**: If `date` and `time` are given but `offset` is\n/// `None`, `Datetime` corresponds to a [Local Date-Time]. From the spec:\n///\n/// > If you omit the offset from an RFC 3339 formatted date-time, it will\n/// > represent the given date-time without any relation to an offset or\n/// > timezone. It cannot be converted to an instant in time without additional\n/// > information. Conversion to an instant, if required, is implementation-\n/// > specific.\n/// >\n/// > ```toml\n/// > ldt1 = 1979-05-27T07:32:00\n/// > ldt2 = 1979-05-27T00:32:00.999999\n/// > ```\n///\n/// **3. Local Date**: If only `date` is given, `Datetime` corresponds to a\n/// [Local Date]; see the docs for [`Date`].\n///\n/// **4. Local Time**: If only `time` is given, `Datetime` corresponds to a\n/// [Local Time]; see the docs for [`Time`].\n///\n/// [TOML v1.0.0 spec]: https://toml.io/en/v1.0.0\n/// [Offset Date-Time]: https://toml.io/en/v1.0.0#offset-date-time\n/// [Local Date-Time]: https://toml.io/en/v1.0.0#local-date-time\n/// [Local Date]: https://toml.io/en/v1.0.0#local-date\n/// [Local Time]: https://toml.io/en/v1.0.0#local-time\npub struct Datetime {\n    /// Optional date.\n    /// Required for: *Offset Date-Time*, *Local Date-Time*, *Local Date*.\n    pub date: Option<Date>,\n\n    /// Optional time.\n    /// Required for: *Offset Date-Time*, *Local Date-Time*, *Local Time*.\n    pub time: Option<Time>,\n\n    /// Optional offset.\n    /// Required for: *Offset Date-Time*.\n    pub offset: Option<Offset>,\n}","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"datetime::DatetimeParseError":["/// Error returned from parsing a `Datetime` in the `FromStr` implementation.\n#[non_exhaustive]\npub struct DatetimeParseError {}","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"datetime::Offset":["/// A parsed TOML time offset\n///\npub enum Offset {\n    /// > A suffix which, when applied to a time, denotes a UTC offset of 00:00;\n    /// > often spoken \"Zulu\" from the ICAO phonetic alphabet representation of\n    /// > the letter \"Z\". --- [RFC 3339 section 2]\n    ///\n    /// [RFC 3339 section 2]: https://datatracker.ietf.org/doc/html/rfc3339#section-2\n    Z,\n\n    /// Offset between local time and UTC\n    Custom {\n        /// Minutes: -1_440..1_440\n        minutes: i16,\n    },\n}","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"datetime::Time":["/// A parsed TOML time value\n///\n/// May be part of a [`Datetime`]. Alone, `Time` corresponds to a [Local Time].\n/// From the TOML v1.0.0 spec:\n///\n/// > If you include only the time portion of an RFC 3339 formatted date-time,\n/// > it will represent that time of day without any relation to a specific\n/// > day or any offset or timezone.\n/// >\n/// > ```toml\n/// > lt1 = 07:32:00\n/// > lt2 = 00:32:00.999999\n/// > ```\n/// >\n/// > Millisecond precision is required. Further precision of fractional\n/// > seconds is implementation-specific. If the value contains greater\n/// > precision than the implementation can support, the additional precision\n/// > must be truncated, not rounded.\n///\n/// [Local Time]: https://toml.io/en/v1.0.0#local-time\npub struct Time {\n    /// Hour: 0 to 23\n    pub hour: u8,\n    /// Minute: 0 to 59\n    pub minute: u8,\n    /// Second: 0 to {58, 59, 60} (based on leap second rules)\n    pub second: u8,\n    /// Nanosecond: 0 to 999_999_999\n    pub nanosecond: u32,\n}","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"],"datetime::digit":["fn digit(chars: &mut str::Chars<'_>) -> Result<u8, DatetimeParseError>{\n    match chars.next() {\n        Some(c) if ('0'..='9').contains(&c) => Ok(c as u8 - b'0'),\n        _ => Err(DatetimeParseError {}),\n    }\n}","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))"]},"struct_constructor":{"bool":["eq"],"datetime::Date":["clone"],"datetime::Datetime":["clone","from","from_str"],"datetime::DatetimeParseError":["clone"],"datetime::Offset":["clone"],"datetime::Time":["clone"],"std::cmp::Ordering":["cmp","partial_cmp"],"u8":["digit"]},"struct_to_trait":{"datetime::Date":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"datetime::Datetime":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"datetime::DatetimeParseError":["std::clone::Clone","std::error::Error","std::fmt::Debug","std::fmt::Display"],"datetime::Offset":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"datetime::Time":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"]},"targets":{"<datetime::Date as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))","std::fmt::Display"],"<datetime::Datetime as std::convert::From<datetime::Date>>::from":["from","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))","std::convert::From"],"<datetime::Datetime as std::convert::From<datetime::Time>>::from":["from","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))","std::convert::From"],"<datetime::Datetime as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))","std::fmt::Display"],"<datetime::Datetime as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))","std::str::FromStr"],"<datetime::DatetimeParseError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))","std::fmt::Display"],"<datetime::Offset as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))","std::fmt::Display"],"<datetime::Time as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))","std::fmt::Display"],"datetime::digit":["digit","Real(LocalPath(\"crates/toml_datetime/src/datetime.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["datetime::Date","datetime::Datetime","datetime::DatetimeParseError","datetime::Offset","datetime::Time"],"std::cmp::Eq":["datetime::Date","datetime::Datetime","datetime::Offset","datetime::Time"],"std::cmp::Ord":["datetime::Date","datetime::Datetime","datetime::Offset","datetime::Time"],"std::cmp::PartialEq":["datetime::Date","datetime::Datetime","datetime::Offset","datetime::Time"],"std::cmp::PartialOrd":["datetime::Date","datetime::Datetime","datetime::Offset","datetime::Time"],"std::convert::From":["datetime::Datetime"],"std::error::Error":["datetime::DatetimeParseError"],"std::fmt::Debug":["datetime::Date","datetime::Datetime","datetime::DatetimeParseError","datetime::Offset","datetime::Time"],"std::fmt::Display":["datetime::Date","datetime::Datetime","datetime::DatetimeParseError","datetime::Offset","datetime::Time"],"std::marker::Copy":["datetime::Date","datetime::Datetime","datetime::Offset","datetime::Time"],"std::marker::StructuralEq":["datetime::Date","datetime::Datetime","datetime::Offset","datetime::Time"],"std::marker::StructuralPartialEq":["datetime::Date","datetime::Datetime","datetime::Offset","datetime::Time"],"std::str::FromStr":["datetime::Datetime"]},"type_to_def_path":{"datetime::Date":"datetime::Date","datetime::Datetime":"datetime::Datetime","datetime::DatetimeParseError":"datetime::DatetimeParseError","datetime::Offset":"datetime::Offset","datetime::Time":"datetime::Time"}}