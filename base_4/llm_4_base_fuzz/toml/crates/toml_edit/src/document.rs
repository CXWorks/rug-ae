use std::str::FromStr;
use crate::parser;
use crate::table::Iter;
use crate::{Item, RawString, Table};
/// Type representing a TOML document
#[derive(Debug, Clone)]
pub struct Document {
    pub(crate) root: Item,
    pub(crate) trailing: RawString,
    pub(crate) original: Option<String>,
    pub(crate) span: Option<std::ops::Range<usize>>,
}
impl Document {
    /// Creates an empty document
    pub fn new() -> Self {
        Default::default()
    }
    /// Returns a reference to the root item.
    pub fn as_item(&self) -> &Item {
        &self.root
    }
    /// Returns a mutable reference to the root item.
    pub fn as_item_mut(&mut self) -> &mut Item {
        &mut self.root
    }
    /// Returns a reference to the root table.
    pub fn as_table(&self) -> &Table {
        self.root.as_table().expect("root should always be a table")
    }
    /// Returns a mutable reference to the root table.
    pub fn as_table_mut(&mut self) -> &mut Table {
        self.root.as_table_mut().expect("root should always be a table")
    }
    /// Returns an iterator over the root table.
    pub fn iter(&self) -> Iter<'_> {
        self.as_table().iter()
    }
    /// Set whitespace after last element
    pub fn set_trailing(&mut self, trailing: impl Into<RawString>) {
        self.trailing = trailing.into();
    }
    /// Whitespace after last element
    pub fn trailing(&self) -> &RawString {
        &self.trailing
    }
    /// # Panics
    ///
    /// If run on on a `Document` not generated by the parser
    pub(crate) fn despan(&mut self) {
        self.span = None;
        self.root.despan(self.original.as_deref().unwrap());
        self.trailing.despan(self.original.as_deref().unwrap());
    }
}
impl Default for Document {
    fn default() -> Self {
        Self {
            root: Item::Table(Table::with_pos(Some(0))),
            trailing: Default::default(),
            original: Default::default(),
            span: Default::default(),
        }
    }
}
impl FromStr for Document {
    type Err = crate::TomlError;
    /// Parses a document from a &str
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut d = parser::parse_document(s)?;
        d.despan();
        Ok(d)
    }
}
impl std::ops::Deref for Document {
    type Target = Table;
    fn deref(&self) -> &Self::Target {
        self.as_table()
    }
}
impl std::ops::DerefMut for Document {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.as_table_mut()
    }
}
impl From<Table> for Document {
    fn from(root: Table) -> Self {
        Self {
            root: Item::Table(root),
            ..Default::default()
        }
    }
}
#[cfg(test)]
mod tests_llm_16_16 {
    use crate::{Document, Item, Table};
    use std::str::FromStr;
    #[test]
    fn test_from_table() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2)) = <(&str, &str, &str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut table = Table::new();
        table[rug_fuzz_0] = Item::Value(rug_fuzz_1.into());
        let doc = Document::from(table.clone());
        debug_assert_eq!(doc[rug_fuzz_2].as_str(), Some("value"));
        debug_assert_eq!(doc.to_string(), table.to_string());
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_17 {
    use super::*;
    use crate::*;
    use crate::{Document, Item};
    #[test]
    fn test_document_default() {
        let _rug_st_tests_llm_16_17_rrrruuuugggg_test_document_default = 0;
        let doc = Document::default();
        debug_assert!(matches!(doc.as_item(), & Item::Table(_)));
        debug_assert!(doc.trailing().as_str().unwrap().is_empty());
        debug_assert!(doc.original.is_none());
        debug_assert!(doc.span.is_none());
        let _rug_ed_tests_llm_16_17_rrrruuuugggg_test_document_default = 0;
    }
}
#[cfg(test)]
mod tests_llm_16_18 {
    use super::*;
    use crate::*;
    use std::ops::Deref;
    #[test]
    fn test_document_deref_to_table() {
        let _rug_st_tests_llm_16_18_rrrruuuugggg_test_document_deref_to_table = 0;
        let doc = Document::new();
        let table: &Table = doc.deref();
        debug_assert!(table.is_empty());
        let _rug_ed_tests_llm_16_18_rrrruuuugggg_test_document_deref_to_table = 0;
    }
}
#[cfg(test)]
mod tests_llm_16_19 {
    use super::*;
    use crate::*;
    use std::ops::DerefMut;
    use crate::Document;
    use crate::Item;
    #[test]
    fn deref_mut_for_document() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2)) = <(&str, &str, &str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut doc = Document::new();
        let table = doc.deref_mut();
        debug_assert!(table.is_empty());
        table[rug_fuzz_0] = Item::Value(rug_fuzz_1.parse().unwrap());
        debug_assert_eq!(doc[rug_fuzz_2].as_str(), Some("value"));
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_20_llm_16_20 {
    use crate as toml_edit;
    use crate::Document;
    use std::str::FromStr;
    #[test]
    fn test_from_str_valid_toml() {
        let _rug_st_tests_llm_16_20_llm_16_20_rrrruuuugggg_test_from_str_valid_toml = 0;
        let rug_fuzz_0 = r#"
            [package]
            name = "your_package"
            version = "0.1.0"
        "#;
        let toml_str = rug_fuzz_0;
        let doc_result = Document::from_str(toml_str);
        debug_assert!(doc_result.is_ok());
        let doc = doc_result.unwrap();
        debug_assert_eq!(doc.to_string(), toml_str.trim());
        let _rug_ed_tests_llm_16_20_llm_16_20_rrrruuuugggg_test_from_str_valid_toml = 0;
    }
    #[test]
    fn test_from_str_invalid_toml() {
        let _rug_st_tests_llm_16_20_llm_16_20_rrrruuuugggg_test_from_str_invalid_toml = 0;
        let rug_fuzz_0 = r#"
            [package
            name = "your_package"
            version = "0.1.0"
        "#;
        let toml_str = rug_fuzz_0;
        let doc_result = Document::from_str(toml_str);
        debug_assert!(doc_result.is_err());
        let _rug_ed_tests_llm_16_20_llm_16_20_rrrruuuugggg_test_from_str_invalid_toml = 0;
    }
}
#[cfg(test)]
mod tests_llm_16_178 {
    use crate::{Document, Item, Value, Table};
    #[test]
    fn test_as_item() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2, mut rug_fuzz_3)) = <(&str, &str, &str, &str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut doc = Document::new();
        debug_assert!(
            doc.as_item().is_table(), "The root item should always be a table."
        );
        doc[rug_fuzz_0] = Item::Value(Value::from(rug_fuzz_1));
        let item = doc.as_item();
        debug_assert!(item.is_table(), "The root item should always be a table.");
        let table = item.as_table().unwrap();
        debug_assert!(
            table.contains_key(rug_fuzz_2), "The table should contain a 'title' entry."
        );
        debug_assert_eq!(
            table[rug_fuzz_3].as_value().unwrap().as_str().unwrap(), "TOML Example"
        );
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_179 {
    use super::*;
    use crate::*;
    use crate::table::Table;
    #[test]
    fn test_as_item_mut() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2)) = <(&str, &str, &str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut doc = Document::new();
        let item = doc.as_item_mut();
        debug_assert!(matches!(item, & mut Item::Table(_)));
        let mut table = item.as_table_mut().unwrap();
        table.insert(rug_fuzz_0, Item::Value(rug_fuzz_1.parse().unwrap()));
        debug_assert_eq!(table.get(rug_fuzz_2).unwrap().as_str().unwrap(), "value");
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_180 {
    use super::*;
    use crate::*;
    use crate::{Document, Item, Table};
    #[test]
    fn test_document_as_table() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2)) = <(&str, &str, &str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut doc = Document::new();
        let table = doc.as_table();
        debug_assert_eq!(table.iter().count(), 0);
        doc[rug_fuzz_0] = Item::Value(rug_fuzz_1.into());
        let table = doc.as_table();
        debug_assert_eq!(table.iter().count(), 1);
        debug_assert_eq!(
            table[rug_fuzz_2].as_value().unwrap().as_str().unwrap(), "value"
        );
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_182_llm_16_182 {
    use super::*;
    use crate::*;
    use crate::Document;
    #[test]
    fn test_despan() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2, mut rug_fuzz_3, mut rug_fuzz_4, mut rug_fuzz_5, mut rug_fuzz_6, mut rug_fuzz_7)) = <(&str, i64, &str, &str, &str, &str, &str, &str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut doc = Document::new();
        doc[rug_fuzz_0] = crate::Item::Value(crate::Value::from(rug_fuzz_1));
        doc[rug_fuzz_2] = crate::Item::Table(crate::Table::new());
        doc[rug_fuzz_3] = crate::Item::ArrayOfTables(crate::ArrayOfTables::new());
        let original = doc.to_string();
        doc.original = Some(original.clone());
        doc.despan();
        debug_assert_eq!(doc[rug_fuzz_4].span(), None);
        debug_assert_eq!(doc[rug_fuzz_5].as_value().unwrap().span(), None);
        debug_assert_eq!(doc[rug_fuzz_6].span(), None);
        debug_assert_eq!(doc[rug_fuzz_7].span(), None);
        debug_assert_eq!(doc.to_string(), original);
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_184 {
    use crate::Document;
    #[test]
    fn document_new_is_empty() {
        let _rug_st_tests_llm_16_184_rrrruuuugggg_document_new_is_empty = 0;
        let doc = Document::new();
        debug_assert!(doc.is_empty());
        let _rug_ed_tests_llm_16_184_rrrruuuugggg_document_new_is_empty = 0;
    }
}
#[cfg(test)]
mod tests_llm_16_185 {
    use crate::{Document, RawString};
    #[test]
    fn test_set_trailing() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut document = Document::new();
        debug_assert_eq!(document.trailing().as_str(), Some(""));
        document.set_trailing(rug_fuzz_0);
        debug_assert_eq!(document.trailing().as_str(), Some("  "));
             }
});    }
    #[test]
    fn test_set_trailing_on_new_document() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut document = Document::new();
        document.set_trailing(rug_fuzz_0);
        debug_assert_eq!(document.trailing().as_str(), Some("  "));
             }
});    }
    #[test]
    fn test_set_trailing_with_raw_string() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut document = Document::new();
        let raw_string: RawString = rug_fuzz_0.into();
        document.set_trailing(raw_string.clone());
        debug_assert_eq!(document.trailing(), & raw_string);
             }
});    }
    #[test]
    fn test_set_trailing_preserves_content() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2)) = <(&str, &str, &str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let mut document: Document = rug_fuzz_0.parse().unwrap();
        document.set_trailing(rug_fuzz_1);
        debug_assert_eq!(document[rug_fuzz_2].as_str(), Some("value"));
        debug_assert_eq!(document.trailing().as_str(), Some("\n"));
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_186 {
    use super::*;
    use crate::*;
    use crate::raw_string::RawString;
    #[test]
    fn test_document_trailing() {
        let _rug_st_tests_llm_16_186_rrrruuuugggg_test_document_trailing = 0;
        let doc = Document::new();
        debug_assert_eq!(doc.trailing(), & RawString::default());
        let _rug_ed_tests_llm_16_186_rrrruuuugggg_test_document_trailing = 0;
    }
}
