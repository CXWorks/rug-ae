//! [`Uuid`] parsing constructs and utilities.
//!
//! [`Uuid`]: ../struct.Uuid.html
use crate::{
    error::*, std::{convert::TryFrom, str},
    Uuid,
};
impl str::FromStr for Uuid {
    type Err = Error;
    fn from_str(uuid_str: &str) -> Result<Self, Self::Err> {
        Uuid::parse_str(uuid_str)
    }
}
impl TryFrom<&'_ str> for Uuid {
    type Error = Error;
    fn try_from(uuid_str: &'_ str) -> Result<Self, Self::Error> {
        Uuid::parse_str(uuid_str)
    }
}
impl Uuid {
    /// Parses a `Uuid` from a string of hexadecimal digits with optional
    /// hyphens.
    ///
    /// Any of the formats generated by this module (simple, hyphenated, urn,
    /// Microsoft GUID) are supported by this parsing function.
    ///
    /// Prefer [`try_parse`] unless you need detailed user-facing diagnostics.
    /// This method will be eventually deprecated in favor of `try_parse`.
    ///
    /// # Examples
    ///
    /// Parse a hyphenated UUID:
    ///
    /// ```
    /// # use uuid::{Uuid, Version, Variant};
    /// # fn main() -> Result<(), uuid::Error> {
    /// let uuid = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000")?;
    ///
    /// assert_eq!(Some(Version::Random), uuid.get_version());
    /// assert_eq!(Variant::RFC4122, uuid.get_variant());
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// [`try_parse`]: #method.try_parse
    pub fn parse_str(input: &str) -> Result<Uuid, Error> {
        try_parse(input.as_bytes()).map(Uuid::from_bytes).map_err(InvalidUuid::into_err)
    }
    /// Parses a `Uuid` from a string of hexadecimal digits with optional
    /// hyphens.
    ///
    /// This function is similar to [`parse_str`], in fact `parse_str` shares
    /// the same underlying parser. The difference is that if `try_parse`
    /// fails, it won't generate very useful error messages. The `parse_str`
    /// function will eventually be deprecated in favor or `try_parse`.
    ///
    /// To parse a UUID from a byte stream instead of a UTF8 string, see
    /// [`try_parse_ascii`].
    ///
    /// # Examples
    ///
    /// Parse a hyphenated UUID:
    ///
    /// ```
    /// # use uuid::{Uuid, Version, Variant};
    /// # fn main() -> Result<(), uuid::Error> {
    /// let uuid = Uuid::try_parse("550e8400-e29b-41d4-a716-446655440000")?;
    ///
    /// assert_eq!(Some(Version::Random), uuid.get_version());
    /// assert_eq!(Variant::RFC4122, uuid.get_variant());
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// [`parse_str`]: #method.parse_str
    /// [`try_parse_ascii`]: #method.try_parse_ascii
    pub const fn try_parse(input: &str) -> Result<Uuid, Error> {
        Self::try_parse_ascii(input.as_bytes())
    }
    /// Parses a `Uuid` from a string of hexadecimal digits with optional
    /// hyphens.
    ///
    /// The input is expected to be a string of ASCII characters. This method
    /// can be more convenient than [`try_parse`] if the UUID is being
    /// parsed from a byte stream instead of from a UTF8 string.
    ///
    /// # Examples
    ///
    /// Parse a hyphenated UUID:
    ///
    /// ```
    /// # use uuid::{Uuid, Version, Variant};
    /// # fn main() -> Result<(), uuid::Error> {
    /// let uuid = Uuid::try_parse_ascii(b"550e8400-e29b-41d4-a716-446655440000")?;
    ///
    /// assert_eq!(Some(Version::Random), uuid.get_version());
    /// assert_eq!(Variant::RFC4122, uuid.get_variant());
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// [`try_parse`]: #method.try_parse
    pub const fn try_parse_ascii(input: &[u8]) -> Result<Uuid, Error> {
        match try_parse(input) {
            Ok(bytes) => Ok(Uuid::from_bytes(bytes)),
            Err(_) => Err(Error(ErrorKind::Other)),
        }
    }
}
const fn try_parse(input: &[u8]) -> Result<[u8; 16], InvalidUuid> {
    let result = match (input.len(), input) {
        (32, s) => parse_simple(s),
        (36, s)
        | (38, [b'{', s @ .., b'}'])
        | (45, [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..]) => {
            parse_hyphenated(s)
        }
        _ => Err(()),
    };
    match result {
        Ok(b) => Ok(b),
        Err(()) => Err(InvalidUuid(input)),
    }
}
#[inline]
const fn parse_simple(s: &[u8]) -> Result<[u8; 16], ()> {
    if s.len() != 32 {
        return Err(());
    }
    let mut buf: [u8; 16] = [0; 16];
    let mut i = 0;
    while i < 16 {
        let h1 = HEX_TABLE[s[i * 2] as usize];
        let h2 = HEX_TABLE[s[i * 2 + 1] as usize];
        if h1 | h2 == 0xff {
            return Err(());
        }
        buf[i] = SHL4_TABLE[h1 as usize] | h2;
        i += 1;
    }
    Ok(buf)
}
#[inline]
const fn parse_hyphenated(s: &[u8]) -> Result<[u8; 16], ()> {
    if s.len() != 36 {
        return Err(());
    }
    match [s[8], s[13], s[18], s[23]] {
        [b'-', b'-', b'-', b'-'] => {}
        _ => return Err(()),
    }
    let positions: [u8; 8] = [0, 4, 9, 14, 19, 24, 28, 32];
    let mut buf: [u8; 16] = [0; 16];
    let mut j = 0;
    while j < 8 {
        let i = positions[j];
        let h1 = HEX_TABLE[s[i as usize] as usize];
        let h2 = HEX_TABLE[s[(i + 1) as usize] as usize];
        let h3 = HEX_TABLE[s[(i + 2) as usize] as usize];
        let h4 = HEX_TABLE[s[(i + 3) as usize] as usize];
        if h1 | h2 | h3 | h4 == 0xff {
            return Err(());
        }
        buf[j * 2] = SHL4_TABLE[h1 as usize] | h2;
        buf[j * 2 + 1] = SHL4_TABLE[h3 as usize] | h4;
        j += 1;
    }
    Ok(buf)
}
const HEX_TABLE: &[u8; 256] = &{
    let mut buf = [0; 256];
    let mut i: u8 = 0;
    loop {
        buf[i
            as usize] = match i {
            b'0'..=b'9' => i - b'0',
            b'a'..=b'f' => i - b'a' + 10,
            b'A'..=b'F' => i - b'A' + 10,
            _ => 0xff,
        };
        if i == 255 {
            break buf;
        }
        i += 1;
    }
};
const SHL4_TABLE: &[u8; 256] = &{
    let mut buf = [0; 256];
    let mut i: u8 = 0;
    loop {
        buf[i as usize] = i.wrapping_shl(4);
        if i == 255 {
            break buf;
        }
        i += 1;
    }
};
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{std::string::ToString, tests::new};
    #[test]
    fn test_parse_uuid_v4_valid() {
        let from_hyphenated = Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8")
            .unwrap();
        let from_simple = Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").unwrap();
        let from_urn = Uuid::parse_str("urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8")
            .unwrap();
        let from_guid = Uuid::parse_str("{67e55044-10b1-426f-9247-bb680e5fe0c8}")
            .unwrap();
        assert_eq!(from_hyphenated, from_simple);
        assert_eq!(from_hyphenated, from_urn);
        assert_eq!(from_hyphenated, from_guid);
        assert!(Uuid::parse_str("00000000000000000000000000000000").is_ok());
        assert!(Uuid::parse_str("67e55044-10b1-426f-9247-bb680e5fe0c8").is_ok());
        assert!(Uuid::parse_str("F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4").is_ok());
        assert!(Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c8").is_ok());
        assert!(Uuid::parse_str("01020304-1112-2122-3132-414243444546").is_ok());
        assert!(
            Uuid::parse_str("urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8").is_ok()
        );
        assert!(Uuid::parse_str("{6d93bade-bd9f-4e13-8914-9474e1e3567b}").is_ok());
        let nil = Uuid::nil();
        assert_eq!(Uuid::parse_str("00000000000000000000000000000000").unwrap(), nil);
        assert_eq!(
            Uuid::parse_str("00000000-0000-0000-0000-000000000000").unwrap(), nil
        );
    }
    #[test]
    fn test_parse_uuid_v4_invalid() {
        assert_eq!(Uuid::parse_str(""), Err(Error(ErrorKind::SimpleLength { len : 0 })));
        assert_eq!(
            Uuid::parse_str("!"), Err(Error(ErrorKind::Char { character : '!', index : 1,
            }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2-4faa-B6BF-329BF39FA1E45"),
            Err(Error(ErrorKind::GroupLength { group : 4, len : 13, index : 25, }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2-4faa-BBF-329BF39FA1E4"),
            Err(Error(ErrorKind::GroupLength { group : 3, len : 3, index : 20, }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2-4faa-BGBF-329BF39FA1E4"),
            Err(Error(ErrorKind::Char { character : 'G', index : 21, }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2F4faaFB6BFF329BF39FA1E4"),
            Err(Error(ErrorKind::GroupCount { count : 2 }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2-4faaFB6BFF329BF39FA1E4"),
            Err(Error(ErrorKind::GroupCount { count : 3 }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2-4faa-B6BFF329BF39FA1E4"),
            Err(Error(ErrorKind::GroupCount { count : 4 }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2-4faa"), Err(Error(ErrorKind::GroupCount {
            count : 3 }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2-4faaXB6BFF329BF39FA1E4"),
            Err(Error(ErrorKind::Char { character : 'X', index : 19, }))
        );
        assert_eq!(
            Uuid::parse_str("{F9168C5E-CEB2-4faa9B6BFF329BF39FA1E41"),
            Err(Error(ErrorKind::Char { character : '{', index : 1, }))
        );
        assert_eq!(
            Uuid::parse_str("{F9168C5E-CEB2-4faa9B6BFF329BF39FA1E41}"),
            Err(Error(ErrorKind::GroupCount { count : 3 }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB-24fa-eB6BFF32-BF39FA1E4"),
            Err(Error(ErrorKind::GroupLength { group : 1, len : 3, index : 10, }))
        );
        assert_eq!(
            Uuid::parse_str("01020304-1112-2122-3132-41424344"),
            Err(Error(ErrorKind::GroupLength { group : 4, len : 8, index : 25, }))
        );
        assert_eq!(
            Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c"),
            Err(Error(ErrorKind::SimpleLength { len : 31 }))
        );
        assert_eq!(
            Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c88"),
            Err(Error(ErrorKind::SimpleLength { len : 33 }))
        );
        assert_eq!(
            Uuid::parse_str("67e5504410b1426f9247bb680e5fe0cg8"),
            Err(Error(ErrorKind::Char { character : 'g', index : 32, }))
        );
        assert_eq!(
            Uuid::parse_str("67e5504410b1426%9247bb680e5fe0c8"),
            Err(Error(ErrorKind::Char { character : '%', index : 16, }))
        );
        assert_eq!(
            Uuid::parse_str("231231212212423424324323477343246663"),
            Err(Error(ErrorKind::SimpleLength { len : 36 }))
        );
        assert_eq!(
            Uuid::parse_str("{00000000000000000000000000000000}"),
            Err(Error(ErrorKind::GroupCount { count : 1 }))
        );
        assert_eq!(
            Uuid::parse_str("67e5504410b1426f9247bb680e5fe0c"),
            Err(Error(ErrorKind::SimpleLength { len : 31 }))
        );
        assert_eq!(
            Uuid::parse_str("67e550X410b1426f9247bb680e5fe0cd"),
            Err(Error(ErrorKind::Char { character : 'X', index : 7, }))
        );
        assert_eq!(
            Uuid::parse_str("67e550-4105b1426f9247bb680e5fe0c"),
            Err(Error(ErrorKind::GroupCount { count : 2 }))
        );
        assert_eq!(
            Uuid::parse_str("F9168C5E-CEB2-4faa-B6BF1-02BF39FA1E4"),
            Err(Error(ErrorKind::GroupLength { group : 3, len : 5, index : 20, }))
        );
    }
    #[test]
    fn test_roundtrip_default() {
        let uuid_orig = new();
        let orig_str = uuid_orig.to_string();
        let uuid_out = Uuid::parse_str(&orig_str).unwrap();
        assert_eq!(uuid_orig, uuid_out);
    }
    #[test]
    fn test_roundtrip_hyphenated() {
        let uuid_orig = new();
        let orig_str = uuid_orig.hyphenated().to_string();
        let uuid_out = Uuid::parse_str(&orig_str).unwrap();
        assert_eq!(uuid_orig, uuid_out);
    }
    #[test]
    fn test_roundtrip_simple() {
        let uuid_orig = new();
        let orig_str = uuid_orig.simple().to_string();
        let uuid_out = Uuid::parse_str(&orig_str).unwrap();
        assert_eq!(uuid_orig, uuid_out);
    }
    #[test]
    fn test_roundtrip_urn() {
        let uuid_orig = new();
        let orig_str = uuid_orig.urn().to_string();
        let uuid_out = Uuid::parse_str(&orig_str).unwrap();
        assert_eq!(uuid_orig, uuid_out);
    }
    #[test]
    fn test_roundtrip_braced() {
        let uuid_orig = new();
        let orig_str = uuid_orig.braced().to_string();
        let uuid_out = Uuid::parse_str(&orig_str).unwrap();
        assert_eq!(uuid_orig, uuid_out);
    }
    #[test]
    fn test_try_parse_ascii_non_utf8() {
        assert!(
            Uuid::try_parse_ascii(b"67e55044-10b1-426f-9247-bb680e5\0e0c8").is_err()
        );
    }
}
#[cfg(test)]
mod tests_llm_16_100_llm_16_100 {
    use super::*;
    use crate::*;
    #[test]
    fn test_parse_valid_uuids() {
        let _rug_st_tests_llm_16_100_llm_16_100_rrrruuuugggg_test_parse_valid_uuids = 0;
        let rug_fuzz_0 = "550e8400e29b41d4a716446655440000";
        let rug_fuzz_1 = 0x55;
        let rug_fuzz_2 = 0x0e;
        let rug_fuzz_3 = 0x84;
        let rug_fuzz_4 = 0x00;
        let rug_fuzz_5 = 0xe2;
        let rug_fuzz_6 = 0x9b;
        let rug_fuzz_7 = 0x41;
        let rug_fuzz_8 = 0xd4;
        let rug_fuzz_9 = 0xa7;
        let rug_fuzz_10 = 0x16;
        let rug_fuzz_11 = 0x44;
        let rug_fuzz_12 = 0x66;
        let rug_fuzz_13 = 0x55;
        let rug_fuzz_14 = 0x44;
        let rug_fuzz_15 = 0x00;
        let rug_fuzz_16 = 0x00;
        let rug_fuzz_17 = "550e8400-e29b-41d4-a716-446655440000";
        let rug_fuzz_18 = 0x55;
        let rug_fuzz_19 = 0x0e;
        let rug_fuzz_20 = 0x84;
        let rug_fuzz_21 = 0x00;
        let rug_fuzz_22 = 0xe2;
        let rug_fuzz_23 = 0x9b;
        let rug_fuzz_24 = 0x41;
        let rug_fuzz_25 = 0xd4;
        let rug_fuzz_26 = 0xa7;
        let rug_fuzz_27 = 0x16;
        let rug_fuzz_28 = 0x44;
        let rug_fuzz_29 = 0x66;
        let rug_fuzz_30 = 0x55;
        let rug_fuzz_31 = 0x44;
        let rug_fuzz_32 = 0x00;
        let rug_fuzz_33 = 0x00;
        let rug_fuzz_34 = "urn:uuid:550e8400-e29b-41d4-a716-446655440000";
        let rug_fuzz_35 = 0x55;
        let rug_fuzz_36 = 0x0e;
        let rug_fuzz_37 = 0x84;
        let rug_fuzz_38 = 0x00;
        let rug_fuzz_39 = 0xe2;
        let rug_fuzz_40 = 0x9b;
        let rug_fuzz_41 = 0x41;
        let rug_fuzz_42 = 0xd4;
        let rug_fuzz_43 = 0xa7;
        let rug_fuzz_44 = 0x16;
        let rug_fuzz_45 = 0x44;
        let rug_fuzz_46 = 0x66;
        let rug_fuzz_47 = 0x55;
        let rug_fuzz_48 = 0x44;
        let rug_fuzz_49 = 0x00;
        let rug_fuzz_50 = 0x00;
        let simple_uuid = Uuid::parse_str(rug_fuzz_0).unwrap();
        debug_assert_eq!(
            Uuid::from_bytes([rug_fuzz_1, rug_fuzz_2, rug_fuzz_3, rug_fuzz_4, rug_fuzz_5,
            rug_fuzz_6, rug_fuzz_7, rug_fuzz_8, rug_fuzz_9, rug_fuzz_10, rug_fuzz_11,
            rug_fuzz_12, rug_fuzz_13, rug_fuzz_14, rug_fuzz_15, rug_fuzz_16]),
            simple_uuid
        );
        debug_assert_eq!(Some(Version::Random), simple_uuid.get_version());
        debug_assert_eq!(Variant::RFC4122, simple_uuid.get_variant());
        let hyphenated_uuid = Uuid::parse_str(rug_fuzz_17).unwrap();
        debug_assert_eq!(
            Uuid::from_bytes([rug_fuzz_18, rug_fuzz_19, rug_fuzz_20, rug_fuzz_21,
            rug_fuzz_22, rug_fuzz_23, rug_fuzz_24, rug_fuzz_25, rug_fuzz_26, rug_fuzz_27,
            rug_fuzz_28, rug_fuzz_29, rug_fuzz_30, rug_fuzz_31, rug_fuzz_32,
            rug_fuzz_33]), hyphenated_uuid
        );
        debug_assert_eq!(Some(Version::Random), hyphenated_uuid.get_version());
        debug_assert_eq!(Variant::RFC4122, hyphenated_uuid.get_variant());
        let urn_uuid = Uuid::parse_str(rug_fuzz_34).unwrap();
        debug_assert_eq!(
            Uuid::from_bytes([rug_fuzz_35, rug_fuzz_36, rug_fuzz_37, rug_fuzz_38,
            rug_fuzz_39, rug_fuzz_40, rug_fuzz_41, rug_fuzz_42, rug_fuzz_43, rug_fuzz_44,
            rug_fuzz_45, rug_fuzz_46, rug_fuzz_47, rug_fuzz_48, rug_fuzz_49,
            rug_fuzz_50]), urn_uuid
        );
        debug_assert_eq!(Some(Version::Random), urn_uuid.get_version());
        debug_assert_eq!(Variant::RFC4122, urn_uuid.get_variant());
        let _rug_ed_tests_llm_16_100_llm_16_100_rrrruuuugggg_test_parse_valid_uuids = 0;
    }
    #[test]
    fn test_parse_invalid_uuids() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2)) = <(&str, &str, &str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        debug_assert!(Uuid::parse_str(rug_fuzz_0).is_err());
        debug_assert!(Uuid::parse_str(rug_fuzz_1).is_err());
        debug_assert!(Uuid::parse_str(rug_fuzz_2).is_err());
             }
});    }
    #[test]
    fn test_parse_uuid_with_braces() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0, mut rug_fuzz_1, mut rug_fuzz_2, mut rug_fuzz_3, mut rug_fuzz_4, mut rug_fuzz_5, mut rug_fuzz_6, mut rug_fuzz_7, mut rug_fuzz_8, mut rug_fuzz_9, mut rug_fuzz_10, mut rug_fuzz_11, mut rug_fuzz_12, mut rug_fuzz_13, mut rug_fuzz_14, mut rug_fuzz_15, mut rug_fuzz_16)) = <(&str, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let braced_uuid = Uuid::parse_str(rug_fuzz_0).unwrap();
        debug_assert_eq!(
            Uuid::from_bytes([rug_fuzz_1, rug_fuzz_2, rug_fuzz_3, rug_fuzz_4, rug_fuzz_5,
            rug_fuzz_6, rug_fuzz_7, rug_fuzz_8, rug_fuzz_9, rug_fuzz_10, rug_fuzz_11,
            rug_fuzz_12, rug_fuzz_13, rug_fuzz_14, rug_fuzz_15, rug_fuzz_16]),
            braced_uuid
        );
        debug_assert_eq!(Some(Version::Random), braced_uuid.get_version());
        debug_assert_eq!(Variant::RFC4122, braced_uuid.get_variant());
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_101_llm_16_101 {
    use super::*;
    use crate::*;
    use crate::Uuid;
    #[test]
    fn test_try_parse_valid_uuid() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let input = rug_fuzz_0;
        debug_assert!(Uuid::try_parse(input).is_ok());
             }
});    }
    #[test]
    fn test_try_parse_invalid_uuid() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let input = rug_fuzz_0;
        debug_assert!(Uuid::try_parse(input).is_err());
             }
});    }
    #[test]
    fn test_try_parse_valid_uuid_no_hyphens() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let input = rug_fuzz_0;
        debug_assert!(Uuid::try_parse(input).is_ok());
             }
});    }
    #[test]
    fn test_try_parse_invalid_uuid_wrong_length() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let input = rug_fuzz_0;
        debug_assert!(Uuid::try_parse(input).is_err());
             }
});    }
    #[test]
    fn test_try_parse_valid_uuid_uppercase() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let input = rug_fuzz_0;
        debug_assert!(Uuid::try_parse(input).is_ok());
             }
});    }
    #[test]
    fn test_try_parse_uuid_with_braces() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let input = rug_fuzz_0;
        debug_assert!(Uuid::try_parse(input).is_err());
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_104 {
    use super::*;
    use crate::*;
    use std::str::FromStr;
    use crate::Uuid;
    #[test]
    fn test_from_str_valid_uuid() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let valid_uuid_str = rug_fuzz_0;
        let uuid = Uuid::from_str(valid_uuid_str);
        debug_assert!(uuid.is_ok());
        debug_assert_eq!(uuid.unwrap().to_string(), valid_uuid_str);
             }
});    }
    #[test]
    fn test_from_str_invalid_uuid() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let invalid_uuid_str = rug_fuzz_0;
        let uuid = Uuid::from_str(invalid_uuid_str);
        debug_assert!(uuid.is_err());
             }
});    }
    #[test]
    fn test_from_str_invalid_length() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let invalid_uuid_length_str = rug_fuzz_0;
        let uuid = Uuid::from_str(invalid_uuid_length_str);
        debug_assert!(uuid.is_err());
             }
});    }
    #[test]
    fn test_from_str_invalid_characters() {

    extern crate bolero;
    extern crate arbitrary;
    bolero::check!()
        .for_each(|rug_data| {
            if let Ok((mut rug_fuzz_0)) = <(&str) as arbitrary::Arbitrary>::arbitrary(&mut arbitrary::Unstructured::new(rug_data)){

        let invalid_uuid_chars_str = rug_fuzz_0;
        let uuid = Uuid::from_str(invalid_uuid_chars_str);
        debug_assert!(uuid.is_err());
             }
});    }
}
#[cfg(test)]
mod tests_llm_16_107 {
    use super::*;
    use crate::*;
    use crate::parser::InvalidUuid;
    #[test]
    fn test_try_parse_valid_non_hyphenated() {
        let _rug_st_tests_llm_16_107_rrrruuuugggg_test_try_parse_valid_non_hyphenated = 0;
        let rug_fuzz_0 = b"1234567890abcdef1234567890abcdef";
        let uuid_bytes = rug_fuzz_0;
        debug_assert_eq!(
            try_parse(uuid_bytes), Ok([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef])
        );
        let _rug_ed_tests_llm_16_107_rrrruuuugggg_test_try_parse_valid_non_hyphenated = 0;
    }
    #[test]
    fn test_try_parse_valid_hyphenated() {
        let _rug_st_tests_llm_16_107_rrrruuuugggg_test_try_parse_valid_hyphenated = 0;
        let rug_fuzz_0 = b"12345678-90ab-cdef-1234-567890abcdef";
        let uuid_bytes = rug_fuzz_0;
        debug_assert_eq!(
            try_parse(uuid_bytes), Ok([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef])
        );
        let _rug_ed_tests_llm_16_107_rrrruuuugggg_test_try_parse_valid_hyphenated = 0;
    }
    #[test]
    fn test_try_parse_valid_braced() {
        let _rug_st_tests_llm_16_107_rrrruuuugggg_test_try_parse_valid_braced = 0;
        let rug_fuzz_0 = b"{12345678-90ab-cdef-1234-567890abcdef}";
        let uuid_bytes = rug_fuzz_0;
        debug_assert_eq!(
            try_parse(uuid_bytes), Ok([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef])
        );
        let _rug_ed_tests_llm_16_107_rrrruuuugggg_test_try_parse_valid_braced = 0;
    }
    #[test]
    fn test_try_parse_valid_urn() {
        let _rug_st_tests_llm_16_107_rrrruuuugggg_test_try_parse_valid_urn = 0;
        let rug_fuzz_0 = b"urn:uuid:12345678-90ab-cdef-1234-567890abcdef";
        let uuid_bytes = rug_fuzz_0;
        debug_assert_eq!(
            try_parse(uuid_bytes), Ok([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
            0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef])
        );
        let _rug_ed_tests_llm_16_107_rrrruuuugggg_test_try_parse_valid_urn = 0;
    }
    #[test]
    fn test_try_parse_invalid_length() {
        let _rug_st_tests_llm_16_107_rrrruuuugggg_test_try_parse_invalid_length = 0;
        let rug_fuzz_0 = b"12345";
        let uuid_bytes = rug_fuzz_0;
        debug_assert_eq!(try_parse(uuid_bytes), Err(InvalidUuid(uuid_bytes)));
        let _rug_ed_tests_llm_16_107_rrrruuuugggg_test_try_parse_invalid_length = 0;
    }
    #[test]
    fn test_try_parse_invalid_characters() {
        let _rug_st_tests_llm_16_107_rrrruuuugggg_test_try_parse_invalid_characters = 0;
        let rug_fuzz_0 = b"12345678-90ab-cdef-1234-567890abcdefg";
        let uuid_bytes = rug_fuzz_0;
        debug_assert_eq!(try_parse(uuid_bytes), Err(InvalidUuid(uuid_bytes)));
        let _rug_ed_tests_llm_16_107_rrrruuuugggg_test_try_parse_invalid_characters = 0;
    }
    #[test]
    fn test_try_parse_invalid_hyphenation() {
        let _rug_st_tests_llm_16_107_rrrruuuugggg_test_try_parse_invalid_hyphenation = 0;
        let rug_fuzz_0 = b"12345678-90ab-cdef-1234-567890abcde-";
        let uuid_bytes = rug_fuzz_0;
        debug_assert_eq!(try_parse(uuid_bytes), Err(InvalidUuid(uuid_bytes)));
        let _rug_ed_tests_llm_16_107_rrrruuuugggg_test_try_parse_invalid_hyphenation = 0;
    }
}
