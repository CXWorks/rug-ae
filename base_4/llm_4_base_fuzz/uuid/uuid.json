{"dependencies":{"<&'a T as timestamp::ClockSequence>::generate_sequence":[],"<Uuid as std::clone::Clone>::clone":["Uuid"],"<Uuid as std::cmp::Eq>::assert_receiver_is_total_eq":["Uuid"],"<Uuid as std::cmp::Ord>::cmp":["Uuid","std::cmp::Ordering"],"<Uuid as std::cmp::PartialEq>::eq":["Uuid"],"<Uuid as std::cmp::PartialOrd>::partial_cmp":["Uuid","std::marker::Sized","std::option::Option"],"<Uuid as std::convert::AsRef<[u8]>>::as_ref":["Uuid"],"<Uuid as std::default::Default>::default":["Uuid"],"<Uuid as std::hash::Hash>::hash":["Uuid","std::hash::Hasher","std::marker::Sized"],"<Variant as std::clone::Clone>::clone":["Variant"],"<Variant as std::cmp::PartialEq>::eq":["Variant"],"<Variant as std::fmt::Debug>::fmt":["Variant","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<Version as std::clone::Clone>::clone":["Version"],"<Version as std::cmp::PartialEq>::eq":["Version"],"<Version as std::fmt::Debug>::fmt":["Version","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<builder::Builder as std::fmt::Debug>::fmt":["Uuid","builder::Builder","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::clone::Clone>::clone":["error::Error","error::ErrorKind"],"<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["error::Error","error::ErrorKind"],"<error::Error as std::cmp::PartialEq>::eq":["error::Error","error::ErrorKind"],"<error::Error as std::fmt::Debug>::fmt":["error::Error","error::ErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::fmt::Display>::fmt":["error::Error","error::ErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::hash::Hash>::hash":["error::Error","error::ErrorKind","std::hash::Hasher","std::marker::Sized"],"<error::ErrorKind as std::clone::Clone>::clone":["error::ErrorKind"],"<error::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["error::ErrorKind"],"<error::ErrorKind as std::cmp::PartialEq>::eq":["error::ErrorKind"],"<error::ErrorKind as std::fmt::Debug>::fmt":["error::ErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ErrorKind as std::hash::Hash>::hash":["error::ErrorKind","std::hash::Hasher","std::marker::Sized"],"<error::InvalidUuid<'a> as std::clone::Clone>::clone":["error::InvalidUuid"],"<error::InvalidUuid<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["error::InvalidUuid"],"<error::InvalidUuid<'a> as std::cmp::PartialEq>::eq":["error::InvalidUuid"],"<error::InvalidUuid<'a> as std::fmt::Debug>::fmt":["error::InvalidUuid","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::InvalidUuid<'a> as std::hash::Hash>::hash":["error::InvalidUuid","std::hash::Hasher","std::marker::Sized"],"<fmt::Braced as std::borrow::Borrow<Uuid>>::borrow":["Uuid","fmt::Braced"],"<fmt::Braced as std::clone::Clone>::clone":["Uuid","fmt::Braced"],"<fmt::Braced as std::cmp::Eq>::assert_receiver_is_total_eq":["Uuid","fmt::Braced"],"<fmt::Braced as std::cmp::Ord>::cmp":["Uuid","fmt::Braced","std::cmp::Ordering"],"<fmt::Braced as std::cmp::PartialEq>::eq":["Uuid","fmt::Braced"],"<fmt::Braced as std::cmp::PartialOrd>::partial_cmp":["Uuid","fmt::Braced","std::marker::Sized","std::option::Option"],"<fmt::Braced as std::convert::AsRef<Uuid>>::as_ref":["Uuid","fmt::Braced"],"<fmt::Braced as std::convert::From<Uuid>>::from":["Uuid","fmt::Braced"],"<fmt::Braced as std::default::Default>::default":["Uuid","fmt::Braced"],"<fmt::Braced as std::fmt::Debug>::fmt":["Uuid","fmt::Braced","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Braced as std::fmt::Display>::fmt":["Uuid","fmt::Braced","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Braced as std::fmt::LowerHex>::fmt":["Uuid","fmt::Braced","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Braced as std::fmt::UpperHex>::fmt":["Uuid","fmt::Braced","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Braced as std::hash::Hash>::hash":["Uuid","fmt::Braced","std::hash::Hasher","std::marker::Sized"],"<fmt::Hyphenated as std::borrow::Borrow<Uuid>>::borrow":["Uuid","fmt::Hyphenated"],"<fmt::Hyphenated as std::clone::Clone>::clone":["Uuid","fmt::Hyphenated"],"<fmt::Hyphenated as std::cmp::Eq>::assert_receiver_is_total_eq":["Uuid","fmt::Hyphenated"],"<fmt::Hyphenated as std::cmp::Ord>::cmp":["Uuid","fmt::Hyphenated","std::cmp::Ordering"],"<fmt::Hyphenated as std::cmp::PartialEq>::eq":["Uuid","fmt::Hyphenated"],"<fmt::Hyphenated as std::cmp::PartialOrd>::partial_cmp":["Uuid","fmt::Hyphenated","std::marker::Sized","std::option::Option"],"<fmt::Hyphenated as std::convert::AsRef<Uuid>>::as_ref":["Uuid","fmt::Hyphenated"],"<fmt::Hyphenated as std::convert::From<Uuid>>::from":["Uuid","fmt::Hyphenated"],"<fmt::Hyphenated as std::default::Default>::default":["Uuid","fmt::Hyphenated"],"<fmt::Hyphenated as std::fmt::Debug>::fmt":["Uuid","fmt::Hyphenated","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Hyphenated as std::fmt::Display>::fmt":["Uuid","fmt::Hyphenated","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Hyphenated as std::fmt::LowerHex>::fmt":["Uuid","fmt::Hyphenated","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Hyphenated as std::fmt::UpperHex>::fmt":["Uuid","fmt::Hyphenated","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Hyphenated as std::hash::Hash>::hash":["Uuid","fmt::Hyphenated","std::hash::Hasher","std::marker::Sized"],"<fmt::Simple as std::borrow::Borrow<Uuid>>::borrow":["Uuid","fmt::Simple"],"<fmt::Simple as std::clone::Clone>::clone":["Uuid","fmt::Simple"],"<fmt::Simple as std::cmp::Eq>::assert_receiver_is_total_eq":["Uuid","fmt::Simple"],"<fmt::Simple as std::cmp::Ord>::cmp":["Uuid","fmt::Simple","std::cmp::Ordering"],"<fmt::Simple as std::cmp::PartialEq>::eq":["Uuid","fmt::Simple"],"<fmt::Simple as std::cmp::PartialOrd>::partial_cmp":["Uuid","fmt::Simple","std::marker::Sized","std::option::Option"],"<fmt::Simple as std::convert::AsRef<Uuid>>::as_ref":["Uuid","fmt::Simple"],"<fmt::Simple as std::convert::From<Uuid>>::from":["Uuid","fmt::Simple"],"<fmt::Simple as std::default::Default>::default":["Uuid","fmt::Simple"],"<fmt::Simple as std::fmt::Debug>::fmt":["Uuid","fmt::Simple","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Simple as std::fmt::Display>::fmt":["Uuid","fmt::Simple","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Simple as std::fmt::LowerHex>::fmt":["Uuid","fmt::Simple","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Simple as std::fmt::UpperHex>::fmt":["Uuid","fmt::Simple","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Simple as std::hash::Hash>::hash":["Uuid","fmt::Simple","std::hash::Hasher","std::marker::Sized"],"<fmt::Urn as std::borrow::Borrow<Uuid>>::borrow":["Uuid","fmt::Urn"],"<fmt::Urn as std::clone::Clone>::clone":["Uuid","fmt::Urn"],"<fmt::Urn as std::cmp::Eq>::assert_receiver_is_total_eq":["Uuid","fmt::Urn"],"<fmt::Urn as std::cmp::Ord>::cmp":["Uuid","fmt::Urn","std::cmp::Ordering"],"<fmt::Urn as std::cmp::PartialEq>::eq":["Uuid","fmt::Urn"],"<fmt::Urn as std::cmp::PartialOrd>::partial_cmp":["Uuid","fmt::Urn","std::marker::Sized","std::option::Option"],"<fmt::Urn as std::convert::AsRef<Uuid>>::as_ref":["Uuid","fmt::Urn"],"<fmt::Urn as std::convert::From<Uuid>>::from":["Uuid","fmt::Urn"],"<fmt::Urn as std::default::Default>::default":["Uuid","fmt::Urn"],"<fmt::Urn as std::fmt::Debug>::fmt":["Uuid","fmt::Urn","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Urn as std::fmt::Display>::fmt":["Uuid","fmt::Urn","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Urn as std::fmt::LowerHex>::fmt":["Uuid","fmt::Urn","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Urn as std::fmt::UpperHex>::fmt":["Uuid","fmt::Urn","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fmt::Urn as std::hash::Hash>::hash":["Uuid","fmt::Urn","std::hash::Hasher","std::marker::Sized"],"<timestamp::Timestamp as std::clone::Clone>::clone":["timestamp::Timestamp"],"<timestamp::Timestamp as std::cmp::Eq>::assert_receiver_is_total_eq":["timestamp::Timestamp"],"<timestamp::Timestamp as std::cmp::PartialEq>::eq":["timestamp::Timestamp"],"<timestamp::Timestamp as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","timestamp::Timestamp"],"<timestamp::Timestamp as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","timestamp::Timestamp"],"<timestamp::context::NoContext as std::clone::Clone>::clone":["timestamp::context::NoContext"],"<timestamp::context::NoContext as std::default::Default>::default":["timestamp::context::NoContext"],"<timestamp::context::NoContext as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","timestamp::context::NoContext"],"<timestamp::context::NoContext as timestamp::ClockSequence>::generate_sequence":["timestamp::context::NoContext"],"Uuid":["Uuid"],"Uuid::as_bytes":["Uuid"],"Uuid::as_fields":["Uuid"],"Uuid::as_u128":["Uuid"],"Uuid::as_u64_pair":["Uuid"],"Uuid::encode_buffer":[],"Uuid::get_timestamp":["Uuid","std::marker::Sized","std::option::Option"],"Uuid::get_variant":["Uuid","Variant"],"Uuid::get_version":["Uuid","std::marker::Sized","std::option::Option"],"Uuid::get_version_num":["Uuid"],"Uuid::into_bytes":["Uuid"],"Uuid::is_nil":["Uuid"],"Uuid::to_bytes_le":["Uuid"],"Uuid::to_fields_le":["Uuid"],"Uuid::to_u128_le":["Uuid"],"Variant":["Variant"],"Version":["Version"],"builder::<impl Uuid>::from_bytes":["Uuid"],"builder::<impl Uuid>::from_bytes_le":["Uuid"],"builder::<impl Uuid>::from_bytes_ref":["Uuid"],"builder::<impl Uuid>::from_fields":["Uuid"],"builder::<impl Uuid>::from_fields_le":["Uuid"],"builder::<impl Uuid>::from_slice":["std::marker::Sized","std::result::Result"],"builder::<impl Uuid>::from_slice_le":["std::marker::Sized","std::result::Result"],"builder::<impl Uuid>::from_u128":["Uuid"],"builder::<impl Uuid>::from_u128_le":["Uuid"],"builder::<impl Uuid>::from_u64_pair":["Uuid"],"builder::<impl Uuid>::nil":["Uuid"],"builder::Builder":["Uuid","builder::Builder"],"builder::Builder::as_uuid":["Uuid","builder::Builder"],"builder::Builder::from_bytes":["Uuid","builder::Builder"],"builder::Builder::from_bytes_le":["Uuid","builder::Builder"],"builder::Builder::from_fields":["Uuid","builder::Builder"],"builder::Builder::from_fields_le":["Uuid","builder::Builder"],"builder::Builder::from_md5_bytes":["Uuid","builder::Builder"],"builder::Builder::from_random_bytes":["Uuid","builder::Builder"],"builder::Builder::from_rfc4122_timestamp":["Uuid","builder::Builder"],"builder::Builder::from_sha1_bytes":["Uuid","builder::Builder"],"builder::Builder::from_slice":["std::marker::Sized","std::result::Result"],"builder::Builder::from_slice_le":["std::marker::Sized","std::result::Result"],"builder::Builder::from_u128":["Uuid","builder::Builder"],"builder::Builder::from_u128_le":["Uuid","builder::Builder"],"builder::Builder::into_uuid":["Uuid","builder::Builder"],"builder::Builder::nil":["Uuid","builder::Builder"],"builder::Builder::set_variant":["Uuid","Variant","builder::Builder"],"builder::Builder::set_version":["Uuid","Version","builder::Builder"],"builder::Builder::with_variant":["Uuid","Variant","builder::Builder"],"builder::Builder::with_version":["Uuid","Version","builder::Builder"],"error::Error":["error::Error","error::ErrorKind"],"error::ErrorKind":["error::ErrorKind"],"error::InvalidUuid":["error::InvalidUuid"],"error::InvalidUuid::<'a>::into_err":["error::Error","error::ErrorKind","error::InvalidUuid"],"fmt::<impl Uuid>::as_braced":["Uuid","fmt::Braced"],"fmt::<impl Uuid>::as_hyphenated":["Uuid","fmt::Hyphenated"],"fmt::<impl Uuid>::as_simple":["Uuid","fmt::Simple"],"fmt::<impl Uuid>::as_urn":["Uuid","fmt::Urn"],"fmt::<impl Uuid>::braced":["Uuid","fmt::Braced"],"fmt::<impl Uuid>::hyphenated":["Uuid","fmt::Hyphenated"],"fmt::<impl Uuid>::simple":["Uuid","fmt::Simple"],"fmt::<impl Uuid>::urn":["Uuid","fmt::Urn"],"fmt::<impl std::convert::From<fmt::Braced> for Uuid>::from":["Uuid","fmt::Braced"],"fmt::<impl std::convert::From<fmt::Hyphenated> for Uuid>::from":["Uuid","fmt::Hyphenated"],"fmt::<impl std::convert::From<fmt::Simple> for Uuid>::from":["Uuid","fmt::Simple"],"fmt::<impl std::convert::From<fmt::Urn> for Uuid>::from":["Uuid","fmt::Urn"],"fmt::<impl std::fmt::Debug for Uuid>::fmt":["Uuid","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"fmt::<impl std::fmt::Display for Uuid>::fmt":["Uuid","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"fmt::<impl std::fmt::Display for Variant>::fmt":["Variant","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"fmt::<impl std::fmt::LowerHex for Uuid>::fmt":["Uuid","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"fmt::<impl std::fmt::UpperHex for Uuid>::fmt":["Uuid","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"fmt::Braced":["Uuid","fmt::Braced"],"fmt::Braced::as_uuid":["Uuid","fmt::Braced"],"fmt::Braced::encode_lower":["Uuid","fmt::Braced"],"fmt::Braced::encode_upper":["Uuid","fmt::Braced"],"fmt::Braced::from_uuid":["Uuid","fmt::Braced"],"fmt::Braced::into_uuid":["Uuid","fmt::Braced"],"fmt::Hyphenated":["Uuid","fmt::Hyphenated"],"fmt::Hyphenated::as_uuid":["Uuid","fmt::Hyphenated"],"fmt::Hyphenated::encode_lower":["Uuid","fmt::Hyphenated"],"fmt::Hyphenated::encode_upper":["Uuid","fmt::Hyphenated"],"fmt::Hyphenated::from_uuid":["Uuid","fmt::Hyphenated"],"fmt::Hyphenated::into_uuid":["Uuid","fmt::Hyphenated"],"fmt::Simple":["Uuid","fmt::Simple"],"fmt::Simple::as_uuid":["Uuid","fmt::Simple"],"fmt::Simple::encode_lower":["Uuid","fmt::Simple"],"fmt::Simple::encode_upper":["Uuid","fmt::Simple"],"fmt::Simple::from_uuid":["Uuid","fmt::Simple"],"fmt::Simple::into_uuid":["Uuid","fmt::Simple"],"fmt::Urn":["Uuid","fmt::Urn"],"fmt::Urn::as_uuid":["Uuid","fmt::Urn"],"fmt::Urn::encode_lower":["Uuid","fmt::Urn"],"fmt::Urn::encode_upper":["Uuid","fmt::Urn"],"fmt::Urn::from_uuid":["Uuid","fmt::Urn"],"fmt::Urn::into_uuid":["Uuid","fmt::Urn"],"fmt::encode_braced":[],"fmt::encode_hyphenated":[],"fmt::encode_simple":[],"fmt::encode_urn":[],"fmt::format_hyphenated":[],"fmt::format_simple":[],"parser::<impl Uuid>::parse_str":["std::marker::Sized","std::result::Result"],"parser::<impl Uuid>::try_parse":["std::marker::Sized","std::result::Result"],"parser::<impl Uuid>::try_parse_ascii":["std::marker::Sized","std::result::Result"],"parser::<impl std::convert::TryFrom<&str> for Uuid>::try_from":["std::marker::Sized","std::result::Result"],"parser::<impl std::str::FromStr for Uuid>::from_str":["std::marker::Sized","std::result::Result"],"parser::parse_hyphenated":["std::marker::Sized","std::result::Result"],"parser::parse_simple":["std::marker::Sized","std::result::Result"],"parser::try_parse":["std::marker::Sized","std::result::Result"],"timestamp::ClockSequence::generate_sequence":[],"timestamp::Timestamp":["timestamp::Timestamp"],"timestamp::Timestamp::from_rfc4122":["timestamp::Timestamp"],"timestamp::Timestamp::from_unix":["std::marker::Sized","timestamp::ClockSequence","timestamp::Timestamp","timestamp::context::NoContext"],"timestamp::Timestamp::now":["std::marker::Sized","timestamp::ClockSequence","timestamp::Timestamp","timestamp::context::NoContext"],"timestamp::Timestamp::rfc4122_to_unix":[],"timestamp::Timestamp::to_unix":["timestamp::Timestamp"],"timestamp::Timestamp::to_unix_nanos":["timestamp::Timestamp"],"timestamp::context::NoContext":["timestamp::context::NoContext"],"timestamp::decode_rfc4122_timestamp":["Uuid"],"timestamp::encode_rfc4122_timestamp":["Uuid"],"timestamp::now":[]},"glob_path_import":{},"self_to_fn":{"Uuid":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl AsRef<[u8]> for Uuid {\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        &self.0\n    }\n}","impl Default for Uuid {\n    #[inline]\n    fn default() -> Self {\n        Uuid::nil()\n    }\n}","impl From<$T> for Uuid {\n            #[inline]\n            fn from(f: $T) -> Self {\n                f.into_uuid()\n            }\n        }","impl TryFrom<&'_ str> for Uuid {\n    type Error = Error;\n\n    fn try_from(uuid_str: &'_ str) -> Result<Self, Self::Error> {\n        Uuid::parse_str(uuid_str)\n    }\n}","impl Uuid {\n    /// Get a [`Hyphenated`] formatter.\n    #[inline]\n    pub const fn hyphenated(self) -> Hyphenated {\n        Hyphenated(self)\n    }\n\n    /// Get a borrowed [`Hyphenated`] formatter.\n    #[inline]\n    pub fn as_hyphenated(&self) -> &Hyphenated {\n        // SAFETY: `Uuid` and `Hyphenated` have the same ABI\n        unsafe { &*(self as *const Uuid as *const Hyphenated) }\n    }\n\n    /// Get a [`Simple`] formatter.\n    #[inline]\n    pub const fn simple(self) -> Simple {\n        Simple(self)\n    }\n\n    /// Get a borrowed [`Simple`] formatter.\n    #[inline]\n    pub fn as_simple(&self) -> &Simple {\n        // SAFETY: `Uuid` and `Simple` have the same ABI\n        unsafe { &*(self as *const Uuid as *const Simple) }\n    }\n\n    /// Get a [`Urn`] formatter.\n    #[inline]\n    pub const fn urn(self) -> Urn {\n        Urn(self)\n    }\n\n    /// Get a borrowed [`Urn`] formatter.\n    #[inline]\n    pub fn as_urn(&self) -> &Urn {\n        // SAFETY: `Uuid` and `Urn` have the same ABI\n        unsafe { &*(self as *const Uuid as *const Urn) }\n    }\n\n    /// Get a [`Braced`] formatter.\n    #[inline]\n    pub const fn braced(self) -> Braced {\n        Braced(self)\n    }\n\n    /// Get a borrowed [`Braced`] formatter.\n    #[inline]\n    pub fn as_braced(&self) -> &Braced {\n        // SAFETY: `Uuid` and `Braced` have the same ABI\n        unsafe { &*(self as *const Uuid as *const Braced) }\n    }\n}","impl Uuid {\n    /// Parses a `Uuid` from a string of hexadecimal digits with optional\n    /// hyphens.\n    ///\n    /// Any of the formats generated by this module (simple, hyphenated, urn,\n    /// Microsoft GUID) are supported by this parsing function.\n    ///\n    /// Prefer [`try_parse`] unless you need detailed user-facing diagnostics.\n    /// This method will be eventually deprecated in favor of `try_parse`.\n    ///\n    /// # Examples\n    ///\n    /// Parse a hyphenated UUID:\n    ///\n    /// ```\n    /// # use uuid::{Uuid, Version, Variant};\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::parse_str(\"550e8400-e29b-41d4-a716-446655440000\")?;\n    ///\n    /// assert_eq!(Some(Version::Random), uuid.get_version());\n    /// assert_eq!(Variant::RFC4122, uuid.get_variant());\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// [`try_parse`]: #method.try_parse\n    pub fn parse_str(input: &str) -> Result<Uuid, Error> {\n        try_parse(input.as_bytes())\n            .map(Uuid::from_bytes)\n            .map_err(InvalidUuid::into_err)\n    }\n\n    /// Parses a `Uuid` from a string of hexadecimal digits with optional\n    /// hyphens.\n    ///\n    /// This function is similar to [`parse_str`], in fact `parse_str` shares\n    /// the same underlying parser. The difference is that if `try_parse`\n    /// fails, it won't generate very useful error messages. The `parse_str`\n    /// function will eventually be deprecated in favor or `try_parse`.\n    ///\n    /// To parse a UUID from a byte stream instead of a UTF8 string, see\n    /// [`try_parse_ascii`].\n    ///\n    /// # Examples\n    ///\n    /// Parse a hyphenated UUID:\n    ///\n    /// ```\n    /// # use uuid::{Uuid, Version, Variant};\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::try_parse(\"550e8400-e29b-41d4-a716-446655440000\")?;\n    ///\n    /// assert_eq!(Some(Version::Random), uuid.get_version());\n    /// assert_eq!(Variant::RFC4122, uuid.get_variant());\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// [`parse_str`]: #method.parse_str\n    /// [`try_parse_ascii`]: #method.try_parse_ascii\n    pub const fn try_parse(input: &str) -> Result<Uuid, Error> {\n        Self::try_parse_ascii(input.as_bytes())\n    }\n\n    /// Parses a `Uuid` from a string of hexadecimal digits with optional\n    /// hyphens.\n    ///\n    /// The input is expected to be a string of ASCII characters. This method\n    /// can be more convenient than [`try_parse`] if the UUID is being\n    /// parsed from a byte stream instead of from a UTF8 string.\n    ///\n    /// # Examples\n    ///\n    /// Parse a hyphenated UUID:\n    ///\n    /// ```\n    /// # use uuid::{Uuid, Version, Variant};\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::try_parse_ascii(b\"550e8400-e29b-41d4-a716-446655440000\")?;\n    ///\n    /// assert_eq!(Some(Version::Random), uuid.get_version());\n    /// assert_eq!(Variant::RFC4122, uuid.get_variant());\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// [`try_parse`]: #method.try_parse\n    pub const fn try_parse_ascii(input: &[u8]) -> Result<Uuid, Error> {\n        match try_parse(input) {\n            Ok(bytes) => Ok(Uuid::from_bytes(bytes)),\n            // If parsing fails then we don't know exactly what went wrong\n            // In this case, we just return a generic error\n            Err(_) => Err(Error(ErrorKind::Other)),\n        }\n    }\n}","impl Uuid {\n    /// The 'nil UUID' (all zeros).\n    ///\n    /// The nil UUID is a special form of UUID that is specified to have all\n    /// 128 bits set to zero.\n    ///\n    /// # References\n    ///\n    /// * [Nil UUID in RFC4122](https://tools.ietf.org/html/rfc4122.html#section-4.1.7)\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let uuid = Uuid::nil();\n    ///\n    /// assert_eq!(\n    ///     \"00000000-0000-0000-0000-000000000000\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn nil() -> Self {\n        Uuid::from_bytes([0; 16])\n    }\n\n    /// The 'max UUID' (all ones).\n    ///\n    /// The max UUID is a special form of UUID that is specified to have all\n    /// 128 bits set to one.\n    ///\n    /// # References\n    ///\n    /// * [Max UUID in Draft RFC: New UUID Formats, Version 4](https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format-04#section-5.4)\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let uuid = Uuid::max();\n    ///\n    /// assert_eq!(\n    ///     \"ffffffff-ffff-ffff-ffff-ffffffffffff\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    #[cfg(uuid_unstable)]\n    pub const fn max() -> Self {\n        Uuid::from_bytes([0xFF; 16])\n    }\n\n    /// Creates a UUID from four field values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let d1 = 0xa1a2a3a4;\n    /// let d2 = 0xb1b2;\n    /// let d3 = 0xc1c2;\n    /// let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n    ///\n    /// let uuid = Uuid::from_fields(d1, d2, d3, &d4);\n    ///\n    /// assert_eq!(\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Uuid {\n        Uuid::from_bytes([\n            (d1 >> 24) as u8,\n            (d1 >> 16) as u8,\n            (d1 >> 8) as u8,\n            d1 as u8,\n            (d2 >> 8) as u8,\n            d2 as u8,\n            (d3 >> 8) as u8,\n            d3 as u8,\n            d4[0],\n            d4[1],\n            d4[2],\n            d4[3],\n            d4[4],\n            d4[5],\n            d4[6],\n            d4[7],\n        ])\n    }\n\n    /// Creates a UUID from four field values in little-endian order.\n    ///\n    /// The bytes in the `d1`, `d2` and `d3` fields will be flipped to convert\n    /// into big-endian order. This is based on the endianness of the UUID,\n    /// rather than the target environment so bytes will be flipped on both\n    /// big and little endian machines.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let d1 = 0xa1a2a3a4;\n    /// let d2 = 0xb1b2;\n    /// let d3 = 0xc1c2;\n    /// let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n    ///\n    /// let uuid = Uuid::from_fields_le(d1, d2, d3, &d4);\n    ///\n    /// assert_eq!(\n    ///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn from_fields_le(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Uuid {\n        Uuid::from_bytes([\n            d1 as u8,\n            (d1 >> 8) as u8,\n            (d1 >> 16) as u8,\n            (d1 >> 24) as u8,\n            (d2) as u8,\n            (d2 >> 8) as u8,\n            d3 as u8,\n            (d3 >> 8) as u8,\n            d4[0],\n            d4[1],\n            d4[2],\n            d4[3],\n            d4[4],\n            d4[5],\n            d4[6],\n            d4[7],\n        ])\n    }\n\n    /// Creates a UUID from a 128bit value.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n    ///\n    /// let uuid = Uuid::from_u128(v);\n    ///\n    /// assert_eq!(\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn from_u128(v: u128) -> Self {\n        Uuid::from_bytes([\n            (v >> 120) as u8,\n            (v >> 112) as u8,\n            (v >> 104) as u8,\n            (v >> 96) as u8,\n            (v >> 88) as u8,\n            (v >> 80) as u8,\n            (v >> 72) as u8,\n            (v >> 64) as u8,\n            (v >> 56) as u8,\n            (v >> 48) as u8,\n            (v >> 40) as u8,\n            (v >> 32) as u8,\n            (v >> 24) as u8,\n            (v >> 16) as u8,\n            (v >> 8) as u8,\n            v as u8,\n        ])\n    }\n\n    /// Creates a UUID from a 128bit value in little-endian order.\n    ///\n    /// The entire value will be flipped to convert into big-endian order.\n    /// This is based on the endianness of the UUID, rather than the target\n    /// environment so bytes will be flipped on both big and little endian\n    /// machines.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n    ///\n    /// let uuid = Uuid::from_u128_le(v);\n    ///\n    /// assert_eq!(\n    ///     \"d8d7d6d5-d4d3-d2d1-c2c1-b2b1a4a3a2a1\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn from_u128_le(v: u128) -> Self {\n        Uuid::from_bytes([\n            v as u8,\n            (v >> 8) as u8,\n            (v >> 16) as u8,\n            (v >> 24) as u8,\n            (v >> 32) as u8,\n            (v >> 40) as u8,\n            (v >> 48) as u8,\n            (v >> 56) as u8,\n            (v >> 64) as u8,\n            (v >> 72) as u8,\n            (v >> 80) as u8,\n            (v >> 88) as u8,\n            (v >> 96) as u8,\n            (v >> 104) as u8,\n            (v >> 112) as u8,\n            (v >> 120) as u8,\n        ])\n    }\n\n    /// Creates a UUID from two 64bit values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let hi = 0xa1a2a3a4b1b2c1c2u64;\n    /// let lo = 0xd1d2d3d4d5d6d7d8u64;\n    ///\n    /// let uuid = Uuid::from_u64_pair(hi, lo);\n    ///\n    /// assert_eq!(\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn from_u64_pair(high_bits: u64, low_bits: u64) -> Self {\n        Uuid::from_bytes([\n            (high_bits >> 56) as u8,\n            (high_bits >> 48) as u8,\n            (high_bits >> 40) as u8,\n            (high_bits >> 32) as u8,\n            (high_bits >> 24) as u8,\n            (high_bits >> 16) as u8,\n            (high_bits >> 8) as u8,\n            high_bits as u8,\n            (low_bits >> 56) as u8,\n            (low_bits >> 48) as u8,\n            (low_bits >> 40) as u8,\n            (low_bits >> 32) as u8,\n            (low_bits >> 24) as u8,\n            (low_bits >> 16) as u8,\n            (low_bits >> 8) as u8,\n            low_bits as u8,\n        ])\n    }\n\n    /// Creates a UUID using the supplied bytes.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if `b` has any length other than 16.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// # use uuid::Uuid;\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Uuid::from_slice(&bytes)?;\n    ///\n    /// assert_eq!(\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn from_slice(b: &[u8]) -> Result<Uuid, Error> {\n        if b.len() != 16 {\n            return Err(Error(ErrorKind::ByteLength { len: b.len() }));\n        }\n\n        let mut bytes: Bytes = [0; 16];\n        bytes.copy_from_slice(b);\n        Ok(Uuid::from_bytes(bytes))\n    }\n\n    /// Creates a UUID using the supplied bytes in little endian order.\n    ///\n    /// The individual fields encoded in the buffer will be flipped.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if `b` has any length other than 16.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// # use uuid::Uuid;\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Uuid::from_slice_le(&bytes)?;\n    ///\n    /// assert_eq!(\n    ///     uuid.hyphenated().to_string(),\n    ///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\"\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn from_slice_le(b: &[u8]) -> Result<Uuid, Error> {\n        if b.len() != 16 {\n            return Err(Error(ErrorKind::ByteLength { len: b.len() }));\n        }\n\n        let mut bytes: Bytes = [0; 16];\n        bytes.copy_from_slice(b);\n        Ok(Uuid::from_bytes_le(bytes))\n    }\n\n    /// Creates a UUID using the supplied bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// # use uuid::Uuid;\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Uuid::from_bytes(bytes);\n    ///\n    /// assert_eq!(\n    ///     uuid.hyphenated().to_string(),\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\"\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub const fn from_bytes(bytes: Bytes) -> Uuid {\n        Uuid(bytes)\n    }\n\n    /// Creates a UUID using the supplied bytes in little endian order.\n    ///\n    /// The individual fields encoded in the buffer will be flipped.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// # use uuid::Uuid;\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Uuid::from_bytes_le(bytes);\n    ///\n    /// assert_eq!(\n    ///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub const fn from_bytes_le(b: Bytes) -> Uuid {\n        Uuid([\n            b[3], b[2], b[1], b[0], b[5], b[4], b[7], b[6], b[8], b[9], b[10], b[11], b[12], b[13],\n            b[14], b[15],\n        ])\n    }\n\n    /// Creates a reference to a UUID from a reference to the supplied bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// # use uuid::Uuid;\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Uuid::from_bytes_ref(&bytes);\n    ///\n    /// assert_eq!(\n    ///     uuid.hyphenated().to_string(),\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\"\n    /// );\n    ///\n    /// assert!(std::ptr::eq(\n    ///     uuid as *const Uuid as *const u8,\n    ///     &bytes as *const [u8; 16] as *const u8,\n    /// ));\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn from_bytes_ref(bytes: &Bytes) -> &Uuid {\n        // SAFETY: `Bytes` and `Uuid` have the same ABI\n        unsafe { &*(bytes as *const Bytes as *const Uuid) }\n    }\n\n    // NOTE: There is no `from_u128_ref` because in little-endian\n    // environments the value isn't properly encoded. Callers would\n    // need to use `.to_be()` themselves.\n}","impl Uuid {\n    /// UUID namespace for Domain Name System (DNS).\n    pub const NAMESPACE_DNS: Self = Uuid([\n        0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,\n        0xc8,\n    ]);\n\n    /// UUID namespace for ISO Object Identifiers (OIDs).\n    pub const NAMESPACE_OID: Self = Uuid([\n        0x6b, 0xa7, 0xb8, 0x12, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,\n        0xc8,\n    ]);\n\n    /// UUID namespace for Uniform Resource Locators (URLs).\n    pub const NAMESPACE_URL: Self = Uuid([\n        0x6b, 0xa7, 0xb8, 0x11, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,\n        0xc8,\n    ]);\n\n    /// UUID namespace for X.500 Distinguished Names (DNs).\n    pub const NAMESPACE_X500: Self = Uuid([\n        0x6b, 0xa7, 0xb8, 0x14, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,\n        0xc8,\n    ]);\n\n    /// Returns the variant of the UUID structure.\n    ///\n    /// This determines the interpretation of the structure of the UUID.\n    /// This method simply reads the value of the variant byte. It doesn't\n    /// validate the rest of the UUID as conforming to that variant.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::{Uuid, Variant};\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let my_uuid = Uuid::parse_str(\"02f09a3f-1624-3b1d-8409-44eff7708208\")?;\n    ///\n    /// assert_eq!(Variant::RFC4122, my_uuid.get_variant());\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// # References\n    ///\n    /// * [Variant in RFC4122](http://tools.ietf.org/html/rfc4122#section-4.1.1)\n    pub const fn get_variant(&self) -> Variant {\n        match self.as_bytes()[8] {\n            x if x & 0x80 == 0x00 => Variant::NCS,\n            x if x & 0xc0 == 0x80 => Variant::RFC4122,\n            x if x & 0xe0 == 0xc0 => Variant::Microsoft,\n            x if x & 0xe0 == 0xe0 => Variant::Future,\n            // The above match arms are actually exhaustive\n            // We just return `Future` here because we can't\n            // use `unreachable!()` in a `const fn`\n            _ => Variant::Future,\n        }\n    }\n\n    /// Returns the version number of the UUID.\n    ///\n    /// This represents the algorithm used to generate the value.\n    /// This method is the future-proof alternative to [`Uuid::get_version`].\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let my_uuid = Uuid::parse_str(\"02f09a3f-1624-3b1d-8409-44eff7708208\")?;\n    ///\n    /// assert_eq!(3, my_uuid.get_version_num());\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// # References\n    ///\n    /// * [Version in RFC4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.3)\n    pub const fn get_version_num(&self) -> usize {\n        (self.as_bytes()[6] >> 4) as usize\n    }\n\n    /// Returns the version of the UUID.\n    ///\n    /// This represents the algorithm used to generate the value.\n    /// If the version field doesn't contain a recognized version then `None`\n    /// is returned. If you're trying to read the version for a future extension\n    /// you can also use [`Uuid::get_version_num`] to unconditionally return a\n    /// number. Future extensions may start to return `Some` once they're\n    /// standardized and supported.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::{Uuid, Version};\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let my_uuid = Uuid::parse_str(\"02f09a3f-1624-3b1d-8409-44eff7708208\")?;\n    ///\n    /// assert_eq!(Some(Version::Md5), my_uuid.get_version());\n    /// # Ok(())\n    /// # }\n    /// ```\n    ///\n    /// # References\n    ///\n    /// * [Version in RFC4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.3)\n    pub const fn get_version(&self) -> Option<Version> {\n        match self.get_version_num() {\n            0 if self.is_nil() => Some(Version::Nil),\n            1 => Some(Version::Mac),\n            2 => Some(Version::Dce),\n            3 => Some(Version::Md5),\n            4 => Some(Version::Random),\n            5 => Some(Version::Sha1),\n            #[cfg(uuid_unstable)]\n            6 => Some(Version::SortMac),\n            #[cfg(uuid_unstable)]\n            7 => Some(Version::SortRand),\n            #[cfg(uuid_unstable)]\n            8 => Some(Version::Custom),\n            #[cfg(uuid_unstable)]\n            0xf => Some(Version::Max),\n            _ => None,\n        }\n    }\n\n    /// Returns the four field values of the UUID.\n    ///\n    /// These values can be passed to the [`Uuid::from_fields`] method to get\n    /// the original `Uuid` back.\n    ///\n    /// * The first field value represents the first group of (eight) hex\n    ///   digits, taken as a big-endian `u32` value.  For V1 UUIDs, this field\n    ///   represents the low 32 bits of the timestamp.\n    /// * The second field value represents the second group of (four) hex\n    ///   digits, taken as a big-endian `u16` value.  For V1 UUIDs, this field\n    ///   represents the middle 16 bits of the timestamp.\n    /// * The third field value represents the third group of (four) hex digits,\n    ///   taken as a big-endian `u16` value.  The 4 most significant bits give\n    ///   the UUID version, and for V1 UUIDs, the last 12 bits represent the\n    ///   high 12 bits of the timestamp.\n    /// * The last field value represents the last two groups of four and twelve\n    ///   hex digits, taken in order.  The first 1-3 bits of this indicate the\n    ///   UUID variant, and for V1 UUIDs, the next 13-15 bits indicate the clock\n    ///   sequence and the last 48 bits indicate the node ID.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::nil();\n    ///\n    /// assert_eq!(uuid.as_fields(), (0, 0, 0, &[0u8; 8]));\n    ///\n    /// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n    ///\n    /// assert_eq!(\n    ///     uuid.as_fields(),\n    ///     (\n    ///         0xa1a2a3a4,\n    ///         0xb1b2,\n    ///         0xc1c2,\n    ///         &[0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8],\n    ///     )\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn as_fields(&self) -> (u32, u16, u16, &[u8; 8]) {\n        let bytes = self.as_bytes();\n\n        let d1 = (bytes[0] as u32) << 24\n            | (bytes[1] as u32) << 16\n            | (bytes[2] as u32) << 8\n            | (bytes[3] as u32);\n\n        let d2 = (bytes[4] as u16) << 8 | (bytes[5] as u16);\n\n        let d3 = (bytes[6] as u16) << 8 | (bytes[7] as u16);\n\n        let d4: &[u8; 8] = convert::TryInto::try_into(&bytes[8..16]).unwrap();\n        (d1, d2, d3, d4)\n    }\n\n    /// Returns the four field values of the UUID in little-endian order.\n    ///\n    /// The bytes in the returned integer fields will be converted from\n    /// big-endian order. This is based on the endianness of the UUID,\n    /// rather than the target environment so bytes will be flipped on both\n    /// big and little endian machines.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use uuid::Uuid;\n    ///\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n    ///\n    /// assert_eq!(\n    ///     uuid.to_fields_le(),\n    ///     (\n    ///         0xa4a3a2a1,\n    ///         0xb2b1,\n    ///         0xc2c1,\n    ///         &[0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8],\n    ///     )\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn to_fields_le(&self) -> (u32, u16, u16, &[u8; 8]) {\n        let d1 = (self.as_bytes()[0] as u32)\n            | (self.as_bytes()[1] as u32) << 8\n            | (self.as_bytes()[2] as u32) << 16\n            | (self.as_bytes()[3] as u32) << 24;\n\n        let d2 = (self.as_bytes()[4] as u16) | (self.as_bytes()[5] as u16) << 8;\n\n        let d3 = (self.as_bytes()[6] as u16) | (self.as_bytes()[7] as u16) << 8;\n\n        let d4: &[u8; 8] = convert::TryInto::try_into(&self.as_bytes()[8..16]).unwrap();\n        (d1, d2, d3, d4)\n    }\n\n    /// Returns a 128bit value containing the value.\n    ///\n    /// The bytes in the UUID will be packed directly into a `u128`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n    ///\n    /// assert_eq!(\n    ///     uuid.as_u128(),\n    ///     0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8,\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub const fn as_u128(&self) -> u128 {\n        u128::from_be_bytes(*self.as_bytes())\n    }\n\n    /// Returns a 128bit little-endian value containing the value.\n    ///\n    /// The bytes in the `u128` will be flipped to convert into big-endian\n    /// order. This is based on the endianness of the UUID, rather than the\n    /// target environment so bytes will be flipped on both big and little\n    /// endian machines.\n    ///\n    /// Note that this will produce a different result than\n    /// [`Uuid::to_fields_le`], because the entire UUID is reversed, rather\n    /// than reversing the individual fields in-place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n    ///\n    /// assert_eq!(\n    ///     uuid.to_u128_le(),\n    ///     0xd8d7d6d5d4d3d2d1c2c1b2b1a4a3a2a1,\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub const fn to_u128_le(&self) -> u128 {\n        u128::from_le_bytes(*self.as_bytes())\n    }\n\n    /// Returns two 64bit values containing the value.\n    ///\n    /// The bytes in the UUID will be split into two `u64`.\n    /// The first u64 represents the 64 most significant bits,\n    /// the second one represents the 64 least significant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n    /// assert_eq!(\n    ///     uuid.as_u64_pair(),\n    ///     (0xa1a2a3a4b1b2c1c2, 0xd1d2d3d4d5d6d7d8),\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub const fn as_u64_pair(&self) -> (u64, u64) {\n        let value = self.as_u128();\n        ((value >> 64) as u64, value as u64)\n    }\n\n    /// Returns a slice of 16 octets containing the value.\n    ///\n    /// This method borrows the underlying byte value of the UUID.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let bytes1 = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    /// let uuid1 = Uuid::from_bytes_ref(&bytes1);\n    ///\n    /// let bytes2 = uuid1.as_bytes();\n    /// let uuid2 = Uuid::from_bytes_ref(bytes2);\n    ///\n    /// assert_eq!(uuid1, uuid2);\n    ///\n    /// assert!(std::ptr::eq(\n    ///     uuid2 as *const Uuid as *const u8,\n    ///     &bytes1 as *const [u8; 16] as *const u8,\n    /// ));\n    /// ```\n    pub const fn as_bytes(&self) -> &Bytes {\n        &self.0\n    }\n\n    /// Consumes self and returns the underlying byte value of the UUID.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    /// let uuid = Uuid::from_bytes(bytes);\n    /// assert_eq!(bytes, uuid.into_bytes());\n    /// ```\n    pub const fn into_bytes(self) -> Bytes {\n        self.0\n    }\n\n    /// Returns the bytes of the UUID in little-endian order.\n    ///\n    /// The bytes will be flipped to convert into little-endian order. This is\n    /// based on the endianness of the UUID, rather than the target environment\n    /// so bytes will be flipped on both big and little endian machines.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use uuid::Uuid;\n    ///\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n    ///\n    /// assert_eq!(\n    ///     uuid.to_bytes_le(),\n    ///     ([\n    ///         0xa4, 0xa3, 0xa2, 0xa1, 0xb2, 0xb1, 0xc2, 0xc1, 0xd1, 0xd2,\n    ///         0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8\n    ///     ])\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub const fn to_bytes_le(&self) -> Bytes {\n        [\n            self.0[3], self.0[2], self.0[1], self.0[0], self.0[5], self.0[4], self.0[7], self.0[6],\n            self.0[8], self.0[9], self.0[10], self.0[11], self.0[12], self.0[13], self.0[14],\n            self.0[15],\n        ]\n    }\n\n    /// Tests if the UUID is nil (all zeros).\n    pub const fn is_nil(&self) -> bool {\n        self.as_u128() == u128::MIN\n    }\n\n    /// Tests if the UUID is max (all ones).\n    #[cfg(uuid_unstable)]\n    pub const fn is_max(&self) -> bool {\n        self.as_u128() == u128::MAX\n    }\n\n    /// A buffer that can be used for `encode_...` calls, that is\n    /// guaranteed to be long enough for any of the format adapters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use uuid::Uuid;\n    /// let uuid = Uuid::nil();\n    ///\n    /// assert_eq!(\n    ///     uuid.simple().encode_lower(&mut Uuid::encode_buffer()),\n    ///     \"00000000000000000000000000000000\"\n    /// );\n    ///\n    /// assert_eq!(\n    ///     uuid.hyphenated()\n    ///         .encode_lower(&mut Uuid::encode_buffer()),\n    ///     \"00000000-0000-0000-0000-000000000000\"\n    /// );\n    ///\n    /// assert_eq!(\n    ///     uuid.urn().encode_lower(&mut Uuid::encode_buffer()),\n    ///     \"urn:uuid:00000000-0000-0000-0000-000000000000\"\n    /// );\n    /// ```\n    pub const fn encode_buffer() -> [u8; fmt::Urn::LENGTH] {\n        [0; fmt::Urn::LENGTH]\n    }\n\n    /// If the UUID is the correct version (v1, v6, or v7) this will return\n    /// the timestamp and counter portion parsed from a V1 UUID.\n    ///\n    /// Returns `None` if the supplied UUID is not V1.\n    ///\n    /// The V1 timestamp format defined in RFC4122 specifies a 60-bit\n    /// integer representing the number of 100-nanosecond intervals\n    /// since 00:00:00.00, 15 Oct 1582.\n    ///\n    /// [`Timestamp`] offers several options for converting the raw RFC4122\n    /// value into more commonly-used formats, such as a unix timestamp.\n    ///\n    /// # Roundtripping\n    ///\n    /// This method is unlikely to roundtrip a timestamp in a UUID due to the way\n    /// UUIDs encode timestamps. The timestamp returned from this method will be truncated to\n    /// 100ns precision for version 1 and 6 UUIDs, and to millisecond precision for version 7 UUIDs.\n    ///\n    /// [`Timestamp`]: v1/struct.Timestamp.html\n    pub const fn get_timestamp(&self) -> Option<Timestamp> {\n        match self.get_version() {\n            Some(Version::Mac) => {\n                let (ticks, counter) = timestamp::decode_rfc4122_timestamp(self);\n\n                Some(Timestamp::from_rfc4122(ticks, counter))\n            }\n            #[cfg(uuid_unstable)]\n            Some(Version::SortMac) => {\n                let (ticks, counter) = timestamp::decode_sorted_rfc4122_timestamp(self);\n\n                Some(Timestamp::from_rfc4122(ticks, counter))\n            }\n            #[cfg(uuid_unstable)]\n            Some(Version::SortRand) => {\n                let millis = timestamp::decode_unix_timestamp_millis(self);\n\n                let seconds = millis / 1000;\n                let nanos = ((millis % 1000) * 1_000_000) as u32;\n\n                Some(Timestamp {\n                    seconds,\n                    nanos,\n                    #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n                    counter: 0,\n                })\n            }\n            _ => None,\n        }\n    }\n}","impl fmt::Display for Uuid {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::LowerHex::fmt(self, f)\n    }\n}","impl fmt::LowerHex for Uuid {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::LowerHex::fmt(self.as_hyphenated(), f)\n    }\n}","impl fmt::UpperHex for Uuid {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::UpperHex::fmt(self.as_hyphenated(), f)\n    }\n}","impl std::fmt::Debug for Uuid {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::LowerHex::fmt(self, f)\n    }\n}","impl str::FromStr for Uuid {\n    type Err = Error;\n\n    fn from_str(uuid_str: &str) -> Result<Self, Self::Err> {\n        Uuid::parse_str(uuid_str)\n    }\n}"],"Variant":["Clone","Copy","Debug","PartialEq","impl fmt::Display for Variant {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Variant::NCS => write!(f, \"NCS\"),\n            Variant::RFC4122 => write!(f, \"RFC4122\"),\n            Variant::Microsoft => write!(f, \"Microsoft\"),\n            Variant::Future => write!(f, \"Future\"),\n        }\n    }\n}"],"Version":["Clone","Copy","Debug","PartialEq"],"builder::Builder":["Debug","impl Builder {\n    /// Creates a `Builder` using the supplied bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Builder::from_bytes(bytes).into_uuid();\n    ///\n    /// assert_eq!(\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn from_bytes(b: Bytes) -> Self {\n        Builder(Uuid::from_bytes(b))\n    }\n\n    /// Creates a `Builder` using the supplied bytes in little endian order.\n    ///\n    /// The individual fields encoded in the buffer will be flipped.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// # use uuid::{Builder, Uuid};\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Builder::from_bytes_le(bytes).into_uuid();\n    ///\n    /// assert_eq!(\n    ///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub const fn from_bytes_le(b: Bytes) -> Self {\n        Builder(Uuid::from_bytes_le(b))\n    }\n\n    /// Creates a `Builder` for a version 1 UUID using the supplied timestamp and node ID.\n    pub const fn from_rfc4122_timestamp(ticks: u64, counter: u16, node_id: &[u8; 6]) -> Self {\n        Builder(timestamp::encode_rfc4122_timestamp(ticks, counter, node_id))\n    }\n\n    /// Creates a `Builder` for a version 3 UUID using the supplied MD5 hashed bytes.\n    pub const fn from_md5_bytes(md5_bytes: Bytes) -> Self {\n        Builder(Uuid::from_bytes(md5_bytes))\n            .with_variant(Variant::RFC4122)\n            .with_version(Version::Md5)\n    }\n\n    /// Creates a `Builder` for a version 4 UUID using the supplied random bytes.\n    ///\n    /// This method assumes the bytes are already sufficiently random, it will only\n    /// set the appropriate bits for the UUID version and variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use uuid::{Builder, Variant, Version};\n    /// # let rng = || [\n    /// #     70, 235, 208, 238, 14, 109, 67, 201, 185, 13, 204, 195, 90,\n    /// # 145, 63, 62,\n    /// # ];\n    /// let random_bytes = rng();\n    /// let uuid = Builder::from_random_bytes(random_bytes).into_uuid();\n    ///\n    /// assert_eq!(Some(Version::Random), uuid.get_version());\n    /// assert_eq!(Variant::RFC4122, uuid.get_variant());\n    /// ```\n    pub const fn from_random_bytes(random_bytes: Bytes) -> Self {\n        Builder(Uuid::from_bytes(random_bytes))\n            .with_variant(Variant::RFC4122)\n            .with_version(Version::Random)\n    }\n\n    /// Creates a `Builder` for a version 5 UUID using the supplied SHA-1 hashed bytes.\n    ///\n    /// This method assumes the bytes are already a SHA-1 hash, it will only set the appropriate\n    /// bits for the UUID version and variant.\n    pub const fn from_sha1_bytes(sha1_bytes: Bytes) -> Self {\n        Builder(Uuid::from_bytes(sha1_bytes))\n            .with_variant(Variant::RFC4122)\n            .with_version(Version::Sha1)\n    }\n\n    /// Creates a `Builder` for a version 6 UUID using the supplied timestamp and node ID.\n    ///\n    /// This method will encode the ticks, counter, and node ID in a sortable UUID.\n    #[cfg(uuid_unstable)]\n    pub const fn from_sorted_rfc4122_timestamp(\n        ticks: u64,\n        counter: u16,\n        node_id: &[u8; 6],\n    ) -> Self {\n        Builder(timestamp::encode_sorted_rfc4122_timestamp(\n            ticks, counter, node_id,\n        ))\n    }\n\n    /// Creates a `Builder` for a version 7 UUID using the supplied Unix timestamp and random bytes.\n    ///\n    /// This method assumes the bytes are already sufficiently random.\n    ///\n    /// # Examples\n    ///\n    /// Creating a UUID using the current system timestamp:\n    ///\n    /// ```\n    /// # use std::convert::TryInto;\n    /// use std::time::{Duration, SystemTime};\n    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {\n    /// # use uuid::{Builder, Uuid, Variant, Version, Timestamp, NoContext};\n    /// # let rng = || [\n    /// #     70, 235, 208, 238, 14, 109, 67, 201, 185, 13\n    /// # ];\n    /// let ts = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)?;\n    ///\n    /// let random_bytes = rng();\n    ///\n    /// let uuid = Builder::from_unix_timestamp_millis(ts.as_millis().try_into()?, &random_bytes).into_uuid();\n    ///\n    /// assert_eq!(Some(Version::SortRand), uuid.get_version());\n    /// assert_eq!(Variant::RFC4122, uuid.get_variant());\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[cfg(uuid_unstable)]\n    pub const fn from_unix_timestamp_millis(millis: u64, random_bytes: &[u8; 10]) -> Self {\n        Builder(timestamp::encode_unix_timestamp_millis(\n            millis,\n            random_bytes,\n        ))\n    }\n\n    /// Creates a `Builder` for a version 8 UUID using the supplied user-defined bytes.\n    ///\n    /// This method won't interpret the given bytes in any way, except to set the appropriate\n    /// bits for the UUID version and variant.\n    #[cfg(uuid_unstable)]\n    pub const fn from_custom_bytes(custom_bytes: Bytes) -> Self {\n        Builder::from_bytes(custom_bytes)\n            .with_variant(Variant::RFC4122)\n            .with_version(Version::Custom)\n    }\n\n    /// Creates a `Builder` using the supplied bytes.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if `b` has any length other than 16.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Builder::from_slice(&bytes)?.into_uuid();\n    ///\n    /// assert_eq!(\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn from_slice(b: &[u8]) -> Result<Self, Error> {\n        Ok(Builder(Uuid::from_slice(b)?))\n    }\n\n    /// Creates a `Builder` using the supplied bytes in little endian order.\n    ///\n    /// The individual fields encoded in the buffer will be flipped.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if `b` has any length other than 16.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// # fn main() -> Result<(), uuid::Error> {\n    /// let bytes = [\n    ///     0xa1, 0xa2, 0xa3, 0xa4,\n    ///     0xb1, 0xb2,\n    ///     0xc1, 0xc2,\n    ///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n    /// ];\n    ///\n    /// let uuid = Builder::from_slice_le(&bytes)?.into_uuid();\n    ///\n    /// assert_eq!(\n    ///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn from_slice_le(b: &[u8]) -> Result<Self, Error> {\n        Ok(Builder(Uuid::from_slice_le(b)?))\n    }\n\n    /// Creates a `Builder` from four field values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// let d1 = 0xa1a2a3a4;\n    /// let d2 = 0xb1b2;\n    /// let d3 = 0xc1c2;\n    /// let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n    ///\n    /// let uuid = Builder::from_fields(d1, d2, d3, &d4).into_uuid();\n    ///\n    /// assert_eq!(\n    ///     uuid.hyphenated().to_string(),\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\"\n    /// );\n    /// ```\n    pub const fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Self {\n        Builder(Uuid::from_fields(d1, d2, d3, d4))\n    }\n\n    /// Creates a `Builder` from four field values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// let d1 = 0xa1a2a3a4;\n    /// let d2 = 0xb1b2;\n    /// let d3 = 0xc1c2;\n    /// let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n    ///\n    /// let uuid = Builder::from_fields_le(d1, d2, d3, &d4).into_uuid();\n    ///\n    /// assert_eq!(\n    ///     uuid.hyphenated().to_string(),\n    ///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\"\n    /// );\n    /// ```\n    pub const fn from_fields_le(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Self {\n        Builder(Uuid::from_fields_le(d1, d2, d3, d4))\n    }\n\n    /// Creates a `Builder` from a 128bit value.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n    ///\n    /// let uuid = Builder::from_u128(v).into_uuid();\n    ///\n    /// assert_eq!(\n    ///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn from_u128(v: u128) -> Self {\n        Builder(Uuid::from_u128(v))\n    }\n\n    /// Creates a UUID from a 128bit value in little-endian order.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n    ///\n    /// let uuid = Builder::from_u128_le(v).into_uuid();\n    ///\n    /// assert_eq!(\n    ///     \"d8d7d6d5-d4d3-d2d1-c2c1-b2b1a4a3a2a1\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn from_u128_le(v: u128) -> Self {\n        Builder(Uuid::from_u128_le(v))\n    }\n\n    /// Creates a `Builder` with an initial [`Uuid::nil`].\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// let uuid = Builder::nil().into_uuid();\n    ///\n    /// assert_eq!(\n    ///     \"00000000-0000-0000-0000-000000000000\",\n    ///     uuid.hyphenated().to_string(),\n    /// );\n    /// ```\n    pub const fn nil() -> Self {\n        Builder(Uuid::nil())\n    }\n\n    /// Specifies the variant of the UUID.\n    pub fn set_variant(&mut self, v: Variant) -> &mut Self {\n        *self = Builder(self.0).with_variant(v);\n        self\n    }\n\n    /// Specifies the variant of the UUID.\n    pub const fn with_variant(mut self, v: Variant) -> Self {\n        let byte = (self.0).0[8];\n\n        (self.0).0[8] = match v {\n            Variant::NCS => byte & 0x7f,\n            Variant::RFC4122 => (byte & 0x3f) | 0x80,\n            Variant::Microsoft => (byte & 0x1f) | 0xc0,\n            Variant::Future => byte | 0xe0,\n        };\n\n        self\n    }\n\n    /// Specifies the version number of the UUID.\n    pub fn set_version(&mut self, v: Version) -> &mut Self {\n        *self = Builder(self.0).with_version(v);\n        self\n    }\n\n    /// Specifies the version number of the UUID.\n    pub const fn with_version(mut self, v: Version) -> Self {\n        (self.0).0[6] = ((self.0).0[6] & 0x0f) | ((v as u8) << 4);\n\n        self\n    }\n\n    /// Get a reference to the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// let builder = Builder::nil();\n    ///\n    /// let uuid1 = builder.as_uuid();\n    /// let uuid2 = builder.as_uuid();\n    ///\n    /// assert_eq!(uuid1, uuid2);\n    /// ```\n    pub const fn as_uuid(&self) -> &Uuid {\n        &self.0\n    }\n\n    /// Convert the builder into a [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # use uuid::Builder;\n    /// let uuid = Builder::nil().into_uuid();\n    ///\n    /// assert_eq!(\n    ///     uuid.hyphenated().to_string(),\n    ///     \"00000000-0000-0000-0000-000000000000\"\n    /// );\n    /// ```\n    pub const fn into_uuid(self) -> Uuid {\n        self.0\n    }\n}"],"error::Error":["Clone","Debug","Eq","Hash","PartialEq","impl error::Error for Error {}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self.0 {\n            ErrorKind::Char {\n                character, index, ..\n            } => {\n                write!(f, \"invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `{}` at {}\", character, index)\n            }\n            ErrorKind::SimpleLength { len } => {\n                write!(\n                    f,\n                    \"invalid length: expected length 32 for simple format, found {}\",\n                    len\n                )\n            }\n            ErrorKind::ByteLength { len } => {\n                write!(f, \"invalid length: expected 16 bytes, found {}\", len)\n            }\n            ErrorKind::GroupCount { count } => {\n                write!(f, \"invalid group count: expected 5, found {}\", count)\n            }\n            ErrorKind::GroupLength { group, len, .. } => {\n                let expected = [8, 4, 4, 4, 12][group];\n                write!(\n                    f,\n                    \"invalid group length in group {}: expected {}, found {}\",\n                    group, expected, len\n                )\n            }\n            ErrorKind::InvalidUTF8 => write!(f, \"non-UTF8 input\"),\n            ErrorKind::Other => write!(f, \"failed to parse a UUID\"),\n        }\n    }\n}"],"error::ErrorKind":["Clone","Debug","Eq","Hash","PartialEq"],"error::InvalidUuid":["Clone","Debug","Eq","Hash","PartialEq","impl<'a> InvalidUuid<'a> {\n    /// Converts the lightweight error type into detailed diagnostics.\n    pub fn into_err(self) -> Error {\n        // Check whether or not the input was ever actually a valid UTF8 string\n        let input_str = match std::str::from_utf8(self.0) {\n            Ok(s) => s,\n            Err(_) => return Error(ErrorKind::InvalidUTF8),\n        };\n\n        let (uuid_str, offset, simple) = match input_str.as_bytes() {\n            [b'{', s @ .., b'}'] => (s, 1, false),\n            [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] => {\n                (s, \"urn:uuid:\".len(), false)\n            }\n            s => (s, 0, true),\n        };\n\n        let mut hyphen_count = 0;\n        let mut group_bounds = [0; 4];\n\n        // SAFETY: the byte array came from a valid utf8 string,\n        // and is aligned along char boundaries.\n        let uuid_str = unsafe { std::str::from_utf8_unchecked(uuid_str) };\n\n        for (index, character) in uuid_str.char_indices() {\n            let byte = character as u8;\n            if character as u32 - byte as u32 > 0 {\n                // Multibyte char\n                return Error(ErrorKind::Char {\n                    character,\n                    index: index + offset + 1,\n                });\n            } else if byte == b'-' {\n                // While we search, also count group breaks\n                if hyphen_count < 4 {\n                    group_bounds[hyphen_count] = index;\n                }\n                hyphen_count += 1;\n            } else if !matches!(byte, b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F') {\n                // Non-hex char\n                return Error(ErrorKind::Char {\n                    character: byte as char,\n                    index: index + offset + 1,\n                });\n            }\n        }\n\n        if hyphen_count == 0 && simple {\n            // This means that we tried and failed to parse a simple uuid.\n            // Since we verified that all the characters are valid, this means\n            // that it MUST have an invalid length.\n            Error(ErrorKind::SimpleLength {\n                len: input_str.len(),\n            })\n        } else if hyphen_count != 4 {\n            // We tried to parse a hyphenated variant, but there weren't\n            // 5 groups (4 hyphen splits).\n            Error(ErrorKind::GroupCount {\n                count: hyphen_count + 1,\n            })\n        } else {\n            // There are 5 groups, one of them has an incorrect length\n            const BLOCK_STARTS: [usize; 5] = [0, 9, 14, 19, 24];\n            for i in 0..4 {\n                if group_bounds[i] != BLOCK_STARTS[i + 1] - 1 {\n                    return Error(ErrorKind::GroupLength {\n                        group: i,\n                        len: group_bounds[i] - BLOCK_STARTS[i],\n                        index: offset + BLOCK_STARTS[i] + 1,\n                    });\n                }\n            }\n\n            // The last group must be too long\n            Error(ErrorKind::GroupLength {\n                group: 4,\n                len: input_str.len() - BLOCK_STARTS[4],\n                index: offset + BLOCK_STARTS[4] + 1,\n            })\n        }\n    }\n}"],"fmt::Braced":["Clone","Copy","Debug","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl AsRef<Uuid> for $T {\n            #[inline]\n            fn as_ref(&self) -> &Uuid {\n                &self.0\n            }\n        }","impl Borrow<Uuid> for $T {\n            #[inline]\n            fn borrow(&self) -> &Uuid {\n                &self.0\n            }\n        }","impl Braced {\n    /// The length of a braced [`Uuid`] string.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    pub const LENGTH: usize = 38;\n\n    /// Creates a [`Braced`] from a [`Uuid`].\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    /// [`Braced`]: struct.Braced.html\n    pub const fn from_uuid(uuid: Uuid) -> Self {\n        Braced(uuid)\n    }\n\n    /// Writes the [`Uuid`] as a lower-case hyphenated string surrounded by\n    /// braces to `buffer`, and returns the subslice of the buffer that contains\n    /// the encoded UUID.\n    ///\n    /// This is slightly more efficient than using the formatting\n    /// infrastructure as it avoids virtual calls, and may avoid\n    /// double buffering.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough: it must have length at least\n    /// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n    /// sufficiently-large temporary buffer.\n    ///\n    /// [`LENGTH`]: #associatedconstant.LENGTH\n    /// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// fn main() -> Result<(), uuid::Error> {\n    ///     let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\")?;\n    ///\n    ///     // the encoded portion is returned\n    ///     assert_eq!(\n    ///         uuid.braced()\n    ///             .encode_lower(&mut Uuid::encode_buffer()),\n    ///         \"{936da01f-9abd-4d9d-80c7-02af85c822a8}\"\n    ///     );\n    ///\n    ///     // the buffer is mutated directly, and trailing contents remains\n    ///     let mut buf = [b'!'; 40];\n    ///     uuid.braced().encode_lower(&mut buf);\n    ///     assert_eq!(\n    ///         &buf as &[_],\n    ///         b\"{936da01f-9abd-4d9d-80c7-02af85c822a8}!!\" as &[_]\n    ///     );\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    /// */\n    #[inline]\n    pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {\n        encode_braced(self.0.as_bytes(), buffer, false)\n    }\n\n    /// Writes the [`Uuid`] as an upper-case hyphenated string surrounded by\n    /// braces to `buffer`, and returns the subslice of the buffer that contains\n    /// the encoded UUID.\n    ///\n    /// This is slightly more efficient than using the formatting\n    /// infrastructure as it avoids virtual calls, and may avoid\n    /// double buffering.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough: it must have length at least\n    /// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n    /// sufficiently-large temporary buffer.\n    ///\n    /// [`LENGTH`]: #associatedconstant.LENGTH\n    /// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// fn main() -> Result<(), uuid::Error> {\n    ///     let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\")?;\n    ///\n    ///     // the encoded portion is returned\n    ///     assert_eq!(\n    ///         uuid.braced()\n    ///             .encode_upper(&mut Uuid::encode_buffer()),\n    ///         \"{936DA01F-9ABD-4D9D-80C7-02AF85C822A8}\"\n    ///     );\n    ///\n    ///     // the buffer is mutated directly, and trailing contents remains\n    ///     let mut buf = [b'!'; 40];\n    ///     uuid.braced().encode_upper(&mut buf);\n    ///     assert_eq!(\n    ///         &buf as &[_],\n    ///         b\"{936DA01F-9ABD-4D9D-80C7-02AF85C822A8}!!\" as &[_]\n    ///     );\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    /// */\n    #[inline]\n    pub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {\n        encode_braced(self.0.as_bytes(), buffer, true)\n    }\n\n    /// Get a reference to the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// let braced = Uuid::nil().braced();\n    /// assert_eq!(*braced.as_uuid(), Uuid::nil());\n    /// ```\n    pub const fn as_uuid(&self) -> &Uuid {\n        &self.0\n    }\n\n    /// Consumes the [`Braced`], returning the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// let braced = Uuid::nil().braced();\n    /// assert_eq!(braced.into_uuid(), Uuid::nil());\n    /// ```\n    pub const fn into_uuid(self) -> Uuid {\n        self.0\n    }\n}","impl From<Uuid> for $T {\n            #[inline]\n            fn from(f: Uuid) -> Self {\n                $T(f)\n            }\n        }","impl<$($a),*> fmt::Display for $T<$($a),*> {\n            #[inline]\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::LowerHex::fmt(self, f)\n            }\n        }","impl<$($a),*> fmt::LowerHex for $T<$($a),*> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))\n            }\n        }","impl<$($a),*> fmt::UpperHex for $T<$($a),*> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))\n            }\n        }"],"fmt::Hyphenated":["Clone","Copy","Debug","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl AsRef<Uuid> for $T {\n            #[inline]\n            fn as_ref(&self) -> &Uuid {\n                &self.0\n            }\n        }","impl Borrow<Uuid> for $T {\n            #[inline]\n            fn borrow(&self) -> &Uuid {\n                &self.0\n            }\n        }","impl From<Uuid> for $T {\n            #[inline]\n            fn from(f: Uuid) -> Self {\n                $T(f)\n            }\n        }","impl Hyphenated {\n    /// The length of a hyphenated [`Uuid`] string.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    pub const LENGTH: usize = 36;\n\n    /// Creates a [`Hyphenated`] from a [`Uuid`].\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    /// [`Hyphenated`]: struct.Hyphenated.html\n    pub const fn from_uuid(uuid: Uuid) -> Self {\n        Hyphenated(uuid)\n    }\n\n    /// Writes the [`Uuid`] as a lower-case hyphenated string to\n    /// `buffer`, and returns the subslice of the buffer that contains the\n    /// encoded UUID.\n    ///\n    /// This is slightly more efficient than using the formatting\n    /// infrastructure as it avoids virtual calls, and may avoid\n    /// double buffering.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough: it must have length at least\n    /// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n    /// sufficiently-large temporary buffer.\n    ///\n    /// [`LENGTH`]: #associatedconstant.LENGTH\n    /// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// fn main() -> Result<(), uuid::Error> {\n    ///     let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\")?;\n    ///\n    ///     // the encoded portion is returned\n    ///     assert_eq!(\n    ///         uuid.hyphenated()\n    ///             .encode_lower(&mut Uuid::encode_buffer()),\n    ///         \"936da01f-9abd-4d9d-80c7-02af85c822a8\"\n    ///     );\n    ///\n    ///     // the buffer is mutated directly, and trailing contents remains\n    ///     let mut buf = [b'!'; 40];\n    ///     uuid.hyphenated().encode_lower(&mut buf);\n    ///     assert_eq!(\n    ///         &buf as &[_],\n    ///         b\"936da01f-9abd-4d9d-80c7-02af85c822a8!!!!\" as &[_]\n    ///     );\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    /// */\n    #[inline]\n    pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {\n        encode_hyphenated(self.0.as_bytes(), buffer, false)\n    }\n\n    /// Writes the [`Uuid`] as an upper-case hyphenated string to\n    /// `buffer`, and returns the subslice of the buffer that contains the\n    /// encoded UUID.\n    ///\n    /// This is slightly more efficient than using the formatting\n    /// infrastructure as it avoids virtual calls, and may avoid\n    /// double buffering.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough: it must have length at least\n    /// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n    /// sufficiently-large temporary buffer.\n    ///\n    /// [`LENGTH`]: #associatedconstant.LENGTH\n    /// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// fn main() -> Result<(), uuid::Error> {\n    ///     let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\")?;\n    ///\n    ///     // the encoded portion is returned\n    ///     assert_eq!(\n    ///         uuid.hyphenated()\n    ///             .encode_upper(&mut Uuid::encode_buffer()),\n    ///         \"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n    ///     );\n    ///\n    ///     // the buffer is mutated directly, and trailing contents remains\n    ///     let mut buf = [b'!'; 40];\n    ///     uuid.hyphenated().encode_upper(&mut buf);\n    ///     assert_eq!(\n    ///         &buf as &[_],\n    ///         b\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8!!!!\" as &[_]\n    ///     );\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    /// */\n    #[inline]\n    pub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {\n        encode_hyphenated(self.0.as_bytes(), buffer, true)\n    }\n\n    /// Get a reference to the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// let hyphenated = Uuid::nil().hyphenated();\n    /// assert_eq!(*hyphenated.as_uuid(), Uuid::nil());\n    /// ```\n    pub const fn as_uuid(&self) -> &Uuid {\n        &self.0\n    }\n\n    /// Consumes the [`Hyphenated`], returning the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// let hyphenated = Uuid::nil().hyphenated();\n    /// assert_eq!(hyphenated.into_uuid(), Uuid::nil());\n    /// ```\n    pub const fn into_uuid(self) -> Uuid {\n        self.0\n    }\n}","impl<$($a),*> fmt::Display for $T<$($a),*> {\n            #[inline]\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::LowerHex::fmt(self, f)\n            }\n        }","impl<$($a),*> fmt::LowerHex for $T<$($a),*> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))\n            }\n        }","impl<$($a),*> fmt::UpperHex for $T<$($a),*> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))\n            }\n        }"],"fmt::Simple":["Clone","Copy","Debug","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl AsRef<Uuid> for $T {\n            #[inline]\n            fn as_ref(&self) -> &Uuid {\n                &self.0\n            }\n        }","impl Borrow<Uuid> for $T {\n            #[inline]\n            fn borrow(&self) -> &Uuid {\n                &self.0\n            }\n        }","impl From<Uuid> for $T {\n            #[inline]\n            fn from(f: Uuid) -> Self {\n                $T(f)\n            }\n        }","impl Simple {\n    /// The length of a simple [`Uuid`] string.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    pub const LENGTH: usize = 32;\n\n    /// Creates a [`Simple`] from a [`Uuid`].\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    /// [`Simple`]: struct.Simple.html\n    pub const fn from_uuid(uuid: Uuid) -> Self {\n        Simple(uuid)\n    }\n\n    /// Writes the [`Uuid`] as a lower-case simple string to `buffer`,\n    /// and returns the subslice of the buffer that contains the encoded UUID.\n    ///\n    /// This is slightly more efficient than using the formatting\n    /// infrastructure as it avoids virtual calls, and may avoid\n    /// double buffering.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough: it must have length at least\n    /// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n    /// sufficiently-large temporary buffer.\n    ///\n    /// [`LENGTH`]: #associatedconstant.LENGTH\n    /// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// fn main() -> Result<(), uuid::Error> {\n    ///     let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\")?;\n    ///\n    ///     // the encoded portion is returned\n    ///     assert_eq!(\n    ///         uuid.simple().encode_lower(&mut Uuid::encode_buffer()),\n    ///         \"936da01f9abd4d9d80c702af85c822a8\"\n    ///     );\n    ///\n    ///     // the buffer is mutated directly, and trailing contents remains\n    ///     let mut buf = [b'!'; 36];\n    ///     assert_eq!(\n    ///         uuid.simple().encode_lower(&mut buf),\n    ///         \"936da01f9abd4d9d80c702af85c822a8\"\n    ///     );\n    ///     assert_eq!(\n    ///         &buf as &[_],\n    ///         b\"936da01f9abd4d9d80c702af85c822a8!!!!\" as &[_]\n    ///     );\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    /// */\n    #[inline]\n    pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {\n        encode_simple(self.0.as_bytes(), buffer, false)\n    }\n\n    /// Writes the [`Uuid`] as an upper-case simple string to `buffer`,\n    /// and returns the subslice of the buffer that contains the encoded UUID.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough: it must have length at least\n    /// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n    /// sufficiently-large temporary buffer.\n    ///\n    /// [`LENGTH`]: #associatedconstant.LENGTH\n    /// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// fn main() -> Result<(), uuid::Error> {\n    ///     let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\")?;\n    ///\n    ///     // the encoded portion is returned\n    ///     assert_eq!(\n    ///         uuid.simple().encode_upper(&mut Uuid::encode_buffer()),\n    ///         \"936DA01F9ABD4D9D80C702AF85C822A8\"\n    ///     );\n    ///\n    ///     // the buffer is mutated directly, and trailing contents remains\n    ///     let mut buf = [b'!'; 36];\n    ///     assert_eq!(\n    ///         uuid.simple().encode_upper(&mut buf),\n    ///         \"936DA01F9ABD4D9D80C702AF85C822A8\"\n    ///     );\n    ///     assert_eq!(\n    ///         &buf as &[_],\n    ///         b\"936DA01F9ABD4D9D80C702AF85C822A8!!!!\" as &[_]\n    ///     );\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    /// */\n    #[inline]\n    pub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {\n        encode_simple(self.0.as_bytes(), buffer, true)\n    }\n\n    /// Get a reference to the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// let simple = Uuid::nil().simple();\n    /// assert_eq!(*simple.as_uuid(), Uuid::nil());\n    /// ```\n    pub const fn as_uuid(&self) -> &Uuid {\n        &self.0\n    }\n\n    /// Consumes the [`Simple`], returning the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// let simple = Uuid::nil().simple();\n    /// assert_eq!(simple.into_uuid(), Uuid::nil());\n    /// ```\n    pub const fn into_uuid(self) -> Uuid {\n        self.0\n    }\n}","impl<$($a),*> fmt::Display for $T<$($a),*> {\n            #[inline]\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::LowerHex::fmt(self, f)\n            }\n        }","impl<$($a),*> fmt::LowerHex for $T<$($a),*> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))\n            }\n        }","impl<$($a),*> fmt::UpperHex for $T<$($a),*> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))\n            }\n        }"],"fmt::Urn":["Clone","Copy","Debug","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl AsRef<Uuid> for $T {\n            #[inline]\n            fn as_ref(&self) -> &Uuid {\n                &self.0\n            }\n        }","impl Borrow<Uuid> for $T {\n            #[inline]\n            fn borrow(&self) -> &Uuid {\n                &self.0\n            }\n        }","impl From<Uuid> for $T {\n            #[inline]\n            fn from(f: Uuid) -> Self {\n                $T(f)\n            }\n        }","impl Urn {\n    /// The length of a URN [`Uuid`] string.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    pub const LENGTH: usize = 45;\n\n    /// Creates a [`Urn`] from a [`Uuid`].\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    /// [`Urn`]: struct.Urn.html\n    pub const fn from_uuid(uuid: Uuid) -> Self {\n        Urn(uuid)\n    }\n\n    /// Writes the [`Uuid`] as a lower-case URN string to\n    /// `buffer`, and returns the subslice of the buffer that contains the\n    /// encoded UUID.\n    ///\n    /// This is slightly more efficient than using the formatting\n    /// infrastructure as it avoids virtual calls, and may avoid\n    /// double buffering.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough: it must have length at least\n    /// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n    /// sufficiently-large temporary buffer.\n    ///\n    /// [`LENGTH`]: #associatedconstant.LENGTH\n    /// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// fn main() -> Result<(), uuid::Error> {\n    ///     let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\")?;\n    ///\n    ///     // the encoded portion is returned\n    ///     assert_eq!(\n    ///         uuid.urn().encode_lower(&mut Uuid::encode_buffer()),\n    ///         \"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8\"\n    ///     );\n    ///\n    ///     // the buffer is mutated directly, and trailing contents remains\n    ///     let mut buf = [b'!'; 49];\n    ///     uuid.urn().encode_lower(&mut buf);\n    ///     assert_eq!(\n    ///         uuid.urn().encode_lower(&mut buf),\n    ///         \"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8\"\n    ///     );\n    ///     assert_eq!(\n    ///         &buf as &[_],\n    ///         b\"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8!!!!\" as &[_]\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    /// */\n    #[inline]\n    pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {\n        encode_urn(self.0.as_bytes(), buffer, false)\n    }\n\n    /// Writes the [`Uuid`] as an upper-case URN string to\n    /// `buffer`, and returns the subslice of the buffer that contains the\n    /// encoded UUID.\n    ///\n    /// This is slightly more efficient than using the formatting\n    /// infrastructure as it avoids virtual calls, and may avoid\n    /// double buffering.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough: it must have length at least\n    /// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n    /// sufficiently-large temporary buffer.\n    ///\n    /// [`LENGTH`]: #associatedconstant.LENGTH\n    /// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// fn main() -> Result<(), uuid::Error> {\n    ///     let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\")?;\n    ///\n    ///     // the encoded portion is returned\n    ///     assert_eq!(\n    ///         uuid.urn().encode_upper(&mut Uuid::encode_buffer()),\n    ///         \"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n    ///     );\n    ///\n    ///     // the buffer is mutated directly, and trailing contents remains\n    ///     let mut buf = [b'!'; 49];\n    ///     assert_eq!(\n    ///         uuid.urn().encode_upper(&mut buf),\n    ///         \"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n    ///     );\n    ///     assert_eq!(\n    ///         &buf as &[_],\n    ///         b\"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8!!!!\" as &[_]\n    ///     );\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    /// */\n    #[inline]\n    pub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {\n        encode_urn(self.0.as_bytes(), buffer, true)\n    }\n\n    /// Get a reference to the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// let urn = Uuid::nil().urn();\n    /// assert_eq!(*urn.as_uuid(), Uuid::nil());\n    /// ```\n    pub const fn as_uuid(&self) -> &Uuid {\n        &self.0\n    }\n\n    /// Consumes the [`Urn`], returning the underlying [`Uuid`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use uuid::Uuid;\n    ///\n    /// let urn = Uuid::nil().urn();\n    /// assert_eq!(urn.into_uuid(), Uuid::nil());\n    /// ```\n    pub const fn into_uuid(self) -> Uuid {\n        self.0\n    }\n}","impl<$($a),*> fmt::Display for $T<$($a),*> {\n            #[inline]\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::LowerHex::fmt(self, f)\n            }\n        }","impl<$($a),*> fmt::LowerHex for $T<$($a),*> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))\n            }\n        }","impl<$($a),*> fmt::UpperHex for $T<$($a),*> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))\n            }\n        }"],"timestamp::Timestamp":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Timestamp {\n    /// Get a timestamp representing the current system time.\n    ///\n    /// This method defers to the standard library's `SystemTime` type.\n    ///\n    /// # Panics\n    ///\n    /// This method will panic if calculating the elapsed time since the Unix epoch fails.\n    #[cfg(feature = \"std\")]\n    pub fn now(context: impl ClockSequence<Output = u16>) -> Self {\n        #[cfg(not(any(feature = \"v1\", feature = \"v6\")))]\n        {\n            let _ = context;\n        }\n\n        let (seconds, nanos) = now();\n\n        Timestamp {\n            seconds,\n            nanos,\n            #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n            counter: context.generate_sequence(seconds, nanos),\n        }\n    }\n\n    /// Construct a `Timestamp` from an RFC4122 timestamp and counter, as used\n    /// in versions 1 and 6 UUIDs.\n    ///\n    /// # Overflow\n    ///\n    /// If conversion from RFC4122 ticks to the internal timestamp format would overflow\n    /// it will wrap.\n    pub const fn from_rfc4122(ticks: u64, counter: u16) -> Self {\n        #[cfg(not(any(feature = \"v1\", feature = \"v6\")))]\n        {\n            let _ = counter;\n        }\n\n        let (seconds, nanos) = Self::rfc4122_to_unix(ticks);\n\n        Timestamp {\n            seconds,\n            nanos,\n            #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n            counter,\n        }\n    }\n\n    /// Construct a `Timestamp` from a Unix timestamp, as used in version 7 UUIDs.\n    ///\n    /// # Overflow\n    ///\n    /// If conversion from RFC4122 ticks to the internal timestamp format would overflow\n    /// it will wrap.\n    pub fn from_unix(context: impl ClockSequence<Output = u16>, seconds: u64, nanos: u32) -> Self {\n        #[cfg(not(any(feature = \"v1\", feature = \"v6\")))]\n        {\n            let _ = context;\n\n            Timestamp { seconds, nanos }\n        }\n        #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n        {\n            let counter = context.generate_sequence(seconds, nanos);\n\n            Timestamp {\n                seconds,\n                nanos,\n                counter,\n            }\n        }\n    }\n\n    /// Get the value of the timestamp as an RFC4122 timestamp and counter,\n    /// as used in versions 1 and 6 UUIDs.\n    ///\n    /// # Overflow\n    ///\n    /// If conversion from RFC4122 ticks to the internal timestamp format would overflow\n    /// it will wrap.\n    #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n    pub const fn to_rfc4122(&self) -> (u64, u16) {\n        (\n            Self::unix_to_rfc4122_ticks(self.seconds, self.nanos),\n            self.counter,\n        )\n    }\n\n    /// Get the value of the timestamp as a Unix timestamp, as used in version 7 UUIDs.\n    ///\n    /// # Overflow\n    ///\n    /// If conversion from RFC4122 ticks to the internal timestamp format would overflow\n    /// it will wrap.\n    pub const fn to_unix(&self) -> (u64, u32) {\n        (self.seconds, self.nanos)\n    }\n\n    #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n    const fn unix_to_rfc4122_ticks(seconds: u64, nanos: u32) -> u64 {\n        let ticks = UUID_TICKS_BETWEEN_EPOCHS\n            .wrapping_add(seconds.wrapping_mul(10_000_000))\n            .wrapping_add(nanos as u64 / 100);\n\n        ticks\n    }\n\n    const fn rfc4122_to_unix(ticks: u64) -> (u64, u32) {\n        (\n            ticks.wrapping_sub(UUID_TICKS_BETWEEN_EPOCHS) / 10_000_000,\n            (ticks.wrapping_sub(UUID_TICKS_BETWEEN_EPOCHS) % 10_000_000) as u32 * 100,\n        )\n    }\n\n    #[deprecated(note = \"use `to_unix` instead; this method will be removed in a future release\")]\n    /// Get the number of fractional nanoseconds in the Unix timestamp.\n    ///\n    /// This method is deprecated and probably doesn't do what you're expecting it to.\n    /// It doesn't return the timestamp as nanoseconds since the Unix epoch, it returns\n    /// the fractional seconds of the timestamp.\n    pub const fn to_unix_nanos(&self) -> u32 {\n        panic!(\"`Timestamp::to_unix_nanos` is deprecated and will be removed: use `Timestamp::to_unix` instead\")\n    }\n}"],"timestamp::context::NoContext":["Clone","Copy","Debug","Default","impl ClockSequence for NoContext {\n        type Output = u16;\n\n        fn generate_sequence(&self, _seconds: u64, _nanos: u32) -> Self::Output {\n            0\n        }\n    }"]},"single_path_import":{"builder::Builder":"Builder","error::Error":"Error","timestamp::ClockSequence":"ClockSequence","timestamp::Timestamp":"Timestamp","timestamp::context::NoContext":"NoContext"},"srcs":{"<&'a T as timestamp::ClockSequence>::generate_sequence":["fn generate_sequence(&self, seconds: u64, subsec_nanos: u32) -> Self::Output{\n        (**self).generate_sequence(seconds, subsec_nanos)\n    }","Real(LocalPath(\"src/timestamp.rs\"))"],"<Uuid as std::convert::AsRef<[u8]>>::as_ref":["#[inline]\nfn as_ref(&self) -> &[u8]{\n        &self.0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Uuid as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n        Uuid::nil()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self.0 {\n            ErrorKind::Char {\n                character, index, ..\n            } => {\n                write!(f, \"invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `{}` at {}\", character, index)\n            }\n            ErrorKind::SimpleLength { len } => {\n                write!(\n                    f,\n                    \"invalid length: expected length 32 for simple format, found {}\",\n                    len\n                )\n            }\n            ErrorKind::ByteLength { len } => {\n                write!(f, \"invalid length: expected 16 bytes, found {}\", len)\n            }\n            ErrorKind::GroupCount { count } => {\n                write!(f, \"invalid group count: expected 5, found {}\", count)\n            }\n            ErrorKind::GroupLength { group, len, .. } => {\n                let expected = [8, 4, 4, 4, 12][group];\n                write!(\n                    f,\n                    \"invalid group length in group {}: expected {}, found {}\",\n                    group, expected, len\n                )\n            }\n            ErrorKind::InvalidUTF8 => write!(f, \"non-UTF8 input\"),\n            ErrorKind::Other => write!(f, \"failed to parse a UUID\"),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<fmt::Braced as std::borrow::Borrow<Uuid>>::borrow":["#[inline]\nfn borrow(&self) -> &Uuid{\n                &self.0\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Braced as std::convert::AsRef<Uuid>>::as_ref":["#[inline]\nfn as_ref(&self) -> &Uuid{\n                &self.0\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Braced as std::convert::From<Uuid>>::from":["#[inline]\nfn from(f: Uuid) -> Self{\n                $T(f)\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Braced as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                fmt::LowerHex::fmt(self, f)\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Braced as std::fmt::LowerHex>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Braced as std::fmt::UpperHex>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Hyphenated as std::borrow::Borrow<Uuid>>::borrow":["#[inline]\nfn borrow(&self) -> &Uuid{\n                &self.0\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Hyphenated as std::convert::AsRef<Uuid>>::as_ref":["#[inline]\nfn as_ref(&self) -> &Uuid{\n                &self.0\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Hyphenated as std::convert::From<Uuid>>::from":["#[inline]\nfn from(f: Uuid) -> Self{\n                $T(f)\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Hyphenated as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                fmt::LowerHex::fmt(self, f)\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Hyphenated as std::fmt::LowerHex>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Hyphenated as std::fmt::UpperHex>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Simple as std::borrow::Borrow<Uuid>>::borrow":["#[inline]\nfn borrow(&self) -> &Uuid{\n                &self.0\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Simple as std::convert::AsRef<Uuid>>::as_ref":["#[inline]\nfn as_ref(&self) -> &Uuid{\n                &self.0\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Simple as std::convert::From<Uuid>>::from":["#[inline]\nfn from(f: Uuid) -> Self{\n                $T(f)\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Simple as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                fmt::LowerHex::fmt(self, f)\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Simple as std::fmt::LowerHex>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Simple as std::fmt::UpperHex>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Urn as std::borrow::Borrow<Uuid>>::borrow":["#[inline]\nfn borrow(&self) -> &Uuid{\n                &self.0\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Urn as std::convert::AsRef<Uuid>>::as_ref":["#[inline]\nfn as_ref(&self) -> &Uuid{\n                &self.0\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Urn as std::convert::From<Uuid>>::from":["#[inline]\nfn from(f: Uuid) -> Self{\n                $T(f)\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Urn as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                fmt::LowerHex::fmt(self, f)\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Urn as std::fmt::LowerHex>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Urn as std::fmt::UpperHex>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"<timestamp::context::NoContext as timestamp::ClockSequence>::generate_sequence":["fn generate_sequence(&self, _seconds: u64, _nanos: u32) -> Self::Output{\n            0\n        }","Real(LocalPath(\"src/timestamp.rs\"))"],"Uuid":["/// A Universally Unique Identifier (UUID).\n///\n/// # Examples\n///\n/// Parse a UUID given in the simple format and print it as a urn:\n///\n/// ```\n/// # use uuid::Uuid;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let my_uuid = Uuid::parse_str(\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\")?;\n///\n/// println!(\"{}\", my_uuid.urn());\n/// # Ok(())\n/// # }\n/// ```\n///\n/// Create a new random (V4) UUID and print it out in hexadecimal form:\n///\n/// ```\n/// // Note that this requires the `v4` feature enabled in the uuid crate.\n/// # use uuid::Uuid;\n/// # fn main() {\n/// # #[cfg(feature = \"v4\")] {\n/// let my_uuid = Uuid::new_v4();\n///\n/// println!(\"{}\", my_uuid);\n/// # }\n/// # }\n/// ```\n///\n/// # Formatting\n///\n/// A UUID can be formatted in one of a few ways:\n///\n/// * [`simple`](#method.simple): `a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8`.\n/// * [`hyphenated`](#method.hyphenated):\n///   `a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8`.\n/// * [`urn`](#method.urn): `urn:uuid:A1A2A3A4-B1B2-C1C2-D1D2-D3D4D5D6D7D8`.\n/// * [`braced`](#method.braced): `{a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8}`.\n///\n/// The default representation when formatting a UUID with `Display` is\n/// hyphenated:\n///\n/// ```\n/// # use uuid::Uuid;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let my_uuid = Uuid::parse_str(\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\")?;\n///\n/// assert_eq!(\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     my_uuid.to_string(),\n/// );\n/// # Ok(())\n/// # }\n/// ```\n///\n/// Other formats can be specified using adapter methods on the UUID:\n///\n/// ```\n/// # use uuid::Uuid;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let my_uuid = Uuid::parse_str(\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\")?;\n///\n/// assert_eq!(\n///     \"urn:uuid:a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     my_uuid.urn().to_string(),\n/// );\n/// # Ok(())\n/// # }\n/// ```\n///\n/// # Endianness\n///\n/// The specification for UUIDs encodes the integer fields that make up the\n/// value in big-endian order. This crate assumes integer inputs are already in\n/// the correct order by default, regardless of the endianness of the\n/// environment. Most methods that accept integers have a `_le` variant (such as\n/// `from_fields_le`) that assumes any integer values will need to have their\n/// bytes flipped, regardless of the endianness of the environment.\n///\n/// Most users won't need to worry about endianness unless they need to operate\n/// on individual fields (such as when converting between Microsoft GUIDs). The\n/// important things to remember are:\n///\n/// - The endianness is in terms of the fields of the UUID, not the environment.\n/// - The endianness is assumed to be big-endian when there's no `_le` suffix\n///   somewhere.\n/// - Byte-flipping in `_le` methods applies to each integer.\n/// - Endianness roundtrips, so if you create a UUID with `from_fields_le`\n///   you'll get the same values back out with `to_fields_le`.\n///\n/// # ABI\n///\n/// The `Uuid` type is always guaranteed to be have the same ABI as [`Bytes`].\n#[repr(transparent)]\npub struct Uuid(Bytes);","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::as_bytes":["/// Returns a slice of 16 octets containing the value.\n///\n/// This method borrows the underlying byte value of the UUID.\n///\n/// # Examples\n///\n/// ```\n/// # use uuid::Uuid;\n/// let bytes1 = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n/// let uuid1 = Uuid::from_bytes_ref(&bytes1);\n///\n/// let bytes2 = uuid1.as_bytes();\n/// let uuid2 = Uuid::from_bytes_ref(bytes2);\n///\n/// assert_eq!(uuid1, uuid2);\n///\n/// assert!(std::ptr::eq(\n///     uuid2 as *const Uuid as *const u8,\n///     &bytes1 as *const [u8; 16] as *const u8,\n/// ));\n/// ```\npub const fn as_bytes(&self) -> &Bytes{\n        &self.0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::as_fields":["/// Returns the four field values of the UUID.\n///\n/// These values can be passed to the [`Uuid::from_fields`] method to get\n/// the original `Uuid` back.\n///\n/// * The first field value represents the first group of (eight) hex\n///   digits, taken as a big-endian `u32` value.  For V1 UUIDs, this field\n///   represents the low 32 bits of the timestamp.\n/// * The second field value represents the second group of (four) hex\n///   digits, taken as a big-endian `u16` value.  For V1 UUIDs, this field\n///   represents the middle 16 bits of the timestamp.\n/// * The third field value represents the third group of (four) hex digits,\n///   taken as a big-endian `u16` value.  The 4 most significant bits give\n///   the UUID version, and for V1 UUIDs, the last 12 bits represent the\n///   high 12 bits of the timestamp.\n/// * The last field value represents the last two groups of four and twelve\n///   hex digits, taken in order.  The first 1-3 bits of this indicate the\n///   UUID variant, and for V1 UUIDs, the next 13-15 bits indicate the clock\n///   sequence and the last 48 bits indicate the node ID.\n///\n/// # Examples\n///\n/// ```\n/// # use uuid::Uuid;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::nil();\n///\n/// assert_eq!(uuid.as_fields(), (0, 0, 0, &[0u8; 8]));\n///\n/// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n///\n/// assert_eq!(\n///     uuid.as_fields(),\n///     (\n///         0xa1a2a3a4,\n///         0xb1b2,\n///         0xc1c2,\n///         &[0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8],\n///     )\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub fn as_fields(&self) -> (u32, u16, u16, &[u8; 8]){\n        let bytes = self.as_bytes();\n\n        let d1 = (bytes[0] as u32) << 24\n            | (bytes[1] as u32) << 16\n            | (bytes[2] as u32) << 8\n            | (bytes[3] as u32);\n\n        let d2 = (bytes[4] as u16) << 8 | (bytes[5] as u16);\n\n        let d3 = (bytes[6] as u16) << 8 | (bytes[7] as u16);\n\n        let d4: &[u8; 8] = convert::TryInto::try_into(&bytes[8..16]).unwrap();\n        (d1, d2, d3, d4)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::as_u128":["/// Returns a 128bit value containing the value.\n///\n/// The bytes in the UUID will be packed directly into a `u128`.\n///\n/// # Examples\n///\n/// ```\n/// # use uuid::Uuid;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n///\n/// assert_eq!(\n///     uuid.as_u128(),\n///     0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8,\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub const fn as_u128(&self) -> u128{\n        u128::from_be_bytes(*self.as_bytes())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::as_u64_pair":["/// Returns two 64bit values containing the value.\n///\n/// The bytes in the UUID will be split into two `u64`.\n/// The first u64 represents the 64 most significant bits,\n/// the second one represents the 64 least significant.\n///\n/// # Examples\n///\n/// ```\n/// # use uuid::Uuid;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n/// assert_eq!(\n///     uuid.as_u64_pair(),\n///     (0xa1a2a3a4b1b2c1c2, 0xd1d2d3d4d5d6d7d8),\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub const fn as_u64_pair(&self) -> (u64, u64){\n        let value = self.as_u128();\n        ((value >> 64) as u64, value as u64)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::encode_buffer":["/// A buffer that can be used for `encode_...` calls, that is\n/// guaranteed to be long enough for any of the format adapters.\n///\n/// # Examples\n///\n/// ```\n/// # use uuid::Uuid;\n/// let uuid = Uuid::nil();\n///\n/// assert_eq!(\n///     uuid.simple().encode_lower(&mut Uuid::encode_buffer()),\n///     \"00000000000000000000000000000000\"\n/// );\n///\n/// assert_eq!(\n///     uuid.hyphenated()\n///         .encode_lower(&mut Uuid::encode_buffer()),\n///     \"00000000-0000-0000-0000-000000000000\"\n/// );\n///\n/// assert_eq!(\n///     uuid.urn().encode_lower(&mut Uuid::encode_buffer()),\n///     \"urn:uuid:00000000-0000-0000-0000-000000000000\"\n/// );\n/// ```\npub const fn encode_buffer() -> [u8; fmt::Urn::LENGTH]{\n        [0; fmt::Urn::LENGTH]\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::get_timestamp":["/// If the UUID is the correct version (v1, v6, or v7) this will return\n/// the timestamp and counter portion parsed from a V1 UUID.\n///\n/// Returns `None` if the supplied UUID is not V1.\n///\n/// The V1 timestamp format defined in RFC4122 specifies a 60-bit\n/// integer representing the number of 100-nanosecond intervals\n/// since 00:00:00.00, 15 Oct 1582.\n///\n/// [`Timestamp`] offers several options for converting the raw RFC4122\n/// value into more commonly-used formats, such as a unix timestamp.\n///\n/// # Roundtripping\n///\n/// This method is unlikely to roundtrip a timestamp in a UUID due to the way\n/// UUIDs encode timestamps. The timestamp returned from this method will be truncated to\n/// 100ns precision for version 1 and 6 UUIDs, and to millisecond precision for version 7 UUIDs.\n///\n/// [`Timestamp`]: v1/struct.Timestamp.html\npub const fn get_timestamp(&self) -> Option<Timestamp>{\n        match self.get_version() {\n            Some(Version::Mac) => {\n                let (ticks, counter) = timestamp::decode_rfc4122_timestamp(self);\n\n                Some(Timestamp::from_rfc4122(ticks, counter))\n            }\n            #[cfg(uuid_unstable)]\n            Some(Version::SortMac) => {\n                let (ticks, counter) = timestamp::decode_sorted_rfc4122_timestamp(self);\n\n                Some(Timestamp::from_rfc4122(ticks, counter))\n            }\n            #[cfg(uuid_unstable)]\n            Some(Version::SortRand) => {\n                let millis = timestamp::decode_unix_timestamp_millis(self);\n\n                let seconds = millis / 1000;\n                let nanos = ((millis % 1000) * 1_000_000) as u32;\n\n                Some(Timestamp {\n                    seconds,\n                    nanos,\n                    #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n                    counter: 0,\n                })\n            }\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::get_variant":["/// Returns the variant of the UUID structure.\n///\n/// This determines the interpretation of the structure of the UUID.\n/// This method simply reads the value of the variant byte. It doesn't\n/// validate the rest of the UUID as conforming to that variant.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::{Uuid, Variant};\n/// # fn main() -> Result<(), uuid::Error> {\n/// let my_uuid = Uuid::parse_str(\"02f09a3f-1624-3b1d-8409-44eff7708208\")?;\n///\n/// assert_eq!(Variant::RFC4122, my_uuid.get_variant());\n/// # Ok(())\n/// # }\n/// ```\n///\n/// # References\n///\n/// * [Variant in RFC4122](http://tools.ietf.org/html/rfc4122#section-4.1.1)\npub const fn get_variant(&self) -> Variant{\n        match self.as_bytes()[8] {\n            x if x & 0x80 == 0x00 => Variant::NCS,\n            x if x & 0xc0 == 0x80 => Variant::RFC4122,\n            x if x & 0xe0 == 0xc0 => Variant::Microsoft,\n            x if x & 0xe0 == 0xe0 => Variant::Future,\n            // The above match arms are actually exhaustive\n            // We just return `Future` here because we can't\n            // use `unreachable!()` in a `const fn`\n            _ => Variant::Future,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::get_version":["/// Returns the version of the UUID.\n///\n/// This represents the algorithm used to generate the value.\n/// If the version field doesn't contain a recognized version then `None`\n/// is returned. If you're trying to read the version for a future extension\n/// you can also use [`Uuid::get_version_num`] to unconditionally return a\n/// number. Future extensions may start to return `Some` once they're\n/// standardized and supported.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::{Uuid, Version};\n/// # fn main() -> Result<(), uuid::Error> {\n/// let my_uuid = Uuid::parse_str(\"02f09a3f-1624-3b1d-8409-44eff7708208\")?;\n///\n/// assert_eq!(Some(Version::Md5), my_uuid.get_version());\n/// # Ok(())\n/// # }\n/// ```\n///\n/// # References\n///\n/// * [Version in RFC4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.3)\npub const fn get_version(&self) -> Option<Version>{\n        match self.get_version_num() {\n            0 if self.is_nil() => Some(Version::Nil),\n            1 => Some(Version::Mac),\n            2 => Some(Version::Dce),\n            3 => Some(Version::Md5),\n            4 => Some(Version::Random),\n            5 => Some(Version::Sha1),\n            #[cfg(uuid_unstable)]\n            6 => Some(Version::SortMac),\n            #[cfg(uuid_unstable)]\n            7 => Some(Version::SortRand),\n            #[cfg(uuid_unstable)]\n            8 => Some(Version::Custom),\n            #[cfg(uuid_unstable)]\n            0xf => Some(Version::Max),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::get_version_num":["/// Returns the version number of the UUID.\n///\n/// This represents the algorithm used to generate the value.\n/// This method is the future-proof alternative to [`Uuid::get_version`].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Uuid;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let my_uuid = Uuid::parse_str(\"02f09a3f-1624-3b1d-8409-44eff7708208\")?;\n///\n/// assert_eq!(3, my_uuid.get_version_num());\n/// # Ok(())\n/// # }\n/// ```\n///\n/// # References\n///\n/// * [Version in RFC4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.3)\npub const fn get_version_num(&self) -> usize{\n        (self.as_bytes()[6] >> 4) as usize\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::into_bytes":["/// Consumes self and returns the underlying byte value of the UUID.\n///\n/// # Examples\n///\n/// ```\n/// # use uuid::Uuid;\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n/// let uuid = Uuid::from_bytes(bytes);\n/// assert_eq!(bytes, uuid.into_bytes());\n/// ```\npub const fn into_bytes(self) -> Bytes{\n        self.0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::is_nil":["/// Tests if the UUID is nil (all zeros).\npub const fn is_nil(&self) -> bool{\n        self.as_u128() == u128::MIN\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::to_bytes_le":["/// Returns the bytes of the UUID in little-endian order.\n///\n/// The bytes will be flipped to convert into little-endian order. This is\n/// based on the endianness of the UUID, rather than the target environment\n/// so bytes will be flipped on both big and little endian machines.\n///\n/// # Examples\n///\n/// ```\n/// use uuid::Uuid;\n///\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n///\n/// assert_eq!(\n///     uuid.to_bytes_le(),\n///     ([\n///         0xa4, 0xa3, 0xa2, 0xa1, 0xb2, 0xb1, 0xc2, 0xc1, 0xd1, 0xd2,\n///         0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8\n///     ])\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub const fn to_bytes_le(&self) -> Bytes{\n        [\n            self.0[3], self.0[2], self.0[1], self.0[0], self.0[5], self.0[4], self.0[7], self.0[6],\n            self.0[8], self.0[9], self.0[10], self.0[11], self.0[12], self.0[13], self.0[14],\n            self.0[15],\n        ]\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::to_fields_le":["/// Returns the four field values of the UUID in little-endian order.\n///\n/// The bytes in the returned integer fields will be converted from\n/// big-endian order. This is based on the endianness of the UUID,\n/// rather than the target environment so bytes will be flipped on both\n/// big and little endian machines.\n///\n/// # Examples\n///\n/// ```\n/// use uuid::Uuid;\n///\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n///\n/// assert_eq!(\n///     uuid.to_fields_le(),\n///     (\n///         0xa4a3a2a1,\n///         0xb2b1,\n///         0xc2c1,\n///         &[0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8],\n///     )\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub fn to_fields_le(&self) -> (u32, u16, u16, &[u8; 8]){\n        let d1 = (self.as_bytes()[0] as u32)\n            | (self.as_bytes()[1] as u32) << 8\n            | (self.as_bytes()[2] as u32) << 16\n            | (self.as_bytes()[3] as u32) << 24;\n\n        let d2 = (self.as_bytes()[4] as u16) | (self.as_bytes()[5] as u16) << 8;\n\n        let d3 = (self.as_bytes()[6] as u16) | (self.as_bytes()[7] as u16) << 8;\n\n        let d4: &[u8; 8] = convert::TryInto::try_into(&self.as_bytes()[8..16]).unwrap();\n        (d1, d2, d3, d4)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Uuid::to_u128_le":["/// Returns a 128bit little-endian value containing the value.\n///\n/// The bytes in the `u128` will be flipped to convert into big-endian\n/// order. This is based on the endianness of the UUID, rather than the\n/// target environment so bytes will be flipped on both big and little\n/// endian machines.\n///\n/// Note that this will produce a different result than\n/// [`Uuid::to_fields_le`], because the entire UUID is reversed, rather\n/// than reversing the individual fields in-place.\n///\n/// # Examples\n///\n/// ```\n/// # use uuid::Uuid;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::parse_str(\"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\")?;\n///\n/// assert_eq!(\n///     uuid.to_u128_le(),\n///     0xd8d7d6d5d4d3d2d1c2c1b2b1a4a3a2a1,\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub const fn to_u128_le(&self) -> u128{\n        u128::from_le_bytes(*self.as_bytes())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Variant":["/// The reserved variants of UUIDs.\n///\n/// # References\n///\n/// * [Variant in RFC4122](http://tools.ietf.org/html/rfc4122#section-4.1.1)\n#[non_exhaustive]\n#[repr(u8)]\npub enum Variant {\n    /// Reserved by the NCS for backward compatibility.\n    NCS = 0u8,\n    /// As described in the RFC4122 Specification (default).\n    RFC4122,\n    /// Reserved by Microsoft for backward compatibility.\n    Microsoft,\n    /// Reserved for future expansion.\n    Future,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Version":["/// The version of the UUID, denoting the generating algorithm.\n///\n/// # References\n///\n/// * [Version in RFC4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.3)\n#[non_exhaustive]\n#[repr(u8)]\npub enum Version {\n    /// The \"nil\" (all zeros) UUID.\n    Nil = 0u8,\n    /// Version 1: Timestamp and node ID.\n    Mac = 1,\n    /// Version 2: DCE Security.\n    Dce = 2,\n    /// Version 3: MD5 hash.\n    Md5 = 3,\n    /// Version 4: Random.\n    Random = 4,\n    /// Version 5: SHA-1 hash.\n    Sha1 = 5,\n    /// Version 6: Sortable Timestamp and node ID.\n    #[cfg(uuid_unstable)]\n    SortMac = 6,\n    /// Version 7: Timestamp and random.\n    #[cfg(uuid_unstable)]\n    SortRand = 7,\n    /// Version 8: Custom.\n    #[cfg(uuid_unstable)]\n    Custom = 8,\n    /// The \"max\" (all ones) UUID.\n    #[cfg(uuid_unstable)]\n    Max = 0xff,\n}","Real(LocalPath(\"src/lib.rs\"))"],"builder::<impl Uuid>::from_bytes":["/// Creates a UUID using the supplied bytes.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # fn main() -> Result<(), uuid::Error> {\n/// # use uuid::Uuid;\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Uuid::from_bytes(bytes);\n///\n/// assert_eq!(\n///     uuid.hyphenated().to_string(),\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\"\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub const fn from_bytes(bytes: Bytes) -> Uuid{\n        Uuid(bytes)\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_bytes_le":["/// Creates a UUID using the supplied bytes in little endian order.\n///\n/// The individual fields encoded in the buffer will be flipped.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # fn main() -> Result<(), uuid::Error> {\n/// # use uuid::Uuid;\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Uuid::from_bytes_le(bytes);\n///\n/// assert_eq!(\n///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub const fn from_bytes_le(b: Bytes) -> Uuid{\n        Uuid([\n            b[3], b[2], b[1], b[0], b[5], b[4], b[7], b[6], b[8], b[9], b[10], b[11], b[12], b[13],\n            b[14], b[15],\n        ])\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_bytes_ref":["/// Creates a reference to a UUID from a reference to the supplied bytes.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # fn main() -> Result<(), uuid::Error> {\n/// # use uuid::Uuid;\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Uuid::from_bytes_ref(&bytes);\n///\n/// assert_eq!(\n///     uuid.hyphenated().to_string(),\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\"\n/// );\n///\n/// assert!(std::ptr::eq(\n///     uuid as *const Uuid as *const u8,\n///     &bytes as *const [u8; 16] as *const u8,\n/// ));\n/// # Ok(())\n/// # }\n/// ```\npub fn from_bytes_ref(bytes: &Bytes) -> &Uuid{\n        // SAFETY: `Bytes` and `Uuid` have the same ABI\n        unsafe { &*(bytes as *const Bytes as *const Uuid) }\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_fields":["/// Creates a UUID from four field values.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Uuid;\n/// let d1 = 0xa1a2a3a4;\n/// let d2 = 0xb1b2;\n/// let d3 = 0xc1c2;\n/// let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n///\n/// let uuid = Uuid::from_fields(d1, d2, d3, &d4);\n///\n/// assert_eq!(\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Uuid{\n        Uuid::from_bytes([\n            (d1 >> 24) as u8,\n            (d1 >> 16) as u8,\n            (d1 >> 8) as u8,\n            d1 as u8,\n            (d2 >> 8) as u8,\n            d2 as u8,\n            (d3 >> 8) as u8,\n            d3 as u8,\n            d4[0],\n            d4[1],\n            d4[2],\n            d4[3],\n            d4[4],\n            d4[5],\n            d4[6],\n            d4[7],\n        ])\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_fields_le":["/// Creates a UUID from four field values in little-endian order.\n///\n/// The bytes in the `d1`, `d2` and `d3` fields will be flipped to convert\n/// into big-endian order. This is based on the endianness of the UUID,\n/// rather than the target environment so bytes will be flipped on both\n/// big and little endian machines.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Uuid;\n/// let d1 = 0xa1a2a3a4;\n/// let d2 = 0xb1b2;\n/// let d3 = 0xc1c2;\n/// let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n///\n/// let uuid = Uuid::from_fields_le(d1, d2, d3, &d4);\n///\n/// assert_eq!(\n///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn from_fields_le(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Uuid{\n        Uuid::from_bytes([\n            d1 as u8,\n            (d1 >> 8) as u8,\n            (d1 >> 16) as u8,\n            (d1 >> 24) as u8,\n            (d2) as u8,\n            (d2 >> 8) as u8,\n            d3 as u8,\n            (d3 >> 8) as u8,\n            d4[0],\n            d4[1],\n            d4[2],\n            d4[3],\n            d4[4],\n            d4[5],\n            d4[6],\n            d4[7],\n        ])\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_slice":["/// Creates a UUID using the supplied bytes.\n///\n/// # Errors\n///\n/// This function will return an error if `b` has any length other than 16.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # fn main() -> Result<(), uuid::Error> {\n/// # use uuid::Uuid;\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Uuid::from_slice(&bytes)?;\n///\n/// assert_eq!(\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub fn from_slice(b: &[u8]) -> Result<Uuid, Error>{\n        if b.len() != 16 {\n            return Err(Error(ErrorKind::ByteLength { len: b.len() }));\n        }\n\n        let mut bytes: Bytes = [0; 16];\n        bytes.copy_from_slice(b);\n        Ok(Uuid::from_bytes(bytes))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_slice_le":["/// Creates a UUID using the supplied bytes in little endian order.\n///\n/// The individual fields encoded in the buffer will be flipped.\n///\n/// # Errors\n///\n/// This function will return an error if `b` has any length other than 16.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # fn main() -> Result<(), uuid::Error> {\n/// # use uuid::Uuid;\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Uuid::from_slice_le(&bytes)?;\n///\n/// assert_eq!(\n///     uuid.hyphenated().to_string(),\n///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\"\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub fn from_slice_le(b: &[u8]) -> Result<Uuid, Error>{\n        if b.len() != 16 {\n            return Err(Error(ErrorKind::ByteLength { len: b.len() }));\n        }\n\n        let mut bytes: Bytes = [0; 16];\n        bytes.copy_from_slice(b);\n        Ok(Uuid::from_bytes_le(bytes))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_u128":["/// Creates a UUID from a 128bit value.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Uuid;\n/// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n///\n/// let uuid = Uuid::from_u128(v);\n///\n/// assert_eq!(\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn from_u128(v: u128) -> Self{\n        Uuid::from_bytes([\n            (v >> 120) as u8,\n            (v >> 112) as u8,\n            (v >> 104) as u8,\n            (v >> 96) as u8,\n            (v >> 88) as u8,\n            (v >> 80) as u8,\n            (v >> 72) as u8,\n            (v >> 64) as u8,\n            (v >> 56) as u8,\n            (v >> 48) as u8,\n            (v >> 40) as u8,\n            (v >> 32) as u8,\n            (v >> 24) as u8,\n            (v >> 16) as u8,\n            (v >> 8) as u8,\n            v as u8,\n        ])\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_u128_le":["/// Creates a UUID from a 128bit value in little-endian order.\n///\n/// The entire value will be flipped to convert into big-endian order.\n/// This is based on the endianness of the UUID, rather than the target\n/// environment so bytes will be flipped on both big and little endian\n/// machines.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Uuid;\n/// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n///\n/// let uuid = Uuid::from_u128_le(v);\n///\n/// assert_eq!(\n///     \"d8d7d6d5-d4d3-d2d1-c2c1-b2b1a4a3a2a1\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn from_u128_le(v: u128) -> Self{\n        Uuid::from_bytes([\n            v as u8,\n            (v >> 8) as u8,\n            (v >> 16) as u8,\n            (v >> 24) as u8,\n            (v >> 32) as u8,\n            (v >> 40) as u8,\n            (v >> 48) as u8,\n            (v >> 56) as u8,\n            (v >> 64) as u8,\n            (v >> 72) as u8,\n            (v >> 80) as u8,\n            (v >> 88) as u8,\n            (v >> 96) as u8,\n            (v >> 104) as u8,\n            (v >> 112) as u8,\n            (v >> 120) as u8,\n        ])\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::from_u64_pair":["/// Creates a UUID from two 64bit values.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Uuid;\n/// let hi = 0xa1a2a3a4b1b2c1c2u64;\n/// let lo = 0xd1d2d3d4d5d6d7d8u64;\n///\n/// let uuid = Uuid::from_u64_pair(hi, lo);\n///\n/// assert_eq!(\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn from_u64_pair(high_bits: u64, low_bits: u64) -> Self{\n        Uuid::from_bytes([\n            (high_bits >> 56) as u8,\n            (high_bits >> 48) as u8,\n            (high_bits >> 40) as u8,\n            (high_bits >> 32) as u8,\n            (high_bits >> 24) as u8,\n            (high_bits >> 16) as u8,\n            (high_bits >> 8) as u8,\n            high_bits as u8,\n            (low_bits >> 56) as u8,\n            (low_bits >> 48) as u8,\n            (low_bits >> 40) as u8,\n            (low_bits >> 32) as u8,\n            (low_bits >> 24) as u8,\n            (low_bits >> 16) as u8,\n            (low_bits >> 8) as u8,\n            low_bits as u8,\n        ])\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::<impl Uuid>::nil":["/// The 'nil UUID' (all zeros).\n///\n/// The nil UUID is a special form of UUID that is specified to have all\n/// 128 bits set to zero.\n///\n/// # References\n///\n/// * [Nil UUID in RFC4122](https://tools.ietf.org/html/rfc4122.html#section-4.1.7)\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Uuid;\n/// let uuid = Uuid::nil();\n///\n/// assert_eq!(\n///     \"00000000-0000-0000-0000-000000000000\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn nil() -> Self{\n        Uuid::from_bytes([0; 16])\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder":["/// A builder for creating a UUID.\n///\n/// This type is useful if you need to mutate individual fields of a [`Uuid`]\n/// while constructing it. Since the [`Uuid`] type is `Copy`, it doesn't offer\n/// any methods to mutate in place. They live on the `Builder` instead.\n///\n/// The `Builder` type also always exposes APIs to construct [`Uuid`]s for any\n/// version without needing crate features or additional dependencies. It's a\n/// lower-level API than the methods on [`Uuid`].\n///\n/// # Examples\n///\n/// Creating a version 4 UUID from externally generated random bytes:\n///\n/// ```\n/// # use uuid::{Builder, Version, Variant};\n/// # let rng = || [\n/// #     70, 235, 208, 238, 14, 109, 67, 201, 185, 13, 204, 195, 90,\n/// # 145, 63, 62,\n/// # ];\n/// let random_bytes = rng();\n///\n/// let uuid = Builder::from_random_bytes(random_bytes).into_uuid();\n///\n/// assert_eq!(Some(Version::Random), uuid.get_version());\n/// assert_eq!(Variant::RFC4122, uuid.get_variant());\n/// ```\n#[allow(missing_copy_implementations)]\npub struct Builder(Uuid);","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::as_uuid":["/// Get a reference to the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// let builder = Builder::nil();\n///\n/// let uuid1 = builder.as_uuid();\n/// let uuid2 = builder.as_uuid();\n///\n/// assert_eq!(uuid1, uuid2);\n/// ```\npub const fn as_uuid(&self) -> &Uuid{\n        &self.0\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_bytes":["/// Creates a `Builder` using the supplied bytes.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Builder::from_bytes(bytes).into_uuid();\n///\n/// assert_eq!(\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn from_bytes(b: Bytes) -> Self{\n        Builder(Uuid::from_bytes(b))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_bytes_le":["/// Creates a `Builder` using the supplied bytes in little endian order.\n///\n/// The individual fields encoded in the buffer will be flipped.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # fn main() -> Result<(), uuid::Error> {\n/// # use uuid::{Builder, Uuid};\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Builder::from_bytes_le(bytes).into_uuid();\n///\n/// assert_eq!(\n///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub const fn from_bytes_le(b: Bytes) -> Self{\n        Builder(Uuid::from_bytes_le(b))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_fields":["/// Creates a `Builder` from four field values.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// let d1 = 0xa1a2a3a4;\n/// let d2 = 0xb1b2;\n/// let d3 = 0xc1c2;\n/// let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n///\n/// let uuid = Builder::from_fields(d1, d2, d3, &d4).into_uuid();\n///\n/// assert_eq!(\n///     uuid.hyphenated().to_string(),\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\"\n/// );\n/// ```\npub const fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Self{\n        Builder(Uuid::from_fields(d1, d2, d3, d4))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_fields_le":["/// Creates a `Builder` from four field values.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// let d1 = 0xa1a2a3a4;\n/// let d2 = 0xb1b2;\n/// let d3 = 0xc1c2;\n/// let d4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n///\n/// let uuid = Builder::from_fields_le(d1, d2, d3, &d4).into_uuid();\n///\n/// assert_eq!(\n///     uuid.hyphenated().to_string(),\n///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\"\n/// );\n/// ```\npub const fn from_fields_le(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Self{\n        Builder(Uuid::from_fields_le(d1, d2, d3, d4))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_md5_bytes":["/// Creates a `Builder` for a version 3 UUID using the supplied MD5 hashed bytes.\npub const fn from_md5_bytes(md5_bytes: Bytes) -> Self{\n        Builder(Uuid::from_bytes(md5_bytes))\n            .with_variant(Variant::RFC4122)\n            .with_version(Version::Md5)\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_random_bytes":["/// Creates a `Builder` for a version 4 UUID using the supplied random bytes.\n///\n/// This method assumes the bytes are already sufficiently random, it will only\n/// set the appropriate bits for the UUID version and variant.\n///\n/// # Examples\n///\n/// ```\n/// # use uuid::{Builder, Variant, Version};\n/// # let rng = || [\n/// #     70, 235, 208, 238, 14, 109, 67, 201, 185, 13, 204, 195, 90,\n/// # 145, 63, 62,\n/// # ];\n/// let random_bytes = rng();\n/// let uuid = Builder::from_random_bytes(random_bytes).into_uuid();\n///\n/// assert_eq!(Some(Version::Random), uuid.get_version());\n/// assert_eq!(Variant::RFC4122, uuid.get_variant());\n/// ```\npub const fn from_random_bytes(random_bytes: Bytes) -> Self{\n        Builder(Uuid::from_bytes(random_bytes))\n            .with_variant(Variant::RFC4122)\n            .with_version(Version::Random)\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_rfc4122_timestamp":["/// Creates a `Builder` for a version 1 UUID using the supplied timestamp and node ID.\npub const fn from_rfc4122_timestamp(ticks: u64, counter: u16, node_id: &[u8; 6]) -> Self{\n        Builder(timestamp::encode_rfc4122_timestamp(ticks, counter, node_id))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_sha1_bytes":["/// Creates a `Builder` for a version 5 UUID using the supplied SHA-1 hashed bytes.\n///\n/// This method assumes the bytes are already a SHA-1 hash, it will only set the appropriate\n/// bits for the UUID version and variant.\npub const fn from_sha1_bytes(sha1_bytes: Bytes) -> Self{\n        Builder(Uuid::from_bytes(sha1_bytes))\n            .with_variant(Variant::RFC4122)\n            .with_version(Version::Sha1)\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_slice":["/// Creates a `Builder` using the supplied bytes.\n///\n/// # Errors\n///\n/// This function will return an error if `b` has any length other than 16.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Builder::from_slice(&bytes)?.into_uuid();\n///\n/// assert_eq!(\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub fn from_slice(b: &[u8]) -> Result<Self, Error>{\n        Ok(Builder(Uuid::from_slice(b)?))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_slice_le":["/// Creates a `Builder` using the supplied bytes in little endian order.\n///\n/// The individual fields encoded in the buffer will be flipped.\n///\n/// # Errors\n///\n/// This function will return an error if `b` has any length other than 16.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// # fn main() -> Result<(), uuid::Error> {\n/// let bytes = [\n///     0xa1, 0xa2, 0xa3, 0xa4,\n///     0xb1, 0xb2,\n///     0xc1, 0xc2,\n///     0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,\n/// ];\n///\n/// let uuid = Builder::from_slice_le(&bytes)?.into_uuid();\n///\n/// assert_eq!(\n///     \"a4a3a2a1-b2b1-c2c1-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// # Ok(())\n/// # }\n/// ```\npub fn from_slice_le(b: &[u8]) -> Result<Self, Error>{\n        Ok(Builder(Uuid::from_slice_le(b)?))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_u128":["/// Creates a `Builder` from a 128bit value.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n///\n/// let uuid = Builder::from_u128(v).into_uuid();\n///\n/// assert_eq!(\n///     \"a1a2a3a4-b1b2-c1c2-d1d2-d3d4d5d6d7d8\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn from_u128(v: u128) -> Self{\n        Builder(Uuid::from_u128(v))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::from_u128_le":["/// Creates a UUID from a 128bit value in little-endian order.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// let v = 0xa1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8u128;\n///\n/// let uuid = Builder::from_u128_le(v).into_uuid();\n///\n/// assert_eq!(\n///     \"d8d7d6d5-d4d3-d2d1-c2c1-b2b1a4a3a2a1\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn from_u128_le(v: u128) -> Self{\n        Builder(Uuid::from_u128_le(v))\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::into_uuid":["/// Convert the builder into a [`Uuid`].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// let uuid = Builder::nil().into_uuid();\n///\n/// assert_eq!(\n///     uuid.hyphenated().to_string(),\n///     \"00000000-0000-0000-0000-000000000000\"\n/// );\n/// ```\npub const fn into_uuid(self) -> Uuid{\n        self.0\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::nil":["/// Creates a `Builder` with an initial [`Uuid::nil`].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// # use uuid::Builder;\n/// let uuid = Builder::nil().into_uuid();\n///\n/// assert_eq!(\n///     \"00000000-0000-0000-0000-000000000000\",\n///     uuid.hyphenated().to_string(),\n/// );\n/// ```\npub const fn nil() -> Self{\n        Builder(Uuid::nil())\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::set_variant":["/// Specifies the variant of the UUID.\npub fn set_variant(&mut self, v: Variant) -> &mut Self{\n        *self = Builder(self.0).with_variant(v);\n        self\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::set_version":["/// Specifies the version number of the UUID.\npub fn set_version(&mut self, v: Version) -> &mut Self{\n        *self = Builder(self.0).with_version(v);\n        self\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::with_variant":["/// Specifies the variant of the UUID.\npub const fn with_variant(mut self, v: Variant) -> Self{\n        let byte = (self.0).0[8];\n\n        (self.0).0[8] = match v {\n            Variant::NCS => byte & 0x7f,\n            Variant::RFC4122 => (byte & 0x3f) | 0x80,\n            Variant::Microsoft => (byte & 0x1f) | 0xc0,\n            Variant::Future => byte | 0xe0,\n        };\n\n        self\n    }","Real(LocalPath(\"src/builder.rs\"))"],"builder::Builder::with_version":["/// Specifies the version number of the UUID.\npub const fn with_version(mut self, v: Version) -> Self{\n        (self.0).0[6] = ((self.0).0[6] & 0x0f) | ((v as u8) << 4);\n\n        self\n    }","Real(LocalPath(\"src/builder.rs\"))"],"error::Error":["/// A general error that can occur when working with UUIDs.\npub struct Error(pub(crate) ErrorKind);","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorKind":["pub(crate) enum ErrorKind {\n    /// Invalid character in the [`Uuid`] string.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    Char { character: char, index: usize },\n    /// A simple [`Uuid`] didn't contain 32 characters.\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    SimpleLength { len: usize },\n    /// A byte array didn't contain 16 bytes\n    ByteLength { len: usize },\n    /// A hyphenated [`Uuid`] didn't contain 5 groups\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    GroupCount { count: usize },\n    /// A hyphenated [`Uuid`] had a group that wasn't the right length\n    ///\n    /// [`Uuid`]: ../struct.Uuid.html\n    GroupLength {\n        group: usize,\n        len: usize,\n        index: usize,\n    },\n    /// The input was not a valid UTF8 string\n    InvalidUTF8,\n    /// Some other error occurred.\n    Other,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::InvalidUuid":["/// A string that is guaranteed to fail to parse to a [`Uuid`].\n///\n/// This type acts as a lightweight error indicator, suggesting\n/// that the string cannot be parsed but offering no error\n/// details. To get details, use `InvalidUuid::into_err`.\n///\n/// [`Uuid`]: ../struct.Uuid.html\npub struct InvalidUuid<'a>(pub(crate) &'a [u8]);","Real(LocalPath(\"src/error.rs\"))"],"error::InvalidUuid::<'a>::into_err":["/// Converts the lightweight error type into detailed diagnostics.\npub fn into_err(self) -> Error{\n        // Check whether or not the input was ever actually a valid UTF8 string\n        let input_str = match std::str::from_utf8(self.0) {\n            Ok(s) => s,\n            Err(_) => return Error(ErrorKind::InvalidUTF8),\n        };\n\n        let (uuid_str, offset, simple) = match input_str.as_bytes() {\n            [b'{', s @ .., b'}'] => (s, 1, false),\n            [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] => {\n                (s, \"urn:uuid:\".len(), false)\n            }\n            s => (s, 0, true),\n        };\n\n        let mut hyphen_count = 0;\n        let mut group_bounds = [0; 4];\n\n        // SAFETY: the byte array came from a valid utf8 string,\n        // and is aligned along char boundaries.\n        let uuid_str = unsafe { std::str::from_utf8_unchecked(uuid_str) };\n\n        for (index, character) in uuid_str.char_indices() {\n            let byte = character as u8;\n            if character as u32 - byte as u32 > 0 {\n                // Multibyte char\n                return Error(ErrorKind::Char {\n                    character,\n                    index: index + offset + 1,\n                });\n            } else if byte == b'-' {\n                // While we search, also count group breaks\n                if hyphen_count < 4 {\n                    group_bounds[hyphen_count] = index;\n                }\n                hyphen_count += 1;\n            } else if !matches!(byte, b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F') {\n                // Non-hex char\n                return Error(ErrorKind::Char {\n                    character: byte as char,\n                    index: index + offset + 1,\n                });\n            }\n        }\n\n        if hyphen_count == 0 && simple {\n            // This means that we tried and failed to parse a simple uuid.\n            // Since we verified that all the characters are valid, this means\n            // that it MUST have an invalid length.\n            Error(ErrorKind::SimpleLength {\n                len: input_str.len(),\n            })\n        } else if hyphen_count != 4 {\n            // We tried to parse a hyphenated variant, but there weren't\n            // 5 groups (4 hyphen splits).\n            Error(ErrorKind::GroupCount {\n                count: hyphen_count + 1,\n            })\n        } else {\n            // There are 5 groups, one of them has an incorrect length\n            const BLOCK_STARTS: [usize; 5] = [0, 9, 14, 19, 24];\n            for i in 0..4 {\n                if group_bounds[i] != BLOCK_STARTS[i + 1] - 1 {\n                    return Error(ErrorKind::GroupLength {\n                        group: i,\n                        len: group_bounds[i] - BLOCK_STARTS[i],\n                        index: offset + BLOCK_STARTS[i] + 1,\n                    });\n                }\n            }\n\n            // The last group must be too long\n            Error(ErrorKind::GroupLength {\n                group: 4,\n                len: input_str.len() - BLOCK_STARTS[4],\n                index: offset + BLOCK_STARTS[4] + 1,\n            })\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"fmt::<impl Uuid>::as_braced":["/// Get a borrowed [`Braced`] formatter.\n#[inline]\npub fn as_braced(&self) -> &Braced{\n        // SAFETY: `Uuid` and `Braced` have the same ABI\n        unsafe { &*(self as *const Uuid as *const Braced) }\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl Uuid>::as_hyphenated":["/// Get a borrowed [`Hyphenated`] formatter.\n#[inline]\npub fn as_hyphenated(&self) -> &Hyphenated{\n        // SAFETY: `Uuid` and `Hyphenated` have the same ABI\n        unsafe { &*(self as *const Uuid as *const Hyphenated) }\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl Uuid>::as_simple":["/// Get a borrowed [`Simple`] formatter.\n#[inline]\npub fn as_simple(&self) -> &Simple{\n        // SAFETY: `Uuid` and `Simple` have the same ABI\n        unsafe { &*(self as *const Uuid as *const Simple) }\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl Uuid>::as_urn":["/// Get a borrowed [`Urn`] formatter.\n#[inline]\npub fn as_urn(&self) -> &Urn{\n        // SAFETY: `Uuid` and `Urn` have the same ABI\n        unsafe { &*(self as *const Uuid as *const Urn) }\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl Uuid>::braced":["/// Get a [`Braced`] formatter.\n#[inline]\npub const fn braced(self) -> Braced{\n        Braced(self)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl Uuid>::hyphenated":["/// Get a [`Hyphenated`] formatter.\n#[inline]\npub const fn hyphenated(self) -> Hyphenated{\n        Hyphenated(self)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl Uuid>::simple":["/// Get a [`Simple`] formatter.\n#[inline]\npub const fn simple(self) -> Simple{\n        Simple(self)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl Uuid>::urn":["/// Get a [`Urn`] formatter.\n#[inline]\npub const fn urn(self) -> Urn{\n        Urn(self)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::convert::From<fmt::Braced> for Uuid>::from":["#[inline]\nfn from(f: $T) -> Self{\n                f.into_uuid()\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::convert::From<fmt::Hyphenated> for Uuid>::from":["#[inline]\nfn from(f: $T) -> Self{\n                f.into_uuid()\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::convert::From<fmt::Simple> for Uuid>::from":["#[inline]\nfn from(f: $T) -> Self{\n                f.into_uuid()\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::convert::From<fmt::Urn> for Uuid>::from":["#[inline]\nfn from(f: $T) -> Self{\n                f.into_uuid()\n            }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::fmt::Debug for Uuid>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::LowerHex::fmt(self, f)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::fmt::Display for Uuid>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::LowerHex::fmt(self, f)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::fmt::Display for Variant>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            Variant::NCS => write!(f, \"NCS\"),\n            Variant::RFC4122 => write!(f, \"RFC4122\"),\n            Variant::Microsoft => write!(f, \"Microsoft\"),\n            Variant::Future => write!(f, \"Future\"),\n        }\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::fmt::LowerHex for Uuid>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::LowerHex::fmt(self.as_hyphenated(), f)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::<impl std::fmt::UpperHex for Uuid>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::UpperHex::fmt(self.as_hyphenated(), f)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Braced":["/// Format a [`Uuid`] as a braced hyphenated string, like\n/// `{67e55044-10b1-426f-9247-bb680e5fe0c8}`.\n#[repr(transparent)]\npub struct Braced(Uuid);","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Braced::as_uuid":["/// Get a reference to the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// let braced = Uuid::nil().braced();\n/// assert_eq!(*braced.as_uuid(), Uuid::nil());\n/// ```\npub const fn as_uuid(&self) -> &Uuid{\n        &self.0\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Braced::encode_lower":["/// Writes the [`Uuid`] as a lower-case hyphenated string surrounded by\n/// braces to `buffer`, and returns the subslice of the buffer that contains\n/// the encoded UUID.\n///\n/// This is slightly more efficient than using the formatting\n/// infrastructure as it avoids virtual calls, and may avoid\n/// double buffering.\n///\n/// [`Uuid`]: ../struct.Uuid.html\n///\n/// # Panics\n///\n/// Panics if the buffer is not large enough: it must have length at least\n/// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n/// sufficiently-large temporary buffer.\n///\n/// [`LENGTH`]: #associatedconstant.LENGTH\n/// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// fn main() -> Result<(), uuid::Error> {\n///     let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\")?;\n///\n///     // the encoded portion is returned\n///     assert_eq!(\n///         uuid.braced()\n///             .encode_lower(&mut Uuid::encode_buffer()),\n///         \"{936da01f-9abd-4d9d-80c7-02af85c822a8}\"\n///     );\n///\n///     // the buffer is mutated directly, and trailing contents remains\n///     let mut buf = [b'!'; 40];\n///     uuid.braced().encode_lower(&mut buf);\n///     assert_eq!(\n///         &buf as &[_],\n///         b\"{936da01f-9abd-4d9d-80c7-02af85c822a8}!!\" as &[_]\n///     );\n///\n///     Ok(())\n/// }\n/// ```\n/// */\n#[inline]\npub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str{\n        encode_braced(self.0.as_bytes(), buffer, false)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Braced::encode_upper":["/// Writes the [`Uuid`] as an upper-case hyphenated string surrounded by\n/// braces to `buffer`, and returns the subslice of the buffer that contains\n/// the encoded UUID.\n///\n/// This is slightly more efficient than using the formatting\n/// infrastructure as it avoids virtual calls, and may avoid\n/// double buffering.\n///\n/// [`Uuid`]: ../struct.Uuid.html\n///\n/// # Panics\n///\n/// Panics if the buffer is not large enough: it must have length at least\n/// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n/// sufficiently-large temporary buffer.\n///\n/// [`LENGTH`]: #associatedconstant.LENGTH\n/// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// fn main() -> Result<(), uuid::Error> {\n///     let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\")?;\n///\n///     // the encoded portion is returned\n///     assert_eq!(\n///         uuid.braced()\n///             .encode_upper(&mut Uuid::encode_buffer()),\n///         \"{936DA01F-9ABD-4D9D-80C7-02AF85C822A8}\"\n///     );\n///\n///     // the buffer is mutated directly, and trailing contents remains\n///     let mut buf = [b'!'; 40];\n///     uuid.braced().encode_upper(&mut buf);\n///     assert_eq!(\n///         &buf as &[_],\n///         b\"{936DA01F-9ABD-4D9D-80C7-02AF85C822A8}!!\" as &[_]\n///     );\n///\n///     Ok(())\n/// }\n/// ```\n/// */\n#[inline]\npub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str{\n        encode_braced(self.0.as_bytes(), buffer, true)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Braced::from_uuid":["/// Creates a [`Braced`] from a [`Uuid`].\n///\n/// [`Uuid`]: ../struct.Uuid.html\n/// [`Braced`]: struct.Braced.html\npub const fn from_uuid(uuid: Uuid) -> Self{\n        Braced(uuid)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Braced::into_uuid":["/// Consumes the [`Braced`], returning the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// let braced = Uuid::nil().braced();\n/// assert_eq!(braced.into_uuid(), Uuid::nil());\n/// ```\npub const fn into_uuid(self) -> Uuid{\n        self.0\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Hyphenated":["/// Format a [`Uuid`] as a hyphenated string, like\n/// `67e55044-10b1-426f-9247-bb680e5fe0c8`.\n#[repr(transparent)]\npub struct Hyphenated(Uuid);","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Hyphenated::as_uuid":["/// Get a reference to the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// let hyphenated = Uuid::nil().hyphenated();\n/// assert_eq!(*hyphenated.as_uuid(), Uuid::nil());\n/// ```\npub const fn as_uuid(&self) -> &Uuid{\n        &self.0\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Hyphenated::encode_lower":["/// Writes the [`Uuid`] as a lower-case hyphenated string to\n/// `buffer`, and returns the subslice of the buffer that contains the\n/// encoded UUID.\n///\n/// This is slightly more efficient than using the formatting\n/// infrastructure as it avoids virtual calls, and may avoid\n/// double buffering.\n///\n/// [`Uuid`]: ../struct.Uuid.html\n///\n/// # Panics\n///\n/// Panics if the buffer is not large enough: it must have length at least\n/// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n/// sufficiently-large temporary buffer.\n///\n/// [`LENGTH`]: #associatedconstant.LENGTH\n/// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// fn main() -> Result<(), uuid::Error> {\n///     let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\")?;\n///\n///     // the encoded portion is returned\n///     assert_eq!(\n///         uuid.hyphenated()\n///             .encode_lower(&mut Uuid::encode_buffer()),\n///         \"936da01f-9abd-4d9d-80c7-02af85c822a8\"\n///     );\n///\n///     // the buffer is mutated directly, and trailing contents remains\n///     let mut buf = [b'!'; 40];\n///     uuid.hyphenated().encode_lower(&mut buf);\n///     assert_eq!(\n///         &buf as &[_],\n///         b\"936da01f-9abd-4d9d-80c7-02af85c822a8!!!!\" as &[_]\n///     );\n///\n///     Ok(())\n/// }\n/// ```\n/// */\n#[inline]\npub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str{\n        encode_hyphenated(self.0.as_bytes(), buffer, false)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Hyphenated::encode_upper":["/// Writes the [`Uuid`] as an upper-case hyphenated string to\n/// `buffer`, and returns the subslice of the buffer that contains the\n/// encoded UUID.\n///\n/// This is slightly more efficient than using the formatting\n/// infrastructure as it avoids virtual calls, and may avoid\n/// double buffering.\n///\n/// [`Uuid`]: ../struct.Uuid.html\n///\n/// # Panics\n///\n/// Panics if the buffer is not large enough: it must have length at least\n/// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n/// sufficiently-large temporary buffer.\n///\n/// [`LENGTH`]: #associatedconstant.LENGTH\n/// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// fn main() -> Result<(), uuid::Error> {\n///     let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\")?;\n///\n///     // the encoded portion is returned\n///     assert_eq!(\n///         uuid.hyphenated()\n///             .encode_upper(&mut Uuid::encode_buffer()),\n///         \"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n///     );\n///\n///     // the buffer is mutated directly, and trailing contents remains\n///     let mut buf = [b'!'; 40];\n///     uuid.hyphenated().encode_upper(&mut buf);\n///     assert_eq!(\n///         &buf as &[_],\n///         b\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8!!!!\" as &[_]\n///     );\n///\n///     Ok(())\n/// }\n/// ```\n/// */\n#[inline]\npub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str{\n        encode_hyphenated(self.0.as_bytes(), buffer, true)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Hyphenated::from_uuid":["/// Creates a [`Hyphenated`] from a [`Uuid`].\n///\n/// [`Uuid`]: ../struct.Uuid.html\n/// [`Hyphenated`]: struct.Hyphenated.html\npub const fn from_uuid(uuid: Uuid) -> Self{\n        Hyphenated(uuid)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Hyphenated::into_uuid":["/// Consumes the [`Hyphenated`], returning the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// let hyphenated = Uuid::nil().hyphenated();\n/// assert_eq!(hyphenated.into_uuid(), Uuid::nil());\n/// ```\npub const fn into_uuid(self) -> Uuid{\n        self.0\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Simple":["/// Format a [`Uuid`] as a simple string, like\n/// `67e5504410b1426f9247bb680e5fe0c8`.\n#[repr(transparent)]\npub struct Simple(Uuid);","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Simple::as_uuid":["/// Get a reference to the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// let simple = Uuid::nil().simple();\n/// assert_eq!(*simple.as_uuid(), Uuid::nil());\n/// ```\npub const fn as_uuid(&self) -> &Uuid{\n        &self.0\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Simple::encode_lower":["/// Writes the [`Uuid`] as a lower-case simple string to `buffer`,\n/// and returns the subslice of the buffer that contains the encoded UUID.\n///\n/// This is slightly more efficient than using the formatting\n/// infrastructure as it avoids virtual calls, and may avoid\n/// double buffering.\n///\n/// [`Uuid`]: ../struct.Uuid.html\n///\n/// # Panics\n///\n/// Panics if the buffer is not large enough: it must have length at least\n/// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n/// sufficiently-large temporary buffer.\n///\n/// [`LENGTH`]: #associatedconstant.LENGTH\n/// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// fn main() -> Result<(), uuid::Error> {\n///     let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\")?;\n///\n///     // the encoded portion is returned\n///     assert_eq!(\n///         uuid.simple().encode_lower(&mut Uuid::encode_buffer()),\n///         \"936da01f9abd4d9d80c702af85c822a8\"\n///     );\n///\n///     // the buffer is mutated directly, and trailing contents remains\n///     let mut buf = [b'!'; 36];\n///     assert_eq!(\n///         uuid.simple().encode_lower(&mut buf),\n///         \"936da01f9abd4d9d80c702af85c822a8\"\n///     );\n///     assert_eq!(\n///         &buf as &[_],\n///         b\"936da01f9abd4d9d80c702af85c822a8!!!!\" as &[_]\n///     );\n///\n///     Ok(())\n/// }\n/// ```\n/// */\n#[inline]\npub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str{\n        encode_simple(self.0.as_bytes(), buffer, false)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Simple::encode_upper":["/// Writes the [`Uuid`] as an upper-case simple string to `buffer`,\n/// and returns the subslice of the buffer that contains the encoded UUID.\n///\n/// [`Uuid`]: ../struct.Uuid.html\n///\n/// # Panics\n///\n/// Panics if the buffer is not large enough: it must have length at least\n/// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n/// sufficiently-large temporary buffer.\n///\n/// [`LENGTH`]: #associatedconstant.LENGTH\n/// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// fn main() -> Result<(), uuid::Error> {\n///     let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\")?;\n///\n///     // the encoded portion is returned\n///     assert_eq!(\n///         uuid.simple().encode_upper(&mut Uuid::encode_buffer()),\n///         \"936DA01F9ABD4D9D80C702AF85C822A8\"\n///     );\n///\n///     // the buffer is mutated directly, and trailing contents remains\n///     let mut buf = [b'!'; 36];\n///     assert_eq!(\n///         uuid.simple().encode_upper(&mut buf),\n///         \"936DA01F9ABD4D9D80C702AF85C822A8\"\n///     );\n///     assert_eq!(\n///         &buf as &[_],\n///         b\"936DA01F9ABD4D9D80C702AF85C822A8!!!!\" as &[_]\n///     );\n///\n///     Ok(())\n/// }\n/// ```\n/// */\n#[inline]\npub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str{\n        encode_simple(self.0.as_bytes(), buffer, true)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Simple::from_uuid":["/// Creates a [`Simple`] from a [`Uuid`].\n///\n/// [`Uuid`]: ../struct.Uuid.html\n/// [`Simple`]: struct.Simple.html\npub const fn from_uuid(uuid: Uuid) -> Self{\n        Simple(uuid)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Simple::into_uuid":["/// Consumes the [`Simple`], returning the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// let simple = Uuid::nil().simple();\n/// assert_eq!(simple.into_uuid(), Uuid::nil());\n/// ```\npub const fn into_uuid(self) -> Uuid{\n        self.0\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Urn":["/// Format a [`Uuid`] as a URN string, like\n/// `urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8`.\n#[repr(transparent)]\npub struct Urn(Uuid);","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Urn::as_uuid":["/// Get a reference to the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// let urn = Uuid::nil().urn();\n/// assert_eq!(*urn.as_uuid(), Uuid::nil());\n/// ```\npub const fn as_uuid(&self) -> &Uuid{\n        &self.0\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Urn::encode_lower":["/// Writes the [`Uuid`] as a lower-case URN string to\n/// `buffer`, and returns the subslice of the buffer that contains the\n/// encoded UUID.\n///\n/// This is slightly more efficient than using the formatting\n/// infrastructure as it avoids virtual calls, and may avoid\n/// double buffering.\n///\n/// [`Uuid`]: ../struct.Uuid.html\n///\n/// # Panics\n///\n/// Panics if the buffer is not large enough: it must have length at least\n/// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n/// sufficiently-large temporary buffer.\n///\n/// [`LENGTH`]: #associatedconstant.LENGTH\n/// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// fn main() -> Result<(), uuid::Error> {\n///     let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\")?;\n///\n///     // the encoded portion is returned\n///     assert_eq!(\n///         uuid.urn().encode_lower(&mut Uuid::encode_buffer()),\n///         \"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8\"\n///     );\n///\n///     // the buffer is mutated directly, and trailing contents remains\n///     let mut buf = [b'!'; 49];\n///     uuid.urn().encode_lower(&mut buf);\n///     assert_eq!(\n///         uuid.urn().encode_lower(&mut buf),\n///         \"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8\"\n///     );\n///     assert_eq!(\n///         &buf as &[_],\n///         b\"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8!!!!\" as &[_]\n///     );\n///     \n///     Ok(())\n/// }\n/// ```\n/// */\n#[inline]\npub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str{\n        encode_urn(self.0.as_bytes(), buffer, false)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Urn::encode_upper":["/// Writes the [`Uuid`] as an upper-case URN string to\n/// `buffer`, and returns the subslice of the buffer that contains the\n/// encoded UUID.\n///\n/// This is slightly more efficient than using the formatting\n/// infrastructure as it avoids virtual calls, and may avoid\n/// double buffering.\n///\n/// [`Uuid`]: ../struct.Uuid.html\n///\n/// # Panics\n///\n/// Panics if the buffer is not large enough: it must have length at least\n/// [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n/// sufficiently-large temporary buffer.\n///\n/// [`LENGTH`]: #associatedconstant.LENGTH\n/// [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// fn main() -> Result<(), uuid::Error> {\n///     let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\")?;\n///\n///     // the encoded portion is returned\n///     assert_eq!(\n///         uuid.urn().encode_upper(&mut Uuid::encode_buffer()),\n///         \"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n///     );\n///\n///     // the buffer is mutated directly, and trailing contents remains\n///     let mut buf = [b'!'; 49];\n///     assert_eq!(\n///         uuid.urn().encode_upper(&mut buf),\n///         \"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n///     );\n///     assert_eq!(\n///         &buf as &[_],\n///         b\"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8!!!!\" as &[_]\n///     );\n///\n///     Ok(())\n/// }\n/// ```\n/// */\n#[inline]\npub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str{\n        encode_urn(self.0.as_bytes(), buffer, true)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Urn::from_uuid":["/// Creates a [`Urn`] from a [`Uuid`].\n///\n/// [`Uuid`]: ../struct.Uuid.html\n/// [`Urn`]: struct.Urn.html\npub const fn from_uuid(uuid: Uuid) -> Self{\n        Urn(uuid)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Urn::into_uuid":["/// Consumes the [`Urn`], returning the underlying [`Uuid`].\n///\n/// # Examples\n///\n/// ```rust\n/// use uuid::Uuid;\n///\n/// let urn = Uuid::nil().urn();\n/// assert_eq!(urn.into_uuid(), Uuid::nil());\n/// ```\npub const fn into_uuid(self) -> Uuid{\n        self.0\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::encode_braced":["#[inline]\nfn encode_braced<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str{\n    let buf = &mut buffer[..Braced::LENGTH];\n    buf[0] = b'{';\n    buf[Braced::LENGTH - 1] = b'}';\n\n    // SAFETY: `buf` is guaranteed to be at least `LEN` bytes\n    // SAFETY: The encoded buffer is ASCII encoded\n    unsafe {\n        let dst = buf.as_mut_ptr().add(1);\n\n        ptr::write(dst.cast(), format_hyphenated(src, upper));\n        str::from_utf8_unchecked_mut(buf)\n    }\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::encode_hyphenated":["#[inline]\nfn encode_hyphenated<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str{\n    let buf = &mut buffer[..Hyphenated::LENGTH];\n    let dst = buf.as_mut_ptr();\n\n    // SAFETY: `buf` is guaranteed to be at least `LEN` bytes\n    // SAFETY: The encoded buffer is ASCII encoded\n    unsafe {\n        ptr::write(dst.cast(), format_hyphenated(src, upper));\n        str::from_utf8_unchecked_mut(buf)\n    }\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::encode_simple":["#[inline]\nfn encode_simple<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str{\n    let buf = &mut buffer[..Simple::LENGTH];\n    let dst = buf.as_mut_ptr();\n\n    // SAFETY: `buf` is guaranteed to be at least `LEN` bytes\n    // SAFETY: The encoded buffer is ASCII encoded\n    unsafe {\n        ptr::write(dst.cast(), format_simple(src, upper));\n        str::from_utf8_unchecked_mut(buf)\n    }\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::encode_urn":["#[inline]\nfn encode_urn<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str{\n    let buf = &mut buffer[..Urn::LENGTH];\n    buf[..9].copy_from_slice(b\"urn:uuid:\");\n\n    // SAFETY: `buf` is guaranteed to be at least `LEN` bytes\n    // SAFETY: The encoded buffer is ASCII encoded\n    unsafe {\n        let dst = buf.as_mut_ptr().add(9);\n\n        ptr::write(dst.cast(), format_hyphenated(src, upper));\n        str::from_utf8_unchecked_mut(buf)\n    }\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::format_hyphenated":["#[inline]\nconst fn format_hyphenated(src: &[u8; 16], upper: bool) -> [u8; 36]{\n    let lut = if upper { &UPPER } else { &LOWER };\n    let groups = [(0, 8), (9, 13), (14, 18), (19, 23), (24, 36)];\n    let mut dst = [0; 36];\n\n    let mut group_idx = 0;\n    let mut i = 0;\n    while group_idx < 5 {\n        let (start, end) = groups[group_idx];\n        let mut j = start;\n        while j < end {\n            let x = src[i];\n            i += 1;\n\n            dst[j] = lut[(x >> 4) as usize];\n            dst[j + 1] = lut[(x & 0x0f) as usize];\n            j += 2;\n        }\n        if group_idx < 4 {\n            dst[end] = b'-';\n        }\n        group_idx += 1;\n    }\n    dst\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::format_simple":["#[inline]\nconst fn format_simple(src: &[u8; 16], upper: bool) -> [u8; 32]{\n    let lut = if upper { &UPPER } else { &LOWER };\n    let mut dst = [0; 32];\n    let mut i = 0;\n    while i < 16 {\n        let x = src[i];\n        dst[i * 2] = lut[(x >> 4) as usize];\n        dst[i * 2 + 1] = lut[(x & 0x0f) as usize];\n        i += 1;\n    }\n    dst\n}","Real(LocalPath(\"src/fmt.rs\"))"],"parser::<impl Uuid>::parse_str":["/// Parses a `Uuid` from a string of hexadecimal digits with optional\n/// hyphens.\n///\n/// Any of the formats generated by this module (simple, hyphenated, urn,\n/// Microsoft GUID) are supported by this parsing function.\n///\n/// Prefer [`try_parse`] unless you need detailed user-facing diagnostics.\n/// This method will be eventually deprecated in favor of `try_parse`.\n///\n/// # Examples\n///\n/// Parse a hyphenated UUID:\n///\n/// ```\n/// # use uuid::{Uuid, Version, Variant};\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::parse_str(\"550e8400-e29b-41d4-a716-446655440000\")?;\n///\n/// assert_eq!(Some(Version::Random), uuid.get_version());\n/// assert_eq!(Variant::RFC4122, uuid.get_variant());\n/// # Ok(())\n/// # }\n/// ```\n///\n/// [`try_parse`]: #method.try_parse\npub fn parse_str(input: &str) -> Result<Uuid, Error>{\n        try_parse(input.as_bytes())\n            .map(Uuid::from_bytes)\n            .map_err(InvalidUuid::into_err)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::<impl Uuid>::try_parse":["/// Parses a `Uuid` from a string of hexadecimal digits with optional\n/// hyphens.\n///\n/// This function is similar to [`parse_str`], in fact `parse_str` shares\n/// the same underlying parser. The difference is that if `try_parse`\n/// fails, it won't generate very useful error messages. The `parse_str`\n/// function will eventually be deprecated in favor or `try_parse`.\n///\n/// To parse a UUID from a byte stream instead of a UTF8 string, see\n/// [`try_parse_ascii`].\n///\n/// # Examples\n///\n/// Parse a hyphenated UUID:\n///\n/// ```\n/// # use uuid::{Uuid, Version, Variant};\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::try_parse(\"550e8400-e29b-41d4-a716-446655440000\")?;\n///\n/// assert_eq!(Some(Version::Random), uuid.get_version());\n/// assert_eq!(Variant::RFC4122, uuid.get_variant());\n/// # Ok(())\n/// # }\n/// ```\n///\n/// [`parse_str`]: #method.parse_str\n/// [`try_parse_ascii`]: #method.try_parse_ascii\npub const fn try_parse(input: &str) -> Result<Uuid, Error>{\n        Self::try_parse_ascii(input.as_bytes())\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::<impl Uuid>::try_parse_ascii":["/// Parses a `Uuid` from a string of hexadecimal digits with optional\n/// hyphens.\n///\n/// The input is expected to be a string of ASCII characters. This method\n/// can be more convenient than [`try_parse`] if the UUID is being\n/// parsed from a byte stream instead of from a UTF8 string.\n///\n/// # Examples\n///\n/// Parse a hyphenated UUID:\n///\n/// ```\n/// # use uuid::{Uuid, Version, Variant};\n/// # fn main() -> Result<(), uuid::Error> {\n/// let uuid = Uuid::try_parse_ascii(b\"550e8400-e29b-41d4-a716-446655440000\")?;\n///\n/// assert_eq!(Some(Version::Random), uuid.get_version());\n/// assert_eq!(Variant::RFC4122, uuid.get_variant());\n/// # Ok(())\n/// # }\n/// ```\n///\n/// [`try_parse`]: #method.try_parse\npub const fn try_parse_ascii(input: &[u8]) -> Result<Uuid, Error>{\n        match try_parse(input) {\n            Ok(bytes) => Ok(Uuid::from_bytes(bytes)),\n            // If parsing fails then we don't know exactly what went wrong\n            // In this case, we just return a generic error\n            Err(_) => Err(Error(ErrorKind::Other)),\n        }\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::<impl std::convert::TryFrom<&str> for Uuid>::try_from":["fn try_from(uuid_str: &'_ str) -> Result<Self, Self::Error>{\n        Uuid::parse_str(uuid_str)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::<impl std::str::FromStr for Uuid>::from_str":["fn from_str(uuid_str: &str) -> Result<Self, Self::Err>{\n        Uuid::parse_str(uuid_str)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::parse_hyphenated":["#[inline]\nconst fn parse_hyphenated(s: &[u8]) -> Result<[u8; 16], ()>{\n    // This length check here removes all other bounds\n    // checks in this function\n    if s.len() != 36 {\n        return Err(());\n    }\n\n    // We look at two hex-encoded values (4 chars) at a time because\n    // that's the size of the smallest group in a hyphenated UUID.\n    // The indexes we're interested in are:\n    //\n    // uuid     : 936da01f-9abd-4d9d-80c7-02af85c822a8\n    //            |   |   ||   ||   ||   ||   |   |\n    // hyphens  : |   |   8|  13|  18|  23|   |   |\n    // positions: 0   4    9   14   19   24  28  32\n\n    // First, ensure the hyphens appear in the right places\n    match [s[8], s[13], s[18], s[23]] {\n        [b'-', b'-', b'-', b'-'] => {}\n        _ => return Err(()),\n    }\n\n    let positions: [u8; 8] = [0, 4, 9, 14, 19, 24, 28, 32];\n    let mut buf: [u8; 16] = [0; 16];\n    let mut j = 0;\n\n    while j < 8 {\n        let i = positions[j];\n\n        // The decoding here is the same as the simple case\n        // We're just dealing with two values instead of one\n        let h1 = HEX_TABLE[s[i as usize] as usize];\n        let h2 = HEX_TABLE[s[(i + 1) as usize] as usize];\n        let h3 = HEX_TABLE[s[(i + 2) as usize] as usize];\n        let h4 = HEX_TABLE[s[(i + 3) as usize] as usize];\n\n        if h1 | h2 | h3 | h4 == 0xff {\n            return Err(());\n        }\n\n        buf[j * 2] = SHL4_TABLE[h1 as usize] | h2;\n        buf[j * 2 + 1] = SHL4_TABLE[h3 as usize] | h4;\n        j += 1;\n    }\n\n    Ok(buf)\n}","Real(LocalPath(\"src/parser.rs\"))"],"parser::parse_simple":["#[inline]\nconst fn parse_simple(s: &[u8]) -> Result<[u8; 16], ()>{\n    // This length check here removes all other bounds\n    // checks in this function\n    if s.len() != 32 {\n        return Err(());\n    }\n\n    let mut buf: [u8; 16] = [0; 16];\n    let mut i = 0;\n\n    while i < 16 {\n        // Convert a two-char hex value (like `A8`)\n        // into a byte (like `10101000`)\n        let h1 = HEX_TABLE[s[i * 2] as usize];\n        let h2 = HEX_TABLE[s[i * 2 + 1] as usize];\n\n        // We use `0xff` as a sentinel value to indicate\n        // an invalid hex character sequence (like the letter `G`)\n        if h1 | h2 == 0xff {\n            return Err(());\n        }\n\n        // The upper nibble needs to be shifted into position\n        // to produce the final byte value\n        buf[i] = SHL4_TABLE[h1 as usize] | h2;\n        i += 1;\n    }\n\n    Ok(buf)\n}","Real(LocalPath(\"src/parser.rs\"))"],"parser::try_parse":["const fn try_parse(input: &[u8]) -> Result<[u8; 16], InvalidUuid>{\n    let result = match (input.len(), input) {\n        // Inputs of 32 bytes must be a non-hyphenated UUID\n        (32, s) => parse_simple(s),\n        // Hyphenated UUIDs may be wrapped in various ways:\n        // - `{UUID}` for braced UUIDs\n        // - `urn:uuid:UUID` for URNs\n        // - `UUID` for a regular hyphenated UUID\n        (36, s)\n        | (38, [b'{', s @ .., b'}'])\n        | (45, [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..]) => {\n            parse_hyphenated(s)\n        }\n        // Any other shaped input is immediately invalid\n        _ => Err(()),\n    };\n\n    match result {\n        Ok(b) => Ok(b),\n        Err(()) => Err(InvalidUuid(input)),\n    }\n}","Real(LocalPath(\"src/parser.rs\"))"],"timestamp::ClockSequence":["/// A counter that can be used by version 1 and version 6 UUIDs to support\n/// the uniqueness of timestamps.\n///\n/// # References\n///\n/// * [Clock Sequence in RFC4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.5)\npub trait ClockSequence {\n    /// The type of sequence returned by this counter.\n    type Output;\n\n    /// Get the next value in the sequence to feed into a timestamp.\n    ///\n    /// This method will be called each time a [`Timestamp`] is constructed.\n    fn generate_sequence(&self, seconds: u64, subsec_nanos: u32) -> Self::Output;\n}","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::Timestamp":["/// A timestamp that can be encoded into a UUID.\n///\n/// This type abstracts the specific encoding, so versions 1, 6, and 7\n/// UUIDs can both be supported through the same type, even\n/// though they have a different representation of a timestamp.\n///\n/// # References\n///\n/// * [Timestamp in RFC4122](https://www.rfc-editor.org/rfc/rfc4122#section-4.1.4)\n/// * [Timestamp in Draft RFC: New UUID Formats, Version 4](https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format-04#section-6.1)\n/// * [Clock Sequence in RFC4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.5)\npub struct Timestamp {\n    pub(crate) seconds: u64,\n    pub(crate) nanos: u32,\n    #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n    pub(crate) counter: u16,\n}","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::Timestamp::from_rfc4122":["/// Construct a `Timestamp` from an RFC4122 timestamp and counter, as used\n/// in versions 1 and 6 UUIDs.\n///\n/// # Overflow\n///\n/// If conversion from RFC4122 ticks to the internal timestamp format would overflow\n/// it will wrap.\npub const fn from_rfc4122(ticks: u64, counter: u16) -> Self{\n        #[cfg(not(any(feature = \"v1\", feature = \"v6\")))]\n        {\n            let _ = counter;\n        }\n\n        let (seconds, nanos) = Self::rfc4122_to_unix(ticks);\n\n        Timestamp {\n            seconds,\n            nanos,\n            #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n            counter,\n        }\n    }","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::Timestamp::from_unix":["/// Construct a `Timestamp` from a Unix timestamp, as used in version 7 UUIDs.\n///\n/// # Overflow\n///\n/// If conversion from RFC4122 ticks to the internal timestamp format would overflow\n/// it will wrap.\npub fn from_unix(context: impl ClockSequence<Output = u16>, seconds: u64, nanos: u32) -> Self{\n        #[cfg(not(any(feature = \"v1\", feature = \"v6\")))]\n        {\n            let _ = context;\n\n            Timestamp { seconds, nanos }\n        }\n        #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n        {\n            let counter = context.generate_sequence(seconds, nanos);\n\n            Timestamp {\n                seconds,\n                nanos,\n                counter,\n            }\n        }\n    }","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::Timestamp::now":["/// Get a timestamp representing the current system time.\n///\n/// This method defers to the standard library's `SystemTime` type.\n///\n/// # Panics\n///\n/// This method will panic if calculating the elapsed time since the Unix epoch fails.\n#[cfg(feature = \"std\")]\npub fn now(context: impl ClockSequence<Output = u16>) -> Self{\n        #[cfg(not(any(feature = \"v1\", feature = \"v6\")))]\n        {\n            let _ = context;\n        }\n\n        let (seconds, nanos) = now();\n\n        Timestamp {\n            seconds,\n            nanos,\n            #[cfg(any(feature = \"v1\", feature = \"v6\"))]\n            counter: context.generate_sequence(seconds, nanos),\n        }\n    }","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::Timestamp::rfc4122_to_unix":["const fn rfc4122_to_unix(ticks: u64) -> (u64, u32){\n        (\n            ticks.wrapping_sub(UUID_TICKS_BETWEEN_EPOCHS) / 10_000_000,\n            (ticks.wrapping_sub(UUID_TICKS_BETWEEN_EPOCHS) % 10_000_000) as u32 * 100,\n        )\n    }","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::Timestamp::to_unix":["/// Get the value of the timestamp as a Unix timestamp, as used in version 7 UUIDs.\n///\n/// # Overflow\n///\n/// If conversion from RFC4122 ticks to the internal timestamp format would overflow\n/// it will wrap.\npub const fn to_unix(&self) -> (u64, u32){\n        (self.seconds, self.nanos)\n    }","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::Timestamp::to_unix_nanos":["#[deprecated(note = \"use `to_unix` instead; this method will be removed in a future release\")]\n/// Get the number of fractional nanoseconds in the Unix timestamp.\n///\n/// This method is deprecated and probably doesn't do what you're expecting it to.\n/// It doesn't return the timestamp as nanoseconds since the Unix epoch, it returns\n/// the fractional seconds of the timestamp.\npub const fn to_unix_nanos(&self) -> u32{\n        panic!(\"`Timestamp::to_unix_nanos` is deprecated and will be removed: use `Timestamp::to_unix` instead\")\n    }","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::context::NoContext":["/// An empty counter that will always return the value `0`.\n///\n/// This type should be used when constructing timestamps for version 7 UUIDs,\n/// since they don't need a counter for uniqueness.\npub struct NoContext;","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::decode_rfc4122_timestamp":["pub(crate) const fn decode_rfc4122_timestamp(uuid: &Uuid) -> (u64, u16){\n    let bytes = uuid.as_bytes();\n\n    let ticks: u64 = ((bytes[6] & 0x0F) as u64) << 56\n        | (bytes[7] as u64) << 48\n        | (bytes[4] as u64) << 40\n        | (bytes[5] as u64) << 32\n        | (bytes[0] as u64) << 24\n        | (bytes[1] as u64) << 16\n        | (bytes[2] as u64) << 8\n        | (bytes[3] as u64);\n\n    let counter: u16 = ((bytes[8] & 0x3F) as u16) << 8 | (bytes[9] as u16);\n\n    (ticks, counter)\n}","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::encode_rfc4122_timestamp":["pub(crate) const fn encode_rfc4122_timestamp(ticks: u64, counter: u16, node_id: &[u8; 6]) -> Uuid{\n    let time_low = (ticks & 0xFFFF_FFFF) as u32;\n    let time_mid = ((ticks >> 32) & 0xFFFF) as u16;\n    let time_high_and_version = (((ticks >> 48) & 0x0FFF) as u16) | (1 << 12);\n\n    let mut d4 = [0; 8];\n\n    d4[0] = (((counter & 0x3F00) >> 8) as u8) | 0x80;\n    d4[1] = (counter & 0xFF) as u8;\n    d4[2] = node_id[0];\n    d4[3] = node_id[1];\n    d4[4] = node_id[2];\n    d4[5] = node_id[3];\n    d4[6] = node_id[4];\n    d4[7] = node_id[5];\n\n    Uuid::from_fields(time_low, time_mid, time_high_and_version, &d4)\n}","Real(LocalPath(\"src/timestamp.rs\"))"],"timestamp::now":["#[cfg(all(\n    feature = \"std\",\n    any(\n        not(feature = \"js\"),\n        not(all(\n            target_arch = \"wasm32\",\n            target_vendor = \"unknown\",\n            target_os = \"unknown\"\n        ))\n    )\n))]\nfn now() -> (u64, u32){\n    let dur = std::time::SystemTime::UNIX_EPOCH.elapsed().expect(\n        \"Getting elapsed time since UNIX_EPOCH. If this fails, we've somehow violated causality\",\n    );\n\n    (dur.as_secs(), dur.subsec_nanos())\n}","Real(LocalPath(\"src/timestamp.rs\"))"]},"struct_constructor":{"&'b mut str":["encode_braced","encode_hyphenated","encode_simple","encode_urn"],"&'buf mut str":["encode_lower","encode_upper"],"&Uuid":["as_ref","as_uuid","borrow","from_bytes_ref"],"&[u8; 16]":["as_bytes"],"&[u8]":["as_ref"],"&fmt::Braced":["as_braced"],"&fmt::Hyphenated":["as_hyphenated"],"&fmt::Simple":["as_simple"],"&fmt::Urn":["as_urn"],"(u32, u16, u16, &[u8; 8])":["as_fields","to_fields_le"],"(u64, u16)":["decode_rfc4122_timestamp"],"(u64, u32)":["now","rfc4122_to_unix","to_unix"],"(u64, u64)":["as_u64_pair"],"<&'a T as timestamp::ClockSequence>::Output":["generate_sequence"],"<Self as timestamp::ClockSequence>::Output":["generate_sequence"],"<timestamp::context::NoContext as timestamp::ClockSequence>::Output":["generate_sequence"],"Uuid":["clone","default","encode_rfc4122_timestamp","from","from_bytes","from_bytes_le","from_fields","from_fields_le","from_slice","from_slice_le","from_str","from_u128","from_u128_le","from_u64_pair","into_uuid","nil","parse_str","try_from","try_parse","try_parse_ascii"],"Variant":["clone","get_variant"],"Version":["clone","get_version"],"[u8; 16]":["into_bytes","parse_hyphenated","parse_simple","to_bytes_le","try_parse"],"[u8; 32]":["format_simple"],"[u8; 36]":["format_hyphenated"],"[u8; _]":["encode_buffer"],"bool":["eq","is_nil"],"builder::Builder":["from_bytes","from_bytes_le","from_fields","from_fields_le","from_md5_bytes","from_random_bytes","from_rfc4122_timestamp","from_sha1_bytes","from_slice","from_slice_le","from_u128","from_u128_le","nil"],"error::Error":["clone","into_err"],"error::ErrorKind":["clone"],"error::InvalidUuid":["clone"],"fmt::Braced":["braced","clone","default","from","from_uuid"],"fmt::Hyphenated":["clone","default","from","from_uuid","hyphenated"],"fmt::Simple":["clone","default","from","from_uuid","simple"],"fmt::Urn":["clone","default","from","from_uuid","urn"],"std::cmp::Ordering":["cmp","partial_cmp"],"timestamp::Timestamp":["clone","from_rfc4122","from_unix","get_timestamp","now"],"timestamp::context::NoContext":["clone","default"],"u128":["as_u128","to_u128_le"],"u32":["to_unix_nanos"],"usize":["get_version_num"]},"struct_to_trait":{"Uuid":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::convert::TryFrom","std::default::Default","std::fmt::Debug","std::fmt::Display","std::fmt::LowerHex","std::fmt::UpperHex","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"Variant":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralPartialEq"],"Version":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"builder::Builder":["std::fmt::Debug"],"error::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::ErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::InvalidUuid":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"fmt::Braced":["std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::fmt::LowerHex","std::fmt::UpperHex","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"fmt::Hyphenated":["std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::fmt::LowerHex","std::fmt::UpperHex","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"fmt::Simple":["std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::fmt::LowerHex","std::fmt::UpperHex","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"fmt::Urn":["std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::fmt::LowerHex","std::fmt::UpperHex","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"timestamp::Timestamp":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"timestamp::context::NoContext":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Copy","timestamp::ClockSequence"]},"targets":{"<&'a T as timestamp::ClockSequence>::generate_sequence":["generate_sequence","Real(LocalPath(\"src/timestamp.rs\"))","timestamp::ClockSequence"],"<Uuid as std::convert::AsRef<[u8]>>::as_ref":["as_ref","Real(LocalPath(\"src/lib.rs\"))","std::convert::AsRef"],"<Uuid as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<fmt::Braced as std::borrow::Borrow<Uuid>>::borrow":["borrow","Real(LocalPath(\"src/fmt.rs\"))","std::borrow::Borrow"],"<fmt::Braced as std::convert::AsRef<Uuid>>::as_ref":["as_ref","Real(LocalPath(\"src/fmt.rs\"))","std::convert::AsRef"],"<fmt::Braced as std::convert::From<Uuid>>::from":["from","Real(LocalPath(\"src/fmt.rs\"))","std::convert::From"],"<fmt::Braced as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::Display"],"<fmt::Braced as std::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::LowerHex"],"<fmt::Braced as std::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::UpperHex"],"<fmt::Hyphenated as std::borrow::Borrow<Uuid>>::borrow":["borrow","Real(LocalPath(\"src/fmt.rs\"))","std::borrow::Borrow"],"<fmt::Hyphenated as std::convert::AsRef<Uuid>>::as_ref":["as_ref","Real(LocalPath(\"src/fmt.rs\"))","std::convert::AsRef"],"<fmt::Hyphenated as std::convert::From<Uuid>>::from":["from","Real(LocalPath(\"src/fmt.rs\"))","std::convert::From"],"<fmt::Hyphenated as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::Display"],"<fmt::Hyphenated as std::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::LowerHex"],"<fmt::Hyphenated as std::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::UpperHex"],"<fmt::Simple as std::borrow::Borrow<Uuid>>::borrow":["borrow","Real(LocalPath(\"src/fmt.rs\"))","std::borrow::Borrow"],"<fmt::Simple as std::convert::AsRef<Uuid>>::as_ref":["as_ref","Real(LocalPath(\"src/fmt.rs\"))","std::convert::AsRef"],"<fmt::Simple as std::convert::From<Uuid>>::from":["from","Real(LocalPath(\"src/fmt.rs\"))","std::convert::From"],"<fmt::Simple as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::Display"],"<fmt::Simple as std::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::LowerHex"],"<fmt::Simple as std::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::UpperHex"],"<fmt::Urn as std::borrow::Borrow<Uuid>>::borrow":["borrow","Real(LocalPath(\"src/fmt.rs\"))","std::borrow::Borrow"],"<fmt::Urn as std::convert::AsRef<Uuid>>::as_ref":["as_ref","Real(LocalPath(\"src/fmt.rs\"))","std::convert::AsRef"],"<fmt::Urn as std::convert::From<Uuid>>::from":["from","Real(LocalPath(\"src/fmt.rs\"))","std::convert::From"],"<fmt::Urn as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::Display"],"<fmt::Urn as std::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::LowerHex"],"<fmt::Urn as std::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::UpperHex"],"<timestamp::context::NoContext as timestamp::ClockSequence>::generate_sequence":["generate_sequence","Real(LocalPath(\"src/timestamp.rs\"))","timestamp::ClockSequence"],"Uuid::as_bytes":["as_bytes","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::as_fields":["as_fields","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::as_u128":["as_u128","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::as_u64_pair":["as_u64_pair","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::encode_buffer":["encode_buffer","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::get_timestamp":["get_timestamp","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::get_variant":["get_variant","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::get_version":["get_version","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::get_version_num":["get_version_num","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::into_bytes":["into_bytes","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::is_nil":["is_nil","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::to_bytes_le":["to_bytes_le","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::to_fields_le":["to_fields_le","Real(LocalPath(\"src/lib.rs\"))",""],"Uuid::to_u128_le":["to_u128_le","Real(LocalPath(\"src/lib.rs\"))",""],"builder::<impl Uuid>::from_bytes":["from_bytes","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_bytes_le":["from_bytes_le","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_bytes_ref":["from_bytes_ref","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_fields":["from_fields","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_fields_le":["from_fields_le","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_slice":["from_slice","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_slice_le":["from_slice_le","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_u128":["from_u128","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_u128_le":["from_u128_le","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::from_u64_pair":["from_u64_pair","Real(LocalPath(\"src/builder.rs\"))",""],"builder::<impl Uuid>::nil":["nil","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::as_uuid":["as_uuid","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_bytes":["from_bytes","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_bytes_le":["from_bytes_le","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_fields":["from_fields","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_fields_le":["from_fields_le","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_md5_bytes":["from_md5_bytes","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_random_bytes":["from_random_bytes","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_rfc4122_timestamp":["from_rfc4122_timestamp","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_sha1_bytes":["from_sha1_bytes","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_slice":["from_slice","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_slice_le":["from_slice_le","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_u128":["from_u128","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::from_u128_le":["from_u128_le","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::into_uuid":["into_uuid","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::nil":["nil","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::set_variant":["set_variant","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::set_version":["set_version","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::with_variant":["with_variant","Real(LocalPath(\"src/builder.rs\"))",""],"builder::Builder::with_version":["with_version","Real(LocalPath(\"src/builder.rs\"))",""],"error::InvalidUuid::<'a>::into_err":["into_err","Real(LocalPath(\"src/error.rs\"))",""],"fmt::<impl Uuid>::as_braced":["as_braced","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::<impl Uuid>::as_hyphenated":["as_hyphenated","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::<impl Uuid>::as_simple":["as_simple","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::<impl Uuid>::as_urn":["as_urn","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::<impl Uuid>::braced":["braced","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::<impl Uuid>::hyphenated":["hyphenated","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::<impl Uuid>::simple":["simple","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::<impl Uuid>::urn":["urn","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::<impl std::convert::From<fmt::Braced> for Uuid>::from":["from","Real(LocalPath(\"src/fmt.rs\"))","std::convert::From"],"fmt::<impl std::convert::From<fmt::Hyphenated> for Uuid>::from":["from","Real(LocalPath(\"src/fmt.rs\"))","std::convert::From"],"fmt::<impl std::convert::From<fmt::Simple> for Uuid>::from":["from","Real(LocalPath(\"src/fmt.rs\"))","std::convert::From"],"fmt::<impl std::convert::From<fmt::Urn> for Uuid>::from":["from","Real(LocalPath(\"src/fmt.rs\"))","std::convert::From"],"fmt::<impl std::fmt::Debug for Uuid>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::Debug"],"fmt::<impl std::fmt::Display for Uuid>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::Display"],"fmt::<impl std::fmt::Display for Variant>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::Display"],"fmt::<impl std::fmt::LowerHex for Uuid>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::LowerHex"],"fmt::<impl std::fmt::UpperHex for Uuid>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::UpperHex"],"fmt::Braced::as_uuid":["as_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Braced::encode_lower":["encode_lower","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Braced::encode_upper":["encode_upper","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Braced::from_uuid":["from_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Braced::into_uuid":["into_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Hyphenated::as_uuid":["as_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Hyphenated::encode_lower":["encode_lower","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Hyphenated::encode_upper":["encode_upper","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Hyphenated::from_uuid":["from_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Hyphenated::into_uuid":["into_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Simple::as_uuid":["as_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Simple::encode_lower":["encode_lower","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Simple::encode_upper":["encode_upper","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Simple::from_uuid":["from_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Simple::into_uuid":["into_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Urn::as_uuid":["as_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Urn::encode_lower":["encode_lower","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Urn::encode_upper":["encode_upper","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Urn::from_uuid":["from_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Urn::into_uuid":["into_uuid","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::encode_braced":["encode_braced","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::encode_hyphenated":["encode_hyphenated","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::encode_simple":["encode_simple","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::encode_urn":["encode_urn","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::format_hyphenated":["format_hyphenated","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::format_simple":["format_simple","Real(LocalPath(\"src/fmt.rs\"))",""],"parser::<impl Uuid>::parse_str":["parse_str","Real(LocalPath(\"src/parser.rs\"))",""],"parser::<impl Uuid>::try_parse":["try_parse","Real(LocalPath(\"src/parser.rs\"))",""],"parser::<impl Uuid>::try_parse_ascii":["try_parse_ascii","Real(LocalPath(\"src/parser.rs\"))",""],"parser::<impl std::convert::TryFrom<&str> for Uuid>::try_from":["try_from","Real(LocalPath(\"src/parser.rs\"))","std::convert::TryFrom"],"parser::<impl std::str::FromStr for Uuid>::from_str":["from_str","Real(LocalPath(\"src/parser.rs\"))","std::str::FromStr"],"parser::parse_hyphenated":["parse_hyphenated","Real(LocalPath(\"src/parser.rs\"))",""],"parser::parse_simple":["parse_simple","Real(LocalPath(\"src/parser.rs\"))",""],"parser::try_parse":["try_parse","Real(LocalPath(\"src/parser.rs\"))",""],"timestamp::Timestamp::from_rfc4122":["from_rfc4122","Real(LocalPath(\"src/timestamp.rs\"))",""],"timestamp::Timestamp::from_unix":["from_unix","Real(LocalPath(\"src/timestamp.rs\"))",""],"timestamp::Timestamp::now":["now","Real(LocalPath(\"src/timestamp.rs\"))",""],"timestamp::Timestamp::rfc4122_to_unix":["rfc4122_to_unix","Real(LocalPath(\"src/timestamp.rs\"))",""],"timestamp::Timestamp::to_unix":["to_unix","Real(LocalPath(\"src/timestamp.rs\"))",""],"timestamp::Timestamp::to_unix_nanos":["to_unix_nanos","Real(LocalPath(\"src/timestamp.rs\"))",""],"timestamp::decode_rfc4122_timestamp":["decode_rfc4122_timestamp","Real(LocalPath(\"src/timestamp.rs\"))",""],"timestamp::encode_rfc4122_timestamp":["encode_rfc4122_timestamp","Real(LocalPath(\"src/timestamp.rs\"))",""],"timestamp::now":["now","Real(LocalPath(\"src/timestamp.rs\"))",""]},"trait_to_struct":{"std::borrow::Borrow":["fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn"],"std::clone::Clone":["Uuid","Variant","Version","error::Error","error::ErrorKind","error::InvalidUuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::Timestamp","timestamp::context::NoContext"],"std::cmp::Eq":["Uuid","error::Error","error::ErrorKind","error::InvalidUuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::Timestamp"],"std::cmp::Ord":["Uuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn"],"std::cmp::PartialEq":["Uuid","Variant","Version","error::Error","error::ErrorKind","error::InvalidUuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::Timestamp"],"std::cmp::PartialOrd":["Uuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn"],"std::convert::AsRef":["Uuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn"],"std::convert::From":["Uuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn"],"std::convert::TryFrom":["Uuid"],"std::default::Default":["Uuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::context::NoContext"],"std::error::Error":["error::Error"],"std::fmt::Debug":["Uuid","Variant","Version","builder::Builder","error::Error","error::ErrorKind","error::InvalidUuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::Timestamp","timestamp::context::NoContext"],"std::fmt::Display":["Uuid","Variant","error::Error","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn"],"std::fmt::LowerHex":["Uuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn"],"std::fmt::UpperHex":["Uuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn"],"std::hash::Hash":["Uuid","error::Error","error::ErrorKind","error::InvalidUuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::Timestamp"],"std::marker::Copy":["Uuid","Variant","Version","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::Timestamp","timestamp::context::NoContext"],"std::marker::StructuralEq":["Uuid","error::Error","error::ErrorKind","error::InvalidUuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::Timestamp"],"std::marker::StructuralPartialEq":["Uuid","Variant","Version","error::Error","error::ErrorKind","error::InvalidUuid","fmt::Braced","fmt::Hyphenated","fmt::Simple","fmt::Urn","timestamp::Timestamp"],"std::str::FromStr":["Uuid"],"timestamp::ClockSequence":["timestamp::context::NoContext"]},"type_to_def_path":{"Uuid":"Uuid","Variant":"Variant","Version":"Version","builder::Builder":"builder::Builder","error::Error":"error::Error","error::ErrorKind":"error::ErrorKind","error::InvalidUuid<'a>":"error::InvalidUuid","fmt::Braced":"fmt::Braced","fmt::Hyphenated":"fmt::Hyphenated","fmt::Simple":"fmt::Simple","fmt::Urn":"fmt::Urn","timestamp::Timestamp":"timestamp::Timestamp","timestamp::context::NoContext":"timestamp::context::NoContext"}}