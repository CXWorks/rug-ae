{"dependencies":{"<Hasher as std::clone::Clone>::clone":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"<Hasher as std::default::Default>::default":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"<Hasher as std::fmt::Debug>::fmt":["Hasher","State","baseline::State","specialized::pclmulqdq::State","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<Hasher as std::hash::Hasher>::finish":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"<Hasher as std::hash::Hasher>::write":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"<State as std::clone::Clone>::clone":["State","baseline::State","specialized::pclmulqdq::State"],"<baseline::State as std::clone::Clone>::clone":["baseline::State"],"<specialized::pclmulqdq::State as std::clone::Clone>::clone":["specialized::pclmulqdq::State"],"Hasher":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"Hasher::combine":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"Hasher::finalize":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"Hasher::internal_new_baseline":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"Hasher::internal_new_specialized":["std::marker::Sized","std::option::Option"],"Hasher::new":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"Hasher::new_with_initial":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"Hasher::new_with_initial_len":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"Hasher::reset":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"Hasher::update":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"State":["State","baseline::State","specialized::pclmulqdq::State"],"baseline::State":["baseline::State"],"baseline::State::combine":["baseline::State"],"baseline::State::finalize":["baseline::State"],"baseline::State::new":["baseline::State"],"baseline::State::reset":["baseline::State"],"baseline::State::update":["baseline::State"],"baseline::update_fast_16":[],"baseline::update_slow":[],"combine::combine":[],"combine::gf2_matrix_square":[],"combine::gf2_matrix_times":[],"hash":[],"specialized::pclmulqdq::State":["specialized::pclmulqdq::State"],"specialized::pclmulqdq::State::combine":["specialized::pclmulqdq::State"],"specialized::pclmulqdq::State::finalize":["specialized::pclmulqdq::State"],"specialized::pclmulqdq::State::new":["std::marker::Sized","std::option::Option"],"specialized::pclmulqdq::State::reset":["specialized::pclmulqdq::State"],"specialized::pclmulqdq::State::update":["specialized::pclmulqdq::State"],"specialized::pclmulqdq::calculate":[],"specialized::pclmulqdq::debug":["std::arch::x86_64::__m128i"],"specialized::pclmulqdq::debug::A":["specialized::pclmulqdq::debug::A","std::arch::x86_64::__m128i"],"specialized::pclmulqdq::get":["std::arch::x86_64::__m128i"],"specialized::pclmulqdq::reduce128":["std::arch::x86_64::__m128i"]},"glob_path_import":{},"self_to_fn":{"Hasher":["Clone","impl Default for Hasher {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl Hasher {\n    /// Create a new `Hasher`.\n    ///\n    /// This will perform a CPU feature detection at runtime to select the most\n    /// optimal implementation for the current processor architecture.\n    pub fn new() -> Self {\n        Self::new_with_initial(DEFAULT_INIT_STATE)\n    }\n\n    /// Create a new `Hasher` with an initial CRC32 state.\n    ///\n    /// This works just like `Hasher::new`, except that it allows for an initial\n    /// CRC32 state to be passed in.\n    pub fn new_with_initial(init: u32) -> Self {\n        Self::new_with_initial_len(init, 0)\n    }\n\n    /// Create a new `Hasher` with an initial CRC32 state.\n    ///\n    /// As `new_with_initial`, but also accepts a length (in bytes). The\n    /// resulting object can then be used with `combine` to compute `crc(a ||\n    /// b)` from `crc(a)`, `crc(b)`, and `len(b)`.\n    pub fn new_with_initial_len(init: u32, amount: u64) -> Self {\n        Self::internal_new_specialized(init, amount)\n            .unwrap_or_else(|| Self::internal_new_baseline(init, amount))\n    }\n\n    #[doc(hidden)]\n    // Internal-only API. Don't use.\n    pub fn internal_new_baseline(init: u32, amount: u64) -> Self {\n        Hasher {\n            amount,\n            state: State::Baseline(baseline::State::new(init)),\n        }\n    }\n\n    #[doc(hidden)]\n    // Internal-only API. Don't use.\n    pub fn internal_new_specialized(init: u32, amount: u64) -> Option<Self> {\n        {\n            if let Some(state) = specialized::State::new(init) {\n                return Some(Hasher {\n                    amount,\n                    state: State::Specialized(state),\n                });\n            }\n        }\n        None\n    }\n\n    /// Process the given byte slice and update the hash state.\n    pub fn update(&mut self, buf: &[u8]) {\n        self.amount += buf.len() as u64;\n        match self.state {\n            State::Baseline(ref mut state) => state.update(buf),\n            State::Specialized(ref mut state) => state.update(buf),\n        }\n    }\n\n    /// Finalize the hash state and return the computed CRC32 value.\n    pub fn finalize(self) -> u32 {\n        match self.state {\n            State::Baseline(state) => state.finalize(),\n            State::Specialized(state) => state.finalize(),\n        }\n    }\n\n    /// Reset the hash state.\n    pub fn reset(&mut self) {\n        self.amount = 0;\n        match self.state {\n            State::Baseline(ref mut state) => state.reset(),\n            State::Specialized(ref mut state) => state.reset(),\n        }\n    }\n\n    /// Combine the hash state with the hash state for the subsequent block of bytes.\n    pub fn combine(&mut self, other: &Self) {\n        self.amount += other.amount;\n        let other_crc = other.clone().finalize();\n        match self.state {\n            State::Baseline(ref mut state) => state.combine(other_crc, other.amount),\n            State::Specialized(ref mut state) => state.combine(other_crc, other.amount),\n        }\n    }\n}","impl fmt::Debug for Hasher {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"crc32fast::Hasher\").finish()\n    }\n}","impl hash::Hasher for Hasher {\n    fn write(&mut self, bytes: &[u8]) {\n        self.update(bytes)\n    }\n\n    fn finish(&self) -> u64 {\n        u64::from(self.clone().finalize())\n    }\n}"],"State":["Clone"],"baseline::State":["Clone","impl State {\n    pub fn new(state: u32) -> Self {\n        State { state }\n    }\n\n    pub fn update(&mut self, buf: &[u8]) {\n        self.state = update_fast_16(self.state, buf);\n    }\n\n    pub fn finalize(self) -> u32 {\n        self.state\n    }\n\n    pub fn reset(&mut self) {\n        self.state = 0;\n    }\n\n    pub fn combine(&mut self, other: u32, amount: u64) {\n        self.state = ::combine::combine(self.state, other, amount);\n    }\n}"],"specialized::pclmulqdq::State":["Clone","impl State {\n    #[cfg(not(feature = \"std\"))]\n    pub fn new(state: u32) -> Option<Self> {\n        if cfg!(target_feature = \"pclmulqdq\")\n            && cfg!(target_feature = \"sse2\")\n            && cfg!(target_feature = \"sse4.1\")\n        {\n            // SAFETY: The conditions above ensure that all\n            //         required instructions are supported by the CPU.\n            Some(Self { state })\n        } else {\n            None\n        }\n    }\n\n    #[cfg(feature = \"std\")]\n    pub fn new(state: u32) -> Option<Self> {\n        if is_x86_feature_detected!(\"pclmulqdq\")\n            && is_x86_feature_detected!(\"sse2\")\n            && is_x86_feature_detected!(\"sse4.1\")\n        {\n            // SAFETY: The conditions above ensure that all\n            //         required instructions are supported by the CPU.\n            Some(Self { state })\n        } else {\n            None\n        }\n    }\n\n    pub fn update(&mut self, buf: &[u8]) {\n        // SAFETY: The `State::new` constructor ensures that all\n        //         required instructions are supported by the CPU.\n        self.state = unsafe { calculate(self.state, buf) }\n    }\n\n    pub fn finalize(self) -> u32 {\n        self.state\n    }\n\n    pub fn reset(&mut self) {\n        self.state = 0;\n    }\n\n    pub fn combine(&mut self, other: u32, amount: u64) {\n        self.state = ::combine::combine(self.state, other, amount);\n    }\n}"]},"single_path_import":{"specialized::pclmulqdq::State":"specialized::State"},"srcs":{"<Hasher as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Hasher as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"crc32fast::Hasher\").finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Hasher as std::hash::Hasher>::finish":["fn finish(&self) -> u64{\n        u64::from(self.clone().finalize())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Hasher as std::hash::Hasher>::write":["fn write(&mut self, bytes: &[u8]){\n        self.update(bytes)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher":["/// Represents an in-progress CRC32 computation.\npub struct Hasher {\n    amount: u64,\n    state: State,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::combine":["/// Combine the hash state with the hash state for the subsequent block of bytes.\npub fn combine(&mut self, other: &Self){\n        self.amount += other.amount;\n        let other_crc = other.clone().finalize();\n        match self.state {\n            State::Baseline(ref mut state) => state.combine(other_crc, other.amount),\n            State::Specialized(ref mut state) => state.combine(other_crc, other.amount),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::finalize":["/// Finalize the hash state and return the computed CRC32 value.\npub fn finalize(self) -> u32{\n        match self.state {\n            State::Baseline(state) => state.finalize(),\n            State::Specialized(state) => state.finalize(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::internal_new_baseline":["#[doc(hidden)]\npub fn internal_new_baseline(init: u32, amount: u64) -> Self{\n        Hasher {\n            amount,\n            state: State::Baseline(baseline::State::new(init)),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::internal_new_specialized":["#[doc(hidden)]\npub fn internal_new_specialized(init: u32, amount: u64) -> Option<Self>{\n        {\n            if let Some(state) = specialized::State::new(init) {\n                return Some(Hasher {\n                    amount,\n                    state: State::Specialized(state),\n                });\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::new":["/// Create a new `Hasher`.\n///\n/// This will perform a CPU feature detection at runtime to select the most\n/// optimal implementation for the current processor architecture.\npub fn new() -> Self{\n        Self::new_with_initial(DEFAULT_INIT_STATE)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::new_with_initial":["/// Create a new `Hasher` with an initial CRC32 state.\n///\n/// This works just like `Hasher::new`, except that it allows for an initial\n/// CRC32 state to be passed in.\npub fn new_with_initial(init: u32) -> Self{\n        Self::new_with_initial_len(init, 0)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::new_with_initial_len":["/// Create a new `Hasher` with an initial CRC32 state.\n///\n/// As `new_with_initial`, but also accepts a length (in bytes). The\n/// resulting object can then be used with `combine` to compute `crc(a ||\n/// b)` from `crc(a)`, `crc(b)`, and `len(b)`.\npub fn new_with_initial_len(init: u32, amount: u64) -> Self{\n        Self::internal_new_specialized(init, amount)\n            .unwrap_or_else(|| Self::internal_new_baseline(init, amount))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::reset":["/// Reset the hash state.\npub fn reset(&mut self){\n        self.amount = 0;\n        match self.state {\n            State::Baseline(ref mut state) => state.reset(),\n            State::Specialized(ref mut state) => state.reset(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Hasher::update":["/// Process the given byte slice and update the hash state.\npub fn update(&mut self, buf: &[u8]){\n        self.amount += buf.len() as u64;\n        match self.state {\n            State::Baseline(ref mut state) => state.update(buf),\n            State::Specialized(ref mut state) => state.update(buf),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"State":["enum State {\n    Baseline(baseline::State),\n    Specialized(specialized::State),\n}","Real(LocalPath(\"src/lib.rs\"))"],"baseline::State":["pub struct State {\n    state: u32,\n}","Real(LocalPath(\"src/baseline.rs\"))"],"baseline::State::combine":["pub fn combine(&mut self, other: u32, amount: u64){\n        self.state = ::combine::combine(self.state, other, amount);\n    }","Real(LocalPath(\"src/baseline.rs\"))"],"baseline::State::finalize":["pub fn finalize(self) -> u32{\n        self.state\n    }","Real(LocalPath(\"src/baseline.rs\"))"],"baseline::State::new":["pub fn new(state: u32) -> Self{\n        State { state }\n    }","Real(LocalPath(\"src/baseline.rs\"))"],"baseline::State::reset":["pub fn reset(&mut self){\n        self.state = 0;\n    }","Real(LocalPath(\"src/baseline.rs\"))"],"baseline::State::update":["pub fn update(&mut self, buf: &[u8]){\n        self.state = update_fast_16(self.state, buf);\n    }","Real(LocalPath(\"src/baseline.rs\"))"],"baseline::update_fast_16":["pub(crate) fn update_fast_16(prev: u32, mut buf: &[u8]) -> u32{\n    const UNROLL: usize = 4;\n    const BYTES_AT_ONCE: usize = 16 * UNROLL;\n\n    let mut crc = !prev;\n\n    while buf.len() >= BYTES_AT_ONCE {\n        for _ in 0..UNROLL {\n            crc = CRC32_TABLE[0x0][buf[0xf] as usize]\n                ^ CRC32_TABLE[0x1][buf[0xe] as usize]\n                ^ CRC32_TABLE[0x2][buf[0xd] as usize]\n                ^ CRC32_TABLE[0x3][buf[0xc] as usize]\n                ^ CRC32_TABLE[0x4][buf[0xb] as usize]\n                ^ CRC32_TABLE[0x5][buf[0xa] as usize]\n                ^ CRC32_TABLE[0x6][buf[0x9] as usize]\n                ^ CRC32_TABLE[0x7][buf[0x8] as usize]\n                ^ CRC32_TABLE[0x8][buf[0x7] as usize]\n                ^ CRC32_TABLE[0x9][buf[0x6] as usize]\n                ^ CRC32_TABLE[0xa][buf[0x5] as usize]\n                ^ CRC32_TABLE[0xb][buf[0x4] as usize]\n                ^ CRC32_TABLE[0xc][buf[0x3] as usize ^ ((crc >> 0x18) & 0xFF) as usize]\n                ^ CRC32_TABLE[0xd][buf[0x2] as usize ^ ((crc >> 0x10) & 0xFF) as usize]\n                ^ CRC32_TABLE[0xe][buf[0x1] as usize ^ ((crc >> 0x08) & 0xFF) as usize]\n                ^ CRC32_TABLE[0xf][buf[0x0] as usize ^ ((crc >> 0x00) & 0xFF) as usize];\n            buf = &buf[16..];\n        }\n    }\n\n    update_slow(!crc, buf)\n}","Real(LocalPath(\"src/baseline.rs\"))"],"baseline::update_slow":["pub(crate) fn update_slow(prev: u32, buf: &[u8]) -> u32{\n    let mut crc = !prev;\n\n    for &byte in buf.iter() {\n        crc = CRC32_TABLE[0][((crc as u8) ^ byte) as usize] ^ (crc >> 8);\n    }\n\n    !crc\n}","Real(LocalPath(\"src/baseline.rs\"))"],"combine::combine":["pub(crate) fn combine(mut crc1: u32, crc2: u32, mut len2: u64) -> u32{\n    let mut row: u32;\n    let mut even = [0u32; GF2_DIM]; /* even-power-of-two zeros operator */\n    let mut odd = [0u32; GF2_DIM]; /* odd-power-of-two zeros operator */\n\n    /* degenerate case (also disallow negative lengths) */\n    if len2 <= 0 {\n        return crc1;\n    }\n\n    /* put operator for one zero bit in odd */\n    odd[0] = 0xedb88320; /* CRC-32 polynomial */\n    row = 1;\n    for n in 1..GF2_DIM {\n        odd[n] = row;\n        row <<= 1;\n    }\n\n    /* put operator for two zero bits in even */\n    gf2_matrix_square(&mut even, &odd);\n\n    /* put operator for four zero bits in odd */\n    gf2_matrix_square(&mut odd, &even);\n\n    /* apply len2 zeros to crc1 (first square will put the operator for one\n       zero byte, eight zero bits, in even) */\n    loop {\n        /* apply zeros operator for this bit of len2 */\n        gf2_matrix_square(&mut even, &odd);\n        if len2 & 1 == 1 {\n            crc1 = gf2_matrix_times(&even, crc1);\n        }\n        len2 >>= 1;\n\n        /* if no more bits set, then done */\n        if len2 == 0 {\n            break;\n        }\n\n        /* another iteration of the loop with odd and even swapped */\n        gf2_matrix_square(&mut odd, &even);\n        if len2 & 1 == 1 {\n            crc1 = gf2_matrix_times(&odd, crc1);\n        }\n        len2 >>= 1;\n\n        /* if no more bits set, then done */\n        if len2 == 0 {\n            break;\n        }\n    }\n\n    /* return combined crc */\n    crc1 ^= crc2;\n    return crc1;\n}","Real(LocalPath(\"src/combine.rs\"))"],"combine::gf2_matrix_square":["fn gf2_matrix_square(square: &mut [u32; GF2_DIM], mat: &[u32; GF2_DIM]){\n    for n in 0..GF2_DIM {\n        square[n] = gf2_matrix_times(mat, mat[n]);\n    }\n}","Real(LocalPath(\"src/combine.rs\"))"],"combine::gf2_matrix_times":["fn gf2_matrix_times(mat: &[u32; GF2_DIM], mut vec: u32) -> u32{\n    let mut sum = 0;\n    let mut idx = 0;\n    while vec > 0 {\n        if vec & 1 == 1 {\n            sum ^= mat[idx];\n        }\n        vec >>= 1;\n        idx += 1;\n    }\n    return sum;\n}","Real(LocalPath(\"src/combine.rs\"))"],"hash":["/// Computes the CRC32 hash of a byte slice.\n///\n/// Check out [`Hasher`] for more advanced use-cases.\npub fn hash(buf: &[u8]) -> u32{\n    let mut h = Hasher::new();\n    h.update(buf);\n    h.finalize()\n}","Real(LocalPath(\"src/lib.rs\"))"],"specialized::pclmulqdq::State":["pub struct State {\n    state: u32,\n}","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::State::combine":["pub fn combine(&mut self, other: u32, amount: u64){\n        self.state = ::combine::combine(self.state, other, amount);\n    }","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::State::finalize":["pub fn finalize(self) -> u32{\n        self.state\n    }","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::State::new":["#[cfg(feature = \"std\")]\npub fn new(state: u32) -> Option<Self>{\n        if is_x86_feature_detected!(\"pclmulqdq\")\n            && is_x86_feature_detected!(\"sse2\")\n            && is_x86_feature_detected!(\"sse4.1\")\n        {\n            // SAFETY: The conditions above ensure that all\n            //         required instructions are supported by the CPU.\n            Some(Self { state })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::State::reset":["pub fn reset(&mut self){\n        self.state = 0;\n    }","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::State::update":["pub fn update(&mut self, buf: &[u8]){\n        // SAFETY: The `State::new` constructor ensures that all\n        //         required instructions are supported by the CPU.\n        self.state = unsafe { calculate(self.state, buf) }\n    }","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::calculate":["#[target_feature(enable = \"pclmulqdq\", enable = \"sse2\", enable = \"sse4.1\")]\nunsafe fn calculate(crc: u32, mut data: &[u8]) -> u32{\n    // In theory we can accelerate smaller chunks too, but for now just rely on\n    // the fallback implementation as it's too much hassle and doesn't seem too\n    // beneficial.\n    if data.len() < 128 {\n        return ::baseline::update_fast_16(crc, data);\n    }\n\n    // Step 1: fold by 4 loop\n    let mut x3 = get(&mut data);\n    let mut x2 = get(&mut data);\n    let mut x1 = get(&mut data);\n    let mut x0 = get(&mut data);\n\n    // fold in our initial value, part of the incremental crc checksum\n    x3 = arch::_mm_xor_si128(x3, arch::_mm_cvtsi32_si128(!crc as i32));\n\n    let k1k2 = arch::_mm_set_epi64x(K2, K1);\n    while data.len() >= 64 {\n        x3 = reduce128(x3, get(&mut data), k1k2);\n        x2 = reduce128(x2, get(&mut data), k1k2);\n        x1 = reduce128(x1, get(&mut data), k1k2);\n        x0 = reduce128(x0, get(&mut data), k1k2);\n    }\n\n    let k3k4 = arch::_mm_set_epi64x(K4, K3);\n    let mut x = reduce128(x3, x2, k3k4);\n    x = reduce128(x, x1, k3k4);\n    x = reduce128(x, x0, k3k4);\n\n    // Step 2: fold by 1 loop\n    while data.len() >= 16 {\n        x = reduce128(x, get(&mut data), k3k4);\n    }\n\n    debug(\"128 > 64 init\", x);\n\n    // Perform step 3, reduction from 128 bits to 64 bits. This is\n    // significantly different from the paper and basically doesn't follow it\n    // at all. It's not really clear why, but implementations of this algorithm\n    // in Chrome/Linux diverge in the same way. It is beyond me why this is\n    // different than the paper, maybe the paper has like errata or something?\n    // Unclear.\n    //\n    // It's also not clear to me what's actually happening here and/or why, but\n    // algebraically what's happening is:\n    //\n    // x = (x[0:63] • K4) ^ x[64:127]           // 96 bit result\n    // x = ((x[0:31] as u64) • K5) ^ x[32:95]   // 64 bit result\n    //\n    // It's... not clear to me what's going on here. The paper itself is pretty\n    // vague on this part but definitely uses different constants at least.\n    // It's not clear to me, reading the paper, where the xor operations are\n    // happening or why things are shifting around. This implementation...\n    // appears to work though!\n    drop(K6);\n    let x = arch::_mm_xor_si128(\n        arch::_mm_clmulepi64_si128(x, k3k4, 0x10),\n        arch::_mm_srli_si128(x, 8),\n    );\n    let x = arch::_mm_xor_si128(\n        arch::_mm_clmulepi64_si128(\n            arch::_mm_and_si128(x, arch::_mm_set_epi32(0, 0, 0, !0)),\n            arch::_mm_set_epi64x(0, K5),\n            0x00,\n        ),\n        arch::_mm_srli_si128(x, 4),\n    );\n    debug(\"128 > 64 xx\", x);\n\n    // Perform a Barrett reduction from our now 64 bits to 32 bits. The\n    // algorithm for this is described at the end of the paper, and note that\n    // this also implements the \"bit reflected input\" variant.\n    let pu = arch::_mm_set_epi64x(U_PRIME, P_X);\n\n    // T1(x) = ⌊(R(x) % x^32)⌋ • μ\n    let t1 = arch::_mm_clmulepi64_si128(\n        arch::_mm_and_si128(x, arch::_mm_set_epi32(0, 0, 0, !0)),\n        pu,\n        0x10,\n    );\n    // T2(x) = ⌊(T1(x) % x^32)⌋ • P(x)\n    let t2 = arch::_mm_clmulepi64_si128(\n        arch::_mm_and_si128(t1, arch::_mm_set_epi32(0, 0, 0, !0)),\n        pu,\n        0x00,\n    );\n    // We're doing the bit-reflected variant, so get the upper 32-bits of the\n    // 64-bit result instead of the lower 32-bits.\n    //\n    // C(x) = R(x) ^ T2(x) / x^32\n    let c = arch::_mm_extract_epi32(arch::_mm_xor_si128(x, t2), 1) as u32;\n\n    if !data.is_empty() {\n        ::baseline::update_fast_16(!c, data)\n    } else {\n        !c\n    }\n}","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::debug":["#[cfg(feature = \"std\")]\nunsafe fn debug(s: &str, a: arch::__m128i) -> arch::__m128i{\n    if false {\n        union A {\n            a: arch::__m128i,\n            b: [u8; 16],\n        }\n        let x = A { a }.b;\n        print!(\" {:20} | \", s);\n        for x in x.iter() {\n            print!(\"{:02x} \", x);\n        }\n        println!();\n    }\n    return a;\n}","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::debug::A":["union A {\n            a: arch::__m128i,\n            b: [u8; 16],\n        }","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::get":["unsafe fn get(a: &mut &[u8]) -> arch::__m128i{\n    debug_assert!(a.len() >= 16);\n    let r = arch::_mm_loadu_si128(a.as_ptr() as *const arch::__m128i);\n    *a = &a[16..];\n    return r;\n}","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"],"specialized::pclmulqdq::reduce128":["unsafe fn reduce128(a: arch::__m128i, b: arch::__m128i, keys: arch::__m128i) -> arch::__m128i{\n    let t1 = arch::_mm_clmulepi64_si128(a, keys, 0x00);\n    let t2 = arch::_mm_clmulepi64_si128(a, keys, 0x11);\n    arch::_mm_xor_si128(arch::_mm_xor_si128(b, t1), t2)\n}","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))"]},"struct_constructor":{"Hasher":["clone","default","internal_new_baseline","internal_new_specialized","new","new_with_initial","new_with_initial_len"],"State":["clone"],"baseline::State":["clone","new"],"specialized::pclmulqdq::State":["clone","new"],"std::arch::x86_64::__m128i":["get"],"u32":["finalize","hash"],"u64":["finish"]},"struct_to_trait":{"Hasher":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::hash::Hasher"],"State":["std::clone::Clone"],"baseline::State":["std::clone::Clone"],"specialized::pclmulqdq::State":["std::clone::Clone"]},"targets":{"<Hasher as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<Hasher as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Hasher as std::hash::Hasher>::finish":["finish","Real(LocalPath(\"src/lib.rs\"))","std::hash::Hasher"],"<Hasher as std::hash::Hasher>::write":["write","Real(LocalPath(\"src/lib.rs\"))","std::hash::Hasher"],"Hasher::combine":["combine","Real(LocalPath(\"src/lib.rs\"))",""],"Hasher::finalize":["finalize","Real(LocalPath(\"src/lib.rs\"))",""],"Hasher::internal_new_baseline":["internal_new_baseline","Real(LocalPath(\"src/lib.rs\"))",""],"Hasher::internal_new_specialized":["internal_new_specialized","Real(LocalPath(\"src/lib.rs\"))",""],"Hasher::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Hasher::new_with_initial":["new_with_initial","Real(LocalPath(\"src/lib.rs\"))",""],"Hasher::new_with_initial_len":["new_with_initial_len","Real(LocalPath(\"src/lib.rs\"))",""],"Hasher::reset":["reset","Real(LocalPath(\"src/lib.rs\"))",""],"Hasher::update":["update","Real(LocalPath(\"src/lib.rs\"))",""],"baseline::State::combine":["combine","Real(LocalPath(\"src/baseline.rs\"))",""],"baseline::State::finalize":["finalize","Real(LocalPath(\"src/baseline.rs\"))",""],"baseline::State::new":["new","Real(LocalPath(\"src/baseline.rs\"))",""],"baseline::State::reset":["reset","Real(LocalPath(\"src/baseline.rs\"))",""],"baseline::State::update":["update","Real(LocalPath(\"src/baseline.rs\"))",""],"baseline::update_fast_16":["update_fast_16","Real(LocalPath(\"src/baseline.rs\"))",""],"baseline::update_slow":["update_slow","Real(LocalPath(\"src/baseline.rs\"))",""],"combine::combine":["combine","Real(LocalPath(\"src/combine.rs\"))",""],"combine::gf2_matrix_square":["gf2_matrix_square","Real(LocalPath(\"src/combine.rs\"))",""],"combine::gf2_matrix_times":["gf2_matrix_times","Real(LocalPath(\"src/combine.rs\"))",""],"hash":["hash","Real(LocalPath(\"src/lib.rs\"))",""],"specialized::pclmulqdq::State::combine":["combine","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""],"specialized::pclmulqdq::State::finalize":["finalize","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""],"specialized::pclmulqdq::State::new":["new","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""],"specialized::pclmulqdq::State::reset":["reset","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""],"specialized::pclmulqdq::State::update":["update","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""],"specialized::pclmulqdq::calculate":["calculate","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""],"specialized::pclmulqdq::debug":["debug","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""],"specialized::pclmulqdq::get":["get","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""],"specialized::pclmulqdq::reduce128":["reduce128","Real(LocalPath(\"src/specialized/pclmulqdq.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["Hasher","State","baseline::State","specialized::pclmulqdq::State"],"std::default::Default":["Hasher"],"std::fmt::Debug":["Hasher"],"std::hash::Hasher":["Hasher"]},"type_to_def_path":{"Hasher":"Hasher","State":"State","baseline::State":"baseline::State","specialized::pclmulqdq::State":"specialized::pclmulqdq::State","specialized::pclmulqdq::debug::A":"specialized::pclmulqdq::debug::A"}}