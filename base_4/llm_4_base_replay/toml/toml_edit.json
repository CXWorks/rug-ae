{"dependencies":{"<&'a T as index::Index>::index":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<&'a T as index::Index>::index_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<&'k [&'k key::Key] as encode::Encode>::encode":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<&'k [key::Key] as encode::Encode>::encode":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<&'s array::Array as std::iter::IntoIterator>::into_iter":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<&'s table::Table as std::iter::IntoIterator>::into_iter":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<array::Array as encode::Encode>::encode":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec"],"<array::Array as std::clone::Clone>::clone":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<array::Array as std::default::Default>::default":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<array::Array as std::fmt::Debug>::fmt":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec"],"<array::Array as std::fmt::Display>::fmt":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec"],"<array::Array as std::iter::Extend<V>>::extend":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<array::Array as std::iter::FromIterator<V>>::from_iter":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<array::Array as std::iter::IntoIterator>::into_iter":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<array_of_tables::ArrayOfTables as std::clone::Clone>::clone":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<array_of_tables::ArrayOfTables as std::default::Default>::default":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<array_of_tables::ArrayOfTables as std::fmt::Debug>::fmt":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<array_of_tables::ArrayOfTables as std::fmt::Display>::fmt":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend":["array::Array","array_of_tables::ArrayOfTables","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter":["array::Array","array_of_tables::ArrayOfTables","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<document::Document as std::clone::Clone>::clone":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<document::Document as std::convert::From<table::Table>>::from":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<document::Document as std::default::Default>::default":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<document::Document as std::fmt::Debug>::fmt":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"<document::Document as std::ops::Deref>::deref":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<document::Document as std::ops::DerefMut>::deref_mut":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<document::Document as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<encode::StringStyle as std::clone::Clone>::clone":["encode::StringStyle"],"<encode::StringStyle as std::cmp::Eq>::assert_receiver_is_total_eq":["encode::StringStyle"],"<encode::StringStyle as std::cmp::PartialEq>::eq":["encode::StringStyle"],"<encode::StringStyle as std::fmt::Debug>::fmt":["encode::StringStyle","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<inline_table::InlineTable as encode::Encode>::encode":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String"],"<inline_table::InlineTable as std::clone::Clone>::clone":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as std::default::Default>::default":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as std::fmt::Debug>::fmt":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String"],"<inline_table::InlineTable as std::fmt::Display>::fmt":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String"],"<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<inline_table::InlineTable as std::iter::IntoIterator>::into_iter":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::clear":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::contains_key":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::entry":["indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","table::Entry","table::OccupiedEntry","table::VacantEntry"],"<inline_table::InlineTable as table::TableLike>::entry_format":["indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineTable","internal_string::InternalString","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","table::Entry","table::OccupiedEntry","table::VacantEntry"],"<inline_table::InlineTable as table::TableLike>::fmt":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::get":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::get_key_value":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::get_key_value_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::get_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::get_values":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"<inline_table::InlineTable as table::TableLike>::insert":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<inline_table::InlineTable as table::TableLike>::is_dotted":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::iter":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::iter_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::key_decor":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::key_decor_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::remove":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::set_dotted":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<inline_table::InlineTable as table::TableLike>::sort_values":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"<internal_string::InternalString as std::borrow::Borrow<str>>::borrow":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::clone::Clone>::clone":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::cmp::Eq>::assert_receiver_is_total_eq":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::cmp::Ord>::cmp":["internal_string::InternalString","std::cmp::Ordering","std::string::String"],"<internal_string::InternalString as std::cmp::PartialEq>::eq":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::cmp::PartialOrd>::partial_cmp":["internal_string::InternalString","std::marker::Sized","std::option::Option","std::string::String"],"<internal_string::InternalString as std::convert::AsRef<str>>::as_ref":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::convert::From<&std::string::String>>::from":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::convert::From<&str>>::from":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from":["internal_string::InternalString","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::string::String"],"<internal_string::InternalString as std::convert::From<std::string::String>>::from":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::default::Default>::default":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::fmt::Debug>::fmt":["internal_string::InternalString","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<internal_string::InternalString as std::fmt::Display>::fmt":["internal_string::InternalString","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<internal_string::InternalString as std::hash::Hash>::hash":["internal_string::InternalString","std::hash::Hasher","std::marker::Sized","std::string::String"],"<internal_string::InternalString as std::ops::Deref>::deref":["internal_string::InternalString","std::string::String"],"<internal_string::InternalString as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<item::Item as std::clone::Clone>::clone":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<item::Item as std::default::Default>::default":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<item::Item as std::fmt::Debug>::fmt":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"<item::Item as std::fmt::Display>::fmt":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"<item::Item as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<key::Key as encode::Encode>::encode":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<key::Key as std::clone::Clone>::clone":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::cmp::Ord>::cmp":["internal_string::InternalString","key::Key","repr::Decor","std::cmp::Ordering","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::cmp::PartialEq<&'s str>>::eq":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::cmp::PartialEq<std::string::String>>::eq":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::cmp::PartialEq<str>>::eq":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::cmp::PartialEq>::eq":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::cmp::PartialOrd>::partial_cmp":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::convert::From<&'b std::string::String>>::from":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::convert::From<&'b str>>::from":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::convert::From<internal_string::InternalString>>::from":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::convert::From<std::string::String>>::from":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::fmt::Debug>::fmt":["internal_string::InternalString","key::Key","repr::Decor","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<key::Key as std::fmt::Display>::fmt":["internal_string::InternalString","key::Key","repr::Decor","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<key::Key as std::hash::Hash>::hash":["internal_string::InternalString","key::Key","repr::Decor","std::hash::Hasher","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::ops::Deref>::deref":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::Key as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<key::KeyMut<'k> as std::cmp::Eq>::assert_receiver_is_total_eq":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::KeyMut<'k> as std::cmp::Ord>::cmp":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::cmp::Ordering","std::marker::Sized","std::option::Option","std::string::String"],"<key::KeyMut<'k> as std::cmp::PartialEq>::eq":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::KeyMut<'k> as std::cmp::PartialOrd>::partial_cmp":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::KeyMut<'k> as std::fmt::Debug>::fmt":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<key::KeyMut<'k> as std::fmt::Display>::fmt":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<key::KeyMut<'k> as std::hash::Hash>::hash":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::hash::Hasher","std::marker::Sized","std::option::Option","std::string::String"],"<key::KeyMut<'k> as std::ops::Deref>::deref":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"<parser::errors::Context as std::clone::Clone>::clone":["parser::errors::Context","parser::errors::ParserValue"],"<parser::errors::Context as std::cmp::PartialEq>::eq":["parser::errors::Context","parser::errors::ParserValue"],"<parser::errors::Context as std::fmt::Debug>::fmt":["parser::errors::Context","parser::errors::ParserValue","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<parser::errors::CustomError as std::clone::Clone>::clone":["parser::errors::CustomError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<parser::errors::CustomError as std::error::Error>::description":["parser::errors::CustomError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<parser::errors::CustomError as std::fmt::Debug>::fmt":["parser::errors::CustomError","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","std::vec::Vec"],"<parser::errors::CustomError as std::fmt::Display>::fmt":["parser::errors::CustomError","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","std::vec::Vec"],"<parser::errors::ParserError<'a> as std::fmt::Display>::fmt":["parser::errors::ParserError","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","winnow::Located"],"<parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located"],"<parser::errors::ParserError<'b> as std::fmt::Debug>::fmt":["parser::errors::ParserError","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","winnow::Located"],"<parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context":["parser::errors::Context","parser::errors::ParserError","parser::errors::ParserValue","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located"],"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located","winnow::error::ErrorKind"],"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located","winnow::error::ErrorKind"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located","winnow::error::ErrorKind"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located","winnow::error::ErrorKind"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located","winnow::error::ErrorKind"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located","winnow::error::ErrorKind"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located"],"<parser::errors::ParserValue as std::clone::Clone>::clone":["parser::errors::ParserValue"],"<parser::errors::ParserValue as std::cmp::PartialEq>::eq":["parser::errors::ParserValue"],"<parser::errors::ParserValue as std::fmt::Debug>::fmt":["parser::errors::ParserValue","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<parser::errors::ParserValue as std::fmt::Display>::fmt":["parser::errors::ParserValue","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<parser::errors::TomlError as std::clone::Clone>::clone":["parser::errors::TomlError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<parser::errors::TomlError as std::cmp::Eq>::assert_receiver_is_total_eq":["parser::errors::TomlError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<parser::errors::TomlError as std::cmp::PartialEq>::eq":["parser::errors::TomlError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<parser::errors::TomlError as std::error::Error>::description":["parser::errors::TomlError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<parser::errors::TomlError as std::fmt::Debug>::fmt":["parser::errors::TomlError","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","std::vec::Vec"],"<parser::errors::TomlError as std::fmt::Display>::fmt":["parser::errors::TomlError","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","std::vec::Vec"],"<parser::errors::TomlError as std::hash::Hash>::hash":["parser::errors::TomlError","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<parser::prelude::RecursionCheck as std::clone::Clone>::clone":["parser::prelude::RecursionCheck"],"<parser::prelude::RecursionCheck as std::default::Default>::default":["parser::prelude::RecursionCheck"],"<parser::prelude::RecursionCheck as std::fmt::Debug>::fmt":["parser::prelude::RecursionCheck","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<parser::state::ParseState as std::default::Default>::default":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<raw_string::RawString as std::clone::Clone>::clone":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::cmp::Eq>::assert_receiver_is_total_eq":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::cmp::PartialEq>::eq":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::convert::From<&std::string::String>>::from":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::convert::From<&str>>::from":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::convert::From<internal_string::InternalString>>::from":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::convert::From<std::string::String>>::from":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::default::Default>::default":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawString as std::fmt::Debug>::fmt":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::result::Result","std::string::String"],"<raw_string::RawString as std::hash::Hash>::hash":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::hash::Hasher","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawStringInner as std::clone::Clone>::clone":["internal_string::InternalString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawStringInner as std::cmp::Eq>::assert_receiver_is_total_eq":["internal_string::InternalString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawStringInner as std::cmp::PartialEq>::eq":["internal_string::InternalString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"<raw_string::RawStringInner as std::hash::Hash>::hash":["internal_string::InternalString","raw_string::RawStringInner","std::hash::Hasher","std::marker::Sized","std::ops::Range","std::string::String"],"<repr::Decor as std::clone::Clone>::clone":["repr::Decor","std::marker::Sized","std::option::Option"],"<repr::Decor as std::cmp::Eq>::assert_receiver_is_total_eq":["repr::Decor","std::marker::Sized","std::option::Option"],"<repr::Decor as std::cmp::PartialEq>::eq":["repr::Decor","std::marker::Sized","std::option::Option"],"<repr::Decor as std::default::Default>::default":["repr::Decor","std::marker::Sized","std::option::Option"],"<repr::Decor as std::fmt::Debug>::fmt":["repr::Decor","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<repr::Decor as std::hash::Hash>::hash":["repr::Decor","std::hash::Hasher","std::marker::Sized","std::option::Option"],"<repr::Formatted<T> as encode::Encode>::encode":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","std::result::Result"],"<repr::Formatted<T> as std::clone::Clone>::clone":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"<repr::Formatted<T> as std::cmp::PartialEq>::eq":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"<repr::Formatted<T> as std::fmt::Debug>::fmt":["repr::Decor","repr::Formatted","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<repr::Formatted<T> as std::fmt::Display>::fmt":["repr::Decor","repr::Formatted","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<repr::Formatted<T> as std::hash::Hash>::hash":["repr::Decor","repr::Formatted","std::hash::Hasher","std::marker::Sized","std::option::Option"],"<repr::Repr as std::clone::Clone>::clone":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"<repr::Repr as std::cmp::Eq>::assert_receiver_is_total_eq":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"<repr::Repr as std::cmp::PartialEq>::eq":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"<repr::Repr as std::fmt::Debug>::fmt":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::result::Result","std::string::String"],"<repr::Repr as std::hash::Hash>::hash":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::hash::Hasher","std::marker::Sized","std::ops::Range","std::string::String"],"<std::string::String as index::Index>::index":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<std::string::String as index::Index>::index_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<str as index::Index>::index":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<str as index::Index>::index_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<table::Table as std::clone::Clone>::clone":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as std::default::Default>::default":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as std::fmt::Debug>::fmt":["indexmap::IndexMap","repr::Decor","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","table::Table"],"<table::Table as std::fmt::Display>::fmt":["indexmap::IndexMap","repr::Decor","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","table::Table"],"<table::Table as std::iter::Extend<(K, V)>>::extend":["array::Array","indexmap::IndexMap","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table"],"<table::Table as std::iter::FromIterator<(K, V)>>::from_iter":["array::Array","indexmap::IndexMap","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table"],"<table::Table as std::iter::IntoIterator>::into_iter":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::clear":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::contains_key":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::entry":["indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","repr::Decor","std::marker::Sized","std::option::Option","table::Entry","table::OccupiedEntry","table::Table","table::VacantEntry"],"<table::Table as table::TableLike>::entry_format":["indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String","table::Entry","table::OccupiedEntry","table::Table","table::VacantEntry"],"<table::Table as table::TableLike>::fmt":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::get":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::get_key_value":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::get_key_value_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::get_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::get_values":["indexmap::IndexMap","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","table::Table"],"<table::Table as table::TableLike>::insert":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<table::Table as table::TableLike>::is_dotted":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::iter":["indexmap::IndexMap","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::iter_mut":["indexmap::IndexMap","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::key_decor":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::key_decor_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::remove":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::set_dotted":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::Table as table::TableLike>::sort_values":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"<table::TableKeyValue as std::clone::Clone>::clone":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","table::TableKeyValue","value::Value"],"<table::TableKeyValue as std::fmt::Debug>::fmt":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","table::TableKeyValue","value::Value"],"<usize as index::Index>::index":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<usize as index::Index>::index_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"<value::Value as encode::Encode>::encode":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::clone::Clone>::clone":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<&'b internal_string::InternalString>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<&'b std::string::String>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<&'b str>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<&'b value::Value>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<array::Array>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<bool>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<f64>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<i64>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<inline_table::InlineTable>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<internal_string::InternalString>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<std::string::String>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::convert::From<toml_datetime::Date>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Date","value::Value"],"<value::Value as std::convert::From<toml_datetime::Datetime>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Datetime","value::Value"],"<value::Value as std::convert::From<toml_datetime::Time>>::from":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","toml_datetime::Time","value::Value"],"<value::Value as std::fmt::Debug>::fmt":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::fmt::Display>::fmt":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::iter::FromIterator<(K, V)>>::from_iter":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::iter::FromIterator<V>>::from_iter":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"array::Array":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::clear":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::decor":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::decor_mut":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::despan":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::fmt":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::get":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::get_mut":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::insert":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::insert_formatted":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"array::Array::is_empty":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::iter":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::iter_mut":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::len":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::new":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::push":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::push_formatted":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"array::Array::remove":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"array::Array::replace":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"array::Array::replace_formatted":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"array::Array::set_trailing":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::set_trailing_comma":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::span":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::trailing":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::trailing_comma":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::Array::value_op":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::FnOnce","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"array::Array::with_vec":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array::decorate_array":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array_of_tables::ArrayOfTables":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::clear":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::despan":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::get":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::get_mut":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::into_array":["array::Array","array_of_tables::ArrayOfTables","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"array_of_tables::ArrayOfTables::is_empty":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::iter":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::iter_mut":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::len":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::new":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::push":["array_of_tables::ArrayOfTables","indexmap::IndexMap","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","table::Table"],"array_of_tables::ArrayOfTables::remove":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"array_of_tables::ArrayOfTables::span":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"document::Document":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::as_item":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::as_item_mut":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::as_table":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::as_table_mut":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::despan":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::iter":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::new":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::set_trailing":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"document::Document::trailing":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"encode::<impl repr::ValueRepr for bool>::to_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"encode::<impl repr::ValueRepr for f64>::to_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"encode::<impl repr::ValueRepr for i64>::to_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"encode::<impl repr::ValueRepr for std::string::String>::to_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String","toml_datetime::Datetime"],"encode::<impl std::fmt::Display for document::Document>::fmt":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"encode::Encode::encode":["std::marker::Sized","std::option::Option","std::result::Result"],"encode::StringStyle":["encode::StringStyle"],"encode::StringStyle::literal_end":["encode::StringStyle"],"encode::StringStyle::literal_start":["encode::StringStyle"],"encode::StringStyle::standard_end":["encode::StringStyle"],"encode::StringStyle::standard_start":["encode::StringStyle"],"encode::infer_style":["encode::StringStyle"],"encode::to_f64_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"encode::to_string_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"encode::visit_nested_tables":["indexmap::IndexMap","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::FnMut","std::option::Option","std::result::Result","std::vec::Vec","table::Table"],"encode::visit_table":["indexmap::IndexMap","internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","table::Table"],"index::<impl std::ops::Index<&'s str> for document::Document>::index":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"index::<impl std::ops::Index<&'s str> for table::Table>::index":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"index::<impl std::ops::Index<I> for item::Item>::index":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"index::<impl std::ops::IndexMut<I> for item::Item>::index_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"index::Index::index":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"index::Index::index_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"inline_table::InlineEntry":["indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineEntry","inline_table::InlineOccupiedEntry","inline_table::InlineVacantEntry","std::marker::Sized","std::option::Option"],"inline_table::InlineEntry::<'a>::key":["indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineEntry","inline_table::InlineOccupiedEntry","inline_table::InlineVacantEntry","std::marker::Sized","std::option::Option"],"inline_table::InlineEntry::<'a>::or_insert":["array::Array","indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","inline_table::InlineVacantEntry","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineEntry::<'a>::or_insert_with":["array::Array","indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","inline_table::InlineVacantEntry","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::FnOnce","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineOccupiedEntry":["indexmap::map::OccupiedEntry","inline_table::InlineOccupiedEntry","std::marker::Sized"],"inline_table::InlineOccupiedEntry::<'a>::get":["array::Array","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineOccupiedEntry::<'a>::get_mut":["array::Array","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineOccupiedEntry::<'a>::insert":["array::Array","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineOccupiedEntry::<'a>::into_mut":["array::Array","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineOccupiedEntry::<'a>::key":["indexmap::map::OccupiedEntry","inline_table::InlineOccupiedEntry","std::marker::Sized"],"inline_table::InlineOccupiedEntry::<'a>::key_mut":["indexmap::map::OccupiedEntry","inline_table::InlineOccupiedEntry","internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"inline_table::InlineOccupiedEntry::<'a>::remove":["array::Array","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineTable":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::append_values":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"inline_table::InlineTable::clear":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::contains_key":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::decor":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::decor_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::despan":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::entry":["indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","inline_table::InlineVacantEntry","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::entry_format":["indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineEntry","inline_table::InlineOccupiedEntry","inline_table::InlineTable","inline_table::InlineVacantEntry","internal_string::InternalString","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::fmt":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::get":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::get_key_value":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::get_key_value_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::get_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::get_or_insert":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineTable::get_values":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"inline_table::InlineTable::insert":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineTable::insert_formatted":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineTable::into_table":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","table::Table"],"inline_table::InlineTable::is_dotted":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::is_empty":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::iter":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::iter_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::key_decor":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::key_decor_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::len":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::new":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::preamble":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::remove":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::remove_entry":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::set_dotted":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::set_preamble":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::sort_values":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::sort_values_by":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::FnMut","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::sort_values_by_internal":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::FnMut","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::span":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineTable::with_pairs":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"inline_table::InlineVacantEntry":["indexmap::map::VacantEntry","inline_table::InlineVacantEntry","std::marker::Sized","std::option::Option"],"inline_table::InlineVacantEntry::<'a>::insert":["array::Array","indexmap::IndexMap","indexmap::map::VacantEntry","inline_table::InlineTable","inline_table::InlineVacantEntry","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"inline_table::InlineVacantEntry::<'a>::key":["indexmap::map::VacantEntry","inline_table::InlineVacantEntry","std::marker::Sized","std::option::Option"],"inline_table::decorate_inline_table":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"internal_string::InternalString":["internal_string::InternalString","std::string::String"],"internal_string::InternalString::as_str":["internal_string::InternalString","std::string::String"],"internal_string::InternalString::new":["internal_string::InternalString","std::string::String"],"item::Item":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_array":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_array_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_array_of_tables":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_array_of_tables_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_bool":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_datetime":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_float":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_inline_table":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_inline_table_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_integer":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_str":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_table":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_table_like":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_table_like_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_table_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_value":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::as_value_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::despan":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::get":["array::Array","array_of_tables::ArrayOfTables","index::Index","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::get_mut":["array::Array","array_of_tables::ArrayOfTables","index::Index","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::into_array_of_tables":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::into_table":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::into_value":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_array":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_array_of_tables":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_bool":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_datetime":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_float":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_inline_table":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_integer":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_none":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_str":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_table":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_table_like":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::is_value":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::make_item":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::make_value":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::or_insert":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::span":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::Item::type_name":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::array":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::table":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"item::value":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::as_mut":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::as_repr":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::decor":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::decor_mut":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::default_repr":["internal_string::InternalString","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Repr","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"key::Key::despan":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::display_repr":["internal_string::InternalString","key::Key","repr::Decor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::fmt":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::get":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::get_internal":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::new":["internal_string::InternalString","key::Key","repr::Decor","std::convert::Into","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::parse":["std::marker::Sized","std::result::Result"],"key::Key::try_parse_path":["std::marker::Sized","std::result::Result"],"key::Key::try_parse_simple":["std::marker::Sized","std::result::Result"],"key::Key::with_decor":["internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::Key::with_repr_unchecked":["internal_string::InternalString","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Repr","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"key::KeyMut":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::KeyMut::<'k>::as_repr":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::KeyMut::<'k>::decor":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::KeyMut::<'k>::decor_mut":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::KeyMut::<'k>::default_repr":["internal_string::InternalString","key::Key","key::KeyMut","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Repr","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"key::KeyMut::<'k>::display_repr":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::string::String"],"key::KeyMut::<'k>::fmt":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::KeyMut::<'k>::get":["internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String"],"key::to_key_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"parser::array::array":["parser::prelude::RecursionCheck"],"parser::array::array_value":["parser::prelude::RecursionCheck"],"parser::array::array_values":["parser::prelude::RecursionCheck"],"parser::datetime::date_fullyear":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::date_mday":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::date_month":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::date_time":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::full_date":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::partial_time":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::time_delim":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::time_hour":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::time_minute":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::time_offset":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::time_secfrac":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::time_second":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::datetime::unsigned_digits":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::document::document":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::document::keyval":["std::cell::RefCell"],"parser::document::parse_comment":["std::cell::RefCell"],"parser::document::parse_keyval":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::document::parse_newline":["std::cell::RefCell"],"parser::document::parse_ws":["std::cell::RefCell"],"parser::errors::Context":["parser::errors::Context","parser::errors::ParserValue"],"parser::errors::CustomError":["parser::errors::CustomError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"parser::errors::CustomError::duplicate_key":["internal_string::InternalString","key::Key","parser::errors::CustomError","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"parser::errors::CustomError::extend_wrong_type":["internal_string::InternalString","key::Key","parser::errors::CustomError","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"parser::errors::ParserError":["parser::errors::ParserError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","winnow::Located"],"parser::errors::ParserValue":["parser::errors::ParserValue"],"parser::errors::TomlError":["parser::errors::TomlError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"parser::errors::TomlError::message":["parser::errors::TomlError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"parser::errors::TomlError::new":["parser::errors::ParserError","parser::errors::TomlError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","winnow::Located"],"parser::errors::TomlError::span":["parser::errors::TomlError","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"parser::errors::translate_position":[],"parser::inline_table::descend_path":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String"],"parser::inline_table::inline_table":["parser::prelude::RecursionCheck"],"parser::inline_table::inline_table_keyvals":["parser::prelude::RecursionCheck"],"parser::inline_table::keyval":["parser::prelude::RecursionCheck"],"parser::inline_table::table_from_pairs":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::result::Result","std::string::String","std::vec::Vec"],"parser::key::is_unquoted_char":[],"parser::key::key":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::key::simple_key":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::key::unquoted_key":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::bin_int":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::boolean":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::dec_int":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::digit":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::exp":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::false_":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::float":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::float_":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::frac":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::hex_int":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::hexdig":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::inf":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::integer":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::nan":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::oct_int":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::special_float":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::true_":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::numbers::zero_prefixable_int":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::parse_document":["std::marker::Sized","std::result::Result"],"parser::parse_key":["std::marker::Sized","std::result::Result"],"parser::parse_key_path":["std::marker::Sized","std::result::Result"],"parser::parse_value":["std::marker::Sized","std::result::Result"],"parser::prelude::RecursionCheck":["parser::prelude::RecursionCheck"],"parser::prelude::RecursionCheck::check_depth":["std::marker::Sized","std::result::Result"],"parser::prelude::RecursionCheck::recursing":["parser::prelude::RecursionCheck","std::marker::Sized","std::result::Result","winnow::Located"],"parser::prelude::new_input":["std::marker::Sized","winnow::Located"],"parser::prelude::ok_error":["std::marker::Sized","std::result::Result"],"parser::prelude::trace":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","winnow::Parser"],"parser::state::ParseState":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::state::ParseState::descend_path":["indexmap::IndexMap","internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","table::Table"],"parser::state::ParseState::finalize_table":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::state::ParseState::into_document":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::state::ParseState::on_array_header":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::state::ParseState::on_comment":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::state::ParseState::on_keyval":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","table::TableKeyValue","value::Value"],"parser::state::ParseState::on_std_header":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::state::ParseState::on_ws":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::state::ParseState::start_aray_table":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::state::ParseState::start_table":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::state::ParseState","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","table::Table","value::Value"],"parser::strings::basic_chars":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::basic_string":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::escape_seq_char":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::escaped":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::hexescape":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::literal_string":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::ml_basic_body":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::ml_basic_string":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::ml_literal_body":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::ml_literal_string":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::mlb_content":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::mlb_escaped_nl":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::mlb_quotes":["std::marker::Sized","winnow::Parser"],"parser::strings::mll_content":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::strings::mll_quotes":["std::marker::Sized","winnow::Parser"],"parser::strings::string":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::table::array_table":["std::cell::RefCell"],"parser::table::std_table":["std::cell::RefCell"],"parser::table::table":["std::cell::RefCell"],"parser::trivia::comment":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::trivia::from_utf8_unchecked":[],"parser::trivia::line_ending":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::trivia::line_trailing":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::trivia::newline":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::trivia::ws":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::trivia::ws_comment_newline":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::trivia::ws_newline":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::trivia::ws_newlines":["std::marker::Sized","std::result::Result","winnow::Located"],"parser::value::apply_raw":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"parser::value::value":["parser::prelude::RecursionCheck"],"raw_string::RawString":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"raw_string::RawString::as_str":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"raw_string::RawString::despan":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"raw_string::RawString::encode":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::result::Result","std::string::String"],"raw_string::RawString::encode_with_default":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::string::String"],"raw_string::RawString::span":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"raw_string::RawString::to_str":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"raw_string::RawString::to_str_with_default":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"raw_string::RawString::with_span":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"raw_string::RawStringInner":["internal_string::InternalString","raw_string::RawStringInner","std::marker::Sized","std::ops::Range","std::string::String"],"repr::Decor":["repr::Decor","std::marker::Sized","std::option::Option"],"repr::Decor::clear":["repr::Decor","std::marker::Sized","std::option::Option"],"repr::Decor::despan":["repr::Decor","std::marker::Sized","std::option::Option"],"repr::Decor::new":["repr::Decor","std::convert::Into","std::marker::Sized","std::option::Option"],"repr::Decor::prefix":["repr::Decor","std::marker::Sized","std::option::Option"],"repr::Decor::prefix_encode":["repr::Decor","std::marker::Sized","std::option::Option","std::result::Result"],"repr::Decor::set_prefix":["repr::Decor","std::convert::Into","std::marker::Sized","std::option::Option"],"repr::Decor::set_suffix":["repr::Decor","std::convert::Into","std::marker::Sized","std::option::Option"],"repr::Decor::suffix":["repr::Decor","std::marker::Sized","std::option::Option"],"repr::Decor::suffix_encode":["repr::Decor","std::marker::Sized","std::option::Option","std::result::Result"],"repr::Formatted":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::as_repr":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::decor":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::decor_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::default_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","repr::Repr","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"repr::Formatted::<T>::despan":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::display_repr":["repr::Decor","repr::Formatted","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::fmt":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::into_value":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::new":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::set_repr_unchecked":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","repr::Repr","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"repr::Formatted::<T>::span":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Formatted::<T>::value":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"repr::Repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"repr::Repr::as_raw":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"repr::Repr::despan":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"repr::Repr::encode":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::result::Result","std::string::String"],"repr::Repr::new_unchecked":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::convert::Into","std::marker::Sized","std::ops::Range","std::string::String"],"repr::Repr::span":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"repr::ValueRepr::to_repr":["internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Repr","std::marker::Sized","std::ops::Range","std::string::String"],"table::Entry":["indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","std::marker::Sized","std::option::Option","table::Entry","table::OccupiedEntry","table::VacantEntry"],"table::Entry::<'a>::key":["indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","std::marker::Sized","std::option::Option","table::Entry","table::OccupiedEntry","table::VacantEntry"],"table::Entry::<'a>::or_insert":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Entry","table::OccupiedEntry","table::Table","table::VacantEntry","value::Value"],"table::Entry::<'a>::or_insert_with":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::FnOnce","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Entry","table::OccupiedEntry","table::Table","table::VacantEntry","value::Value"],"table::OccupiedEntry":["indexmap::map::OccupiedEntry","std::marker::Sized","table::OccupiedEntry"],"table::OccupiedEntry::<'a>::get":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::OccupiedEntry","table::Table","value::Value"],"table::OccupiedEntry::<'a>::get_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::OccupiedEntry","table::Table","value::Value"],"table::OccupiedEntry::<'a>::insert":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::OccupiedEntry","table::Table","value::Value"],"table::OccupiedEntry::<'a>::into_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::OccupiedEntry","table::Table","value::Value"],"table::OccupiedEntry::<'a>::key":["indexmap::map::OccupiedEntry","std::marker::Sized","table::OccupiedEntry"],"table::OccupiedEntry::<'a>::key_mut":["indexmap::map::OccupiedEntry","internal_string::InternalString","key::Key","key::KeyMut","repr::Decor","std::marker::Sized","std::option::Option","std::string::String","table::OccupiedEntry"],"table::OccupiedEntry::<'a>::remove":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","indexmap::map::OccupiedEntry","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::OccupiedEntry","table::Table","value::Value"],"table::Table":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::append_values":["indexmap::IndexMap","internal_string::InternalString","key::Key","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","table::Table"],"table::Table::clear":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::contains_array_of_tables":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::contains_key":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::contains_table":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::contains_value":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::decor":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::decor_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::despan":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::entry":["indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","repr::Decor","std::marker::Sized","std::option::Option","table::Entry","table::OccupiedEntry","table::Table","table::VacantEntry"],"table::Table::entry_format":["indexmap::IndexMap","indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String","table::Entry","table::OccupiedEntry","table::Table","table::VacantEntry"],"table::Table::fmt":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::get":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::get_key_value":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::get_key_value_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::get_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::get_values":["indexmap::IndexMap","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","table::Table"],"table::Table::insert":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"table::Table::insert_formatted":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"table::Table::into_inline_table":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","table::Table"],"table::Table::is_dotted":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::is_empty":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::is_implicit":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::iter":["indexmap::IndexMap","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","table::Table"],"table::Table::iter_mut":["indexmap::IndexMap","repr::Decor","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","table::Table"],"table::Table::key_decor":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::key_decor_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::len":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::new":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::position":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::remove":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::remove_entry":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::set_dotted":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::set_implicit":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::set_position":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::sort_values":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::sort_values_by":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::ops::FnMut","std::option::Option","table::Table"],"table::Table::sort_values_by_internal":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::ops::FnMut","std::option::Option","table::Table"],"table::Table::span":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::with_pairs":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::Table::with_pos":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"table::TableKeyValue":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","table::TableKeyValue","value::Value"],"table::TableKeyValue::new":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","table::TableKeyValue","value::Value"],"table::TableLike::clear":[],"table::TableLike::contains_key":[],"table::TableLike::entry":["indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","std::marker::Sized","std::option::Option","table::Entry","table::OccupiedEntry","table::VacantEntry"],"table::TableLike::entry_format":["indexmap::map::OccupiedEntry","indexmap::map::VacantEntry","internal_string::InternalString","key::Key","repr::Decor","std::marker::Sized","std::option::Option","std::string::String","table::Entry","table::OccupiedEntry","table::VacantEntry"],"table::TableLike::fmt":[],"table::TableLike::get":["std::marker::Sized","std::option::Option"],"table::TableLike::get_key_value":["std::marker::Sized","std::option::Option"],"table::TableLike::get_key_value_mut":["std::marker::Sized","std::option::Option"],"table::TableLike::get_mut":["std::marker::Sized","std::option::Option"],"table::TableLike::get_values":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"table::TableLike::insert":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"table::TableLike::is_dotted":[],"table::TableLike::is_empty":[],"table::TableLike::iter":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"table::TableLike::iter_mut":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"table::TableLike::key_decor":["std::marker::Sized","std::option::Option"],"table::TableLike::key_decor_mut":["std::marker::Sized","std::option::Option"],"table::TableLike::len":[],"table::TableLike::remove":["std::marker::Sized","std::option::Option"],"table::TableLike::set_dotted":[],"table::TableLike::sort_values":[],"table::VacantEntry":["indexmap::map::VacantEntry","std::marker::Sized","std::option::Option","table::VacantEntry"],"table::VacantEntry::<'a>::insert":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","indexmap::map::VacantEntry","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","table::VacantEntry","value::Value"],"table::VacantEntry::<'a>::key":["indexmap::map::VacantEntry","std::marker::Sized","std::option::Option","table::VacantEntry"],"table::decorate_table":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"value::Value":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_array":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_array_mut":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_bool":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_datetime":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_float":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_inline_table":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_inline_table_mut":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_integer":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_str":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::decor":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::decor_mut":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::decorate":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::decorated":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::despan":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_array":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_bool":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_datetime":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_float":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_inline_table":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_integer":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_str":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::span":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::type_name":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"visit::Visit::visit_array":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"visit::Visit::visit_array_of_tables":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"visit::Visit::visit_boolean":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit::Visit::visit_datetime":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit::Visit::visit_document":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"visit::Visit::visit_float":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit::Visit::visit_inline_table":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"visit::Visit::visit_integer":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit::Visit::visit_item":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"visit::Visit::visit_string":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit::Visit::visit_table":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"visit::Visit::visit_table_like":[],"visit::Visit::visit_table_like_kv":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"visit::Visit::visit_value":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"visit::visit_array":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","visit::Visit"],"visit::visit_array_of_tables":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","visit::Visit"],"visit::visit_boolean":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit::Visit"],"visit::visit_datetime":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit::Visit"],"visit::visit_document":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value","visit::Visit"],"visit::visit_float":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit::Visit"],"visit::visit_inline_table":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","visit::Visit"],"visit::visit_integer":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit::Visit"],"visit::visit_item":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value","visit::Visit"],"visit::visit_string":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit::Visit"],"visit::visit_table":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table","visit::Visit"],"visit::visit_table_like":["visit::Visit"],"visit::visit_table_like_kv":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value","visit::Visit"],"visit::visit_value":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value","visit::Visit"],"visit_mut::VisitMut::visit_array_mut":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec"],"visit_mut::VisitMut::visit_array_of_tables_mut":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"visit_mut::VisitMut::visit_boolean_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit_mut::VisitMut::visit_datetime_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit_mut::VisitMut::visit_document_mut":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"visit_mut::VisitMut::visit_float_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit_mut::VisitMut::visit_inline_table_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String"],"visit_mut::VisitMut::visit_integer_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit_mut::VisitMut::visit_item_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"visit_mut::VisitMut::visit_string_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option"],"visit_mut::VisitMut::visit_table_like_kv_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","key::KeyMut","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value"],"visit_mut::VisitMut::visit_table_like_mut":[],"visit_mut::VisitMut::visit_table_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table"],"visit_mut::VisitMut::visit_value_mut":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"visit_mut::visit_array_mut":["array::Array","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","visit_mut::VisitMut"],"visit_mut::visit_array_of_tables_mut":["array_of_tables::ArrayOfTables","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","visit_mut::VisitMut"],"visit_mut::visit_boolean_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit_mut::VisitMut"],"visit_mut::visit_datetime_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit_mut::VisitMut"],"visit_mut::visit_document_mut":["array::Array","array_of_tables::ArrayOfTables","document::Document","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value","visit_mut::VisitMut"],"visit_mut::visit_float_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit_mut::VisitMut"],"visit_mut::visit_inline_table_mut":["indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","visit_mut::VisitMut"],"visit_mut::visit_integer_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit_mut::VisitMut"],"visit_mut::visit_item_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value","visit_mut::VisitMut"],"visit_mut::visit_string_mut":["repr::Decor","repr::Formatted","std::marker::Sized","std::option::Option","visit_mut::VisitMut"],"visit_mut::visit_table_like_kv_mut":["array::Array","array_of_tables::ArrayOfTables","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","key::KeyMut","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","table::Table","value::Value","visit_mut::VisitMut"],"visit_mut::visit_table_like_mut":["visit_mut::VisitMut"],"visit_mut::visit_table_mut":["indexmap::IndexMap","repr::Decor","std::marker::Sized","std::option::Option","table::Table","visit_mut::VisitMut"],"visit_mut::visit_value_mut":["array::Array","indexmap::IndexMap","inline_table::InlineTable","internal_string::InternalString","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","std::alloc::Allocator","std::marker::Sized","std::ops::Range","std::option::Option","std::string::String","std::vec::Vec","value::Value","visit_mut::VisitMut"]},"glob_path_import":{"toml_datetime":""},"self_to_fn":{"array::Array":["Clone","Debug","Default","impl Array {\n    /// Auto formats the array.\n    pub fn fmt(&mut self) {\n        decorate_array(self);\n    }\n\n    /// Set whether the array will use a trailing comma\n    pub fn set_trailing_comma(&mut self, yes: bool) {\n        self.trailing_comma = yes;\n    }\n\n    /// Whether the array will use a trailing comma\n    pub fn trailing_comma(&self) -> bool {\n        self.trailing_comma\n    }\n\n    /// Set whitespace after last element\n    pub fn set_trailing(&mut self, trailing: impl Into<RawString>) {\n        self.trailing = trailing.into();\n    }\n\n    /// Whitespace after last element\n    pub fn trailing(&self) -> &RawString {\n        &self.trailing\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor_mut(&mut self) -> &mut Decor {\n        &mut self.decor\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor(&self) -> &Decor {\n        &self.decor\n    }\n\n    /// Returns the location within the original document\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.span.clone()\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        self.span = None;\n        self.decor.despan(input);\n        self.trailing.despan(input);\n        for value in &mut self.values {\n            value.despan(input);\n        }\n    }\n}","impl Array {\n    /// Create an empty `Array`\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// ```\n    pub fn new() -> Self {\n        Default::default()\n    }\n\n    pub(crate) fn with_vec(values: Vec<Item>) -> Self {\n        Self {\n            values,\n            ..Default::default()\n        }\n    }\n}","impl Array {\n    /// Returns an iterator over all values.\n    pub fn iter(&self) -> ArrayIter<'_> {\n        Box::new(self.values.iter().filter_map(Item::as_value))\n    }\n\n    /// Returns an iterator over all values.\n    pub fn iter_mut(&mut self) -> ArrayIterMut<'_> {\n        Box::new(self.values.iter_mut().filter_map(Item::as_value_mut))\n    }\n\n    /// Returns the length of the underlying Vec.\n    ///\n    /// In some rare cases, placeholder elements will exist.  For a more accurate count, call\n    /// `a.iter().count()`\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// arr.push(1);\n    /// arr.push(\"foo\");\n    /// assert_eq!(arr.len(), 2);\n    /// ```\n    pub fn len(&self) -> usize {\n        self.values.len()\n    }\n\n    /// Return true iff `self.len() == 0`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// assert!(arr.is_empty());\n    ///\n    /// arr.push(1);\n    /// arr.push(\"foo\");\n    /// assert!(! arr.is_empty());\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Clears the array, removing all values. Keeps the allocated memory for reuse.\n    pub fn clear(&mut self) {\n        self.values.clear()\n    }\n\n    /// Returns a reference to the value at the given index, or `None` if the index is out of\n    /// bounds.\n    pub fn get(&self, index: usize) -> Option<&Value> {\n        self.values.get(index).and_then(Item::as_value)\n    }\n\n    /// Returns a reference to the value at the given index, or `None` if the index is out of\n    /// bounds.\n    pub fn get_mut(&mut self, index: usize) -> Option<&mut Value> {\n        self.values.get_mut(index).and_then(Item::as_value_mut)\n    }\n\n    /// Appends a new value to the end of the array, applying default formatting to it.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// arr.push(1);\n    /// arr.push(\"foo\");\n    /// ```\n    pub fn push<V: Into<Value>>(&mut self, v: V) {\n        self.value_op(v.into(), true, |items, value| {\n            items.push(Item::Value(value))\n        })\n    }\n\n    /// Appends a new, already formatted value to the end of the array.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let formatted_value = \"'literal'\".parse::<toml_edit::Value>().unwrap();\n    /// let mut arr = toml_edit::Array::new();\n    /// arr.push_formatted(formatted_value);\n    /// ```\n    pub fn push_formatted(&mut self, v: Value) {\n        self.values.push(Item::Value(v));\n    }\n\n    /// Inserts an element at the given position within the array, applying default formatting to\n    /// it and shifting all values after it to the right.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// arr.push(1);\n    /// arr.push(\"foo\");\n    ///\n    /// arr.insert(0, \"start\");\n    /// ```\n    pub fn insert<V: Into<Value>>(&mut self, index: usize, v: V) {\n        self.value_op(v.into(), true, |items, value| {\n            items.insert(index, Item::Value(value))\n        })\n    }\n\n    /// Inserts an already formatted value at the given position within the array, shifting all\n    /// values after it to the right.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// arr.push(1);\n    /// arr.push(\"foo\");\n    ///\n    /// let formatted_value = \"'start'\".parse::<toml_edit::Value>().unwrap();\n    /// arr.insert_formatted(0, formatted_value);\n    /// ```\n    pub fn insert_formatted(&mut self, index: usize, v: Value) {\n        self.values.insert(index, Item::Value(v))\n    }\n\n    /// Replaces the element at the given position within the array, preserving existing formatting.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index >= len`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// arr.push(1);\n    /// arr.push(\"foo\");\n    ///\n    /// arr.replace(0, \"start\");\n    /// ```\n    pub fn replace<V: Into<Value>>(&mut self, index: usize, v: V) -> Value {\n        // Read the existing value's decor and preserve it.\n        let existing_decor = self\n            .get(index)\n            .unwrap_or_else(|| panic!(\"index {} out of bounds (len = {})\", index, self.len()))\n            .decor();\n        let mut value = v.into();\n        *value.decor_mut() = existing_decor.clone();\n        self.replace_formatted(index, value)\n    }\n\n    /// Replaces the element at the given position within the array with an already formatted value.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index >= len`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// arr.push(1);\n    /// arr.push(\"foo\");\n    ///\n    /// let formatted_value = \"'start'\".parse::<toml_edit::Value>().unwrap();\n    /// arr.replace_formatted(0, formatted_value);\n    /// ```\n    pub fn replace_formatted(&mut self, index: usize, v: Value) -> Value {\n        match mem::replace(&mut self.values[index], Item::Value(v)) {\n            Item::Value(old_value) => old_value,\n            x => panic!(\"non-value item {:?} in an array\", x),\n        }\n    }\n\n    /// Removes the value at the given index.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let mut arr = toml_edit::Array::new();\n    /// arr.push(1);\n    /// arr.push(\"foo\");\n    ///\n    /// arr.remove(0);\n    /// assert_eq!(arr.len(), 1);\n    /// ```\n    pub fn remove(&mut self, index: usize) -> Value {\n        let removed = self.values.remove(index);\n        match removed {\n            Item::Value(v) => v,\n            x => panic!(\"non-value item {:?} in an array\", x),\n        }\n    }\n\n    fn value_op<T>(\n        &mut self,\n        v: Value,\n        decorate: bool,\n        op: impl FnOnce(&mut Vec<Item>, Value) -> T,\n    ) -> T {\n        let mut value = v;\n        if !self.is_empty() && decorate {\n            value.decorate(\" \", \"\");\n        } else if decorate {\n            value.decorate(\"\", \"\");\n        }\n        op(&mut self.values, value)\n    }\n}","impl Encode for Array {\n    fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result {\n        let decor = self.decor();\n        decor.prefix_encode(buf, input, default_decor.0)?;\n        write!(buf, \"[\")?;\n\n        for (i, elem) in self.iter().enumerate() {\n            let inner_decor;\n            if i == 0 {\n                inner_decor = DEFAULT_LEADING_VALUE_DECOR;\n            } else {\n                inner_decor = DEFAULT_VALUE_DECOR;\n                write!(buf, \",\")?;\n            }\n            elem.encode(buf, input, inner_decor)?;\n        }\n        if self.trailing_comma() && !self.is_empty() {\n            write!(buf, \",\")?;\n        }\n\n        self.trailing().encode_with_default(buf, input, \"\")?;\n        write!(buf, \"]\")?;\n        decor.suffix_encode(buf, input, default_decor.1)?;\n\n        Ok(())\n    }\n}","impl IntoIterator for Array {\n    type Item = Value;\n    type IntoIter = ArrayIntoIter;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Box::new(\n            self.values\n                .into_iter()\n                .filter(|v| v.is_value())\n                .map(|v| v.into_value().unwrap()),\n        )\n    }\n}","impl std::fmt::Display for Array {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }\n}","impl<V: Into<Value>> Extend<V> for Array {\n    fn extend<T: IntoIterator<Item = V>>(&mut self, iter: T) {\n        for value in iter {\n            self.push_formatted(value.into());\n        }\n    }\n}","impl<V: Into<Value>> FromIterator<V> for Array {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = V>,\n    {\n        let v = iter.into_iter().map(|a| Item::Value(a.into()));\n        Array {\n            values: v.collect(),\n            ..Default::default()\n        }\n    }\n}"],"array_of_tables::ArrayOfTables":["Clone","Debug","Default","impl ArrayOfTables {\n    /// Convert to an inline array\n    pub fn into_array(mut self) -> Array {\n        for value in self.values.iter_mut() {\n            value.make_value();\n        }\n        let mut a = Array::with_vec(self.values);\n        a.fmt();\n        a\n    }\n\n    /// Returns the location within the original document\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.span.clone()\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        self.span = None;\n        for value in &mut self.values {\n            value.despan(input);\n        }\n    }\n}","impl ArrayOfTables {\n    /// Creates an empty array of tables.\n    pub fn new() -> Self {\n        Default::default()\n    }\n}","impl ArrayOfTables {\n    /// Returns an iterator over tables.\n    pub fn iter(&self) -> ArrayOfTablesIter<'_> {\n        Box::new(self.values.iter().filter_map(Item::as_table))\n    }\n\n    /// Returns an iterator over tables.\n    pub fn iter_mut(&mut self) -> ArrayOfTablesIterMut<'_> {\n        Box::new(self.values.iter_mut().filter_map(Item::as_table_mut))\n    }\n\n    /// Returns the length of the underlying Vec.\n    /// To get the actual number of items use `a.iter().count()`.\n    pub fn len(&self) -> usize {\n        self.values.len()\n    }\n\n    /// Returns true iff `self.len() == 0`.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Removes all the tables.\n    pub fn clear(&mut self) {\n        self.values.clear()\n    }\n\n    /// Returns an optional reference to the table.\n    pub fn get(&self, index: usize) -> Option<&Table> {\n        self.values.get(index).and_then(Item::as_table)\n    }\n\n    /// Returns an optional mutable reference to the table.\n    pub fn get_mut(&mut self, index: usize) -> Option<&mut Table> {\n        self.values.get_mut(index).and_then(Item::as_table_mut)\n    }\n\n    /// Appends a table to the array.\n    pub fn push(&mut self, table: Table) {\n        self.values.push(Item::Table(table));\n    }\n\n    /// Removes a table with the given index.\n    pub fn remove(&mut self, index: usize) {\n        self.values.remove(index);\n    }\n}","impl Extend<Table> for ArrayOfTables {\n    fn extend<T: IntoIterator<Item = Table>>(&mut self, iter: T) {\n        for value in iter {\n            self.push(value);\n        }\n    }\n}","impl FromIterator<Table> for ArrayOfTables {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = Table>,\n    {\n        let v = iter.into_iter().map(Item::Table);\n        ArrayOfTables {\n            values: v.collect(),\n            span: None,\n        }\n    }\n}","impl IntoIterator for ArrayOfTables {\n    type Item = Table;\n    type IntoIter = ArrayOfTablesIntoIter;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Box::new(\n            self.values\n                .into_iter()\n                .filter(|v| v.is_table())\n                .map(|v| v.into_table().unwrap()),\n        )\n    }\n}","impl std::fmt::Display for ArrayOfTables {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        // HACK: Without the header, we don't really have a proper way of printing this\n        self.clone().into_array().fmt(f)\n    }\n}"],"document::Document":["Clone","Debug","impl Default for Document {\n    fn default() -> Self {\n        Self {\n            root: Item::Table(Table::with_pos(Some(0))),\n            trailing: Default::default(),\n            original: Default::default(),\n            span: Default::default(),\n        }\n    }\n}","impl Display for Document {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        let mut path = Vec::new();\n        let mut last_position = 0;\n        let mut tables = Vec::new();\n        visit_nested_tables(self.as_table(), &mut path, false, &mut |t, p, is_array| {\n            if let Some(pos) = t.position() {\n                last_position = pos;\n            }\n            tables.push((last_position, t, p.clone(), is_array));\n            Ok(())\n        })\n        .unwrap();\n\n        tables.sort_by_key(|&(id, _, _, _)| id);\n        let mut first_table = true;\n        for (_, table, path, is_array) in tables {\n            visit_table(\n                f,\n                self.original.as_deref(),\n                table,\n                &path,\n                is_array,\n                &mut first_table,\n            )?;\n        }\n        self.trailing()\n            .encode_with_default(f, self.original.as_deref(), \"\")\n    }\n}","impl Document {\n    /// Creates an empty document\n    pub fn new() -> Self {\n        Default::default()\n    }\n\n    /// Returns a reference to the root item.\n    pub fn as_item(&self) -> &Item {\n        &self.root\n    }\n\n    /// Returns a mutable reference to the root item.\n    pub fn as_item_mut(&mut self) -> &mut Item {\n        &mut self.root\n    }\n\n    /// Returns a reference to the root table.\n    pub fn as_table(&self) -> &Table {\n        self.root.as_table().expect(\"root should always be a table\")\n    }\n\n    /// Returns a mutable reference to the root table.\n    pub fn as_table_mut(&mut self) -> &mut Table {\n        self.root\n            .as_table_mut()\n            .expect(\"root should always be a table\")\n    }\n\n    /// Returns an iterator over the root table.\n    pub fn iter(&self) -> Iter<'_> {\n        self.as_table().iter()\n    }\n\n    /// Set whitespace after last element\n    pub fn set_trailing(&mut self, trailing: impl Into<RawString>) {\n        self.trailing = trailing.into();\n    }\n\n    /// Whitespace after last element\n    pub fn trailing(&self) -> &RawString {\n        &self.trailing\n    }\n\n    /// # Panics\n    ///\n    /// If run on on a `Document` not generated by the parser\n    pub(crate) fn despan(&mut self) {\n        self.span = None;\n        self.root.despan(self.original.as_deref().unwrap());\n        self.trailing.despan(self.original.as_deref().unwrap());\n    }\n}","impl From<Table> for Document {\n    fn from(root: Table) -> Self {\n        Self {\n            root: Item::Table(root),\n            ..Default::default()\n        }\n    }\n}","impl FromStr for Document {\n    type Err = crate::TomlError;\n\n    /// Parses a document from a &str\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut d = parser::parse_document(s)?;\n        d.despan();\n        Ok(d)\n    }\n}","impl std::ops::Deref for Document {\n    type Target = Table;\n\n    fn deref(&self) -> &Self::Target {\n        self.as_table()\n    }\n}","impl std::ops::DerefMut for Document {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        self.as_table_mut()\n    }\n}","impl<'s> ops::Index<&'s str> for Document {\n    type Output = Item;\n\n    fn index(&self, key: &'s str) -> &Item {\n        self.root.index(key)\n    }\n}","impl<'s> ops::IndexMut<&'s str> for Document {\n    fn index_mut(&mut self, key: &'s str) -> &mut Item {\n        self.root.index_mut(key)\n    }\n}"],"encode::StringStyle":["Clone","Copy","Debug","Eq","PartialEq","impl StringStyle {\n    fn literal_start(self) -> &'static str {\n        match self {\n            Self::NewlineTripple => \"'''\\n\",\n            Self::OnelineTripple => \"'''\",\n            Self::OnelineSingle => \"'\",\n        }\n    }\n    fn literal_end(self) -> &'static str {\n        match self {\n            Self::NewlineTripple => \"'''\",\n            Self::OnelineTripple => \"'''\",\n            Self::OnelineSingle => \"'\",\n        }\n    }\n\n    fn standard_start(self) -> &'static str {\n        match self {\n            Self::NewlineTripple => \"\\\"\\\"\\\"\\n\",\n            // note: OnelineTripple can happen if do_pretty wants to do\n            // '''it's one line'''\n            // but literal == false\n            Self::OnelineTripple | Self::OnelineSingle => \"\\\"\",\n        }\n    }\n\n    fn standard_end(self) -> &'static str {\n        match self {\n            Self::NewlineTripple => \"\\\"\\\"\\\"\",\n            // note: OnelineTripple can happen if do_pretty wants to do\n            // '''it's one line'''\n            // but literal == false\n            Self::OnelineTripple | Self::OnelineSingle => \"\\\"\",\n        }\n    }\n}"],"inline_table::InlineEntry":["impl<'a> InlineEntry<'a> {\n    /// Returns the entry key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use toml_edit::Table;\n    ///\n    /// let mut map = Table::new();\n    ///\n    /// assert_eq!(\"hello\", map.entry(\"hello\").key());\n    /// ```\n    pub fn key(&self) -> &str {\n        match self {\n            InlineEntry::Occupied(e) => e.key(),\n            InlineEntry::Vacant(e) => e.key(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    pub fn or_insert(self, default: Value) -> &'a mut Value {\n        match self {\n            InlineEntry::Occupied(entry) => entry.into_mut(),\n            InlineEntry::Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns a mutable reference to the value in the entry.\n    pub fn or_insert_with<F: FnOnce() -> Value>(self, default: F) -> &'a mut Value {\n        match self {\n            InlineEntry::Occupied(entry) => entry.into_mut(),\n            InlineEntry::Vacant(entry) => entry.insert(default()),\n        }\n    }\n}"],"inline_table::InlineOccupiedEntry":["impl<'a> InlineOccupiedEntry<'a> {\n    /// Gets a reference to the entry key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use toml_edit::Table;\n    ///\n    /// let mut map = Table::new();\n    ///\n    /// assert_eq!(\"foo\", map.entry(\"foo\").key());\n    /// ```\n    pub fn key(&self) -> &str {\n        self.entry.key().as_str()\n    }\n\n    /// Gets a mutable reference to the entry key\n    pub fn key_mut(&mut self) -> KeyMut<'_> {\n        self.entry.get_mut().key.as_mut()\n    }\n\n    /// Gets a reference to the value in the entry.\n    pub fn get(&self) -> &Value {\n        self.entry.get().value.as_value().unwrap()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    pub fn get_mut(&mut self) -> &mut Value {\n        self.entry.get_mut().value.as_value_mut().unwrap()\n    }\n\n    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself\n    pub fn into_mut(self) -> &'a mut Value {\n        self.entry.into_mut().value.as_value_mut().unwrap()\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value\n    pub fn insert(&mut self, value: Value) -> Value {\n        let mut value = Item::Value(value);\n        std::mem::swap(&mut value, &mut self.entry.get_mut().value);\n        value.into_value().unwrap()\n    }\n\n    /// Takes the value out of the entry, and returns it\n    pub fn remove(self) -> Value {\n        self.entry.shift_remove().value.into_value().unwrap()\n    }\n}"],"inline_table::InlineTable":["Clone","Debug","Default","impl Encode for InlineTable {\n    fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result {\n        let decor = self.decor();\n        decor.prefix_encode(buf, input, default_decor.0)?;\n        write!(buf, \"{{\")?;\n        self.preamble().encode_with_default(buf, input, \"\")?;\n\n        let children = self.get_values();\n        let len = children.len();\n        for (i, (key_path, value)) in children.into_iter().enumerate() {\n            if i != 0 {\n                write!(buf, \",\")?;\n            }\n            let inner_decor = if i == len - 1 {\n                DEFAULT_TRAILING_VALUE_DECOR\n            } else {\n                DEFAULT_VALUE_DECOR\n            };\n            key_path\n                .as_slice()\n                .encode(buf, input, DEFAULT_INLINE_KEY_DECOR)?;\n            write!(buf, \"=\")?;\n            value.encode(buf, input, inner_decor)?;\n        }\n\n        write!(buf, \"}}\")?;\n        decor.suffix_encode(buf, input, default_decor.1)?;\n\n        Ok(())\n    }\n}","impl InlineTable {\n    /// Creates an empty table.\n    pub fn new() -> Self {\n        Default::default()\n    }\n\n    pub(crate) fn with_pairs(items: KeyValuePairs) -> Self {\n        Self {\n            items,\n            ..Default::default()\n        }\n    }\n\n    /// Convert to a table\n    pub fn into_table(self) -> Table {\n        let mut t = Table::with_pairs(self.items);\n        t.fmt();\n        t\n    }\n}","impl InlineTable {\n    /// Get key/values for values that are visually children of this table\n    ///\n    /// For example, this will return dotted keys\n    pub fn get_values(&self) -> Vec<(Vec<&Key>, &Value)> {\n        let mut values = Vec::new();\n        let root = Vec::new();\n        self.append_values(&root, &mut values);\n        values\n    }\n\n    pub(crate) fn append_values<'s, 'c>(\n        &'s self,\n        parent: &[&'s Key],\n        values: &'c mut Vec<(Vec<&'s Key>, &'s Value)>,\n    ) {\n        for value in self.items.values() {\n            let mut path = parent.to_vec();\n            path.push(&value.key);\n            match &value.value {\n                Item::Value(Value::InlineTable(table)) if table.is_dotted() => {\n                    table.append_values(&path, values);\n                }\n                Item::Value(value) => {\n                    values.push((path, value));\n                }\n                _ => {}\n            }\n        }\n    }\n\n    /// Auto formats the table.\n    pub fn fmt(&mut self) {\n        decorate_inline_table(self);\n    }\n\n    /// Sorts the key/value pairs by key.\n    pub fn sort_values(&mut self) {\n        // Assuming standard tables have their position set and this won't negatively impact them\n        self.items.sort_keys();\n        for kv in self.items.values_mut() {\n            match &mut kv.value {\n                Item::Value(Value::InlineTable(table)) if table.is_dotted() => {\n                    table.sort_values();\n                }\n                _ => {}\n            }\n        }\n    }\n\n    /// Sort Key/Value Pairs of the table using the using the comparison function `compare`.\n    ///\n    /// The comparison function receives two key and value pairs to compare (you can sort by keys or\n    /// values or their combination as needed).\n    pub fn sort_values_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&Key, &Value, &Key, &Value) -> std::cmp::Ordering,\n    {\n        self.sort_values_by_internal(&mut compare);\n    }\n\n    fn sort_values_by_internal<F>(&mut self, compare: &mut F)\n    where\n        F: FnMut(&Key, &Value, &Key, &Value) -> std::cmp::Ordering,\n    {\n        let modified_cmp = |_: &InternalString,\n                            val1: &TableKeyValue,\n                            _: &InternalString,\n                            val2: &TableKeyValue|\n         -> std::cmp::Ordering {\n            match (val1.value.as_value(), val2.value.as_value()) {\n                (Some(v1), Some(v2)) => compare(&val1.key, v1, &val2.key, v2),\n                (Some(_), None) => std::cmp::Ordering::Greater,\n                (None, Some(_)) => std::cmp::Ordering::Less,\n                (None, None) => std::cmp::Ordering::Equal,\n            }\n        };\n\n        self.items.sort_by(modified_cmp);\n        for kv in self.items.values_mut() {\n            match &mut kv.value {\n                Item::Value(Value::InlineTable(table)) if table.is_dotted() => {\n                    table.sort_values_by_internal(compare);\n                }\n                _ => {}\n            }\n        }\n    }\n\n    /// Change this table's dotted status\n    pub fn set_dotted(&mut self, yes: bool) {\n        self.dotted = yes;\n    }\n\n    /// Check if this is a wrapper for dotted keys, rather than a standard table\n    pub fn is_dotted(&self) -> bool {\n        self.dotted\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor_mut(&mut self) -> &mut Decor {\n        &mut self.decor\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor(&self) -> &Decor {\n        &self.decor\n    }\n\n    /// Returns the decor associated with a given key of the table.\n    pub fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor> {\n        self.items.get_mut(key).map(|kv| &mut kv.key.decor)\n    }\n\n    /// Returns the decor associated with a given key of the table.\n    pub fn key_decor(&self, key: &str) -> Option<&Decor> {\n        self.items.get(key).map(|kv| &kv.key.decor)\n    }\n\n    /// Set whitespace after before element\n    pub fn set_preamble(&mut self, preamble: impl Into<RawString>) {\n        self.preamble = preamble.into();\n    }\n\n    /// Whitespace after before element\n    pub fn preamble(&self) -> &RawString {\n        &self.preamble\n    }\n\n    /// Returns the location within the original document\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.span.clone()\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        self.span = None;\n        self.decor.despan(input);\n        self.preamble.despan(input);\n        for kv in self.items.values_mut() {\n            kv.key.despan(input);\n            kv.value.despan(input);\n        }\n    }\n}","impl InlineTable {\n    /// Returns an iterator over key/value pairs.\n    pub fn iter(&self) -> InlineTableIter<'_> {\n        Box::new(\n            self.items\n                .iter()\n                .filter(|&(_, kv)| kv.value.is_value())\n                .map(|(k, kv)| (&k[..], kv.value.as_value().unwrap())),\n        )\n    }\n\n    /// Returns an iterator over key/value pairs.\n    pub fn iter_mut(&mut self) -> InlineTableIterMut<'_> {\n        Box::new(\n            self.items\n                .iter_mut()\n                .filter(|(_, kv)| kv.value.is_value())\n                .map(|(_, kv)| (kv.key.as_mut(), kv.value.as_value_mut().unwrap())),\n        )\n    }\n\n    /// Returns the number of key/value pairs.\n    pub fn len(&self) -> usize {\n        self.iter().count()\n    }\n\n    /// Returns true iff the table is empty.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Clears the table, removing all key-value pairs. Keeps the allocated memory for reuse.\n    pub fn clear(&mut self) {\n        self.items.clear()\n    }\n\n    /// Gets the given key's corresponding entry in the Table for in-place manipulation.\n    pub fn entry(&'_ mut self, key: impl Into<InternalString>) -> InlineEntry<'_> {\n        match self.items.entry(key.into()) {\n            indexmap::map::Entry::Occupied(mut entry) => {\n                // Ensure it is a `Value` to simplify `InlineOccupiedEntry`'s code.\n                let scratch = std::mem::take(&mut entry.get_mut().value);\n                let scratch = Item::Value(\n                    scratch\n                        .into_value()\n                        // HACK: `Item::None` is a corner case of a corner case, let's just pick a\n                        // \"safe\" value\n                        .unwrap_or_else(|_| Value::InlineTable(Default::default())),\n                );\n                entry.get_mut().value = scratch;\n\n                InlineEntry::Occupied(InlineOccupiedEntry { entry })\n            }\n            indexmap::map::Entry::Vacant(entry) => {\n                InlineEntry::Vacant(InlineVacantEntry { entry, key: None })\n            }\n        }\n    }\n\n    /// Gets the given key's corresponding entry in the Table for in-place manipulation.\n    pub fn entry_format<'a>(&'a mut self, key: &Key) -> InlineEntry<'a> {\n        // Accept a `&Key` to be consistent with `entry`\n        match self.items.entry(key.get().into()) {\n            indexmap::map::Entry::Occupied(mut entry) => {\n                // Ensure it is a `Value` to simplify `InlineOccupiedEntry`'s code.\n                let scratch = std::mem::take(&mut entry.get_mut().value);\n                let scratch = Item::Value(\n                    scratch\n                        .into_value()\n                        // HACK: `Item::None` is a corner case of a corner case, let's just pick a\n                        // \"safe\" value\n                        .unwrap_or_else(|_| Value::InlineTable(Default::default())),\n                );\n                entry.get_mut().value = scratch;\n\n                InlineEntry::Occupied(InlineOccupiedEntry { entry })\n            }\n            indexmap::map::Entry::Vacant(entry) => InlineEntry::Vacant(InlineVacantEntry {\n                entry,\n                key: Some(key.clone()),\n            }),\n        }\n    }\n    /// Return an optional reference to the value at the given the key.\n    pub fn get(&self, key: &str) -> Option<&Value> {\n        self.items.get(key).and_then(|kv| kv.value.as_value())\n    }\n\n    /// Return an optional mutable reference to the value at the given the key.\n    pub fn get_mut(&mut self, key: &str) -> Option<&mut Value> {\n        self.items\n            .get_mut(key)\n            .and_then(|kv| kv.value.as_value_mut())\n    }\n\n    /// Return references to the key-value pair stored for key, if it is present, else None.\n    pub fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)> {\n        self.items.get(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some((&kv.key, &kv.value))\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Return mutable references to the key-value pair stored for key, if it is present, else None.\n    pub fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)> {\n        self.items.get_mut(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some((kv.key.as_mut(), &mut kv.value))\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Returns true iff the table contains given key.\n    pub fn contains_key(&self, key: &str) -> bool {\n        if let Some(kv) = self.items.get(key) {\n            kv.value.is_value()\n        } else {\n            false\n        }\n    }\n\n    /// Inserts a key/value pair if the table does not contain the key.\n    /// Returns a mutable reference to the corresponding value.\n    pub fn get_or_insert<V: Into<Value>>(\n        &mut self,\n        key: impl Into<InternalString>,\n        value: V,\n    ) -> &mut Value {\n        let key = key.into();\n        self.items\n            .entry(key.clone())\n            .or_insert(TableKeyValue::new(Key::new(key), Item::Value(value.into())))\n            .value\n            .as_value_mut()\n            .expect(\"non-value type in inline table\")\n    }\n\n    /// Inserts a key-value pair into the map.\n    pub fn insert(&mut self, key: impl Into<InternalString>, value: Value) -> Option<Value> {\n        let key = key.into();\n        let kv = TableKeyValue::new(Key::new(key.clone()), Item::Value(value));\n        self.items\n            .insert(key, kv)\n            .and_then(|kv| kv.value.into_value().ok())\n    }\n\n    /// Inserts a key-value pair into the map.\n    pub fn insert_formatted(&mut self, key: &Key, value: Value) -> Option<Value> {\n        let kv = TableKeyValue::new(key.to_owned(), Item::Value(value));\n        self.items\n            .insert(InternalString::from(key.get()), kv)\n            .filter(|kv| kv.value.is_value())\n            .map(|kv| kv.value.into_value().unwrap())\n    }\n\n    /// Removes an item given the key.\n    pub fn remove(&mut self, key: &str) -> Option<Value> {\n        self.items\n            .shift_remove(key)\n            .and_then(|kv| kv.value.into_value().ok())\n    }\n\n    /// Removes a key from the map, returning the stored key and value if the key was previously in the map.\n    pub fn remove_entry(&mut self, key: &str) -> Option<(Key, Value)> {\n        self.items.shift_remove(key).and_then(|kv| {\n            let key = kv.key;\n            kv.value.into_value().ok().map(|value| (key, value))\n        })\n    }\n}","impl IntoIterator for InlineTable {\n    type Item = (InternalString, Value);\n    type IntoIter = InlineTableIntoIter;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Box::new(\n            self.items\n                .into_iter()\n                .filter(|(_, kv)| kv.value.is_value())\n                .map(|(k, kv)| (k, kv.value.into_value().unwrap())),\n        )\n    }\n}","impl Sealed for crate::InlineTable {}","impl TableLike for InlineTable {\n    fn iter(&self) -> Iter<'_> {\n        Box::new(self.items.iter().map(|(key, kv)| (&key[..], &kv.value)))\n    }\n    fn iter_mut(&mut self) -> IterMut<'_> {\n        Box::new(\n            self.items\n                .iter_mut()\n                .map(|(_, kv)| (kv.key.as_mut(), &mut kv.value)),\n        )\n    }\n    fn clear(&mut self) {\n        self.clear();\n    }\n    fn entry<'a>(&'a mut self, key: &str) -> crate::Entry<'a> {\n        // Accept a `&str` rather than an owned type to keep `InternalString`, well, internal\n        match self.items.entry(key.into()) {\n            indexmap::map::Entry::Occupied(entry) => {\n                crate::Entry::Occupied(crate::OccupiedEntry { entry })\n            }\n            indexmap::map::Entry::Vacant(entry) => {\n                crate::Entry::Vacant(crate::VacantEntry { entry, key: None })\n            }\n        }\n    }\n    fn entry_format<'a>(&'a mut self, key: &Key) -> crate::Entry<'a> {\n        // Accept a `&Key` to be consistent with `entry`\n        match self.items.entry(key.get().into()) {\n            indexmap::map::Entry::Occupied(entry) => {\n                crate::Entry::Occupied(crate::OccupiedEntry { entry })\n            }\n            indexmap::map::Entry::Vacant(entry) => crate::Entry::Vacant(crate::VacantEntry {\n                entry,\n                key: Some(key.to_owned()),\n            }),\n        }\n    }\n    fn get<'s>(&'s self, key: &str) -> Option<&'s Item> {\n        self.items.get(key).map(|kv| &kv.value)\n    }\n    fn get_mut<'s>(&'s mut self, key: &str) -> Option<&'s mut Item> {\n        self.items.get_mut(key).map(|kv| &mut kv.value)\n    }\n    fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)> {\n        self.get_key_value(key)\n    }\n    fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)> {\n        self.get_key_value_mut(key)\n    }\n    fn contains_key(&self, key: &str) -> bool {\n        self.contains_key(key)\n    }\n    fn insert(&mut self, key: &str, value: Item) -> Option<Item> {\n        self.insert(key, value.into_value().unwrap())\n            .map(Item::Value)\n    }\n    fn remove(&mut self, key: &str) -> Option<Item> {\n        self.remove(key).map(Item::Value)\n    }\n\n    fn get_values(&self) -> Vec<(Vec<&Key>, &Value)> {\n        self.get_values()\n    }\n    fn fmt(&mut self) {\n        self.fmt()\n    }\n    fn sort_values(&mut self) {\n        self.sort_values()\n    }\n    fn set_dotted(&mut self, yes: bool) {\n        self.set_dotted(yes)\n    }\n    fn is_dotted(&self) -> bool {\n        self.is_dotted()\n    }\n\n    fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor> {\n        self.key_decor_mut(key)\n    }\n    fn key_decor(&self, key: &str) -> Option<&Decor> {\n        self.key_decor(key)\n    }\n}","impl std::fmt::Display for InlineTable {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }\n}","impl<'s> ops::Index<&'s str> for InlineTable {\n    type Output = Value;\n\n    fn index(&self, key: &'s str) -> &Value {\n        self.get(key).expect(\"index not found\")\n    }\n}","impl<'s> ops::IndexMut<&'s str> for InlineTable {\n    fn index_mut(&mut self, key: &'s str) -> &mut Value {\n        self.get_mut(key).expect(\"index not found\")\n    }\n}","impl<K: Into<Key>, V: Into<Value>> Extend<(K, V)> for InlineTable {\n    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n        for (key, value) in iter {\n            let key = key.into();\n            let value = Item::Value(value.into());\n            let value = TableKeyValue::new(key, value);\n            self.items\n                .insert(InternalString::from(value.key.get()), value);\n        }\n    }\n}","impl<K: Into<Key>, V: Into<Value>> FromIterator<(K, V)> for InlineTable {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let mut table = InlineTable::new();\n        table.extend(iter);\n        table\n    }\n}"],"inline_table::InlineVacantEntry":["impl<'a> InlineVacantEntry<'a> {\n    /// Gets a reference to the entry key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use toml_edit::Table;\n    ///\n    /// let mut map = Table::new();\n    ///\n    /// assert_eq!(\"foo\", map.entry(\"foo\").key());\n    /// ```\n    pub fn key(&self) -> &str {\n        self.entry.key().as_str()\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key,\n    /// and returns a mutable reference to it\n    pub fn insert(self, value: Value) -> &'a mut Value {\n        let entry = self.entry;\n        let key = self.key.unwrap_or_else(|| Key::new(entry.key().as_str()));\n        let value = Item::Value(value);\n        entry\n            .insert(TableKeyValue::new(key, value))\n            .value\n            .as_value_mut()\n            .unwrap()\n    }\n}"],"internal_string::InternalString":["Clone","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl AsRef<str> for InternalString {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}","impl Borrow<str> for InternalString {\n    #[inline]\n    fn borrow(&self) -> &str {\n        self.as_str()\n    }\n}","impl From<&InternalString> for InternalString {\n    #[inline]\n    fn from(s: &InternalString) -> Self {\n        s.clone()\n    }\n}","impl From<&String> for InternalString {\n    #[inline]\n    fn from(s: &String) -> Self {\n        InternalString(s.into())\n    }\n}","impl From<&str> for InternalString {\n    #[inline]\n    fn from(s: &str) -> Self {\n        #[cfg(feature = \"kstring\")]\n        let inner = kstring::KString::from_ref(s);\n        #[cfg(not(feature = \"kstring\"))]\n        let inner = String::from(s);\n\n        InternalString(inner)\n    }\n}","impl From<Box<str>> for InternalString {\n    #[inline]\n    fn from(s: Box<str>) -> Self {\n        InternalString(s.into())\n    }\n}","impl From<Key> for InternalString {\n    fn from(key: Key) -> InternalString {\n        key.key\n    }\n}","impl From<String> for InternalString {\n    #[inline]\n    fn from(s: String) -> Self {\n        #[allow(clippy::useless_conversion)] // handle any string type\n        InternalString(s.into())\n    }\n}","impl FromStr for InternalString {\n    type Err = core::convert::Infallible;\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Ok(Self::from(s))\n    }\n}","impl InternalString {\n    /// Create an empty string\n    pub fn new() -> Self {\n        InternalString(Inner::new())\n    }\n\n    /// Access the underlying string\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        self.0.as_str()\n    }\n}","impl std::fmt::Debug for InternalString {\n    #[inline]\n    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n        self.0.fmt(formatter)\n    }\n}","impl std::fmt::Display for InternalString {\n    #[inline]\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.as_str().fmt(f)\n    }\n}","impl std::ops::Deref for InternalString {\n    type Target = str;\n\n    #[inline]\n    fn deref(&self) -> &str {\n        self.as_str()\n    }\n}"],"item::Item":["Clone","Debug","impl Default for Item {\n    fn default() -> Self {\n        Item::None\n    }\n}","impl FromStr for Item {\n    type Err = crate::TomlError;\n\n    /// Parses a value from a &str\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let value = s.parse::<Value>()?;\n        Ok(Item::Value(value))\n    }\n}","impl Item {\n    /// Sets `self` to the given item iff `self` is none and\n    /// returns a mutable reference to `self`.\n    pub fn or_insert(&mut self, item: Item) -> &mut Item {\n        if self.is_none() {\n            *self = item\n        }\n        self\n    }\n}","impl Item {\n    /// Text description of value type\n    pub fn type_name(&self) -> &'static str {\n        match self {\n            Item::None => \"none\",\n            Item::Value(v) => v.type_name(),\n            Item::Table(..) => \"table\",\n            Item::ArrayOfTables(..) => \"array of tables\",\n        }\n    }\n\n    /// Index into a TOML array or map. A string index can be used to access a\n    /// value in a map, and a usize index can be used to access an element of an\n    /// array.\n    ///\n    /// Returns `None` if:\n    /// - The type of `self` does not match the type of the\n    ///   index, for example if the index is a string and `self` is an array or a\n    ///   number.\n    /// - The given key does not exist in the map\n    ///   or the given index is not within the bounds of the array.\n    pub fn get<I: crate::index::Index>(&self, index: I) -> Option<&Item> {\n        index.index(self)\n    }\n\n    /// Mutably index into a TOML array or map. A string index can be used to\n    /// access a value in a map, and a usize index can be used to access an\n    /// element of an array.\n    ///\n    /// Returns `None` if:\n    /// - The type of `self` does not match the type of the\n    ///   index, for example if the index is a string and `self` is an array or a\n    ///   number.\n    /// - The given key does not exist in the map\n    ///   or the given index is not within the bounds of the array.\n    pub fn get_mut<I: crate::index::Index>(&mut self, index: I) -> Option<&mut Item> {\n        index.index_mut(self)\n    }\n\n    /// Casts `self` to value.\n    pub fn as_value(&self) -> Option<&Value> {\n        match *self {\n            Item::Value(ref v) => Some(v),\n            _ => None,\n        }\n    }\n    /// Casts `self` to table.\n    pub fn as_table(&self) -> Option<&Table> {\n        match *self {\n            Item::Table(ref t) => Some(t),\n            _ => None,\n        }\n    }\n    /// Casts `self` to array of tables.\n    pub fn as_array_of_tables(&self) -> Option<&ArrayOfTables> {\n        match *self {\n            Item::ArrayOfTables(ref a) => Some(a),\n            _ => None,\n        }\n    }\n    /// Casts `self` to mutable value.\n    pub fn as_value_mut(&mut self) -> Option<&mut Value> {\n        match *self {\n            Item::Value(ref mut v) => Some(v),\n            _ => None,\n        }\n    }\n    /// Casts `self` to mutable table.\n    pub fn as_table_mut(&mut self) -> Option<&mut Table> {\n        match *self {\n            Item::Table(ref mut t) => Some(t),\n            _ => None,\n        }\n    }\n    /// Casts `self` to mutable array of tables.\n    pub fn as_array_of_tables_mut(&mut self) -> Option<&mut ArrayOfTables> {\n        match *self {\n            Item::ArrayOfTables(ref mut a) => Some(a),\n            _ => None,\n        }\n    }\n    /// Casts `self` to value.\n    pub fn into_value(self) -> Result<Value, Self> {\n        match self {\n            Item::None => Err(self),\n            Item::Value(v) => Ok(v),\n            Item::Table(v) => {\n                let v = v.into_inline_table();\n                Ok(Value::InlineTable(v))\n            }\n            Item::ArrayOfTables(v) => {\n                let v = v.into_array();\n                Ok(Value::Array(v))\n            }\n        }\n    }\n    /// In-place convert to a value\n    pub fn make_value(&mut self) {\n        let other = std::mem::take(self);\n        let other = other.into_value().map(Item::Value).unwrap_or(Item::None);\n        *self = other;\n    }\n    /// Casts `self` to table.\n    pub fn into_table(self) -> Result<Table, Self> {\n        match self {\n            Item::Table(t) => Ok(t),\n            Item::Value(Value::InlineTable(t)) => Ok(t.into_table()),\n            _ => Err(self),\n        }\n    }\n    /// Casts `self` to array of tables.\n    pub fn into_array_of_tables(self) -> Result<ArrayOfTables, Self> {\n        match self {\n            Item::ArrayOfTables(a) => Ok(a),\n            Item::Value(Value::Array(a)) => {\n                if a.is_empty() {\n                    Err(Item::Value(Value::Array(a)))\n                } else if a.iter().all(|v| v.is_inline_table()) {\n                    let mut aot = ArrayOfTables::new();\n                    aot.values = a.values;\n                    for value in aot.values.iter_mut() {\n                        value.make_item();\n                    }\n                    Ok(aot)\n                } else {\n                    Err(Item::Value(Value::Array(a)))\n                }\n            }\n            _ => Err(self),\n        }\n    }\n    // Starting private because the name is unclear\n    pub(crate) fn make_item(&mut self) {\n        let other = std::mem::take(self);\n        let other = match other.into_table().map(crate::Item::Table) {\n            Ok(i) => i,\n            Err(i) => i,\n        };\n        let other = match other.into_array_of_tables().map(crate::Item::ArrayOfTables) {\n            Ok(i) => i,\n            Err(i) => i,\n        };\n        *self = other;\n    }\n    /// Returns true iff `self` is a value.\n    pub fn is_value(&self) -> bool {\n        self.as_value().is_some()\n    }\n    /// Returns true iff `self` is a table.\n    pub fn is_table(&self) -> bool {\n        self.as_table().is_some()\n    }\n    /// Returns true iff `self` is an array of tables.\n    pub fn is_array_of_tables(&self) -> bool {\n        self.as_array_of_tables().is_some()\n    }\n    /// Returns true iff `self` is `None`.\n    pub fn is_none(&self) -> bool {\n        matches!(*self, Item::None)\n    }\n\n    // Duplicate Value downcasting API\n\n    /// Casts `self` to integer.\n    pub fn as_integer(&self) -> Option<i64> {\n        self.as_value().and_then(Value::as_integer)\n    }\n\n    /// Returns true iff `self` is an integer.\n    pub fn is_integer(&self) -> bool {\n        self.as_integer().is_some()\n    }\n\n    /// Casts `self` to float.\n    pub fn as_float(&self) -> Option<f64> {\n        self.as_value().and_then(Value::as_float)\n    }\n\n    /// Returns true iff `self` is a float.\n    pub fn is_float(&self) -> bool {\n        self.as_float().is_some()\n    }\n\n    /// Casts `self` to boolean.\n    pub fn as_bool(&self) -> Option<bool> {\n        self.as_value().and_then(Value::as_bool)\n    }\n\n    /// Returns true iff `self` is a boolean.\n    pub fn is_bool(&self) -> bool {\n        self.as_bool().is_some()\n    }\n\n    /// Casts `self` to str.\n    pub fn as_str(&self) -> Option<&str> {\n        self.as_value().and_then(Value::as_str)\n    }\n\n    /// Returns true iff `self` is a string.\n    pub fn is_str(&self) -> bool {\n        self.as_str().is_some()\n    }\n\n    /// Casts `self` to date-time.\n    pub fn as_datetime(&self) -> Option<&Datetime> {\n        self.as_value().and_then(Value::as_datetime)\n    }\n\n    /// Returns true iff `self` is a date-time.\n    pub fn is_datetime(&self) -> bool {\n        self.as_datetime().is_some()\n    }\n\n    /// Casts `self` to array.\n    pub fn as_array(&self) -> Option<&Array> {\n        self.as_value().and_then(Value::as_array)\n    }\n\n    /// Casts `self` to mutable array.\n    pub fn as_array_mut(&mut self) -> Option<&mut Array> {\n        self.as_value_mut().and_then(Value::as_array_mut)\n    }\n\n    /// Returns true iff `self` is an array.\n    pub fn is_array(&self) -> bool {\n        self.as_array().is_some()\n    }\n\n    /// Casts `self` to inline table.\n    pub fn as_inline_table(&self) -> Option<&InlineTable> {\n        self.as_value().and_then(Value::as_inline_table)\n    }\n\n    /// Casts `self` to mutable inline table.\n    pub fn as_inline_table_mut(&mut self) -> Option<&mut InlineTable> {\n        self.as_value_mut().and_then(Value::as_inline_table_mut)\n    }\n\n    /// Returns true iff `self` is an inline table.\n    pub fn is_inline_table(&self) -> bool {\n        self.as_inline_table().is_some()\n    }\n\n    /// Casts `self` to either a table or an inline table.\n    pub fn as_table_like(&self) -> Option<&dyn TableLike> {\n        self.as_table()\n            .map(|t| t as &dyn TableLike)\n            .or_else(|| self.as_inline_table().map(|t| t as &dyn TableLike))\n    }\n\n    /// Casts `self` to either a table or an inline table.\n    pub fn as_table_like_mut(&mut self) -> Option<&mut dyn TableLike> {\n        match self {\n            Item::Table(t) => Some(t as &mut dyn TableLike),\n            Item::Value(Value::InlineTable(t)) => Some(t as &mut dyn TableLike),\n            _ => None,\n        }\n    }\n\n    /// Returns true iff `self` is either a table, or an inline table.\n    pub fn is_table_like(&self) -> bool {\n        self.as_table_like().is_some()\n    }\n\n    /// Returns the location within the original document\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        match self {\n            Item::None => None,\n            Item::Value(v) => v.span(),\n            Item::Table(v) => v.span(),\n            Item::ArrayOfTables(v) => v.span(),\n        }\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        match self {\n            Item::None => {}\n            Item::Value(v) => v.despan(input),\n            Item::Table(v) => v.despan(input),\n            Item::ArrayOfTables(v) => v.despan(input),\n        }\n    }\n}","impl std::fmt::Display for Item {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match &self {\n            Item::None => Ok(()),\n            Item::Value(v) => v.fmt(f),\n            Item::Table(v) => v.fmt(f),\n            Item::ArrayOfTables(v) => v.fmt(f),\n        }\n    }\n}","impl<I> ops::Index<I> for Item\nwhere\n    I: Index,\n{\n    type Output = Item;\n\n    fn index(&self, index: I) -> &Item {\n        index.index(self).expect(\"index not found\")\n    }\n}","impl<I> ops::IndexMut<I> for Item\nwhere\n    I: Index,\n{\n    fn index_mut(&mut self, index: I) -> &mut Item {\n        index.index_mut(self).expect(\"index not found\")\n    }\n}"],"key::Key":["Clone","Debug","impl Encode for Key {\n    fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result {\n        let decor = self.decor();\n        decor.prefix_encode(buf, input, default_decor.0)?;\n\n        if let Some(input) = input {\n            let repr = self\n                .as_repr()\n                .map(Cow::Borrowed)\n                .unwrap_or_else(|| Cow::Owned(self.default_repr()));\n            repr.encode(buf, input)?;\n        } else {\n            let repr = self.display_repr();\n            write!(buf, \"{}\", repr)?;\n        };\n\n        decor.suffix_encode(buf, input, default_decor.1)?;\n        Ok(())\n    }\n}","impl Eq for Key {}","impl From<InternalString> for Key {\n    fn from(s: InternalString) -> Self {\n        Key::new(s)\n    }\n}","impl From<String> for Key {\n    fn from(s: String) -> Self {\n        Key::new(s)\n    }\n}","impl FromStr for Key {\n    type Err = crate::TomlError;\n\n    /// Tries to parse a key from a &str,\n    /// if fails, tries as basic quoted key (surrounds with \"\")\n    /// and then literal quoted key (surrounds with '')\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Key::try_parse_simple(s)\n    }\n}","impl Key {\n    /// Create a new table key\n    pub fn new(key: impl Into<InternalString>) -> Self {\n        Self {\n            key: key.into(),\n            repr: None,\n            decor: Default::default(),\n        }\n    }\n\n    /// Parse a TOML key expression\n    ///\n    /// Unlike `\"\".parse<Key>()`, this supports dotted keys.\n    pub fn parse(repr: &str) -> Result<Vec<Self>, crate::TomlError> {\n        Self::try_parse_path(repr)\n    }\n\n    pub(crate) fn with_repr_unchecked(mut self, repr: Repr) -> Self {\n        self.repr = Some(repr);\n        self\n    }\n\n    /// While creating the `Key`, add `Decor` to it\n    pub fn with_decor(mut self, decor: Decor) -> Self {\n        self.decor = decor;\n        self\n    }\n\n    /// Access a mutable proxy for the `Key`.\n    pub fn as_mut(&mut self) -> KeyMut<'_> {\n        KeyMut { key: self }\n    }\n\n    /// Returns the parsed key value.\n    pub fn get(&self) -> &str {\n        &self.key\n    }\n\n    pub(crate) fn get_internal(&self) -> &InternalString {\n        &self.key\n    }\n\n    /// Returns key raw representation, if available.\n    pub fn as_repr(&self) -> Option<&Repr> {\n        self.repr.as_ref()\n    }\n\n    /// Returns the default raw representation.\n    pub fn default_repr(&self) -> Repr {\n        to_key_repr(&self.key)\n    }\n\n    /// Returns a raw representation.\n    pub fn display_repr(&self) -> Cow<'_, str> {\n        self.as_repr()\n            .and_then(|r| r.as_raw().as_str())\n            .map(Cow::Borrowed)\n            .unwrap_or_else(|| {\n                Cow::Owned(self.default_repr().as_raw().as_str().unwrap().to_owned())\n            })\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor_mut(&mut self) -> &mut Decor {\n        &mut self.decor\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor(&self) -> &Decor {\n        &self.decor\n    }\n\n    /// Returns the location within the original document\n    #[cfg(feature = \"serde\")]\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.repr.as_ref().and_then(|r| r.span())\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        self.decor.despan(input);\n        if let Some(repr) = &mut self.repr {\n            repr.despan(input)\n        }\n    }\n\n    /// Auto formats the key.\n    pub fn fmt(&mut self) {\n        self.repr = Some(to_key_repr(&self.key));\n        self.decor.clear();\n    }\n\n    fn try_parse_simple(s: &str) -> Result<Key, crate::TomlError> {\n        let mut key = parser::parse_key(s)?;\n        key.despan(s);\n        Ok(key)\n    }\n\n    fn try_parse_path(s: &str) -> Result<Vec<Key>, crate::TomlError> {\n        let mut keys = parser::parse_key_path(s)?;\n        for key in &mut keys {\n            key.despan(s);\n        }\n        Ok(keys)\n    }\n}","impl Ord for Key {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.get().cmp(other.get())\n    }\n}","impl PartialEq for Key {\n    #[inline]\n    fn eq(&self, other: &Key) -> bool {\n        PartialEq::eq(self.get(), other.get())\n    }\n}","impl PartialEq<String> for Key {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        PartialEq::eq(self.get(), other.as_str())\n    }\n}","impl PartialEq<str> for Key {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        PartialEq::eq(self.get(), other)\n    }\n}","impl PartialOrd for Key {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl std::fmt::Display for Key {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }\n}","impl std::hash::Hash for Key {\n    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n        self.get().hash(state);\n    }\n}","impl std::ops::Deref for Key {\n    type Target = str;\n\n    fn deref(&self) -> &Self::Target {\n        self.get()\n    }\n}","impl<'b> From<&'b String> for Key {\n    fn from(s: &'b String) -> Self {\n        Key::new(s)\n    }\n}","impl<'b> From<&'b str> for Key {\n    fn from(s: &'b str) -> Self {\n        Key::new(s)\n    }\n}","impl<'s> PartialEq<&'s str> for Key {\n    #[inline]\n    fn eq(&self, other: &&str) -> bool {\n        PartialEq::eq(self.get(), *other)\n    }\n}"],"key::KeyMut":["Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl<'k> KeyMut<'k> {\n    /// Returns the parsed key value.\n    pub fn get(&self) -> &str {\n        self.key.get()\n    }\n\n    /// Returns the raw representation, if available.\n    pub fn as_repr(&self) -> Option<&Repr> {\n        self.key.as_repr()\n    }\n\n    /// Returns the default raw representation.\n    pub fn default_repr(&self) -> Repr {\n        self.key.default_repr()\n    }\n\n    /// Returns a raw representation.\n    pub fn display_repr(&self) -> Cow<str> {\n        self.key.display_repr()\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor_mut(&mut self) -> &mut Decor {\n        self.key.decor_mut()\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor(&self) -> &Decor {\n        self.key.decor()\n    }\n\n    /// Auto formats the key.\n    pub fn fmt(&mut self) {\n        self.key.fmt()\n    }\n}","impl<'k> std::fmt::Display for KeyMut<'k> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        std::fmt::Display::fmt(&self.key, f)\n    }\n}","impl<'k> std::ops::Deref for KeyMut<'k> {\n    type Target = str;\n\n    fn deref(&self) -> &Self::Target {\n        self.get()\n    }\n}","impl<'s> PartialEq<&'s str> for KeyMut<'s> {\n    #[inline]\n    fn eq(&self, other: &&str) -> bool {\n        PartialEq::eq(self.get(), *other)\n    }\n}","impl<'s> PartialEq<String> for KeyMut<'s> {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        PartialEq::eq(self.get(), other.as_str())\n    }\n}","impl<'s> PartialEq<str> for KeyMut<'s> {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        PartialEq::eq(self.get(), other)\n    }\n}"],"parser::errors::Context":["Clone","Copy","Debug","PartialEq"],"parser::errors::CustomError":["Clone","Debug","impl CustomError {\n    pub(crate) fn duplicate_key(path: &[Key], i: usize) -> Self {\n        assert!(i < path.len());\n        let key = &path[i];\n        let repr = key.display_repr();\n        Self::DuplicateKey {\n            key: repr.into(),\n            table: Some(path[..i].to_vec()),\n        }\n    }\n\n    pub(crate) fn extend_wrong_type(path: &[Key], i: usize, actual: &'static str) -> Self {\n        assert!(i < path.len());\n        Self::DottedKeyExtendWrongType {\n            key: path[..=i].to_vec(),\n            actual,\n        }\n    }\n}","impl Display for CustomError {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        match self {\n            CustomError::DuplicateKey { key, table } => {\n                if let Some(table) = table {\n                    if table.is_empty() {\n                        write!(f, \"duplicate key `{}` in document root\", key)\n                    } else {\n                        let path = table.iter().map(|k| k.get()).collect::<Vec<_>>().join(\".\");\n                        write!(f, \"duplicate key `{}` in table `{}`\", key, path)\n                    }\n                } else {\n                    write!(f, \"duplicate key `{}`\", key)\n                }\n            }\n            CustomError::DottedKeyExtendWrongType { key, actual } => {\n                let path = key.iter().map(|k| k.get()).collect::<Vec<_>>().join(\".\");\n                write!(\n                    f,\n                    \"dotted key `{}` attempted to extend non-table type ({})\",\n                    path, actual\n                )\n            }\n            CustomError::OutOfRange => write!(f, \"value is out of range\"),\n            CustomError::RecursionLimitExceeded => write!(f, \"recursion limit exceded\"),\n        }\n    }\n}","impl StdError for CustomError {\n    fn description(&self) -> &'static str {\n        \"TOML parse error\"\n    }\n}"],"parser::errors::ParserError":["Debug","impl<'a> std::fmt::Display for ParserError<'a> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let expression = self.context.iter().find_map(|c| match c {\n            Context::Expression(c) => Some(c),\n            _ => None,\n        });\n        let expected = self\n            .context\n            .iter()\n            .filter_map(|c| match c {\n                Context::Expected(c) => Some(c),\n                _ => None,\n            })\n            .collect::<Vec<_>>();\n\n        let mut newline = false;\n\n        if let Some(expression) = expression {\n            newline = true;\n\n            write!(f, \"invalid {}\", expression)?;\n        }\n\n        if !expected.is_empty() {\n            if newline {\n                writeln!(f)?;\n            }\n            newline = true;\n\n            write!(f, \"expected \")?;\n            for (i, expected) in expected.iter().enumerate() {\n                if i != 0 {\n                    write!(f, \", \")?;\n                }\n                write!(f, \"{}\", expected)?;\n            }\n        }\n        if let Some(cause) = &self.cause {\n            if newline {\n                writeln!(f)?;\n            }\n            write!(f, \"{}\", cause)?;\n        }\n\n        Ok(())\n    }\n}","impl<'b, E: std::error::Error + Send + Sync + 'static>\n    winnow::error::FromExternalError<Input<'b>, E> for ParserError<'b>\n{\n    fn from_external_error(input: Input<'b>, _kind: winnow::error::ErrorKind, e: E) -> Self {\n        Self {\n            input,\n            context: Default::default(),\n            cause: Some(Box::new(e)),\n        }\n    }\n}","impl<'b, E: std::error::Error + Send + Sync + 'static> winnow::error::FromExternalError<&'b str, E>\n    for ParserError<'b>\n{\n    fn from_external_error(input: &'b str, _kind: winnow::error::ErrorKind, e: E) -> Self {\n        Self {\n            input: Input::new(BStr::new(input)),\n            context: Default::default(),\n            cause: Some(Box::new(e)),\n        }\n    }\n}","impl<'b> std::cmp::PartialEq for ParserError<'b> {\n    fn eq(&self, other: &Self) -> bool {\n        self.input == other.input\n            && self.context == other.context\n            && self.cause.as_ref().map(ToString::to_string)\n                == other.cause.as_ref().map(ToString::to_string)\n    }\n}","impl<'b> winnow::error::ContextError<Input<'b>, Context> for ParserError<'b> {\n    fn add_context(mut self, _input: Input<'b>, ctx: Context) -> Self {\n        self.context.push(ctx);\n        self\n    }\n}","impl<'b> winnow::error::ParseError<&'b str> for ParserError<'b> {\n    fn from_error_kind(input: &'b str, _kind: winnow::error::ErrorKind) -> Self {\n        Self {\n            input: Input::new(BStr::new(input)),\n            context: Default::default(),\n            cause: Default::default(),\n        }\n    }\n\n    fn append(self, _input: &'b str, _kind: winnow::error::ErrorKind) -> Self {\n        self\n    }\n\n    fn or(self, other: Self) -> Self {\n        other\n    }\n}","impl<'b> winnow::error::ParseError<Input<'b>> for ParserError<'b> {\n    fn from_error_kind(input: Input<'b>, _kind: winnow::error::ErrorKind) -> Self {\n        Self {\n            input,\n            context: Default::default(),\n            cause: Default::default(),\n        }\n    }\n\n    fn append(self, _input: Input<'b>, _kind: winnow::error::ErrorKind) -> Self {\n        self\n    }\n\n    fn or(self, other: Self) -> Self {\n        other\n    }\n}"],"parser::errors::ParserValue":["Clone","Copy","Debug","PartialEq","impl std::fmt::Display for ParserValue {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            ParserValue::CharLiteral('\\n') => \"newline\".fmt(f),\n            ParserValue::CharLiteral('`') => \"'`'\".fmt(f),\n            ParserValue::CharLiteral(c) if c.is_ascii_control() => {\n                write!(f, \"`{}`\", c.escape_debug())\n            }\n            ParserValue::CharLiteral(c) => write!(f, \"`{}`\", c),\n            ParserValue::StringLiteral(c) => write!(f, \"`{}`\", c),\n            ParserValue::Description(c) => write!(f, \"{}\", c),\n        }\n    }\n}"],"parser::errors::TomlError":["Clone","Debug","Eq","Hash","PartialEq","impl Display for TomlError {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        let mut context = false;\n        if let (Some(original), Some(span)) = (&self.original, self.span()) {\n            context = true;\n\n            let (line, column) = translate_position(original.as_bytes(), span.start);\n            let line_num = line + 1;\n            let col_num = column + 1;\n            let gutter = line_num.to_string().len();\n            let content = original.split('\\n').nth(line).expect(\"valid line number\");\n\n            writeln!(\n                f,\n                \"TOML parse error at line {}, column {}\",\n                line_num, col_num\n            )?;\n            //   |\n            for _ in 0..=gutter {\n                write!(f, \" \")?;\n            }\n            writeln!(f, \"|\")?;\n\n            // 1 | 00:32:00.a999999\n            write!(f, \"{} | \", line_num)?;\n            writeln!(f, \"{}\", content)?;\n\n            //   |          ^\n            for _ in 0..=gutter {\n                write!(f, \" \")?;\n            }\n            write!(f, \"|\")?;\n            for _ in 0..=column {\n                write!(f, \" \")?;\n            }\n            // The span will be empty at eof, so we need to make sure we always print at least\n            // one `^`\n            write!(f, \"^\")?;\n            for _ in (span.start + 1)..(span.end.min(span.start + content.len())) {\n                write!(f, \"^\")?;\n            }\n            writeln!(f)?;\n        }\n        writeln!(f, \"{}\", self.message)?;\n        if !context && !self.keys.is_empty() {\n            writeln!(f, \"in `{}`\", self.keys.join(\".\"))?;\n        }\n\n        Ok(())\n    }\n}","impl StdError for TomlError {\n    fn description(&self) -> &'static str {\n        \"TOML parse error\"\n    }\n}","impl TomlError {\n    pub(crate) fn new(error: ParserError<'_>, original: Input<'_>) -> Self {\n        use winnow::stream::Offset;\n        use winnow::stream::Stream;\n\n        let offset = original.offset_to(&error.input);\n        let span = if offset == original.len() {\n            offset..offset\n        } else {\n            offset..(offset + 1)\n        };\n\n        let message = error.to_string();\n        let original = original.next_slice(original.eof_offset()).1;\n\n        Self {\n            message,\n            original: Some(\n                String::from_utf8(original.to_owned()).expect(\"original document was utf8\"),\n            ),\n            keys: Vec::new(),\n            span: Some(span),\n        }\n    }\n\n    #[cfg(feature = \"serde\")]\n    pub(crate) fn custom(message: String, span: Option<std::ops::Range<usize>>) -> Self {\n        Self {\n            message,\n            original: None,\n            keys: Vec::new(),\n            span,\n        }\n    }\n\n    #[cfg(feature = \"serde\")]\n    pub(crate) fn add_key(&mut self, key: String) {\n        self.keys.insert(0, key);\n    }\n\n    /// What went wrong\n    pub fn message(&self) -> &str {\n        &self.message\n    }\n\n    /// The start/end index into the original document where the error occurred\n    pub fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.span.clone()\n    }\n\n    #[cfg(feature = \"serde\")]\n    pub(crate) fn set_span(&mut self, span: Option<std::ops::Range<usize>>) {\n        self.span = span;\n    }\n\n    #[cfg(feature = \"serde\")]\n    pub(crate) fn set_original(&mut self, original: Option<String>) {\n        self.original = original;\n    }\n}"],"parser::prelude::RecursionCheck":["Clone","Copy","Debug","Default","impl RecursionCheck {\n        pub(crate) fn check_depth(depth: usize) -> Result<(), super::errors::CustomError> {\n            if depth < 128 {\n                Ok(())\n            } else {\n                Err(super::errors::CustomError::RecursionLimitExceeded)\n            }\n        }\n\n        pub(crate) fn recursing(\n            mut self,\n            input: Input<'_>,\n        ) -> Result<Self, winnow::error::ErrMode<ParserError<'_>>> {\n            self.current += 1;\n            if self.current < 128 {\n                Ok(self)\n            } else {\n                Err(winnow::error::ErrMode::Backtrack(\n                    winnow::error::FromExternalError::from_external_error(\n                        input,\n                        winnow::error::ErrorKind::Eof,\n                        super::errors::CustomError::RecursionLimitExceeded,\n                    ),\n                ))\n            }\n        }\n    }"],"parser::state::ParseState":["impl Default for ParseState {\n    fn default() -> Self {\n        let mut root = Table::new();\n        root.span = Some(0..0);\n        Self {\n            document: Document::new(),\n            trailing: None,\n            current_table_position: 0,\n            current_table: root,\n            current_is_array: false,\n            current_table_path: Vec::new(),\n        }\n    }\n}","impl ParseState {\n    pub(crate) fn into_document(mut self) -> Result<Document, CustomError> {\n        self.finalize_table()?;\n        let trailing = self.trailing.map(RawString::with_span);\n        self.document.trailing = trailing.unwrap_or_default();\n        Ok(self.document)\n    }\n\n    pub(crate) fn on_ws(&mut self, span: std::ops::Range<usize>) {\n        if let Some(old) = self.trailing.take() {\n            self.trailing = Some(old.start..span.end);\n        } else {\n            self.trailing = Some(span);\n        }\n    }\n\n    pub(crate) fn on_comment(&mut self, span: std::ops::Range<usize>) {\n        if let Some(old) = self.trailing.take() {\n            self.trailing = Some(old.start..span.end);\n        } else {\n            self.trailing = Some(span);\n        }\n    }\n\n    pub(crate) fn on_keyval(\n        &mut self,\n        mut path: Vec<Key>,\n        mut kv: TableKeyValue,\n    ) -> Result<(), CustomError> {\n        {\n            let mut prefix = self.trailing.take();\n            let first_key = if path.is_empty() {\n                &mut kv.key\n            } else {\n                &mut path[0]\n            };\n            let prefix = match (\n                prefix.take(),\n                first_key.decor.prefix().and_then(|d| d.span()),\n            ) {\n                (Some(p), Some(k)) => Some(p.start..k.end),\n                (Some(p), None) | (None, Some(p)) => Some(p),\n                (None, None) => None,\n            };\n            first_key\n                .decor\n                .set_prefix(prefix.map(RawString::with_span).unwrap_or_default());\n        }\n\n        if let (Some(existing), Some(value)) = (self.current_table.span(), kv.value.span()) {\n            self.current_table.span = Some((existing.start)..(value.end));\n        }\n        let table = &mut self.current_table;\n        let table = Self::descend_path(table, &path, true)?;\n\n        // \"Likewise, using dotted keys to redefine tables already defined in [table] form is not allowed\"\n        let mixed_table_types = table.is_dotted() == path.is_empty();\n        if mixed_table_types {\n            return Err(CustomError::DuplicateKey {\n                key: kv.key.get().into(),\n                table: None,\n            });\n        }\n\n        let key: InternalString = kv.key.get_internal().into();\n        match table.items.entry(key) {\n            indexmap::map::Entry::Vacant(o) => {\n                o.insert(kv);\n            }\n            indexmap::map::Entry::Occupied(o) => {\n                // \"Since tables cannot be defined more than once, redefining such tables using a [table] header is not allowed\"\n                return Err(CustomError::DuplicateKey {\n                    key: o.key().as_str().into(),\n                    table: Some(self.current_table_path.clone()),\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    pub(crate) fn start_aray_table(\n        &mut self,\n        path: Vec<Key>,\n        decor: Decor,\n        span: std::ops::Range<usize>,\n    ) -> Result<(), CustomError> {\n        debug_assert!(!path.is_empty());\n        debug_assert!(self.current_table.is_empty());\n        debug_assert!(self.current_table_path.is_empty());\n\n        // Look up the table on start to ensure the duplicate_key error points to the right line\n        let root = self.document.as_table_mut();\n        let parent_table = Self::descend_path(root, &path[..path.len() - 1], false)?;\n        let key = &path[path.len() - 1];\n        let entry = parent_table\n            .entry_format(key)\n            .or_insert(Item::ArrayOfTables(ArrayOfTables::new()));\n        entry\n            .as_array_of_tables()\n            .ok_or_else(|| CustomError::duplicate_key(&path, path.len() - 1))?;\n\n        self.current_table_position += 1;\n        self.current_table.decor = decor;\n        self.current_table.set_implicit(false);\n        self.current_table.set_dotted(false);\n        self.current_table.set_position(self.current_table_position);\n        self.current_table.span = Some(span);\n        self.current_is_array = true;\n        self.current_table_path = path;\n\n        Ok(())\n    }\n\n    pub(crate) fn start_table(\n        &mut self,\n        path: Vec<Key>,\n        decor: Decor,\n        span: std::ops::Range<usize>,\n    ) -> Result<(), CustomError> {\n        debug_assert!(!path.is_empty());\n        debug_assert!(self.current_table.is_empty());\n        debug_assert!(self.current_table_path.is_empty());\n\n        // 1. Look up the table on start to ensure the duplicate_key error points to the right line\n        // 2. Ensure any child tables from an implicit table are preserved\n        let root = self.document.as_table_mut();\n        let parent_table = Self::descend_path(root, &path[..path.len() - 1], false)?;\n        let key = &path[path.len() - 1];\n        if let Some(entry) = parent_table.remove(key.get()) {\n            match entry {\n                Item::Table(t) if t.implicit && !t.is_dotted() => {\n                    self.current_table = t;\n                }\n                // Since tables cannot be defined more than once, redefining such tables using a [table] header is not allowed. Likewise, using dotted keys to redefine tables already defined in [table] form is not allowed.\n                _ => return Err(CustomError::duplicate_key(&path, path.len() - 1)),\n            }\n        }\n\n        self.current_table_position += 1;\n        self.current_table.decor = decor;\n        self.current_table.set_implicit(false);\n        self.current_table.set_dotted(false);\n        self.current_table.set_position(self.current_table_position);\n        self.current_table.span = Some(span);\n        self.current_is_array = false;\n        self.current_table_path = path;\n\n        Ok(())\n    }\n\n    pub(crate) fn finalize_table(&mut self) -> Result<(), CustomError> {\n        let mut table = std::mem::take(&mut self.current_table);\n        let path = std::mem::take(&mut self.current_table_path);\n\n        let root = self.document.as_table_mut();\n        if path.is_empty() {\n            assert!(root.is_empty());\n            std::mem::swap(&mut table, root);\n        } else if self.current_is_array {\n            let parent_table = Self::descend_path(root, &path[..path.len() - 1], false)?;\n            let key = &path[path.len() - 1];\n\n            let entry = parent_table\n                .entry_format(key)\n                .or_insert(Item::ArrayOfTables(ArrayOfTables::new()));\n            let array = entry\n                .as_array_of_tables_mut()\n                .ok_or_else(|| CustomError::duplicate_key(&path, path.len() - 1))?;\n            array.push(table);\n            let span = if let (Some(first), Some(last)) = (\n                array.values.first().and_then(|t| t.span()),\n                array.values.last().and_then(|t| t.span()),\n            ) {\n                Some((first.start)..(last.end))\n            } else {\n                None\n            };\n            array.span = span;\n        } else {\n            let parent_table = Self::descend_path(root, &path[..path.len() - 1], false)?;\n            let key = &path[path.len() - 1];\n\n            let entry = parent_table.entry_format(key);\n            match entry {\n                crate::Entry::Occupied(entry) => {\n                    match entry.into_mut() {\n                        // if [a.b.c] header preceded [a.b]\n                        Item::Table(ref mut t) if t.implicit => {\n                            std::mem::swap(t, &mut table);\n                        }\n                        _ => return Err(CustomError::duplicate_key(&path, path.len() - 1)),\n                    }\n                }\n                crate::Entry::Vacant(entry) => {\n                    let item = Item::Table(table);\n                    entry.insert(item);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    pub(crate) fn descend_path<'t, 'k>(\n        mut table: &'t mut Table,\n        path: &'k [Key],\n        dotted: bool,\n    ) -> Result<&'t mut Table, CustomError> {\n        for (i, key) in path.iter().enumerate() {\n            let entry = table.entry_format(key).or_insert_with(|| {\n                let mut new_table = Table::new();\n                new_table.set_implicit(true);\n                new_table.set_dotted(dotted);\n\n                Item::Table(new_table)\n            });\n            match *entry {\n                Item::Value(ref v) => {\n                    return Err(CustomError::extend_wrong_type(path, i, v.type_name()));\n                }\n                Item::ArrayOfTables(ref mut array) => {\n                    debug_assert!(!array.is_empty());\n\n                    let index = array.len() - 1;\n                    let last_child = array.get_mut(index).unwrap();\n\n                    table = last_child;\n                }\n                Item::Table(ref mut sweet_child_of_mine) => {\n                    // Since tables cannot be defined more than once, redefining such tables using a\n                    // [table] header is not allowed. Likewise, using dotted keys to redefine tables\n                    // already defined in [table] form is not allowed.\n                    if dotted && !sweet_child_of_mine.is_implicit() {\n                        return Err(CustomError::DuplicateKey {\n                            key: key.get().into(),\n                            table: None,\n                        });\n                    }\n                    table = sweet_child_of_mine;\n                }\n                _ => unreachable!(),\n            }\n        }\n        Ok(table)\n    }\n\n    pub(crate) fn on_std_header(\n        &mut self,\n        path: Vec<Key>,\n        trailing: std::ops::Range<usize>,\n        span: std::ops::Range<usize>,\n    ) -> Result<(), CustomError> {\n        debug_assert!(!path.is_empty());\n\n        self.finalize_table()?;\n        let leading = self\n            .trailing\n            .take()\n            .map(RawString::with_span)\n            .unwrap_or_default();\n        self.start_table(\n            path,\n            Decor::new(leading, RawString::with_span(trailing)),\n            span,\n        )?;\n\n        Ok(())\n    }\n\n    pub(crate) fn on_array_header(\n        &mut self,\n        path: Vec<Key>,\n        trailing: std::ops::Range<usize>,\n        span: std::ops::Range<usize>,\n    ) -> Result<(), CustomError> {\n        debug_assert!(!path.is_empty());\n\n        self.finalize_table()?;\n        let leading = self\n            .trailing\n            .take()\n            .map(RawString::with_span)\n            .unwrap_or_default();\n        self.start_aray_table(\n            path,\n            Decor::new(leading, RawString::with_span(trailing)),\n            span,\n        )?;\n\n        Ok(())\n    }\n}"],"raw_string::RawString":["Clone","Eq","Hash","PartialEq","impl Default for RawString {\n    fn default() -> Self {\n        Self(RawStringInner::Empty)\n    }\n}","impl From<&InternalString> for RawString {\n    #[inline]\n    fn from(s: &InternalString) -> Self {\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }\n}","impl From<&String> for RawString {\n    #[inline]\n    fn from(s: &String) -> Self {\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }\n}","impl From<&str> for RawString {\n    #[inline]\n    fn from(s: &str) -> Self {\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }\n}","impl From<Box<str>> for RawString {\n    #[inline]\n    fn from(s: Box<str>) -> Self {\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }\n}","impl From<InternalString> for RawString {\n    #[inline]\n    fn from(inner: InternalString) -> Self {\n        Self(RawStringInner::Explicit(inner))\n    }\n}","impl From<String> for RawString {\n    #[inline]\n    fn from(s: String) -> Self {\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }\n}","impl RawString {\n    pub(crate) fn with_span(span: std::ops::Range<usize>) -> Self {\n        if span.start == span.end {\n            RawString(RawStringInner::Empty)\n        } else {\n            RawString(RawStringInner::Spanned(span))\n        }\n    }\n\n    /// Access the underlying string\n    pub fn as_str(&self) -> Option<&str> {\n        match &self.0 {\n            RawStringInner::Empty => Some(\"\"),\n            RawStringInner::Explicit(s) => Some(s.as_str()),\n            RawStringInner::Spanned(_) => None,\n        }\n    }\n\n    pub(crate) fn to_str<'s>(&'s self, input: &'s str) -> &'s str {\n        match &self.0 {\n            RawStringInner::Empty => \"\",\n            RawStringInner::Explicit(s) => s.as_str(),\n            RawStringInner::Spanned(span) => input.get(span.clone()).unwrap_or_else(|| {\n                panic!(\"span {:?} should be in input:\\n```\\n{}\\n```\", span, input)\n            }),\n        }\n    }\n\n    pub(crate) fn to_str_with_default<'s>(\n        &'s self,\n        input: Option<&'s str>,\n        default: &'s str,\n    ) -> &'s str {\n        match &self.0 {\n            RawStringInner::Empty => \"\",\n            RawStringInner::Explicit(s) => s.as_str(),\n            RawStringInner::Spanned(span) => {\n                if let Some(input) = input {\n                    input.get(span.clone()).unwrap_or_else(|| {\n                        panic!(\"span {:?} should be in input:\\n```\\n{}\\n```\", span, input)\n                    })\n                } else {\n                    default\n                }\n            }\n        }\n    }\n\n    /// Access the underlying span\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        match &self.0 {\n            RawStringInner::Empty => None,\n            RawStringInner::Explicit(_) => None,\n            RawStringInner::Spanned(span) => Some(span.clone()),\n        }\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        match &self.0 {\n            RawStringInner::Empty => {}\n            RawStringInner::Explicit(_) => {}\n            RawStringInner::Spanned(span) => {\n                *self = Self::from(input.get(span.clone()).unwrap_or_else(|| {\n                    panic!(\"span {:?} should be in input:\\n```\\n{}\\n```\", span, input)\n                }))\n            }\n        }\n    }\n\n    pub(crate) fn encode(&self, buf: &mut dyn std::fmt::Write, input: &str) -> std::fmt::Result {\n        let raw = self.to_str(input);\n        for part in raw.split('\\r') {\n            write!(buf, \"{}\", part)?;\n        }\n        Ok(())\n    }\n\n    pub(crate) fn encode_with_default(\n        &self,\n        buf: &mut dyn std::fmt::Write,\n        input: Option<&str>,\n        default: &str,\n    ) -> std::fmt::Result {\n        let raw = self.to_str_with_default(input, default);\n        for part in raw.split('\\r') {\n            write!(buf, \"{}\", part)?;\n        }\n        Ok(())\n    }\n}","impl std::fmt::Debug for RawString {\n    #[inline]\n    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n        match &self.0 {\n            RawStringInner::Empty => write!(formatter, \"empty\"),\n            RawStringInner::Explicit(s) => write!(formatter, \"{:?}\", s),\n            RawStringInner::Spanned(s) => write!(formatter, \"{:?}\", s),\n        }\n    }\n}"],"raw_string::RawStringInner":["Clone","Eq","Hash","PartialEq"],"repr::Decor":["Clone","Default","Eq","Hash","PartialEq","impl Decor {\n    /// Creates a new decor from the given prefix and suffix.\n    pub fn new(prefix: impl Into<RawString>, suffix: impl Into<RawString>) -> Self {\n        Self {\n            prefix: Some(prefix.into()),\n            suffix: Some(suffix.into()),\n        }\n    }\n\n    /// Go back to default decor\n    pub fn clear(&mut self) {\n        self.prefix = None;\n        self.suffix = None;\n    }\n\n    /// Get the prefix.\n    pub fn prefix(&self) -> Option<&RawString> {\n        self.prefix.as_ref()\n    }\n\n    pub(crate) fn prefix_encode(\n        &self,\n        buf: &mut dyn std::fmt::Write,\n        input: Option<&str>,\n        default: &str,\n    ) -> std::fmt::Result {\n        if let Some(prefix) = self.prefix() {\n            prefix.encode_with_default(buf, input, default)\n        } else {\n            write!(buf, \"{}\", default)\n        }\n    }\n\n    /// Set the prefix.\n    pub fn set_prefix(&mut self, prefix: impl Into<RawString>) {\n        self.prefix = Some(prefix.into());\n    }\n\n    /// Get the suffix.\n    pub fn suffix(&self) -> Option<&RawString> {\n        self.suffix.as_ref()\n    }\n\n    pub(crate) fn suffix_encode(\n        &self,\n        buf: &mut dyn std::fmt::Write,\n        input: Option<&str>,\n        default: &str,\n    ) -> std::fmt::Result {\n        if let Some(suffix) = self.suffix() {\n            suffix.encode_with_default(buf, input, default)\n        } else {\n            write!(buf, \"{}\", default)\n        }\n    }\n\n    /// Set the suffix.\n    pub fn set_suffix(&mut self, suffix: impl Into<RawString>) {\n        self.suffix = Some(suffix.into());\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        if let Some(prefix) = &mut self.prefix {\n            prefix.despan(input);\n        }\n        if let Some(suffix) = &mut self.suffix {\n            suffix.despan(input);\n        }\n    }\n}","impl std::fmt::Debug for Decor {\n    #[inline]\n    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let mut d = formatter.debug_struct(\"Decor\");\n        match &self.prefix {\n            Some(r) => d.field(\"prefix\", r),\n            None => d.field(\"prefix\", &\"default\"),\n        };\n        match &self.suffix {\n            Some(r) => d.field(\"suffix\", r),\n            None => d.field(\"suffix\", &\"default\"),\n        };\n        d.finish()\n    }\n}"],"repr::Formatted":["Clone","Eq","Hash","PartialEq","impl<T> Encode for Formatted<T>\nwhere\n    T: ValueRepr,\n{\n    fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result {\n        let decor = self.decor();\n        decor.prefix_encode(buf, input, default_decor.0)?;\n\n        if let Some(input) = input {\n            let repr = self\n                .as_repr()\n                .map(Cow::Borrowed)\n                .unwrap_or_else(|| Cow::Owned(self.default_repr()));\n            repr.encode(buf, input)?;\n        } else {\n            let repr = self.display_repr();\n            write!(buf, \"{}\", repr)?;\n        };\n\n        decor.suffix_encode(buf, input, default_decor.1)?;\n        Ok(())\n    }\n}","impl<T> Formatted<T>\nwhere\n    T: ValueRepr,\n{\n    /// Default-formatted value\n    pub fn new(value: T) -> Self {\n        Self {\n            value,\n            repr: None,\n            decor: Default::default(),\n        }\n    }\n\n    pub(crate) fn set_repr_unchecked(&mut self, repr: Repr) {\n        self.repr = Some(repr);\n    }\n\n    /// The wrapped value\n    pub fn value(&self) -> &T {\n        &self.value\n    }\n\n    /// The wrapped value\n    pub fn into_value(self) -> T {\n        self.value\n    }\n\n    /// Returns the raw representation, if available.\n    pub fn as_repr(&self) -> Option<&Repr> {\n        self.repr.as_ref()\n    }\n\n    /// Returns the default raw representation.\n    pub fn default_repr(&self) -> Repr {\n        self.value.to_repr()\n    }\n\n    /// Returns a raw representation.\n    pub fn display_repr(&self) -> Cow<str> {\n        self.as_repr()\n            .and_then(|r| r.as_raw().as_str())\n            .map(Cow::Borrowed)\n            .unwrap_or_else(|| {\n                Cow::Owned(self.default_repr().as_raw().as_str().unwrap().to_owned())\n            })\n    }\n\n    /// Returns the location within the original document\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.repr.as_ref().and_then(|r| r.span())\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        self.decor.despan(input);\n        if let Some(repr) = &mut self.repr {\n            repr.despan(input);\n        }\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor_mut(&mut self) -> &mut Decor {\n        &mut self.decor\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor(&self) -> &Decor {\n        &self.decor\n    }\n\n    /// Auto formats the value.\n    pub fn fmt(&mut self) {\n        self.repr = Some(self.value.to_repr());\n    }\n}","impl<T> std::fmt::Debug for Formatted<T>\nwhere\n    T: std::fmt::Debug,\n{\n    #[inline]\n    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let mut d = formatter.debug_struct(\"Formatted\");\n        d.field(\"value\", &self.value);\n        match &self.repr {\n            Some(r) => d.field(\"repr\", r),\n            None => d.field(\"repr\", &\"default\"),\n        };\n        d.field(\"decor\", &self.decor);\n        d.finish()\n    }\n}","impl<T> std::fmt::Display for Formatted<T>\nwhere\n    T: ValueRepr,\n{\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }\n}"],"repr::Repr":["Clone","Eq","Hash","PartialEq","impl Repr {\n    pub(crate) fn new_unchecked(raw: impl Into<RawString>) -> Self {\n        Repr {\n            raw_value: raw.into(),\n        }\n    }\n\n    /// Access the underlying value\n    pub fn as_raw(&self) -> &RawString {\n        &self.raw_value\n    }\n\n    /// Returns the location within the original document\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.raw_value.span()\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        self.raw_value.despan(input)\n    }\n\n    pub(crate) fn encode(&self, buf: &mut dyn std::fmt::Write, input: &str) -> std::fmt::Result {\n        self.as_raw().encode(buf, input)\n    }\n}","impl std::fmt::Debug for Repr {\n    #[inline]\n    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n        self.raw_value.fmt(formatter)\n    }\n}"],"std::string::String":["impl Index for String {\n    fn index<'v>(&self, v: &'v Item) -> Option<&'v Item> {\n        self[..].index(v)\n    }\n    fn index_mut<'v>(&self, v: &'v mut Item) -> Option<&'v mut Item> {\n        self[..].index_mut(v)\n    }\n}","impl Sealed for String {}","impl ValueRepr for String {\n    fn to_repr(&self) -> Repr {\n        to_string_repr(self, None, None)\n    }\n}"],"table::Entry":["impl<'a> Entry<'a> {\n    /// Returns the entry key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use toml_edit::Table;\n    ///\n    /// let mut map = Table::new();\n    ///\n    /// assert_eq!(\"hello\", map.entry(\"hello\").key());\n    /// ```\n    pub fn key(&self) -> &str {\n        match self {\n            Entry::Occupied(e) => e.key(),\n            Entry::Vacant(e) => e.key(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    pub fn or_insert(self, default: Item) -> &'a mut Item {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns a mutable reference to the value in the entry.\n    pub fn or_insert_with<F: FnOnce() -> Item>(self, default: F) -> &'a mut Item {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }\n}"],"table::OccupiedEntry":["impl<'a> OccupiedEntry<'a> {\n    /// Gets a reference to the entry key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use toml_edit::Table;\n    ///\n    /// let mut map = Table::new();\n    ///\n    /// assert_eq!(\"foo\", map.entry(\"foo\").key());\n    /// ```\n    pub fn key(&self) -> &str {\n        self.entry.key().as_str()\n    }\n\n    /// Gets a mutable reference to the entry key\n    pub fn key_mut(&mut self) -> KeyMut<'_> {\n        self.entry.get_mut().key.as_mut()\n    }\n\n    /// Gets a reference to the value in the entry.\n    pub fn get(&self) -> &Item {\n        &self.entry.get().value\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    pub fn get_mut(&mut self) -> &mut Item {\n        &mut self.entry.get_mut().value\n    }\n\n    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself\n    pub fn into_mut(self) -> &'a mut Item {\n        &mut self.entry.into_mut().value\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value\n    pub fn insert(&mut self, mut value: Item) -> Item {\n        std::mem::swap(&mut value, &mut self.entry.get_mut().value);\n        value\n    }\n\n    /// Takes the value out of the entry, and returns it\n    pub fn remove(self) -> Item {\n        self.entry.shift_remove().value\n    }\n}"],"table::Table":["Clone","Debug","Default","impl IntoIterator for Table {\n    type Item = (InternalString, Item);\n    type IntoIter = IntoIter;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Box::new(self.items.into_iter().map(|(k, kv)| (k, kv.value)))\n    }\n}","impl Sealed for crate::Table {}","impl Table {\n    /// Creates an empty table.\n    pub fn new() -> Self {\n        Default::default()\n    }\n\n    pub(crate) fn with_pos(doc_position: Option<usize>) -> Self {\n        Self {\n            doc_position,\n            ..Default::default()\n        }\n    }\n\n    pub(crate) fn with_pairs(items: KeyValuePairs) -> Self {\n        Self {\n            items,\n            ..Default::default()\n        }\n    }\n\n    /// Convert to an inline table\n    pub fn into_inline_table(mut self) -> InlineTable {\n        for (_, kv) in self.items.iter_mut() {\n            kv.value.make_value();\n        }\n        let mut t = InlineTable::with_pairs(self.items);\n        t.fmt();\n        t\n    }\n}","impl Table {\n    /// Get key/values for values that are visually children of this table\n    ///\n    /// For example, this will return dotted keys\n    pub fn get_values(&self) -> Vec<(Vec<&Key>, &Value)> {\n        let mut values = Vec::new();\n        let root = Vec::new();\n        self.append_values(&root, &mut values);\n        values\n    }\n\n    fn append_values<'s, 'c>(\n        &'s self,\n        parent: &[&'s Key],\n        values: &'c mut Vec<(Vec<&'s Key>, &'s Value)>,\n    ) {\n        for value in self.items.values() {\n            let mut path = parent.to_vec();\n            path.push(&value.key);\n            match &value.value {\n                Item::Table(table) if table.is_dotted() => {\n                    table.append_values(&path, values);\n                }\n                Item::Value(value) => {\n                    if let Some(table) = value.as_inline_table() {\n                        if table.is_dotted() {\n                            table.append_values(&path, values);\n                        } else {\n                            values.push((path, value));\n                        }\n                    } else {\n                        values.push((path, value));\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n\n    /// Auto formats the table.\n    pub fn fmt(&mut self) {\n        decorate_table(self);\n    }\n\n    /// Sorts Key/Value Pairs of the table.\n    ///\n    /// Doesn't affect subtables or subarrays.\n    pub fn sort_values(&mut self) {\n        // Assuming standard tables have their doc_position set and this won't negatively impact them\n        self.items.sort_keys();\n        for kv in self.items.values_mut() {\n            match &mut kv.value {\n                Item::Table(table) if table.is_dotted() => {\n                    table.sort_values();\n                }\n                _ => {}\n            }\n        }\n    }\n\n    /// Sort Key/Value Pairs of the table using the using the comparison function `compare`.\n    ///\n    /// The comparison function receives two key and value pairs to compare (you can sort by keys or\n    /// values or their combination as needed).\n    pub fn sort_values_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&Key, &Item, &Key, &Item) -> std::cmp::Ordering,\n    {\n        self.sort_values_by_internal(&mut compare);\n    }\n\n    fn sort_values_by_internal<F>(&mut self, compare: &mut F)\n    where\n        F: FnMut(&Key, &Item, &Key, &Item) -> std::cmp::Ordering,\n    {\n        let modified_cmp = |_: &InternalString,\n                            val1: &TableKeyValue,\n                            _: &InternalString,\n                            val2: &TableKeyValue|\n         -> std::cmp::Ordering {\n            compare(&val1.key, &val1.value, &val2.key, &val2.value)\n        };\n\n        self.items.sort_by(modified_cmp);\n\n        for kv in self.items.values_mut() {\n            match &mut kv.value {\n                Item::Table(table) if table.is_dotted() => {\n                    table.sort_values_by_internal(compare);\n                }\n                _ => {}\n            }\n        }\n    }\n\n    /// If a table has no key/value pairs and implicit, it will not be displayed.\n    ///\n    /// # Examples\n    ///\n    /// ```notrust\n    /// [target.\"x86_64/windows.json\".dependencies]\n    /// ```\n    ///\n    /// In the document above, tables `target` and `target.\"x86_64/windows.json\"` are implicit.\n    ///\n    /// ```\n    /// use toml_edit::Document;\n    /// let mut doc = \"[a]\\n[a.b]\\n\".parse::<Document>().expect(\"invalid toml\");\n    ///\n    /// doc[\"a\"].as_table_mut().unwrap().set_implicit(true);\n    /// assert_eq!(doc.to_string(), \"[a.b]\\n\");\n    /// ```\n    pub fn set_implicit(&mut self, implicit: bool) {\n        self.implicit = implicit;\n    }\n\n    /// If a table has no key/value pairs and implicit, it will not be displayed.\n    pub fn is_implicit(&self) -> bool {\n        self.implicit\n    }\n\n    /// Change this table's dotted status\n    pub fn set_dotted(&mut self, yes: bool) {\n        self.dotted = yes;\n    }\n\n    /// Check if this is a wrapper for dotted keys, rather than a standard table\n    pub fn is_dotted(&self) -> bool {\n        self.dotted\n    }\n\n    /// Sets the position of the `Table` within the `Document`.\n    pub fn set_position(&mut self, doc_position: usize) {\n        self.doc_position = Some(doc_position);\n    }\n\n    /// The position of the `Table` within the `Document`.\n    ///\n    /// Returns `None` if the `Table` was created manually (i.e. not via parsing)\n    /// in which case its position is set automatically.  This can be overridden with\n    /// [`Table::set_position`].\n    pub fn position(&self) -> Option<usize> {\n        self.doc_position\n    }\n\n    /// Returns the surrounding whitespace\n    pub fn decor_mut(&mut self) -> &mut Decor {\n        &mut self.decor\n    }\n\n    /// Returns the decor associated with a given key of the table.\n    pub fn decor(&self) -> &Decor {\n        &self.decor\n    }\n\n    /// Returns the decor associated with a given key of the table.\n    pub fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor> {\n        self.items.get_mut(key).map(|kv| &mut kv.key.decor)\n    }\n\n    /// Returns the decor associated with a given key of the table.\n    pub fn key_decor(&self, key: &str) -> Option<&Decor> {\n        self.items.get(key).map(|kv| &kv.key.decor)\n    }\n\n    /// Returns the location within the original document\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        self.span.clone()\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        self.span = None;\n        self.decor.despan(input);\n        for kv in self.items.values_mut() {\n            kv.key.despan(input);\n            kv.value.despan(input);\n        }\n    }\n}","impl Table {\n    /// Returns an iterator over all key/value pairs, including empty.\n    pub fn iter(&self) -> Iter<'_> {\n        Box::new(\n            self.items\n                .iter()\n                .filter(|(_, kv)| !kv.value.is_none())\n                .map(|(key, kv)| (&key[..], &kv.value)),\n        )\n    }\n\n    /// Returns an mutable iterator over all key/value pairs, including empty.\n    pub fn iter_mut(&mut self) -> IterMut<'_> {\n        Box::new(\n            self.items\n                .iter_mut()\n                .filter(|(_, kv)| !kv.value.is_none())\n                .map(|(_, kv)| (kv.key.as_mut(), &mut kv.value)),\n        )\n    }\n\n    /// Returns the number of non-empty items in the table.\n    pub fn len(&self) -> usize {\n        self.items.iter().filter(|i| !(i.1).value.is_none()).count()\n    }\n\n    /// Returns true if the table is empty.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Clears the table, removing all key-value pairs. Keeps the allocated memory for reuse.\n    pub fn clear(&mut self) {\n        self.items.clear()\n    }\n\n    /// Gets the given key's corresponding entry in the Table for in-place manipulation.\n    pub fn entry<'a>(&'a mut self, key: &str) -> Entry<'a> {\n        // Accept a `&str` rather than an owned type to keep `InternalString`, well, internal\n        match self.items.entry(key.into()) {\n            indexmap::map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { entry }),\n            indexmap::map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry { entry, key: None }),\n        }\n    }\n\n    /// Gets the given key's corresponding entry in the Table for in-place manipulation.\n    pub fn entry_format<'a>(&'a mut self, key: &Key) -> Entry<'a> {\n        // Accept a `&Key` to be consistent with `entry`\n        match self.items.entry(key.get().into()) {\n            indexmap::map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { entry }),\n            indexmap::map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry {\n                entry,\n                key: Some(key.to_owned()),\n            }),\n        }\n    }\n\n    /// Returns an optional reference to an item given the key.\n    pub fn get<'a>(&'a self, key: &str) -> Option<&'a Item> {\n        self.items.get(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some(&kv.value)\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Returns an optional mutable reference to an item given the key.\n    pub fn get_mut<'a>(&'a mut self, key: &str) -> Option<&'a mut Item> {\n        self.items.get_mut(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some(&mut kv.value)\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Return references to the key-value pair stored for key, if it is present, else None.\n    pub fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)> {\n        self.items.get(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some((&kv.key, &kv.value))\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Return mutable references to the key-value pair stored for key, if it is present, else None.\n    pub fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)> {\n        self.items.get_mut(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some((kv.key.as_mut(), &mut kv.value))\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Returns true if the table contains an item with the given key.\n    pub fn contains_key(&self, key: &str) -> bool {\n        if let Some(kv) = self.items.get(key) {\n            !kv.value.is_none()\n        } else {\n            false\n        }\n    }\n\n    /// Returns true if the table contains a table with the given key.\n    pub fn contains_table(&self, key: &str) -> bool {\n        if let Some(kv) = self.items.get(key) {\n            kv.value.is_table()\n        } else {\n            false\n        }\n    }\n\n    /// Returns true if the table contains a value with the given key.\n    pub fn contains_value(&self, key: &str) -> bool {\n        if let Some(kv) = self.items.get(key) {\n            kv.value.is_value()\n        } else {\n            false\n        }\n    }\n\n    /// Returns true if the table contains an array of tables with the given key.\n    pub fn contains_array_of_tables(&self, key: &str) -> bool {\n        if let Some(kv) = self.items.get(key) {\n            kv.value.is_array_of_tables()\n        } else {\n            false\n        }\n    }\n\n    /// Inserts a key-value pair into the map.\n    pub fn insert(&mut self, key: &str, item: Item) -> Option<Item> {\n        let kv = TableKeyValue::new(Key::new(key), item);\n        self.items.insert(key.into(), kv).map(|kv| kv.value)\n    }\n\n    /// Inserts a key-value pair into the map.\n    pub fn insert_formatted(&mut self, key: &Key, item: Item) -> Option<Item> {\n        let kv = TableKeyValue::new(key.to_owned(), item);\n        self.items.insert(key.get().into(), kv).map(|kv| kv.value)\n    }\n\n    /// Removes an item given the key.\n    pub fn remove(&mut self, key: &str) -> Option<Item> {\n        self.items.shift_remove(key).map(|kv| kv.value)\n    }\n\n    /// Removes a key from the map, returning the stored key and value if the key was previously in the map.\n    pub fn remove_entry(&mut self, key: &str) -> Option<(Key, Item)> {\n        self.items.shift_remove(key).map(|kv| (kv.key, kv.value))\n    }\n}","impl TableLike for Table {\n    fn iter(&self) -> Iter<'_> {\n        self.iter()\n    }\n    fn iter_mut(&mut self) -> IterMut<'_> {\n        self.iter_mut()\n    }\n    fn clear(&mut self) {\n        self.clear();\n    }\n    fn entry<'a>(&'a mut self, key: &str) -> Entry<'a> {\n        self.entry(key)\n    }\n    fn entry_format<'a>(&'a mut self, key: &Key) -> Entry<'a> {\n        self.entry_format(key)\n    }\n    fn get<'s>(&'s self, key: &str) -> Option<&'s Item> {\n        self.get(key)\n    }\n    fn get_mut<'s>(&'s mut self, key: &str) -> Option<&'s mut Item> {\n        self.get_mut(key)\n    }\n    fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)> {\n        self.get_key_value(key)\n    }\n    fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)> {\n        self.get_key_value_mut(key)\n    }\n    fn contains_key(&self, key: &str) -> bool {\n        self.contains_key(key)\n    }\n    fn insert(&mut self, key: &str, value: Item) -> Option<Item> {\n        self.insert(key, value)\n    }\n    fn remove(&mut self, key: &str) -> Option<Item> {\n        self.remove(key)\n    }\n\n    fn get_values(&self) -> Vec<(Vec<&Key>, &Value)> {\n        self.get_values()\n    }\n    fn fmt(&mut self) {\n        self.fmt()\n    }\n    fn sort_values(&mut self) {\n        self.sort_values()\n    }\n    fn is_dotted(&self) -> bool {\n        self.is_dotted()\n    }\n    fn set_dotted(&mut self, yes: bool) {\n        self.set_dotted(yes)\n    }\n\n    fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor> {\n        self.key_decor_mut(key)\n    }\n    fn key_decor(&self, key: &str) -> Option<&Decor> {\n        self.key_decor(key)\n    }\n}","impl std::fmt::Display for Table {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        use crate::encode::Encode;\n        let children = self.get_values();\n        // print table body\n        for (key_path, value) in children {\n            key_path.as_slice().encode(f, None, DEFAULT_KEY_DECOR)?;\n            write!(f, \"=\")?;\n            value.encode(f, None, DEFAULT_VALUE_DECOR)?;\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}","impl<'s> ops::Index<&'s str> for Table {\n    type Output = Item;\n\n    fn index(&self, key: &'s str) -> &Item {\n        self.get(key).expect(\"index not found\")\n    }\n}","impl<'s> ops::IndexMut<&'s str> for Table {\n    fn index_mut(&mut self, key: &'s str) -> &mut Item {\n        self.entry(key).or_insert(Item::None)\n    }\n}","impl<K: Into<Key>, V: Into<Value>> Extend<(K, V)> for Table {\n    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n        for (key, value) in iter {\n            let key = key.into();\n            let value = Item::Value(value.into());\n            let value = TableKeyValue::new(key, value);\n            self.items.insert(value.key.get().into(), value);\n        }\n    }\n}","impl<K: Into<Key>, V: Into<Value>> FromIterator<(K, V)> for Table {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let mut table = Table::new();\n        table.extend(iter);\n        table\n    }\n}"],"table::TableKeyValue":["Clone","Debug","impl TableKeyValue {\n    pub(crate) fn new(key: Key, value: Item) -> Self {\n        TableKeyValue { key, value }\n    }\n}"],"table::VacantEntry":["impl<'a> VacantEntry<'a> {\n    /// Gets a reference to the entry key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use toml_edit::Table;\n    ///\n    /// let mut map = Table::new();\n    ///\n    /// assert_eq!(\"foo\", map.entry(\"foo\").key());\n    /// ```\n    pub fn key(&self) -> &str {\n        self.entry.key().as_str()\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key,\n    /// and returns a mutable reference to it\n    pub fn insert(self, value: Item) -> &'a mut Item {\n        let entry = self.entry;\n        let key = self.key.unwrap_or_else(|| Key::new(entry.key().as_str()));\n        &mut entry.insert(TableKeyValue::new(key, value)).value\n    }\n}"],"toml_datetime::Datetime":["impl Sealed for crate::Datetime {}","impl ValueRepr for Datetime {\n    fn to_repr(&self) -> Repr {\n        Repr::new_unchecked(self.to_string())\n    }\n}"],"value::Value":["Clone","Debug","impl Encode for Value {\n    fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result {\n        match self {\n            Value::String(repr) => repr.encode(buf, input, default_decor),\n            Value::Integer(repr) => repr.encode(buf, input, default_decor),\n            Value::Float(repr) => repr.encode(buf, input, default_decor),\n            Value::Boolean(repr) => repr.encode(buf, input, default_decor),\n            Value::Datetime(repr) => repr.encode(buf, input, default_decor),\n            Value::Array(array) => array.encode(buf, input, default_decor),\n            Value::InlineTable(table) => table.encode(buf, input, default_decor),\n        }\n    }\n}","impl From<Array> for Value {\n    fn from(array: Array) -> Self {\n        Value::Array(array)\n    }\n}","impl From<Date> for Value {\n    fn from(d: Date) -> Self {\n        let d: Datetime = d.into();\n        d.into()\n    }\n}","impl From<Datetime> for Value {\n    fn from(d: Datetime) -> Self {\n        Value::Datetime(Formatted::new(d))\n    }\n}","impl From<InlineTable> for Value {\n    fn from(table: InlineTable) -> Self {\n        Value::InlineTable(table)\n    }\n}","impl From<InternalString> for Value {\n    fn from(s: InternalString) -> Self {\n        s.as_str().into()\n    }\n}","impl From<String> for Value {\n    fn from(s: String) -> Self {\n        Value::String(Formatted::new(s))\n    }\n}","impl From<Time> for Value {\n    fn from(d: Time) -> Self {\n        let d: Datetime = d.into();\n        d.into()\n    }\n}","impl From<bool> for Value {\n    fn from(b: bool) -> Self {\n        Value::Boolean(Formatted::new(b))\n    }\n}","impl From<f64> for Value {\n    fn from(f: f64) -> Self {\n        Value::Float(Formatted::new(f))\n    }\n}","impl From<i64> for Value {\n    fn from(i: i64) -> Self {\n        Value::Integer(Formatted::new(i))\n    }\n}","impl FromStr for Value {\n    type Err = crate::TomlError;\n\n    /// Parses a value from a &str\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        parser::parse_value(s)\n    }\n}","impl Value {\n    /// Get the decoration of the value.\n    /// # Example\n    /// ```rust\n    /// let v = toml_edit::Value::from(true);\n    /// assert_eq!(v.decor().suffix(), None);\n    ///```\n    pub fn decor_mut(&mut self) -> &mut Decor {\n        match self {\n            Value::String(f) => f.decor_mut(),\n            Value::Integer(f) => f.decor_mut(),\n            Value::Float(f) => f.decor_mut(),\n            Value::Boolean(f) => f.decor_mut(),\n            Value::Datetime(f) => f.decor_mut(),\n            Value::Array(a) => a.decor_mut(),\n            Value::InlineTable(t) => t.decor_mut(),\n        }\n    }\n\n    /// Get the decoration of the value.\n    /// # Example\n    /// ```rust\n    /// let v = toml_edit::Value::from(true);\n    /// assert_eq!(v.decor().suffix(), None);\n    ///```\n    pub fn decor(&self) -> &Decor {\n        match *self {\n            Value::String(ref f) => f.decor(),\n            Value::Integer(ref f) => f.decor(),\n            Value::Float(ref f) => f.decor(),\n            Value::Boolean(ref f) => f.decor(),\n            Value::Datetime(ref f) => f.decor(),\n            Value::Array(ref a) => a.decor(),\n            Value::InlineTable(ref t) => t.decor(),\n        }\n    }\n\n    /// Sets the prefix and the suffix for value.\n    /// # Example\n    /// ```rust\n    /// let mut v = toml_edit::Value::from(42);\n    /// assert_eq!(&v.to_string(), \"42\");\n    /// let d = v.decorated(\" \", \" \");\n    /// assert_eq!(&d.to_string(), \" 42 \");\n    /// ```\n    pub fn decorated(mut self, prefix: impl Into<RawString>, suffix: impl Into<RawString>) -> Self {\n        self.decorate(prefix, suffix);\n        self\n    }\n\n    pub(crate) fn decorate(&mut self, prefix: impl Into<RawString>, suffix: impl Into<RawString>) {\n        let decor = self.decor_mut();\n        *decor = Decor::new(prefix, suffix);\n    }\n\n    /// Returns the location within the original document\n    pub(crate) fn span(&self) -> Option<std::ops::Range<usize>> {\n        match self {\n            Value::String(f) => f.span(),\n            Value::Integer(f) => f.span(),\n            Value::Float(f) => f.span(),\n            Value::Boolean(f) => f.span(),\n            Value::Datetime(f) => f.span(),\n            Value::Array(a) => a.span(),\n            Value::InlineTable(t) => t.span(),\n        }\n    }\n\n    pub(crate) fn despan(&mut self, input: &str) {\n        match self {\n            Value::String(f) => f.despan(input),\n            Value::Integer(f) => f.despan(input),\n            Value::Float(f) => f.despan(input),\n            Value::Boolean(f) => f.despan(input),\n            Value::Datetime(f) => f.despan(input),\n            Value::Array(a) => a.despan(input),\n            Value::InlineTable(t) => t.despan(input),\n        }\n    }\n}","impl Value {\n    /// Text description of value type\n    pub fn type_name(&self) -> &'static str {\n        match self {\n            Value::String(..) => \"string\",\n            Value::Integer(..) => \"integer\",\n            Value::Float(..) => \"float\",\n            Value::Boolean(..) => \"boolean\",\n            Value::Datetime(..) => \"datetime\",\n            Value::Array(..) => \"array\",\n            Value::InlineTable(..) => \"inline table\",\n        }\n    }\n\n    /// Casts `self` to str.\n    pub fn as_str(&self) -> Option<&str> {\n        match *self {\n            Value::String(ref value) => Some(value.value()),\n            _ => None,\n        }\n    }\n\n    /// Returns true iff `self` is a string.\n    pub fn is_str(&self) -> bool {\n        self.as_str().is_some()\n    }\n\n    /// Casts `self` to integer.\n    pub fn as_integer(&self) -> Option<i64> {\n        match *self {\n            Value::Integer(ref value) => Some(*value.value()),\n            _ => None,\n        }\n    }\n\n    /// Returns true iff `self` is an integer.\n    pub fn is_integer(&self) -> bool {\n        self.as_integer().is_some()\n    }\n\n    /// Casts `self` to float.\n    pub fn as_float(&self) -> Option<f64> {\n        match *self {\n            Value::Float(ref value) => Some(*value.value()),\n            _ => None,\n        }\n    }\n\n    /// Returns true iff `self` is a float.\n    pub fn is_float(&self) -> bool {\n        self.as_float().is_some()\n    }\n\n    /// Casts `self` to boolean.\n    pub fn as_bool(&self) -> Option<bool> {\n        match *self {\n            Value::Boolean(ref value) => Some(*value.value()),\n            _ => None,\n        }\n    }\n\n    /// Returns true iff `self` is a boolean.\n    pub fn is_bool(&self) -> bool {\n        self.as_bool().is_some()\n    }\n\n    /// Casts `self` to date-time.\n    pub fn as_datetime(&self) -> Option<&Datetime> {\n        match *self {\n            Value::Datetime(ref value) => Some(value.value()),\n            _ => None,\n        }\n    }\n\n    /// Returns true iff `self` is a date-time.\n    pub fn is_datetime(&self) -> bool {\n        self.as_datetime().is_some()\n    }\n\n    /// Casts `self` to array.\n    pub fn as_array(&self) -> Option<&Array> {\n        match *self {\n            Value::Array(ref value) => Some(value),\n            _ => None,\n        }\n    }\n\n    /// Casts `self` to mutable array.\n    pub fn as_array_mut(&mut self) -> Option<&mut Array> {\n        match *self {\n            Value::Array(ref mut value) => Some(value),\n            _ => None,\n        }\n    }\n\n    /// Returns true iff `self` is an array.\n    pub fn is_array(&self) -> bool {\n        self.as_array().is_some()\n    }\n\n    /// Casts `self` to inline table.\n    pub fn as_inline_table(&self) -> Option<&InlineTable> {\n        match *self {\n            Value::InlineTable(ref value) => Some(value),\n            _ => None,\n        }\n    }\n\n    /// Casts `self` to mutable inline table.\n    pub fn as_inline_table_mut(&mut self) -> Option<&mut InlineTable> {\n        match *self {\n            Value::InlineTable(ref mut value) => Some(value),\n            _ => None,\n        }\n    }\n\n    /// Returns true iff `self` is an inline table.\n    pub fn is_inline_table(&self) -> bool {\n        self.as_inline_table().is_some()\n    }\n}","impl std::fmt::Display for Value {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }\n}","impl<'b> From<&'b InternalString> for Value {\n    fn from(s: &'b InternalString) -> Self {\n        s.as_str().into()\n    }\n}","impl<'b> From<&'b String> for Value {\n    fn from(s: &'b String) -> Self {\n        s.to_owned().into()\n    }\n}","impl<'b> From<&'b Value> for Value {\n    fn from(s: &'b Value) -> Self {\n        s.clone()\n    }\n}","impl<'b> From<&'b str> for Value {\n    fn from(s: &'b str) -> Self {\n        s.to_owned().into()\n    }\n}","impl<K: Into<Key>, V: Into<Value>> FromIterator<(K, V)> for Value {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let table: InlineTable = iter.into_iter().collect();\n        Value::InlineTable(table)\n    }\n}","impl<V: Into<Value>> FromIterator<V> for Value {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = V>,\n    {\n        let array: Array = iter.into_iter().collect();\n        Value::Array(array)\n    }\n}"]},"single_path_import":{"array::Array":"Array","array::ArrayIntoIter":"ArrayIntoIter","array::ArrayIter":"ArrayIter","array::ArrayIterMut":"ArrayIterMut","array_of_tables::ArrayOfTables":"ArrayOfTables","array_of_tables::ArrayOfTablesIntoIter":"ArrayOfTablesIntoIter","array_of_tables::ArrayOfTablesIter":"ArrayOfTablesIter","array_of_tables::ArrayOfTablesIterMut":"ArrayOfTablesIterMut","document::Document":"Document","inline_table::InlineEntry":"InlineEntry","inline_table::InlineOccupiedEntry":"InlineOccupiedEntry","inline_table::InlineTable":"InlineTable","inline_table::InlineTableIntoIter":"InlineTableIntoIter","inline_table::InlineTableIter":"InlineTableIter","inline_table::InlineTableIterMut":"InlineTableIterMut","inline_table::InlineVacantEntry":"InlineVacantEntry","internal_string::InternalString":"InternalString","item::Item":"Item","item::array":"array","item::table":"table","item::value":"value","key::Key":"Key","key::KeyMut":"KeyMut","parser::errors::TomlError":"TomlError","raw_string::RawString":"RawString","repr::Decor":"Decor","repr::Formatted":"Formatted","repr::Repr":"Repr","table::Entry":"Entry","table::IntoIter":"IntoIter","table::Iter":"Iter","table::IterMut":"IterMut","table::OccupiedEntry":"OccupiedEntry","table::Table":"Table","table::TableLike":"TableLike","table::VacantEntry":"VacantEntry","value::Value":"Value"},"srcs":{"<&'a T as index::Index>::index":["fn index<'v>(&self, v: &'v Item) -> Option<&'v Item>{\n        (**self).index(v)\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"<&'a T as index::Index>::index_mut":["fn index_mut<'v>(&self, v: &'v mut Item) -> Option<&'v mut Item>{\n        (**self).index_mut(v)\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"<&'k [&'k key::Key] as encode::Encode>::encode":["fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result{\n        for (i, key) in self.iter().enumerate() {\n            let first = i == 0;\n            let last = i + 1 == self.len();\n\n            let prefix = if first {\n                default_decor.0\n            } else {\n                DEFAULT_KEY_PATH_DECOR.0\n            };\n            let suffix = if last {\n                default_decor.1\n            } else {\n                DEFAULT_KEY_PATH_DECOR.1\n            };\n\n            if !first {\n                write!(buf, \".\")?;\n            }\n            key.encode(buf, input, (prefix, suffix))?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"<&'k [key::Key] as encode::Encode>::encode":["fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result{\n        for (i, key) in self.iter().enumerate() {\n            let first = i == 0;\n            let last = i + 1 == self.len();\n\n            let prefix = if first {\n                default_decor.0\n            } else {\n                DEFAULT_KEY_PATH_DECOR.0\n            };\n            let suffix = if last {\n                default_decor.1\n            } else {\n                DEFAULT_KEY_PATH_DECOR.1\n            };\n\n            if !first {\n                write!(buf, \".\")?;\n            }\n            key.encode(buf, input, (prefix, suffix))?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"<&'s array::Array as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"<&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"<&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<&'s table::Table as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<array::Array as encode::Encode>::encode":["fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result{\n        let decor = self.decor();\n        decor.prefix_encode(buf, input, default_decor.0)?;\n        write!(buf, \"[\")?;\n\n        for (i, elem) in self.iter().enumerate() {\n            let inner_decor;\n            if i == 0 {\n                inner_decor = DEFAULT_LEADING_VALUE_DECOR;\n            } else {\n                inner_decor = DEFAULT_VALUE_DECOR;\n                write!(buf, \",\")?;\n            }\n            elem.encode(buf, input, inner_decor)?;\n        }\n        if self.trailing_comma() && !self.is_empty() {\n            write!(buf, \",\")?;\n        }\n\n        self.trailing().encode_with_default(buf, input, \"\")?;\n        write!(buf, \"]\")?;\n        decor.suffix_encode(buf, input, default_decor.1)?;\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"<array::Array as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"<array::Array as std::iter::Extend<V>>::extend":["fn extend<T: IntoIterator<Item = V>>(&mut self, iter: T){\n        for value in iter {\n            self.push_formatted(value.into());\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"<array::Array as std::iter::FromIterator<V>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = V>,{\n        let v = iter.into_iter().map(|a| Item::Value(a.into()));\n        Array {\n            values: v.collect(),\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"<array::Array as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        Box::new(\n            self.values\n                .into_iter()\n                .filter(|v| v.is_value())\n                .map(|v| v.into_value().unwrap()),\n        )\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"<array_of_tables::ArrayOfTables as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        // HACK: Without the header, we don't really have a proper way of printing this\n        self.clone().into_array().fmt(f)\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend":["fn extend<T: IntoIterator<Item = Table>>(&mut self, iter: T){\n        for value in iter {\n            self.push(value);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = Table>,{\n        let v = iter.into_iter().map(Item::Table);\n        ArrayOfTables {\n            values: v.collect(),\n            span: None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"<array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        Box::new(\n            self.values\n                .into_iter()\n                .filter(|v| v.is_table())\n                .map(|v| v.into_table().unwrap()),\n        )\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"<document::Document as std::convert::From<table::Table>>::from":["fn from(root: Table) -> Self{\n        Self {\n            root: Item::Table(root),\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"<document::Document as std::default::Default>::default":["fn default() -> Self{\n        Self {\n            root: Item::Table(Table::with_pos(Some(0))),\n            trailing: Default::default(),\n            original: Default::default(),\n            span: Default::default(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"<document::Document as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        self.as_table()\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"<document::Document as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut Self::Target{\n        self.as_table_mut()\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"<document::Document as std::str::FromStr>::from_str":["/// Parses a document from a &str\nfn from_str(s: &str) -> Result<Self, Self::Err>{\n        let mut d = parser::parse_document(s)?;\n        d.despan();\n        Ok(d)\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"<inline_table::InlineTable as encode::Encode>::encode":["fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result{\n        let decor = self.decor();\n        decor.prefix_encode(buf, input, default_decor.0)?;\n        write!(buf, \"{{\")?;\n        self.preamble().encode_with_default(buf, input, \"\")?;\n\n        let children = self.get_values();\n        let len = children.len();\n        for (i, (key_path, value)) in children.into_iter().enumerate() {\n            if i != 0 {\n                write!(buf, \",\")?;\n            }\n            let inner_decor = if i == len - 1 {\n                DEFAULT_TRAILING_VALUE_DECOR\n            } else {\n                DEFAULT_VALUE_DECOR\n            };\n            key_path\n                .as_slice()\n                .encode(buf, input, DEFAULT_INLINE_KEY_DECOR)?;\n            write!(buf, \"=\")?;\n            value.encode(buf, input, inner_decor)?;\n        }\n\n        write!(buf, \"}}\")?;\n        decor.suffix_encode(buf, input, default_decor.1)?;\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"<inline_table::InlineTable as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend":["fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T){\n        for (key, value) in iter {\n            let key = key.into();\n            let value = Item::Value(value.into());\n            let value = TableKeyValue::new(key, value);\n            self.items\n                .insert(InternalString::from(value.key.get()), value);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (K, V)>,{\n        let mut table = InlineTable::new();\n        table.extend(iter);\n        table\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        Box::new(\n            self.items\n                .into_iter()\n                .filter(|(_, kv)| kv.value.is_value())\n                .map(|(k, kv)| (k, kv.value.into_value().unwrap())),\n        )\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::clear":["fn clear(&mut self){\n        self.clear();\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::contains_key":["fn contains_key(&self, key: &str) -> bool{\n        self.contains_key(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::entry":["fn entry<'a>(&'a mut self, key: &str) -> crate::Entry<'a>{\n        // Accept a `&str` rather than an owned type to keep `InternalString`, well, internal\n        match self.items.entry(key.into()) {\n            indexmap::map::Entry::Occupied(entry) => {\n                crate::Entry::Occupied(crate::OccupiedEntry { entry })\n            }\n            indexmap::map::Entry::Vacant(entry) => {\n                crate::Entry::Vacant(crate::VacantEntry { entry, key: None })\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::entry_format":["fn entry_format<'a>(&'a mut self, key: &Key) -> crate::Entry<'a>{\n        // Accept a `&Key` to be consistent with `entry`\n        match self.items.entry(key.get().into()) {\n            indexmap::map::Entry::Occupied(entry) => {\n                crate::Entry::Occupied(crate::OccupiedEntry { entry })\n            }\n            indexmap::map::Entry::Vacant(entry) => crate::Entry::Vacant(crate::VacantEntry {\n                entry,\n                key: Some(key.to_owned()),\n            }),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::fmt":["fn fmt(&mut self){\n        self.fmt()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::get":["fn get<'s>(&'s self, key: &str) -> Option<&'s Item>{\n        self.items.get(key).map(|kv| &kv.value)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::get_key_value":["fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)>{\n        self.get_key_value(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::get_key_value_mut":["fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)>{\n        self.get_key_value_mut(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::get_mut":["fn get_mut<'s>(&'s mut self, key: &str) -> Option<&'s mut Item>{\n        self.items.get_mut(key).map(|kv| &mut kv.value)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::get_values":["fn get_values(&self) -> Vec<(Vec<&Key>, &Value)>{\n        self.get_values()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::insert":["fn insert(&mut self, key: &str, value: Item) -> Option<Item>{\n        self.insert(key, value.into_value().unwrap())\n            .map(Item::Value)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::is_dotted":["fn is_dotted(&self) -> bool{\n        self.is_dotted()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::iter":["fn iter(&self) -> Iter<'_>{\n        Box::new(self.items.iter().map(|(key, kv)| (&key[..], &kv.value)))\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::iter_mut":["fn iter_mut(&mut self) -> IterMut<'_>{\n        Box::new(\n            self.items\n                .iter_mut()\n                .map(|(_, kv)| (kv.key.as_mut(), &mut kv.value)),\n        )\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::key_decor":["fn key_decor(&self, key: &str) -> Option<&Decor>{\n        self.key_decor(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::key_decor_mut":["fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor>{\n        self.key_decor_mut(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::remove":["fn remove(&mut self, key: &str) -> Option<Item>{\n        self.remove(key).map(Item::Value)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::set_dotted":["fn set_dotted(&mut self, yes: bool){\n        self.set_dotted(yes)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<inline_table::InlineTable as table::TableLike>::sort_values":["fn sort_values(&mut self){\n        self.sort_values()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"<internal_string::InternalString as std::borrow::Borrow<str>>::borrow":["#[inline]\nfn borrow(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::convert::AsRef<str>>::as_ref":["#[inline]\nfn as_ref(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from":["#[inline]\nfn from(s: &InternalString) -> Self{\n        s.clone()\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::convert::From<&std::string::String>>::from":["#[inline]\nfn from(s: &String) -> Self{\n        InternalString(s.into())\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::convert::From<&str>>::from":["#[inline]\nfn from(s: &str) -> Self{\n        #[cfg(feature = \"kstring\")]\n        let inner = kstring::KString::from_ref(s);\n        #[cfg(not(feature = \"kstring\"))]\n        let inner = String::from(s);\n\n        InternalString(inner)\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from":["#[inline]\nfn from(s: Box<str>) -> Self{\n        InternalString(s.into())\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::convert::From<std::string::String>>::from":["#[inline]\nfn from(s: String) -> Self{\n        #[allow(clippy::useless_conversion)] // handle any string type\n        InternalString(s.into())\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error>{\n        self.0.fmt(formatter)\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        self.as_str().fmt(f)\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<internal_string::InternalString as std::str::FromStr>::from_str":["#[inline]\nfn from_str(s: &str) -> Result<Self, Self::Err>{\n        Ok(Self::from(s))\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"<item::Item as std::default::Default>::default":["fn default() -> Self{\n        Item::None\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"<item::Item as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        match &self {\n            Item::None => Ok(()),\n            Item::Value(v) => v.fmt(f),\n            Item::Table(v) => v.fmt(f),\n            Item::ArrayOfTables(v) => v.fmt(f),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"<item::Item as std::str::FromStr>::from_str":["/// Parses a value from a &str\nfn from_str(s: &str) -> Result<Self, Self::Err>{\n        let value = s.parse::<Value>()?;\n        Ok(Item::Value(value))\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"<key::Key as encode::Encode>::encode":["fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result{\n        let decor = self.decor();\n        decor.prefix_encode(buf, input, default_decor.0)?;\n\n        if let Some(input) = input {\n            let repr = self\n                .as_repr()\n                .map(Cow::Borrowed)\n                .unwrap_or_else(|| Cow::Owned(self.default_repr()));\n            repr.encode(buf, input)?;\n        } else {\n            let repr = self.display_repr();\n            write!(buf, \"{}\", repr)?;\n        };\n\n        decor.suffix_encode(buf, input, default_decor.1)?;\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"<key::Key as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> std::cmp::Ordering{\n        self.get().cmp(other.get())\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::cmp::PartialEq<&'s str>>::eq":["#[inline]\nfn eq(&self, other: &&str) -> bool{\n        PartialEq::eq(self.get(), *other)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::cmp::PartialEq<std::string::String>>::eq":["#[inline]\nfn eq(&self, other: &String) -> bool{\n        PartialEq::eq(self.get(), other.as_str())\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::cmp::PartialEq<str>>::eq":["#[inline]\nfn eq(&self, other: &str) -> bool{\n        PartialEq::eq(self.get(), other)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &Key) -> bool{\n        PartialEq::eq(self.get(), other.get())\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::convert::From<&'b std::string::String>>::from":["fn from(s: &'b String) -> Self{\n        Key::new(s)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::convert::From<&'b str>>::from":["fn from(s: &'b str) -> Self{\n        Key::new(s)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::convert::From<internal_string::InternalString>>::from":["fn from(s: InternalString) -> Self{\n        Key::new(s)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::convert::From<std::string::String>>::from":["fn from(s: String) -> Self{\n        Key::new(s)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::hash::Hash>::hash":["fn hash<H: std::hash::Hasher>(&self, state: &mut H){\n        self.get().hash(state);\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        self.get()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::Key as std::str::FromStr>::from_str":["/// Tries to parse a key from a &str,\n/// if fails, tries as basic quoted key (surrounds with \"\")\n/// and then literal quoted key (surrounds with '')\nfn from_str(s: &str) -> Result<Self, Self::Err>{\n        Key::try_parse_simple(s)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::KeyMut<'k> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        std::fmt::Display::fmt(&self.key, f)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::KeyMut<'k> as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        self.get()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq":["#[inline]\nfn eq(&self, other: &&str) -> bool{\n        PartialEq::eq(self.get(), *other)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq":["#[inline]\nfn eq(&self, other: &String) -> bool{\n        PartialEq::eq(self.get(), other.as_str())\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq":["#[inline]\nfn eq(&self, other: &str) -> bool{\n        PartialEq::eq(self.get(), other)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"<parser::errors::CustomError as std::error::Error>::description":["fn description(&self) -> &'static str{\n        \"TOML parse error\"\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::CustomError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> Result{\n        match self {\n            CustomError::DuplicateKey { key, table } => {\n                if let Some(table) = table {\n                    if table.is_empty() {\n                        write!(f, \"duplicate key `{}` in document root\", key)\n                    } else {\n                        let path = table.iter().map(|k| k.get()).collect::<Vec<_>>().join(\".\");\n                        write!(f, \"duplicate key `{}` in table `{}`\", key, path)\n                    }\n                } else {\n                    write!(f, \"duplicate key `{}`\", key)\n                }\n            }\n            CustomError::DottedKeyExtendWrongType { key, actual } => {\n                let path = key.iter().map(|k| k.get()).collect::<Vec<_>>().join(\".\");\n                write!(\n                    f,\n                    \"dotted key `{}` attempted to extend non-table type ({})\",\n                    path, actual\n                )\n            }\n            CustomError::OutOfRange => write!(f, \"value is out of range\"),\n            CustomError::RecursionLimitExceeded => write!(f, \"recursion limit exceded\"),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'a> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        let expression = self.context.iter().find_map(|c| match c {\n            Context::Expression(c) => Some(c),\n            _ => None,\n        });\n        let expected = self\n            .context\n            .iter()\n            .filter_map(|c| match c {\n                Context::Expected(c) => Some(c),\n                _ => None,\n            })\n            .collect::<Vec<_>>();\n\n        let mut newline = false;\n\n        if let Some(expression) = expression {\n            newline = true;\n\n            write!(f, \"invalid {}\", expression)?;\n        }\n\n        if !expected.is_empty() {\n            if newline {\n                writeln!(f)?;\n            }\n            newline = true;\n\n            write!(f, \"expected \")?;\n            for (i, expected) in expected.iter().enumerate() {\n                if i != 0 {\n                    write!(f, \", \")?;\n                }\n                write!(f, \"{}\", expected)?;\n            }\n        }\n        if let Some(cause) = &self.cause {\n            if newline {\n                writeln!(f)?;\n            }\n            write!(f, \"{}\", cause)?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        self.input == other.input\n            && self.context == other.context\n            && self.cause.as_ref().map(ToString::to_string)\n                == other.cause.as_ref().map(ToString::to_string)\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context":["fn add_context(mut self, _input: Input<'b>, ctx: Context) -> Self{\n        self.context.push(ctx);\n        self\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error":["fn from_external_error(input: &'b str, _kind: winnow::error::ErrorKind, e: E) -> Self{\n        Self {\n            input: Input::new(BStr::new(input)),\n            context: Default::default(),\n            cause: Some(Box::new(e)),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error":["fn from_external_error(input: Input<'b>, _kind: winnow::error::ErrorKind, e: E) -> Self{\n        Self {\n            input,\n            context: Default::default(),\n            cause: Some(Box::new(e)),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append":["fn append(self, _input: &'b str, _kind: winnow::error::ErrorKind) -> Self{\n        self\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind":["fn from_error_kind(input: &'b str, _kind: winnow::error::ErrorKind) -> Self{\n        Self {\n            input: Input::new(BStr::new(input)),\n            context: Default::default(),\n            cause: Default::default(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or":["fn or(self, other: Self) -> Self{\n        other\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append":["fn append(self, _input: Input<'b>, _kind: winnow::error::ErrorKind) -> Self{\n        self\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind":["fn from_error_kind(input: Input<'b>, _kind: winnow::error::ErrorKind) -> Self{\n        Self {\n            input,\n            context: Default::default(),\n            cause: Default::default(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or":["fn or(self, other: Self) -> Self{\n        other\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::ParserValue as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        match self {\n            ParserValue::CharLiteral('\\n') => \"newline\".fmt(f),\n            ParserValue::CharLiteral('`') => \"'`'\".fmt(f),\n            ParserValue::CharLiteral(c) if c.is_ascii_control() => {\n                write!(f, \"`{}`\", c.escape_debug())\n            }\n            ParserValue::CharLiteral(c) => write!(f, \"`{}`\", c),\n            ParserValue::StringLiteral(c) => write!(f, \"`{}`\", c),\n            ParserValue::Description(c) => write!(f, \"{}\", c),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::TomlError as std::error::Error>::description":["fn description(&self) -> &'static str{\n        \"TOML parse error\"\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::errors::TomlError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> Result{\n        let mut context = false;\n        if let (Some(original), Some(span)) = (&self.original, self.span()) {\n            context = true;\n\n            let (line, column) = translate_position(original.as_bytes(), span.start);\n            let line_num = line + 1;\n            let col_num = column + 1;\n            let gutter = line_num.to_string().len();\n            let content = original.split('\\n').nth(line).expect(\"valid line number\");\n\n            writeln!(\n                f,\n                \"TOML parse error at line {}, column {}\",\n                line_num, col_num\n            )?;\n            //   |\n            for _ in 0..=gutter {\n                write!(f, \" \")?;\n            }\n            writeln!(f, \"|\")?;\n\n            // 1 | 00:32:00.a999999\n            write!(f, \"{} | \", line_num)?;\n            writeln!(f, \"{}\", content)?;\n\n            //   |          ^\n            for _ in 0..=gutter {\n                write!(f, \" \")?;\n            }\n            write!(f, \"|\")?;\n            for _ in 0..=column {\n                write!(f, \" \")?;\n            }\n            // The span will be empty at eof, so we need to make sure we always print at least\n            // one `^`\n            write!(f, \"^\")?;\n            for _ in (span.start + 1)..(span.end.min(span.start + content.len())) {\n                write!(f, \"^\")?;\n            }\n            writeln!(f)?;\n        }\n        writeln!(f, \"{}\", self.message)?;\n        if !context && !self.keys.is_empty() {\n            writeln!(f, \"in `{}`\", self.keys.join(\".\"))?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"<parser::state::ParseState as std::default::Default>::default":["fn default() -> Self{\n        let mut root = Table::new();\n        root.span = Some(0..0);\n        Self {\n            document: Document::new(),\n            trailing: None,\n            current_table_position: 0,\n            current_table: root,\n            current_is_array: false,\n            current_table_path: Vec::new(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"<raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from":["#[inline]\nfn from(s: &InternalString) -> Self{\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"<raw_string::RawString as std::convert::From<&std::string::String>>::from":["#[inline]\nfn from(s: &String) -> Self{\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"<raw_string::RawString as std::convert::From<&str>>::from":["#[inline]\nfn from(s: &str) -> Self{\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"<raw_string::RawString as std::convert::From<internal_string::InternalString>>::from":["#[inline]\nfn from(inner: InternalString) -> Self{\n        Self(RawStringInner::Explicit(inner))\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"<raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from":["#[inline]\nfn from(s: Box<str>) -> Self{\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"<raw_string::RawString as std::convert::From<std::string::String>>::from":["#[inline]\nfn from(s: String) -> Self{\n        if s.is_empty() {\n            Self(RawStringInner::Empty)\n        } else {\n            InternalString::from(s).into()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"<raw_string::RawString as std::default::Default>::default":["fn default() -> Self{\n        Self(RawStringInner::Empty)\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"<raw_string::RawString as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error>{\n        match &self.0 {\n            RawStringInner::Empty => write!(formatter, \"empty\"),\n            RawStringInner::Explicit(s) => write!(formatter, \"{:?}\", s),\n            RawStringInner::Spanned(s) => write!(formatter, \"{:?}\", s),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"<repr::Decor as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error>{\n        let mut d = formatter.debug_struct(\"Decor\");\n        match &self.prefix {\n            Some(r) => d.field(\"prefix\", r),\n            None => d.field(\"prefix\", &\"default\"),\n        };\n        match &self.suffix {\n            Some(r) => d.field(\"suffix\", r),\n            None => d.field(\"suffix\", &\"default\"),\n        };\n        d.finish()\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"<repr::Formatted<T> as encode::Encode>::encode":["fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result{\n        let decor = self.decor();\n        decor.prefix_encode(buf, input, default_decor.0)?;\n\n        if let Some(input) = input {\n            let repr = self\n                .as_repr()\n                .map(Cow::Borrowed)\n                .unwrap_or_else(|| Cow::Owned(self.default_repr()));\n            repr.encode(buf, input)?;\n        } else {\n            let repr = self.display_repr();\n            write!(buf, \"{}\", repr)?;\n        };\n\n        decor.suffix_encode(buf, input, default_decor.1)?;\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"<repr::Formatted<T> as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error>{\n        let mut d = formatter.debug_struct(\"Formatted\");\n        d.field(\"value\", &self.value);\n        match &self.repr {\n            Some(r) => d.field(\"repr\", r),\n            None => d.field(\"repr\", &\"default\"),\n        };\n        d.field(\"decor\", &self.decor);\n        d.finish()\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"<repr::Formatted<T> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"<repr::Repr as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error>{\n        self.raw_value.fmt(formatter)\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"<std::string::String as index::Index>::index":["fn index<'v>(&self, v: &'v Item) -> Option<&'v Item>{\n        self[..].index(v)\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"<std::string::String as index::Index>::index_mut":["fn index_mut<'v>(&self, v: &'v mut Item) -> Option<&'v mut Item>{\n        self[..].index_mut(v)\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"<str as index::Index>::index":["fn index<'v>(&self, v: &'v Item) -> Option<&'v Item>{\n        match *v {\n            Item::Table(ref t) => t.get(self),\n            Item::Value(ref v) => v\n                .as_inline_table()\n                .and_then(|t| t.items.get(self))\n                .and_then(|kv| {\n                    if !kv.value.is_none() {\n                        Some(&kv.value)\n                    } else {\n                        None\n                    }\n                }),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"<str as index::Index>::index_mut":["fn index_mut<'v>(&self, v: &'v mut Item) -> Option<&'v mut Item>{\n        if let Item::None = *v {\n            let mut t = InlineTable::default();\n            t.items.insert(\n                InternalString::from(self),\n                TableKeyValue::new(Key::new(self), Item::None),\n            );\n            *v = value(Value::InlineTable(t));\n        }\n        match *v {\n            Item::Table(ref mut t) => Some(t.entry(self).or_insert(Item::None)),\n            Item::Value(ref mut v) => v.as_inline_table_mut().map(|t| {\n                &mut t\n                    .items\n                    .entry(InternalString::from(self))\n                    .or_insert_with(|| TableKeyValue::new(Key::new(self), Item::None))\n                    .value\n            }),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"<table::Table as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        use crate::encode::Encode;\n        let children = self.get_values();\n        // print table body\n        for (key_path, value) in children {\n            key_path.as_slice().encode(f, None, DEFAULT_KEY_DECOR)?;\n            write!(f, \"=\")?;\n            value.encode(f, None, DEFAULT_VALUE_DECOR)?;\n            writeln!(f)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as std::iter::Extend<(K, V)>>::extend":["fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T){\n        for (key, value) in iter {\n            let key = key.into();\n            let value = Item::Value(value.into());\n            let value = TableKeyValue::new(key, value);\n            self.items.insert(value.key.get().into(), value);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as std::iter::FromIterator<(K, V)>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (K, V)>,{\n        let mut table = Table::new();\n        table.extend(iter);\n        table\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        Box::new(self.items.into_iter().map(|(k, kv)| (k, kv.value)))\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::clear":["fn clear(&mut self){\n        self.clear();\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::contains_key":["fn contains_key(&self, key: &str) -> bool{\n        self.contains_key(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::entry":["fn entry<'a>(&'a mut self, key: &str) -> Entry<'a>{\n        self.entry(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::entry_format":["fn entry_format<'a>(&'a mut self, key: &Key) -> Entry<'a>{\n        self.entry_format(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::fmt":["fn fmt(&mut self){\n        self.fmt()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::get":["fn get<'s>(&'s self, key: &str) -> Option<&'s Item>{\n        self.get(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::get_key_value":["fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)>{\n        self.get_key_value(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::get_key_value_mut":["fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)>{\n        self.get_key_value_mut(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::get_mut":["fn get_mut<'s>(&'s mut self, key: &str) -> Option<&'s mut Item>{\n        self.get_mut(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::get_values":["fn get_values(&self) -> Vec<(Vec<&Key>, &Value)>{\n        self.get_values()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::insert":["fn insert(&mut self, key: &str, value: Item) -> Option<Item>{\n        self.insert(key, value)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::is_dotted":["fn is_dotted(&self) -> bool{\n        self.is_dotted()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::iter":["fn iter(&self) -> Iter<'_>{\n        self.iter()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::iter_mut":["fn iter_mut(&mut self) -> IterMut<'_>{\n        self.iter_mut()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::key_decor":["fn key_decor(&self, key: &str) -> Option<&Decor>{\n        self.key_decor(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::key_decor_mut":["fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor>{\n        self.key_decor_mut(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::remove":["fn remove(&mut self, key: &str) -> Option<Item>{\n        self.remove(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::set_dotted":["fn set_dotted(&mut self, yes: bool){\n        self.set_dotted(yes)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<table::Table as table::TableLike>::sort_values":["fn sort_values(&mut self){\n        self.sort_values()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"<usize as index::Index>::index":["fn index<'v>(&self, v: &'v Item) -> Option<&'v Item>{\n        match *v {\n            Item::ArrayOfTables(ref aot) => aot.values.get(*self),\n            Item::Value(ref a) if a.is_array() => a.as_array().and_then(|a| a.values.get(*self)),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"<usize as index::Index>::index_mut":["fn index_mut<'v>(&self, v: &'v mut Item) -> Option<&'v mut Item>{\n        match *v {\n            Item::ArrayOfTables(ref mut vec) => vec.values.get_mut(*self),\n            Item::Value(ref mut a) => a.as_array_mut().and_then(|a| a.values.get_mut(*self)),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"<value::Value as encode::Encode>::encode":["fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result{\n        match self {\n            Value::String(repr) => repr.encode(buf, input, default_decor),\n            Value::Integer(repr) => repr.encode(buf, input, default_decor),\n            Value::Float(repr) => repr.encode(buf, input, default_decor),\n            Value::Boolean(repr) => repr.encode(buf, input, default_decor),\n            Value::Datetime(repr) => repr.encode(buf, input, default_decor),\n            Value::Array(array) => array.encode(buf, input, default_decor),\n            Value::InlineTable(table) => table.encode(buf, input, default_decor),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"<value::Value as std::convert::From<&'b internal_string::InternalString>>::from":["fn from(s: &'b InternalString) -> Self{\n        s.as_str().into()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<&'b std::string::String>>::from":["fn from(s: &'b String) -> Self{\n        s.to_owned().into()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<&'b str>>::from":["fn from(s: &'b str) -> Self{\n        s.to_owned().into()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<&'b value::Value>>::from":["fn from(s: &'b Value) -> Self{\n        s.clone()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<array::Array>>::from":["fn from(array: Array) -> Self{\n        Value::Array(array)\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<bool>>::from":["fn from(b: bool) -> Self{\n        Value::Boolean(Formatted::new(b))\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<f64>>::from":["fn from(f: f64) -> Self{\n        Value::Float(Formatted::new(f))\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<i64>>::from":["fn from(i: i64) -> Self{\n        Value::Integer(Formatted::new(i))\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<inline_table::InlineTable>>::from":["fn from(table: InlineTable) -> Self{\n        Value::InlineTable(table)\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<internal_string::InternalString>>::from":["fn from(s: InternalString) -> Self{\n        s.as_str().into()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<std::string::String>>::from":["fn from(s: String) -> Self{\n        Value::String(Formatted::new(s))\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<toml_datetime::Date>>::from":["fn from(d: Date) -> Self{\n        let d: Datetime = d.into();\n        d.into()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<toml_datetime::Datetime>>::from":["fn from(d: Datetime) -> Self{\n        Value::Datetime(Formatted::new(d))\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::convert::From<toml_datetime::Time>>::from":["fn from(d: Time) -> Self{\n        let d: Datetime = d.into();\n        d.into()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result{\n        crate::encode::Encode::encode(self, f, None, (\"\", \"\"))\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::iter::FromIterator<(K, V)>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (K, V)>,{\n        let table: InlineTable = iter.into_iter().collect();\n        Value::InlineTable(table)\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::iter::FromIterator<V>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = V>,{\n        let array: Array = iter.into_iter().collect();\n        Value::Array(array)\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"<value::Value as std::str::FromStr>::from_str":["/// Parses a value from a &str\nfn from_str(s: &str) -> Result<Self, Self::Err>{\n        parser::parse_value(s)\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"array::Array":["/// Type representing a TOML array,\n/// payload of the `Value::Array` variant's value\npub struct Array {\n    // `trailing` represents whitespaces, newlines\n    // and comments in an empty array or after the trailing comma\n    trailing: RawString,\n    trailing_comma: bool,\n    // prefix before `[` and suffix after `]`\n    decor: Decor,\n    pub(crate) span: Option<std::ops::Range<usize>>,\n    // always Vec<Item::Value>\n    pub(crate) values: Vec<Item>,\n}","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::clear":["/// Clears the array, removing all values. Keeps the allocated memory for reuse.\npub fn clear(&mut self){\n        self.values.clear()\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::decor":["/// Returns the surrounding whitespace\npub fn decor(&self) -> &Decor{\n        &self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::decor_mut":["/// Returns the surrounding whitespace\npub fn decor_mut(&mut self) -> &mut Decor{\n        &mut self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::despan":["pub(crate) fn despan(&mut self, input: &str){\n        self.span = None;\n        self.decor.despan(input);\n        self.trailing.despan(input);\n        for value in &mut self.values {\n            value.despan(input);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::fmt":["/// Auto formats the array.\npub fn fmt(&mut self){\n        decorate_array(self);\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::get":["/// Returns a reference to the value at the given index, or `None` if the index is out of\n/// bounds.\npub fn get(&self, index: usize) -> Option<&Value>{\n        self.values.get(index).and_then(Item::as_value)\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::get_mut":["/// Returns a reference to the value at the given index, or `None` if the index is out of\n/// bounds.\npub fn get_mut(&mut self, index: usize) -> Option<&mut Value>{\n        self.values.get_mut(index).and_then(Item::as_value_mut)\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::insert":["/// Inserts an element at the given position within the array, applying default formatting to\n/// it and shifting all values after it to the right.\n///\n/// # Panics\n///\n/// Panics if `index > len`.\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// arr.push(1);\n/// arr.push(\"foo\");\n///\n/// arr.insert(0, \"start\");\n/// ```\npub fn insert<V: Into<Value>>(&mut self, index: usize, v: V){\n        self.value_op(v.into(), true, |items, value| {\n            items.insert(index, Item::Value(value))\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::insert_formatted":["/// Inserts an already formatted value at the given position within the array, shifting all\n/// values after it to the right.\n///\n/// # Panics\n///\n/// Panics if `index > len`.\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// arr.push(1);\n/// arr.push(\"foo\");\n///\n/// let formatted_value = \"'start'\".parse::<toml_edit::Value>().unwrap();\n/// arr.insert_formatted(0, formatted_value);\n/// ```\npub fn insert_formatted(&mut self, index: usize, v: Value){\n        self.values.insert(index, Item::Value(v))\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::is_empty":["/// Return true iff `self.len() == 0`.\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// assert!(arr.is_empty());\n///\n/// arr.push(1);\n/// arr.push(\"foo\");\n/// assert!(! arr.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::iter":["/// Returns an iterator over all values.\npub fn iter(&self) -> ArrayIter<'_>{\n        Box::new(self.values.iter().filter_map(Item::as_value))\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::iter_mut":["/// Returns an iterator over all values.\npub fn iter_mut(&mut self) -> ArrayIterMut<'_>{\n        Box::new(self.values.iter_mut().filter_map(Item::as_value_mut))\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::len":["/// Returns the length of the underlying Vec.\n///\n/// In some rare cases, placeholder elements will exist.  For a more accurate count, call\n/// `a.iter().count()`\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// arr.push(1);\n/// arr.push(\"foo\");\n/// assert_eq!(arr.len(), 2);\n/// ```\npub fn len(&self) -> usize{\n        self.values.len()\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::new":["/// Create an empty `Array`\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// ```\npub fn new() -> Self{\n        Default::default()\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::push":["/// Appends a new value to the end of the array, applying default formatting to it.\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// arr.push(1);\n/// arr.push(\"foo\");\n/// ```\npub fn push<V: Into<Value>>(&mut self, v: V){\n        self.value_op(v.into(), true, |items, value| {\n            items.push(Item::Value(value))\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::push_formatted":["/// Appends a new, already formatted value to the end of the array.\n///\n/// # Examples\n///\n/// ```rust\n/// let formatted_value = \"'literal'\".parse::<toml_edit::Value>().unwrap();\n/// let mut arr = toml_edit::Array::new();\n/// arr.push_formatted(formatted_value);\n/// ```\npub fn push_formatted(&mut self, v: Value){\n        self.values.push(Item::Value(v));\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::remove":["/// Removes the value at the given index.\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// arr.push(1);\n/// arr.push(\"foo\");\n///\n/// arr.remove(0);\n/// assert_eq!(arr.len(), 1);\n/// ```\npub fn remove(&mut self, index: usize) -> Value{\n        let removed = self.values.remove(index);\n        match removed {\n            Item::Value(v) => v,\n            x => panic!(\"non-value item {:?} in an array\", x),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::replace":["/// Replaces the element at the given position within the array, preserving existing formatting.\n///\n/// # Panics\n///\n/// Panics if `index >= len`.\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// arr.push(1);\n/// arr.push(\"foo\");\n///\n/// arr.replace(0, \"start\");\n/// ```\npub fn replace<V: Into<Value>>(&mut self, index: usize, v: V) -> Value{\n        // Read the existing value's decor and preserve it.\n        let existing_decor = self\n            .get(index)\n            .unwrap_or_else(|| panic!(\"index {} out of bounds (len = {})\", index, self.len()))\n            .decor();\n        let mut value = v.into();\n        *value.decor_mut() = existing_decor.clone();\n        self.replace_formatted(index, value)\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::replace_formatted":["/// Replaces the element at the given position within the array with an already formatted value.\n///\n/// # Panics\n///\n/// Panics if `index >= len`.\n///\n/// # Examples\n///\n/// ```rust\n/// let mut arr = toml_edit::Array::new();\n/// arr.push(1);\n/// arr.push(\"foo\");\n///\n/// let formatted_value = \"'start'\".parse::<toml_edit::Value>().unwrap();\n/// arr.replace_formatted(0, formatted_value);\n/// ```\npub fn replace_formatted(&mut self, index: usize, v: Value) -> Value{\n        match mem::replace(&mut self.values[index], Item::Value(v)) {\n            Item::Value(old_value) => old_value,\n            x => panic!(\"non-value item {:?} in an array\", x),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::set_trailing":["/// Set whitespace after last element\npub fn set_trailing(&mut self, trailing: impl Into<RawString>){\n        self.trailing = trailing.into();\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::set_trailing_comma":["/// Set whether the array will use a trailing comma\npub fn set_trailing_comma(&mut self, yes: bool){\n        self.trailing_comma = yes;\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::span":["/// Returns the location within the original document\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        self.span.clone()\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::trailing":["/// Whitespace after last element\npub fn trailing(&self) -> &RawString{\n        &self.trailing\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::trailing_comma":["/// Whether the array will use a trailing comma\npub fn trailing_comma(&self) -> bool{\n        self.trailing_comma\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::value_op":["fn value_op<T>(\n        &mut self,\n        v: Value,\n        decorate: bool,\n        op: impl FnOnce(&mut Vec<Item>, Value) -> T,\n    ) -> T{\n        let mut value = v;\n        if !self.is_empty() && decorate {\n            value.decorate(\" \", \"\");\n        } else if decorate {\n            value.decorate(\"\", \"\");\n        }\n        op(&mut self.values, value)\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::Array::with_vec":["pub(crate) fn with_vec(values: Vec<Item>) -> Self{\n        Self {\n            values,\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array::decorate_array":["fn decorate_array(array: &mut Array){\n    for (i, value) in array\n        .values\n        .iter_mut()\n        .filter_map(Item::as_value_mut)\n        .enumerate()\n    {\n        // [value1, value2, value3]\n        if i == 0 {\n            value.decorate(DEFAULT_LEADING_VALUE_DECOR.0, DEFAULT_LEADING_VALUE_DECOR.1);\n        } else {\n            value.decorate(DEFAULT_VALUE_DECOR.0, DEFAULT_VALUE_DECOR.1);\n        }\n    }\n    // Since everything is now on the same line, remove trailing commas and whitespace.\n    array.set_trailing_comma(false);\n    array.set_trailing(\"\");\n}","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))"],"array_of_tables::ArrayOfTables":["/// Type representing a TOML array of tables\npub struct ArrayOfTables {\n    // Always Vec<Item::Table>, just `Item` to make `Index` work\n    pub(crate) span: Option<std::ops::Range<usize>>,\n    pub(crate) values: Vec<Item>,\n}","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::clear":["/// Removes all the tables.\npub fn clear(&mut self){\n        self.values.clear()\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::despan":["pub(crate) fn despan(&mut self, input: &str){\n        self.span = None;\n        for value in &mut self.values {\n            value.despan(input);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::get":["/// Returns an optional reference to the table.\npub fn get(&self, index: usize) -> Option<&Table>{\n        self.values.get(index).and_then(Item::as_table)\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::get_mut":["/// Returns an optional mutable reference to the table.\npub fn get_mut(&mut self, index: usize) -> Option<&mut Table>{\n        self.values.get_mut(index).and_then(Item::as_table_mut)\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::into_array":["/// Convert to an inline array\npub fn into_array(mut self) -> Array{\n        for value in self.values.iter_mut() {\n            value.make_value();\n        }\n        let mut a = Array::with_vec(self.values);\n        a.fmt();\n        a\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::is_empty":["/// Returns true iff `self.len() == 0`.\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::iter":["/// Returns an iterator over tables.\npub fn iter(&self) -> ArrayOfTablesIter<'_>{\n        Box::new(self.values.iter().filter_map(Item::as_table))\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::iter_mut":["/// Returns an iterator over tables.\npub fn iter_mut(&mut self) -> ArrayOfTablesIterMut<'_>{\n        Box::new(self.values.iter_mut().filter_map(Item::as_table_mut))\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::len":["/// Returns the length of the underlying Vec.\n/// To get the actual number of items use `a.iter().count()`.\npub fn len(&self) -> usize{\n        self.values.len()\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::new":["/// Creates an empty array of tables.\npub fn new() -> Self{\n        Default::default()\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::push":["/// Appends a table to the array.\npub fn push(&mut self, table: Table){\n        self.values.push(Item::Table(table));\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::remove":["/// Removes a table with the given index.\npub fn remove(&mut self, index: usize){\n        self.values.remove(index);\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"array_of_tables::ArrayOfTables::span":["/// Returns the location within the original document\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        self.span.clone()\n    }","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))"],"document::Document":["/// Type representing a TOML document\npub struct Document {\n    pub(crate) root: Item,\n    // Trailing comments and whitespaces\n    pub(crate) trailing: RawString,\n    pub(crate) original: Option<String>,\n    pub(crate) span: Option<std::ops::Range<usize>>,\n}","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::as_item":["/// Returns a reference to the root item.\npub fn as_item(&self) -> &Item{\n        &self.root\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::as_item_mut":["/// Returns a mutable reference to the root item.\npub fn as_item_mut(&mut self) -> &mut Item{\n        &mut self.root\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::as_table":["/// Returns a reference to the root table.\npub fn as_table(&self) -> &Table{\n        self.root.as_table().expect(\"root should always be a table\")\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::as_table_mut":["/// Returns a mutable reference to the root table.\npub fn as_table_mut(&mut self) -> &mut Table{\n        self.root\n            .as_table_mut()\n            .expect(\"root should always be a table\")\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::despan":["/// # Panics\n///\n/// If run on on a `Document` not generated by the parser\npub(crate) fn despan(&mut self){\n        self.span = None;\n        self.root.despan(self.original.as_deref().unwrap());\n        self.trailing.despan(self.original.as_deref().unwrap());\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::iter":["/// Returns an iterator over the root table.\npub fn iter(&self) -> Iter<'_>{\n        self.as_table().iter()\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::new":["/// Creates an empty document\npub fn new() -> Self{\n        Default::default()\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::set_trailing":["/// Set whitespace after last element\npub fn set_trailing(&mut self, trailing: impl Into<RawString>){\n        self.trailing = trailing.into();\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"document::Document::trailing":["/// Whitespace after last element\npub fn trailing(&self) -> &RawString{\n        &self.trailing\n    }","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))"],"encode::<impl repr::ValueRepr for bool>::to_repr":["fn to_repr(&self) -> Repr{\n        Repr::new_unchecked(self.to_string())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::<impl repr::ValueRepr for f64>::to_repr":["fn to_repr(&self) -> Repr{\n        to_f64_repr(*self)\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::<impl repr::ValueRepr for i64>::to_repr":["fn to_repr(&self) -> Repr{\n        Repr::new_unchecked(self.to_string())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::<impl repr::ValueRepr for std::string::String>::to_repr":["fn to_repr(&self) -> Repr{\n        to_string_repr(self, None, None)\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr":["fn to_repr(&self) -> Repr{\n        Repr::new_unchecked(self.to_string())\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::<impl std::fmt::Display for document::Document>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> Result{\n        let mut path = Vec::new();\n        let mut last_position = 0;\n        let mut tables = Vec::new();\n        visit_nested_tables(self.as_table(), &mut path, false, &mut |t, p, is_array| {\n            if let Some(pos) = t.position() {\n                last_position = pos;\n            }\n            tables.push((last_position, t, p.clone(), is_array));\n            Ok(())\n        })\n        .unwrap();\n\n        tables.sort_by_key(|&(id, _, _, _)| id);\n        let mut first_table = true;\n        for (_, table, path, is_array) in tables {\n            visit_table(\n                f,\n                self.original.as_deref(),\n                table,\n                &path,\n                is_array,\n                &mut first_table,\n            )?;\n        }\n        self.trailing()\n            .encode_with_default(f, self.original.as_deref(), \"\")\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::Encode":["pub(crate) trait Encode {\n    fn encode(\n        &self,\n        buf: &mut dyn Write,\n        input: Option<&str>,\n        default_decor: (&str, &str),\n    ) -> Result;\n}","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::StringStyle":["pub(crate) enum StringStyle {\n    NewlineTripple,\n    OnelineTripple,\n    OnelineSingle,\n}","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::StringStyle::literal_end":["fn literal_end(self) -> &'static str{\n        match self {\n            Self::NewlineTripple => \"'''\",\n            Self::OnelineTripple => \"'''\",\n            Self::OnelineSingle => \"'\",\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::StringStyle::literal_start":["fn literal_start(self) -> &'static str{\n        match self {\n            Self::NewlineTripple => \"'''\\n\",\n            Self::OnelineTripple => \"'''\",\n            Self::OnelineSingle => \"'\",\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::StringStyle::standard_end":["fn standard_end(self) -> &'static str{\n        match self {\n            Self::NewlineTripple => \"\\\"\\\"\\\"\",\n            // note: OnelineTripple can happen if do_pretty wants to do\n            // '''it's one line'''\n            // but literal == false\n            Self::OnelineTripple | Self::OnelineSingle => \"\\\"\",\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::StringStyle::standard_start":["fn standard_start(self) -> &'static str{\n        match self {\n            Self::NewlineTripple => \"\\\"\\\"\\\"\\n\",\n            // note: OnelineTripple can happen if do_pretty wants to do\n            // '''it's one line'''\n            // but literal == false\n            Self::OnelineTripple | Self::OnelineSingle => \"\\\"\",\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::infer_style":["fn infer_style(value: &str) -> (StringStyle, bool){\n    // For doing pretty prints we store in a new String\n    // because there are too many cases where pretty cannot\n    // work. We need to determine:\n    // - if we are a \"multi-line\" pretty (if there are \\n)\n    // - if ['''] appears if multi or ['] if single\n    // - if there are any invalid control characters\n    //\n    // Doing it any other way would require multiple passes\n    // to determine if a pretty string works or not.\n    let mut out = String::with_capacity(value.len() * 2);\n    let mut ty = StringStyle::OnelineSingle;\n    // found consecutive single quotes\n    let mut max_found_singles = 0;\n    let mut found_singles = 0;\n    let mut prefer_literal = false;\n    let mut can_be_pretty = true;\n\n    for ch in value.chars() {\n        if can_be_pretty {\n            if ch == '\\'' {\n                found_singles += 1;\n                if found_singles >= 3 {\n                    can_be_pretty = false;\n                }\n            } else {\n                if found_singles > max_found_singles {\n                    max_found_singles = found_singles;\n                }\n                found_singles = 0\n            }\n            match ch {\n                '\\t' => {}\n                '\\\\' => {\n                    prefer_literal = true;\n                }\n                '\\n' => ty = StringStyle::NewlineTripple,\n                // Escape codes are needed if any ascii control\n                // characters are present, including \\b \\f \\r.\n                c if c <= '\\u{1f}' || c == '\\u{7f}' => can_be_pretty = false,\n                _ => {}\n            }\n            out.push(ch);\n        } else {\n            // the string cannot be represented as pretty,\n            // still check if it should be multiline\n            if ch == '\\n' {\n                ty = StringStyle::NewlineTripple;\n            }\n        }\n    }\n    if found_singles > 0 && value.ends_with('\\'') {\n        // We cannot escape the ending quote so we must use \"\"\"\n        can_be_pretty = false;\n    }\n    if !prefer_literal {\n        can_be_pretty = false;\n    }\n    if !can_be_pretty {\n        debug_assert!(ty != StringStyle::OnelineTripple);\n        return (ty, false);\n    }\n    if found_singles > max_found_singles {\n        max_found_singles = found_singles;\n    }\n    debug_assert!(max_found_singles < 3);\n    if ty == StringStyle::OnelineSingle && max_found_singles >= 1 {\n        // no newlines, but must use ''' because it has ' in it\n        ty = StringStyle::OnelineTripple;\n    }\n    (ty, true)\n}","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::to_f64_repr":["fn to_f64_repr(f: f64) -> Repr{\n    let repr = match (f.is_sign_negative(), f.is_nan(), f == 0.0) {\n        (true, true, _) => \"-nan\".to_owned(),\n        (false, true, _) => \"nan\".to_owned(),\n        (true, false, true) => \"-0.0\".to_owned(),\n        (false, false, true) => \"0.0\".to_owned(),\n        (_, false, false) => {\n            if f % 1.0 == 0.0 {\n                format!(\"{}.0\", f)\n            } else {\n                format!(\"{}\", f)\n            }\n        }\n    };\n    Repr::new_unchecked(repr)\n}","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::to_string_repr":["pub(crate) fn to_string_repr(\n    value: &str,\n    style: Option<StringStyle>,\n    literal: Option<bool>,\n) -> Repr{\n    let (style, literal) = match (style, literal) {\n        (Some(style), Some(literal)) => (style, literal),\n        (_, Some(literal)) => (infer_style(value).0, literal),\n        (Some(style), _) => (style, infer_style(value).1),\n        (_, _) => infer_style(value),\n    };\n\n    let mut output = String::with_capacity(value.len() * 2);\n    if literal {\n        output.push_str(style.literal_start());\n        output.push_str(value);\n        output.push_str(style.literal_end());\n    } else {\n        output.push_str(style.standard_start());\n        for ch in value.chars() {\n            match ch {\n                '\\u{8}' => output.push_str(\"\\\\b\"),\n                '\\u{9}' => output.push_str(\"\\\\t\"),\n                '\\u{a}' => match style {\n                    StringStyle::NewlineTripple => output.push('\\n'),\n                    StringStyle::OnelineSingle => output.push_str(\"\\\\n\"),\n                    _ => unreachable!(),\n                },\n                '\\u{c}' => output.push_str(\"\\\\f\"),\n                '\\u{d}' => output.push_str(\"\\\\r\"),\n                '\\u{22}' => output.push_str(\"\\\\\\\"\"),\n                '\\u{5c}' => output.push_str(\"\\\\\\\\\"),\n                c if c <= '\\u{1f}' || c == '\\u{7f}' => {\n                    write!(output, \"\\\\u{:04X}\", ch as u32).unwrap();\n                }\n                ch => output.push(ch),\n            }\n        }\n        output.push_str(style.standard_end());\n    }\n\n    Repr::new_unchecked(output)\n}","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::visit_nested_tables":["fn visit_nested_tables<'t, F>(\n    table: &'t Table,\n    path: &mut Vec<Key>,\n    is_array_of_tables: bool,\n    callback: &mut F,\n) -> Result\nwhere\n    F: FnMut(&'t Table, &Vec<Key>, bool) -> Result,{\n    if !table.is_dotted() {\n        callback(table, path, is_array_of_tables)?;\n    }\n\n    for kv in table.items.values() {\n        match kv.value {\n            Item::Table(ref t) => {\n                let mut key = kv.key.clone();\n                if t.is_dotted() {\n                    // May have newlines and generally isn't written for standard tables\n                    key.decor_mut().clear();\n                }\n                path.push(key);\n                visit_nested_tables(t, path, false, callback)?;\n                path.pop();\n            }\n            Item::ArrayOfTables(ref a) => {\n                for t in a.iter() {\n                    let key = kv.key.clone();\n                    path.push(key);\n                    visit_nested_tables(t, path, true, callback)?;\n                    path.pop();\n                }\n            }\n            _ => {}\n        }\n    }\n    Ok(())\n}","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"encode::visit_table":["fn visit_table(\n    buf: &mut dyn Write,\n    input: Option<&str>,\n    table: &Table,\n    path: &[Key],\n    is_array_of_tables: bool,\n    first_table: &mut bool,\n) -> Result{\n    let children = table.get_values();\n    // We are intentionally hiding implicit tables without any tables nested under them (ie\n    // `table.is_empty()` which is in contrast to `table.get_values().is_empty()`).  We are\n    // trusting the user that an empty implicit table is not semantically meaningful\n    //\n    // This allows a user to delete all tables under this implicit table and the implicit table\n    // will disappear.\n    //\n    // However, this means that users need to take care in deciding what tables get marked as\n    // implicit.\n    let is_visible_std_table = !(table.implicit && children.is_empty());\n\n    if path.is_empty() {\n        // don't print header for the root node\n        if !children.is_empty() {\n            *first_table = false;\n        }\n    } else if is_array_of_tables {\n        let default_decor = if *first_table {\n            *first_table = false;\n            (\"\", DEFAULT_TABLE_DECOR.1)\n        } else {\n            DEFAULT_TABLE_DECOR\n        };\n        table.decor.prefix_encode(buf, input, default_decor.0)?;\n        write!(buf, \"[[\")?;\n        path.encode(buf, input, DEFAULT_KEY_PATH_DECOR)?;\n        write!(buf, \"]]\")?;\n        table.decor.suffix_encode(buf, input, default_decor.1)?;\n        writeln!(buf)?;\n    } else if is_visible_std_table {\n        let default_decor = if *first_table {\n            *first_table = false;\n            (\"\", DEFAULT_TABLE_DECOR.1)\n        } else {\n            DEFAULT_TABLE_DECOR\n        };\n        table.decor.prefix_encode(buf, input, default_decor.0)?;\n        write!(buf, \"[\")?;\n        path.encode(buf, input, DEFAULT_KEY_PATH_DECOR)?;\n        write!(buf, \"]\")?;\n        table.decor.suffix_encode(buf, input, default_decor.1)?;\n        writeln!(buf)?;\n    }\n    // print table body\n    for (key_path, value) in children {\n        key_path.as_slice().encode(buf, input, DEFAULT_KEY_DECOR)?;\n        write!(buf, \"=\")?;\n        value.encode(buf, input, DEFAULT_VALUE_DECOR)?;\n        writeln!(buf)?;\n    }\n    Ok(())\n}","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))"],"index::<impl std::ops::Index<&'s str> for document::Document>::index":["fn index(&self, key: &'s str) -> &Item{\n        self.root.index(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index":["fn index(&self, key: &'s str) -> &Value{\n        self.get(key).expect(\"index not found\")\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"index::<impl std::ops::Index<&'s str> for table::Table>::index":["fn index(&self, key: &'s str) -> &Item{\n        self.get(key).expect(\"index not found\")\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"index::<impl std::ops::Index<I> for item::Item>::index":["fn index(&self, index: I) -> &Item{\n        index.index(self).expect(\"index not found\")\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut":["fn index_mut(&mut self, key: &'s str) -> &mut Item{\n        self.root.index_mut(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut":["fn index_mut(&mut self, key: &'s str) -> &mut Value{\n        self.get_mut(key).expect(\"index not found\")\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut":["fn index_mut(&mut self, key: &'s str) -> &mut Item{\n        self.entry(key).or_insert(Item::None)\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"index::<impl std::ops::IndexMut<I> for item::Item>::index_mut":["fn index_mut(&mut self, index: I) -> &mut Item{\n        index.index_mut(self).expect(\"index not found\")\n    }","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"index::Index":["pub trait Index: crate::private::Sealed {\n    #[doc(hidden)]\n    fn index<'v>(&self, val: &'v Item) -> Option<&'v Item>;\n    #[doc(hidden)]\n    fn index_mut<'v>(&self, val: &'v mut Item) -> Option<&'v mut Item>;\n}","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))"],"inline_table::InlineEntry":["/// A view into a single location in a map, which may be vacant or occupied.\npub enum InlineEntry<'a> {\n    /// An occupied Entry.\n    Occupied(InlineOccupiedEntry<'a>),\n    /// A vacant Entry.\n    Vacant(InlineVacantEntry<'a>),\n}","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineEntry::<'a>::key":["/// Returns the entry key\n///\n/// # Examples\n///\n/// ```\n/// use toml_edit::Table;\n///\n/// let mut map = Table::new();\n///\n/// assert_eq!(\"hello\", map.entry(\"hello\").key());\n/// ```\npub fn key(&self) -> &str{\n        match self {\n            InlineEntry::Occupied(e) => e.key(),\n            InlineEntry::Vacant(e) => e.key(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineEntry::<'a>::or_insert":["/// Ensures a value is in the entry by inserting the default if empty, and returns\n/// a mutable reference to the value in the entry.\npub fn or_insert(self, default: Value) -> &'a mut Value{\n        match self {\n            InlineEntry::Occupied(entry) => entry.into_mut(),\n            InlineEntry::Vacant(entry) => entry.insert(default),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineEntry::<'a>::or_insert_with":["/// Ensures a value is in the entry by inserting the result of the default function if empty,\n/// and returns a mutable reference to the value in the entry.\npub fn or_insert_with<F: FnOnce() -> Value>(self, default: F) -> &'a mut Value{\n        match self {\n            InlineEntry::Occupied(entry) => entry.into_mut(),\n            InlineEntry::Vacant(entry) => entry.insert(default()),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineOccupiedEntry":["/// A view into a single occupied location in a `IndexMap`.\npub struct InlineOccupiedEntry<'a> {\n    entry: indexmap::map::OccupiedEntry<'a, InternalString, TableKeyValue>,\n}","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineOccupiedEntry::<'a>::get":["/// Gets a reference to the value in the entry.\npub fn get(&self) -> &Value{\n        self.entry.get().value.as_value().unwrap()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineOccupiedEntry::<'a>::get_mut":["/// Gets a mutable reference to the value in the entry.\npub fn get_mut(&mut self) -> &mut Value{\n        self.entry.get_mut().value.as_value_mut().unwrap()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineOccupiedEntry::<'a>::insert":["/// Sets the value of the entry, and returns the entry's old value\npub fn insert(&mut self, value: Value) -> Value{\n        let mut value = Item::Value(value);\n        std::mem::swap(&mut value, &mut self.entry.get_mut().value);\n        value.into_value().unwrap()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineOccupiedEntry::<'a>::into_mut":["/// Converts the OccupiedEntry into a mutable reference to the value in the entry\n/// with a lifetime bound to the map itself\npub fn into_mut(self) -> &'a mut Value{\n        self.entry.into_mut().value.as_value_mut().unwrap()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineOccupiedEntry::<'a>::key":["/// Gets a reference to the entry key\n///\n/// # Examples\n///\n/// ```\n/// use toml_edit::Table;\n///\n/// let mut map = Table::new();\n///\n/// assert_eq!(\"foo\", map.entry(\"foo\").key());\n/// ```\npub fn key(&self) -> &str{\n        self.entry.key().as_str()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineOccupiedEntry::<'a>::key_mut":["/// Gets a mutable reference to the entry key\npub fn key_mut(&mut self) -> KeyMut<'_>{\n        self.entry.get_mut().key.as_mut()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineOccupiedEntry::<'a>::remove":["/// Takes the value out of the entry, and returns it\npub fn remove(self) -> Value{\n        self.entry.shift_remove().value.into_value().unwrap()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable":["/// Type representing a TOML inline table,\n/// payload of the `Value::InlineTable` variant\npub struct InlineTable {\n    // `preamble` represents whitespaces in an empty table\n    preamble: RawString,\n    // prefix before `{` and suffix after `}`\n    decor: Decor,\n    pub(crate) span: Option<std::ops::Range<usize>>,\n    // whether this is a proxy for dotted keys\n    dotted: bool,\n    pub(crate) items: KeyValuePairs,\n}","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::append_values":["pub(crate) fn append_values<'s, 'c>(\n        &'s self,\n        parent: &[&'s Key],\n        values: &'c mut Vec<(Vec<&'s Key>, &'s Value)>,\n    ){\n        for value in self.items.values() {\n            let mut path = parent.to_vec();\n            path.push(&value.key);\n            match &value.value {\n                Item::Value(Value::InlineTable(table)) if table.is_dotted() => {\n                    table.append_values(&path, values);\n                }\n                Item::Value(value) => {\n                    values.push((path, value));\n                }\n                _ => {}\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::clear":["/// Clears the table, removing all key-value pairs. Keeps the allocated memory for reuse.\npub fn clear(&mut self){\n        self.items.clear()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::contains_key":["/// Returns true iff the table contains given key.\npub fn contains_key(&self, key: &str) -> bool{\n        if let Some(kv) = self.items.get(key) {\n            kv.value.is_value()\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::decor":["/// Returns the surrounding whitespace\npub fn decor(&self) -> &Decor{\n        &self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::decor_mut":["/// Returns the surrounding whitespace\npub fn decor_mut(&mut self) -> &mut Decor{\n        &mut self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::despan":["pub(crate) fn despan(&mut self, input: &str){\n        self.span = None;\n        self.decor.despan(input);\n        self.preamble.despan(input);\n        for kv in self.items.values_mut() {\n            kv.key.despan(input);\n            kv.value.despan(input);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::entry":["/// Gets the given key's corresponding entry in the Table for in-place manipulation.\npub fn entry(&'_ mut self, key: impl Into<InternalString>) -> InlineEntry<'_>{\n        match self.items.entry(key.into()) {\n            indexmap::map::Entry::Occupied(mut entry) => {\n                // Ensure it is a `Value` to simplify `InlineOccupiedEntry`'s code.\n                let scratch = std::mem::take(&mut entry.get_mut().value);\n                let scratch = Item::Value(\n                    scratch\n                        .into_value()\n                        // HACK: `Item::None` is a corner case of a corner case, let's just pick a\n                        // \"safe\" value\n                        .unwrap_or_else(|_| Value::InlineTable(Default::default())),\n                );\n                entry.get_mut().value = scratch;\n\n                InlineEntry::Occupied(InlineOccupiedEntry { entry })\n            }\n            indexmap::map::Entry::Vacant(entry) => {\n                InlineEntry::Vacant(InlineVacantEntry { entry, key: None })\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::entry_format":["/// Gets the given key's corresponding entry in the Table for in-place manipulation.\npub fn entry_format<'a>(&'a mut self, key: &Key) -> InlineEntry<'a>{\n        // Accept a `&Key` to be consistent with `entry`\n        match self.items.entry(key.get().into()) {\n            indexmap::map::Entry::Occupied(mut entry) => {\n                // Ensure it is a `Value` to simplify `InlineOccupiedEntry`'s code.\n                let scratch = std::mem::take(&mut entry.get_mut().value);\n                let scratch = Item::Value(\n                    scratch\n                        .into_value()\n                        // HACK: `Item::None` is a corner case of a corner case, let's just pick a\n                        // \"safe\" value\n                        .unwrap_or_else(|_| Value::InlineTable(Default::default())),\n                );\n                entry.get_mut().value = scratch;\n\n                InlineEntry::Occupied(InlineOccupiedEntry { entry })\n            }\n            indexmap::map::Entry::Vacant(entry) => InlineEntry::Vacant(InlineVacantEntry {\n                entry,\n                key: Some(key.clone()),\n            }),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::fmt":["/// Auto formats the table.\npub fn fmt(&mut self){\n        decorate_inline_table(self);\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::get":["/// Return an optional reference to the value at the given the key.\npub fn get(&self, key: &str) -> Option<&Value>{\n        self.items.get(key).and_then(|kv| kv.value.as_value())\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::get_key_value":["/// Return references to the key-value pair stored for key, if it is present, else None.\npub fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)>{\n        self.items.get(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some((&kv.key, &kv.value))\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::get_key_value_mut":["/// Return mutable references to the key-value pair stored for key, if it is present, else None.\npub fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)>{\n        self.items.get_mut(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some((kv.key.as_mut(), &mut kv.value))\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::get_mut":["/// Return an optional mutable reference to the value at the given the key.\npub fn get_mut(&mut self, key: &str) -> Option<&mut Value>{\n        self.items\n            .get_mut(key)\n            .and_then(|kv| kv.value.as_value_mut())\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::get_or_insert":["/// Inserts a key/value pair if the table does not contain the key.\n/// Returns a mutable reference to the corresponding value.\npub fn get_or_insert<V: Into<Value>>(\n        &mut self,\n        key: impl Into<InternalString>,\n        value: V,\n    ) -> &mut Value{\n        let key = key.into();\n        self.items\n            .entry(key.clone())\n            .or_insert(TableKeyValue::new(Key::new(key), Item::Value(value.into())))\n            .value\n            .as_value_mut()\n            .expect(\"non-value type in inline table\")\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::get_values":["/// Get key/values for values that are visually children of this table\n///\n/// For example, this will return dotted keys\npub fn get_values(&self) -> Vec<(Vec<&Key>, &Value)>{\n        let mut values = Vec::new();\n        let root = Vec::new();\n        self.append_values(&root, &mut values);\n        values\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::insert":["/// Inserts a key-value pair into the map.\npub fn insert(&mut self, key: impl Into<InternalString>, value: Value) -> Option<Value>{\n        let key = key.into();\n        let kv = TableKeyValue::new(Key::new(key.clone()), Item::Value(value));\n        self.items\n            .insert(key, kv)\n            .and_then(|kv| kv.value.into_value().ok())\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::insert_formatted":["/// Inserts a key-value pair into the map.\npub fn insert_formatted(&mut self, key: &Key, value: Value) -> Option<Value>{\n        let kv = TableKeyValue::new(key.to_owned(), Item::Value(value));\n        self.items\n            .insert(InternalString::from(key.get()), kv)\n            .filter(|kv| kv.value.is_value())\n            .map(|kv| kv.value.into_value().unwrap())\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::into_table":["/// Convert to a table\npub fn into_table(self) -> Table{\n        let mut t = Table::with_pairs(self.items);\n        t.fmt();\n        t\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::is_dotted":["/// Check if this is a wrapper for dotted keys, rather than a standard table\npub fn is_dotted(&self) -> bool{\n        self.dotted\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::is_empty":["/// Returns true iff the table is empty.\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::iter":["/// Returns an iterator over key/value pairs.\npub fn iter(&self) -> InlineTableIter<'_>{\n        Box::new(\n            self.items\n                .iter()\n                .filter(|&(_, kv)| kv.value.is_value())\n                .map(|(k, kv)| (&k[..], kv.value.as_value().unwrap())),\n        )\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::iter_mut":["/// Returns an iterator over key/value pairs.\npub fn iter_mut(&mut self) -> InlineTableIterMut<'_>{\n        Box::new(\n            self.items\n                .iter_mut()\n                .filter(|(_, kv)| kv.value.is_value())\n                .map(|(_, kv)| (kv.key.as_mut(), kv.value.as_value_mut().unwrap())),\n        )\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::key_decor":["/// Returns the decor associated with a given key of the table.\npub fn key_decor(&self, key: &str) -> Option<&Decor>{\n        self.items.get(key).map(|kv| &kv.key.decor)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::key_decor_mut":["/// Returns the decor associated with a given key of the table.\npub fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor>{\n        self.items.get_mut(key).map(|kv| &mut kv.key.decor)\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::len":["/// Returns the number of key/value pairs.\npub fn len(&self) -> usize{\n        self.iter().count()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::new":["/// Creates an empty table.\npub fn new() -> Self{\n        Default::default()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::preamble":["/// Whitespace after before element\npub fn preamble(&self) -> &RawString{\n        &self.preamble\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::remove":["/// Removes an item given the key.\npub fn remove(&mut self, key: &str) -> Option<Value>{\n        self.items\n            .shift_remove(key)\n            .and_then(|kv| kv.value.into_value().ok())\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::remove_entry":["/// Removes a key from the map, returning the stored key and value if the key was previously in the map.\npub fn remove_entry(&mut self, key: &str) -> Option<(Key, Value)>{\n        self.items.shift_remove(key).and_then(|kv| {\n            let key = kv.key;\n            kv.value.into_value().ok().map(|value| (key, value))\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::set_dotted":["/// Change this table's dotted status\npub fn set_dotted(&mut self, yes: bool){\n        self.dotted = yes;\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::set_preamble":["/// Set whitespace after before element\npub fn set_preamble(&mut self, preamble: impl Into<RawString>){\n        self.preamble = preamble.into();\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::sort_values":["/// Sorts the key/value pairs by key.\npub fn sort_values(&mut self){\n        // Assuming standard tables have their position set and this won't negatively impact them\n        self.items.sort_keys();\n        for kv in self.items.values_mut() {\n            match &mut kv.value {\n                Item::Value(Value::InlineTable(table)) if table.is_dotted() => {\n                    table.sort_values();\n                }\n                _ => {}\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::sort_values_by":["/// Sort Key/Value Pairs of the table using the using the comparison function `compare`.\n///\n/// The comparison function receives two key and value pairs to compare (you can sort by keys or\n/// values or their combination as needed).\npub fn sort_values_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&Key, &Value, &Key, &Value) -> std::cmp::Ordering,{\n        self.sort_values_by_internal(&mut compare);\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::sort_values_by_internal":["fn sort_values_by_internal<F>(&mut self, compare: &mut F)\n    where\n        F: FnMut(&Key, &Value, &Key, &Value) -> std::cmp::Ordering,{\n        let modified_cmp = |_: &InternalString,\n                            val1: &TableKeyValue,\n                            _: &InternalString,\n                            val2: &TableKeyValue|\n         -> std::cmp::Ordering {\n            match (val1.value.as_value(), val2.value.as_value()) {\n                (Some(v1), Some(v2)) => compare(&val1.key, v1, &val2.key, v2),\n                (Some(_), None) => std::cmp::Ordering::Greater,\n                (None, Some(_)) => std::cmp::Ordering::Less,\n                (None, None) => std::cmp::Ordering::Equal,\n            }\n        };\n\n        self.items.sort_by(modified_cmp);\n        for kv in self.items.values_mut() {\n            match &mut kv.value {\n                Item::Value(Value::InlineTable(table)) if table.is_dotted() => {\n                    table.sort_values_by_internal(compare);\n                }\n                _ => {}\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::span":["/// Returns the location within the original document\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        self.span.clone()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineTable::with_pairs":["pub(crate) fn with_pairs(items: KeyValuePairs) -> Self{\n        Self {\n            items,\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineVacantEntry":["/// A view into a single empty location in a `IndexMap`.\npub struct InlineVacantEntry<'a> {\n    entry: indexmap::map::VacantEntry<'a, InternalString, TableKeyValue>,\n    key: Option<Key>,\n}","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineVacantEntry::<'a>::insert":["/// Sets the value of the entry with the VacantEntry's key,\n/// and returns a mutable reference to it\npub fn insert(self, value: Value) -> &'a mut Value{\n        let entry = self.entry;\n        let key = self.key.unwrap_or_else(|| Key::new(entry.key().as_str()));\n        let value = Item::Value(value);\n        entry\n            .insert(TableKeyValue::new(key, value))\n            .value\n            .as_value_mut()\n            .unwrap()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::InlineVacantEntry::<'a>::key":["/// Gets a reference to the entry key\n///\n/// # Examples\n///\n/// ```\n/// use toml_edit::Table;\n///\n/// let mut map = Table::new();\n///\n/// assert_eq!(\"foo\", map.entry(\"foo\").key());\n/// ```\npub fn key(&self) -> &str{\n        self.entry.key().as_str()\n    }","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"inline_table::decorate_inline_table":["fn decorate_inline_table(table: &mut InlineTable){\n    for (key_decor, value) in table\n        .items\n        .iter_mut()\n        .filter(|&(_, ref kv)| kv.value.is_value())\n        .map(|(_, kv)| (&mut kv.key.decor, kv.value.as_value_mut().unwrap()))\n    {\n        key_decor.clear();\n        value.decor_mut().clear();\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))"],"internal_string::InternalString":["/// Opaque string storage internal to `toml_edit`\npub struct InternalString(Inner);","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"internal_string::InternalString::as_str":["/// Access the underlying string\n#[inline]\npub fn as_str(&self) -> &str{\n        self.0.as_str()\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"internal_string::InternalString::new":["/// Create an empty string\npub fn new() -> Self{\n        InternalString(Inner::new())\n    }","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))"],"item::Item":["/// Type representing either a value, a table, an array of tables, or none.\npub enum Item {\n    /// Type representing none.\n    None,\n    /// Type representing value.\n    Value(Value),\n    /// Type representing table.\n    Table(Table),\n    /// Type representing array of tables.\n    ArrayOfTables(ArrayOfTables),\n}","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_array":["/// Casts `self` to array.\npub fn as_array(&self) -> Option<&Array>{\n        self.as_value().and_then(Value::as_array)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_array_mut":["/// Casts `self` to mutable array.\npub fn as_array_mut(&mut self) -> Option<&mut Array>{\n        self.as_value_mut().and_then(Value::as_array_mut)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_array_of_tables":["/// Casts `self` to array of tables.\npub fn as_array_of_tables(&self) -> Option<&ArrayOfTables>{\n        match *self {\n            Item::ArrayOfTables(ref a) => Some(a),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_array_of_tables_mut":["/// Casts `self` to mutable array of tables.\npub fn as_array_of_tables_mut(&mut self) -> Option<&mut ArrayOfTables>{\n        match *self {\n            Item::ArrayOfTables(ref mut a) => Some(a),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_bool":["/// Casts `self` to boolean.\npub fn as_bool(&self) -> Option<bool>{\n        self.as_value().and_then(Value::as_bool)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_datetime":["/// Casts `self` to date-time.\npub fn as_datetime(&self) -> Option<&Datetime>{\n        self.as_value().and_then(Value::as_datetime)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_float":["/// Casts `self` to float.\npub fn as_float(&self) -> Option<f64>{\n        self.as_value().and_then(Value::as_float)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_inline_table":["/// Casts `self` to inline table.\npub fn as_inline_table(&self) -> Option<&InlineTable>{\n        self.as_value().and_then(Value::as_inline_table)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_inline_table_mut":["/// Casts `self` to mutable inline table.\npub fn as_inline_table_mut(&mut self) -> Option<&mut InlineTable>{\n        self.as_value_mut().and_then(Value::as_inline_table_mut)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_integer":["/// Casts `self` to integer.\npub fn as_integer(&self) -> Option<i64>{\n        self.as_value().and_then(Value::as_integer)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_str":["/// Casts `self` to str.\npub fn as_str(&self) -> Option<&str>{\n        self.as_value().and_then(Value::as_str)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_table":["/// Casts `self` to table.\npub fn as_table(&self) -> Option<&Table>{\n        match *self {\n            Item::Table(ref t) => Some(t),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_table_like":["/// Casts `self` to either a table or an inline table.\npub fn as_table_like(&self) -> Option<&dyn TableLike>{\n        self.as_table()\n            .map(|t| t as &dyn TableLike)\n            .or_else(|| self.as_inline_table().map(|t| t as &dyn TableLike))\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_table_like_mut":["/// Casts `self` to either a table or an inline table.\npub fn as_table_like_mut(&mut self) -> Option<&mut dyn TableLike>{\n        match self {\n            Item::Table(t) => Some(t as &mut dyn TableLike),\n            Item::Value(Value::InlineTable(t)) => Some(t as &mut dyn TableLike),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_table_mut":["/// Casts `self` to mutable table.\npub fn as_table_mut(&mut self) -> Option<&mut Table>{\n        match *self {\n            Item::Table(ref mut t) => Some(t),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_value":["/// Casts `self` to value.\npub fn as_value(&self) -> Option<&Value>{\n        match *self {\n            Item::Value(ref v) => Some(v),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::as_value_mut":["/// Casts `self` to mutable value.\npub fn as_value_mut(&mut self) -> Option<&mut Value>{\n        match *self {\n            Item::Value(ref mut v) => Some(v),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::despan":["pub(crate) fn despan(&mut self, input: &str){\n        match self {\n            Item::None => {}\n            Item::Value(v) => v.despan(input),\n            Item::Table(v) => v.despan(input),\n            Item::ArrayOfTables(v) => v.despan(input),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::get":["/// Index into a TOML array or map. A string index can be used to access a\n/// value in a map, and a usize index can be used to access an element of an\n/// array.\n///\n/// Returns `None` if:\n/// - The type of `self` does not match the type of the\n///   index, for example if the index is a string and `self` is an array or a\n///   number.\n/// - The given key does not exist in the map\n///   or the given index is not within the bounds of the array.\npub fn get<I: crate::index::Index>(&self, index: I) -> Option<&Item>{\n        index.index(self)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::get_mut":["/// Mutably index into a TOML array or map. A string index can be used to\n/// access a value in a map, and a usize index can be used to access an\n/// element of an array.\n///\n/// Returns `None` if:\n/// - The type of `self` does not match the type of the\n///   index, for example if the index is a string and `self` is an array or a\n///   number.\n/// - The given key does not exist in the map\n///   or the given index is not within the bounds of the array.\npub fn get_mut<I: crate::index::Index>(&mut self, index: I) -> Option<&mut Item>{\n        index.index_mut(self)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::into_array_of_tables":["/// Casts `self` to array of tables.\npub fn into_array_of_tables(self) -> Result<ArrayOfTables, Self>{\n        match self {\n            Item::ArrayOfTables(a) => Ok(a),\n            Item::Value(Value::Array(a)) => {\n                if a.is_empty() {\n                    Err(Item::Value(Value::Array(a)))\n                } else if a.iter().all(|v| v.is_inline_table()) {\n                    let mut aot = ArrayOfTables::new();\n                    aot.values = a.values;\n                    for value in aot.values.iter_mut() {\n                        value.make_item();\n                    }\n                    Ok(aot)\n                } else {\n                    Err(Item::Value(Value::Array(a)))\n                }\n            }\n            _ => Err(self),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::into_table":["/// Casts `self` to table.\npub fn into_table(self) -> Result<Table, Self>{\n        match self {\n            Item::Table(t) => Ok(t),\n            Item::Value(Value::InlineTable(t)) => Ok(t.into_table()),\n            _ => Err(self),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::into_value":["/// Casts `self` to value.\npub fn into_value(self) -> Result<Value, Self>{\n        match self {\n            Item::None => Err(self),\n            Item::Value(v) => Ok(v),\n            Item::Table(v) => {\n                let v = v.into_inline_table();\n                Ok(Value::InlineTable(v))\n            }\n            Item::ArrayOfTables(v) => {\n                let v = v.into_array();\n                Ok(Value::Array(v))\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_array":["/// Returns true iff `self` is an array.\npub fn is_array(&self) -> bool{\n        self.as_array().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_array_of_tables":["/// Returns true iff `self` is an array of tables.\npub fn is_array_of_tables(&self) -> bool{\n        self.as_array_of_tables().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_bool":["/// Returns true iff `self` is a boolean.\npub fn is_bool(&self) -> bool{\n        self.as_bool().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_datetime":["/// Returns true iff `self` is a date-time.\npub fn is_datetime(&self) -> bool{\n        self.as_datetime().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_float":["/// Returns true iff `self` is a float.\npub fn is_float(&self) -> bool{\n        self.as_float().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_inline_table":["/// Returns true iff `self` is an inline table.\npub fn is_inline_table(&self) -> bool{\n        self.as_inline_table().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_integer":["/// Returns true iff `self` is an integer.\npub fn is_integer(&self) -> bool{\n        self.as_integer().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_none":["/// Returns true iff `self` is `None`.\npub fn is_none(&self) -> bool{\n        matches!(*self, Item::None)\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_str":["/// Returns true iff `self` is a string.\npub fn is_str(&self) -> bool{\n        self.as_str().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_table":["/// Returns true iff `self` is a table.\npub fn is_table(&self) -> bool{\n        self.as_table().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_table_like":["/// Returns true iff `self` is either a table, or an inline table.\npub fn is_table_like(&self) -> bool{\n        self.as_table_like().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::is_value":["/// Returns true iff `self` is a value.\npub fn is_value(&self) -> bool{\n        self.as_value().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::make_item":["pub(crate) fn make_item(&mut self){\n        let other = std::mem::take(self);\n        let other = match other.into_table().map(crate::Item::Table) {\n            Ok(i) => i,\n            Err(i) => i,\n        };\n        let other = match other.into_array_of_tables().map(crate::Item::ArrayOfTables) {\n            Ok(i) => i,\n            Err(i) => i,\n        };\n        *self = other;\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::make_value":["/// In-place convert to a value\npub fn make_value(&mut self){\n        let other = std::mem::take(self);\n        let other = other.into_value().map(Item::Value).unwrap_or(Item::None);\n        *self = other;\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::or_insert":["/// Sets `self` to the given item iff `self` is none and\n/// returns a mutable reference to `self`.\npub fn or_insert(&mut self, item: Item) -> &mut Item{\n        if self.is_none() {\n            *self = item\n        }\n        self\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::span":["/// Returns the location within the original document\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        match self {\n            Item::None => None,\n            Item::Value(v) => v.span(),\n            Item::Table(v) => v.span(),\n            Item::ArrayOfTables(v) => v.span(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::Item::type_name":["/// Text description of value type\npub fn type_name(&self) -> &'static str{\n        match self {\n            Item::None => \"none\",\n            Item::Value(v) => v.type_name(),\n            Item::Table(..) => \"table\",\n            Item::ArrayOfTables(..) => \"array of tables\",\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::array":["/// Returns an empty array of tables.\npub fn array() -> Item{\n    Item::ArrayOfTables(ArrayOfTables::new())\n}","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::table":["/// Returns an empty table.\npub fn table() -> Item{\n    Item::Table(Table::new())\n}","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"item::value":["/// Returns a formatted value.\n///\n/// Since formatting is part of a `Value`, the right hand side of the\n/// assignment needs to be decorated with a space before the value.\n/// The `value` function does just that.\n///\n/// # Examples\n/// ```rust\n/// # use snapbox::assert_eq;\n/// # use toml_edit::*;\n/// let mut table = Table::default();\n/// let mut array = Array::default();\n/// array.push(\"hello\");\n/// array.push(\"\\\\, world\"); // \\ is only allowed in a literal string\n/// table[\"key1\"] = value(\"value1\");\n/// table[\"key2\"] = value(42);\n/// table[\"key3\"] = value(array);\n/// assert_eq(table.to_string(),\n/// r#\"key1 = \"value1\"\n/// key2 = 42\n/// key3 = [\"hello\", '\\, world']\n/// \"#);\n/// ```\npub fn value<V: Into<Value>>(v: V) -> Item{\n    Item::Value(v.into())\n}","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))"],"key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from":["fn from(key: Key) -> InternalString{\n        key.key\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key":["/// Key as part of a Key/Value Pair or a table header.\n///\n/// # Examples\n///\n/// ```notrust\n/// [dependencies.\"nom\"]\n/// version = \"5.0\"\n/// 'literal key' = \"nonsense\"\n/// \"basic string key\" = 42\n/// ```\n///\n/// There are 3 types of keys:\n///\n/// 1. Bare keys (`version` and `dependencies`)\n///\n/// 2. Basic quoted keys (`\"basic string key\"` and `\"nom\"`)\n///\n/// 3. Literal quoted keys (`'literal key'`)\n///\n/// For details see [toml spec](https://github.com/toml-lang/toml/#keyvalue-pair).\n///\n/// To parse a key use `FromStr` trait implementation: `\"string\".parse::<Key>()`.\npub struct Key {\n    key: InternalString,\n    pub(crate) repr: Option<Repr>,\n    pub(crate) decor: Decor,\n}","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::as_mut":["/// Access a mutable proxy for the `Key`.\npub fn as_mut(&mut self) -> KeyMut<'_>{\n        KeyMut { key: self }\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::as_repr":["/// Returns key raw representation, if available.\npub fn as_repr(&self) -> Option<&Repr>{\n        self.repr.as_ref()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::decor":["/// Returns the surrounding whitespace\npub fn decor(&self) -> &Decor{\n        &self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::decor_mut":["/// Returns the surrounding whitespace\npub fn decor_mut(&mut self) -> &mut Decor{\n        &mut self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::default_repr":["/// Returns the default raw representation.\npub fn default_repr(&self) -> Repr{\n        to_key_repr(&self.key)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::despan":["pub(crate) fn despan(&mut self, input: &str){\n        self.decor.despan(input);\n        if let Some(repr) = &mut self.repr {\n            repr.despan(input)\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::display_repr":["/// Returns a raw representation.\npub fn display_repr(&self) -> Cow<'_, str>{\n        self.as_repr()\n            .and_then(|r| r.as_raw().as_str())\n            .map(Cow::Borrowed)\n            .unwrap_or_else(|| {\n                Cow::Owned(self.default_repr().as_raw().as_str().unwrap().to_owned())\n            })\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::fmt":["/// Auto formats the key.\npub fn fmt(&mut self){\n        self.repr = Some(to_key_repr(&self.key));\n        self.decor.clear();\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::get":["/// Returns the parsed key value.\npub fn get(&self) -> &str{\n        &self.key\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::get_internal":["pub(crate) fn get_internal(&self) -> &InternalString{\n        &self.key\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::new":["/// Create a new table key\npub fn new(key: impl Into<InternalString>) -> Self{\n        Self {\n            key: key.into(),\n            repr: None,\n            decor: Default::default(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::parse":["/// Parse a TOML key expression\n///\n/// Unlike `\"\".parse<Key>()`, this supports dotted keys.\npub fn parse(repr: &str) -> Result<Vec<Self>, crate::TomlError>{\n        Self::try_parse_path(repr)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::try_parse_path":["fn try_parse_path(s: &str) -> Result<Vec<Key>, crate::TomlError>{\n        let mut keys = parser::parse_key_path(s)?;\n        for key in &mut keys {\n            key.despan(s);\n        }\n        Ok(keys)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::try_parse_simple":["fn try_parse_simple(s: &str) -> Result<Key, crate::TomlError>{\n        let mut key = parser::parse_key(s)?;\n        key.despan(s);\n        Ok(key)\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::with_decor":["/// While creating the `Key`, add `Decor` to it\npub fn with_decor(mut self, decor: Decor) -> Self{\n        self.decor = decor;\n        self\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::Key::with_repr_unchecked":["pub(crate) fn with_repr_unchecked(mut self, repr: Repr) -> Self{\n        self.repr = Some(repr);\n        self\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::KeyMut":["/// A mutable reference to a `Key`\npub struct KeyMut<'k> {\n    key: &'k mut Key,\n}","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::KeyMut::<'k>::as_repr":["/// Returns the raw representation, if available.\npub fn as_repr(&self) -> Option<&Repr>{\n        self.key.as_repr()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::KeyMut::<'k>::decor":["/// Returns the surrounding whitespace\npub fn decor(&self) -> &Decor{\n        self.key.decor()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::KeyMut::<'k>::decor_mut":["/// Returns the surrounding whitespace\npub fn decor_mut(&mut self) -> &mut Decor{\n        self.key.decor_mut()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::KeyMut::<'k>::default_repr":["/// Returns the default raw representation.\npub fn default_repr(&self) -> Repr{\n        self.key.default_repr()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::KeyMut::<'k>::display_repr":["/// Returns a raw representation.\npub fn display_repr(&self) -> Cow<str>{\n        self.key.display_repr()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::KeyMut::<'k>::fmt":["/// Auto formats the key.\npub fn fmt(&mut self){\n        self.key.fmt()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::KeyMut::<'k>::get":["/// Returns the parsed key value.\npub fn get(&self) -> &str{\n        self.key.get()\n    }","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"key::to_key_repr":["fn to_key_repr(key: &str) -> Repr{\n    if key.as_bytes().iter().copied().all(is_unquoted_char) && !key.is_empty() {\n        Repr::new_unchecked(key)\n    } else {\n        to_string_repr(key, Some(StringStyle::OnelineSingle), Some(false))\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))"],"parser::array::array":["pub(crate) fn array(\n    check: RecursionCheck,\n) -> impl FnMut(Input<'_>) -> IResult<Input<'_>, Array, ParserError<'_>>{\n    move |input| {\n        delimited(\n            ARRAY_OPEN,\n            cut_err(array_values(check)),\n            cut_err(ARRAY_CLOSE)\n                .context(Context::Expression(\"array\"))\n                .context(Context::Expected(ParserValue::CharLiteral(']'))),\n        )\n        .parse_next(input)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/array.rs\"))"],"parser::array::array_value":["pub(crate) fn array_value(\n    check: RecursionCheck,\n) -> impl FnMut(Input<'_>) -> IResult<Input<'_>, Value, ParserError<'_>>{\n    move |input| {\n        (\n            ws_comment_newline.span(),\n            value(check),\n            ws_comment_newline.span(),\n        )\n            .map(|(ws1, v, ws2)| v.decorated(RawString::with_span(ws1), RawString::with_span(ws2)))\n            .parse_next(input)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/array.rs\"))"],"parser::array::array_values":["pub(crate) fn array_values(\n    check: RecursionCheck,\n) -> impl FnMut(Input<'_>) -> IResult<Input<'_>, Array, ParserError<'_>>{\n    move |input| {\n        let check = check.recursing(input)?;\n        (\n            opt(\n                (separated1(array_value(check), ARRAY_SEP), opt(ARRAY_SEP)).map(\n                    |(v, trailing): (Vec<Value>, Option<u8>)| {\n                        (\n                            Array::with_vec(v.into_iter().map(Item::Value).collect()),\n                            trailing.is_some(),\n                        )\n                    },\n                ),\n            ),\n            ws_comment_newline.span(),\n        )\n            .try_map::<_, _, std::str::Utf8Error>(|(array, trailing)| {\n                let (mut array, comma) = array.unwrap_or_default();\n                array.set_trailing_comma(comma);\n                array.set_trailing(RawString::with_span(trailing));\n                Ok(array)\n            })\n            .parse_next(input)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/array.rs\"))"],"parser::datetime::date_fullyear":["pub(crate) fn date_fullyear(input: Input<'_>) -> IResult<Input<'_>, u16, ParserError<'_>>{\n    unsigned_digits::<4, 4>\n        .map(|s: &str| s.parse::<u16>().expect(\"4DIGIT should match u8\"))\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::date_mday":["pub(crate) fn date_mday(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    unsigned_digits::<2, 2>\n        .try_map(|s: &str| {\n            let d = s.parse::<u8>().expect(\"2DIGIT should match u8\");\n            if (1..=31).contains(&d) {\n                Ok(d)\n            } else {\n                Err(CustomError::OutOfRange)\n            }\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::date_month":["pub(crate) fn date_month(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    unsigned_digits::<2, 2>\n        .try_map(|s: &str| {\n            let d = s.parse::<u8>().expect(\"2DIGIT should match u8\");\n            if (1..=12).contains(&d) {\n                Ok(d)\n            } else {\n                Err(CustomError::OutOfRange)\n            }\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::date_time":["pub(crate) fn date_time(input: Input<'_>) -> IResult<Input<'_>, Datetime, ParserError<'_>>{\n    alt((\n        (full_date, opt((time_delim, partial_time, opt(time_offset))))\n            .map(|(date, opt)| {\n                match opt {\n                    // Offset Date-Time\n                    Some((_, time, offset)) => Datetime {\n                        date: Some(date),\n                        time: Some(time),\n                        offset,\n                    },\n                    // Local Date\n                    None => Datetime {\n                        date: Some(date),\n                        time: None,\n                        offset: None,\n                    },\n                }\n            })\n            .context(Context::Expression(\"date-time\")),\n        partial_time\n            .map(|t| t.into())\n            .context(Context::Expression(\"time\")),\n    ))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::full_date":["pub(crate) fn full_date(input: Input<'_>) -> IResult<Input<'_>, Date, ParserError<'_>>{\n    (date_fullyear, b'-', cut_err((date_month, b'-', date_mday)))\n        .map(|(year, _, (month, _, day))| Date { year, month, day })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::partial_time":["pub(crate) fn partial_time(input: Input<'_>) -> IResult<Input<'_>, Time, ParserError<'_>>{\n    (\n        time_hour,\n        b':',\n        cut_err((time_minute, b':', time_second, opt(time_secfrac))),\n    )\n        .map(|(hour, _, (minute, _, second, nanosecond))| Time {\n            hour,\n            minute,\n            second,\n            nanosecond: nanosecond.unwrap_or_default(),\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::time_delim":["pub(crate) fn time_delim(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    one_of(TIME_DELIM).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::time_hour":["pub(crate) fn time_hour(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    unsigned_digits::<2, 2>\n        .try_map(|s: &str| {\n            let d = s.parse::<u8>().expect(\"2DIGIT should match u8\");\n            if (0..=23).contains(&d) {\n                Ok(d)\n            } else {\n                Err(CustomError::OutOfRange)\n            }\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::time_minute":["pub(crate) fn time_minute(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    unsigned_digits::<2, 2>\n        .try_map(|s: &str| {\n            let d = s.parse::<u8>().expect(\"2DIGIT should match u8\");\n            if (0..=59).contains(&d) {\n                Ok(d)\n            } else {\n                Err(CustomError::OutOfRange)\n            }\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::time_offset":["pub(crate) fn time_offset(input: Input<'_>) -> IResult<Input<'_>, Offset, ParserError<'_>>{\n    alt((\n        one_of((b'Z', b'z')).value(Offset::Z),\n        (\n            one_of((b'+', b'-')),\n            cut_err((time_hour, b':', time_minute)),\n        )\n            .map(|(sign, (hours, _, minutes))| {\n                let sign = match sign {\n                    b'+' => 1,\n                    b'-' => -1,\n                    _ => unreachable!(\"Parser prevents this\"),\n                };\n                sign * (hours as i16 * 60 + minutes as i16)\n            })\n            .verify(|minutes| ((-24 * 60)..=(24 * 60)).contains(minutes))\n            .map(|minutes| Offset::Custom { minutes }),\n    ))\n    .context(Context::Expression(\"time offset\"))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::time_secfrac":["pub(crate) fn time_secfrac(input: Input<'_>) -> IResult<Input<'_>, u32, ParserError<'_>>{\n    static SCALE: [u32; 10] = [\n        0,\n        100_000_000,\n        10_000_000,\n        1_000_000,\n        100_000,\n        10_000,\n        1_000,\n        100,\n        10,\n        1,\n    ];\n    const INF: usize = usize::MAX;\n    preceded(b'.', unsigned_digits::<1, INF>)\n        .try_map(|mut repr: &str| -> Result<u32, CustomError> {\n            let max_digits = SCALE.len() - 1;\n            if max_digits < repr.len() {\n                // Millisecond precision is required. Further precision of fractional seconds is\n                // implementation-specific. If the value contains greater precision than the\n                // implementation can support, the additional precision must be truncated, not rounded.\n                repr = &repr[0..max_digits];\n            }\n\n            let v = repr.parse::<u32>().map_err(|_| CustomError::OutOfRange)?;\n            let num_digits = repr.len();\n\n            // scale the number accordingly.\n            let scale = SCALE.get(num_digits).ok_or(CustomError::OutOfRange)?;\n            let v = v.checked_mul(*scale).ok_or(CustomError::OutOfRange)?;\n            Ok(v)\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::time_second":["pub(crate) fn time_second(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    unsigned_digits::<2, 2>\n        .try_map(|s: &str| {\n            let d = s.parse::<u8>().expect(\"2DIGIT should match u8\");\n            if (0..=60).contains(&d) {\n                Ok(d)\n            } else {\n                Err(CustomError::OutOfRange)\n            }\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::datetime::unsigned_digits":["pub(crate) fn unsigned_digits<const MIN: usize, const MAX: usize>(\n    input: Input<'_>,\n) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    take_while(MIN..=MAX, DIGIT)\n        .map(|b: &[u8]| unsafe { from_utf8_unchecked(b, \"`is_ascii_digit` filters out on-ASCII\") })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))"],"parser::document::document":["pub(crate) fn document(input: Input<'_>) -> IResult<Input<'_>, Document, ParserError<'_>>{\n    let state = RefCell::new(ParseState::default());\n    let state_ref = &state;\n\n    let (i, _o) = (\n        // Remove BOM if present\n        opt(b\"\\xEF\\xBB\\xBF\"),\n        parse_ws(state_ref),\n        repeat(0.., (\n            dispatch! {peek(any);\n                crate::parser::trivia::COMMENT_START_SYMBOL => cut_err(parse_comment(state_ref)),\n                crate::parser::table::STD_TABLE_OPEN => cut_err(table(state_ref)),\n                crate::parser::trivia::LF |\n                crate::parser::trivia::CR => parse_newline(state_ref),\n                _ => cut_err(keyval(state_ref)),\n            },\n            parse_ws(state_ref),\n        ))\n        .map(|()| ()),\n        eof,\n    )\n        .parse_next(input)?;\n    state\n        .into_inner()\n        .into_document()\n        .map(|document| (i, document))\n        .map_err(|err| {\n            winnow::error::ErrMode::Backtrack(ParserError::from_external_error(\n                i,\n                winnow::error::ErrorKind::Verify,\n                err,\n            ))\n        })\n}","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))"],"parser::document::keyval":["pub(crate) fn keyval<'s, 'i>(\n    state: &'s RefCell<ParseState>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, (), ParserError<'i>> + 's{\n    move |i| {\n        parse_keyval\n            .try_map(|(p, kv)| state.borrow_mut().on_keyval(p, kv))\n            .parse_next(i)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))"],"parser::document::parse_comment":["pub(crate) fn parse_comment<'s, 'i>(\n    state: &'s RefCell<ParseState>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, (), ParserError<'_>> + 's{\n    move |i| {\n        (comment, line_ending)\n            .span()\n            .map(|span| {\n                state.borrow_mut().on_comment(span);\n            })\n            .parse_next(i)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))"],"parser::document::parse_keyval":["pub(crate) fn parse_keyval(\n    input: Input<'_>,\n) -> IResult<Input<'_>, (Vec<Key>, TableKeyValue), ParserError<'_>>{\n    (\n        key,\n        cut_err((\n            one_of(KEYVAL_SEP)\n                .context(Context::Expected(ParserValue::CharLiteral('.')))\n                .context(Context::Expected(ParserValue::CharLiteral('='))),\n            (\n                ws.span(),\n                value(RecursionCheck::default()),\n                line_trailing\n                    .context(Context::Expected(ParserValue::CharLiteral('\\n')))\n                    .context(Context::Expected(ParserValue::CharLiteral('#'))),\n            ),\n        )),\n    )\n        .try_map::<_, _, std::str::Utf8Error>(|(key, (_, v))| {\n            let mut path = key;\n            let key = path.pop().expect(\"grammar ensures at least 1\");\n\n            let (pre, v, suf) = v;\n            let pre = RawString::with_span(pre);\n            let suf = RawString::with_span(suf);\n            let v = v.decorated(pre, suf);\n            Ok((\n                path,\n                TableKeyValue {\n                    key,\n                    value: Item::Value(v),\n                },\n            ))\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))"],"parser::document::parse_newline":["pub(crate) fn parse_newline<'s, 'i>(\n    state: &'s RefCell<ParseState>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, (), ParserError<'i>> + 's{\n    move |i| {\n        newline\n            .span()\n            .map(|span| state.borrow_mut().on_ws(span))\n            .parse_next(i)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))"],"parser::document::parse_ws":["pub(crate) fn parse_ws<'s, 'i>(\n    state: &'s RefCell<ParseState>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, (), ParserError<'i>> + 's{\n    move |i| {\n        ws.span()\n            .map(|span| state.borrow_mut().on_ws(span))\n            .parse_next(i)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))"],"parser::errors::Context":["pub(crate) enum Context {\n    Expression(&'static str),\n    Expected(ParserValue),\n}","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::CustomError":["pub(crate) enum CustomError {\n    DuplicateKey {\n        key: String,\n        table: Option<Vec<Key>>,\n    },\n    DottedKeyExtendWrongType {\n        key: Vec<Key>,\n        actual: &'static str,\n    },\n    OutOfRange,\n    #[cfg_attr(feature = \"unbounded\", allow(dead_code))]\n    RecursionLimitExceeded,\n}","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::CustomError::duplicate_key":["pub(crate) fn duplicate_key(path: &[Key], i: usize) -> Self{\n        assert!(i < path.len());\n        let key = &path[i];\n        let repr = key.display_repr();\n        Self::DuplicateKey {\n            key: repr.into(),\n            table: Some(path[..i].to_vec()),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::CustomError::extend_wrong_type":["pub(crate) fn extend_wrong_type(path: &[Key], i: usize, actual: &'static str) -> Self{\n        assert!(i < path.len());\n        Self::DottedKeyExtendWrongType {\n            key: path[..=i].to_vec(),\n            actual,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::ParserError":["pub(crate) struct ParserError<'b> {\n    input: Input<'b>,\n    context: Vec<Context>,\n    cause: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,\n}","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::ParserValue":["pub(crate) enum ParserValue {\n    CharLiteral(char),\n    StringLiteral(&'static str),\n    Description(&'static str),\n}","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::TomlError":["/// Type representing a TOML parse error\npub struct TomlError {\n    message: String,\n    original: Option<String>,\n    keys: Vec<String>,\n    span: Option<std::ops::Range<usize>>,\n}","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::TomlError::message":["/// What went wrong\npub fn message(&self) -> &str{\n        &self.message\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::TomlError::new":["pub(crate) fn new(error: ParserError<'_>, original: Input<'_>) -> Self{\n        use winnow::stream::Offset;\n        use winnow::stream::Stream;\n\n        let offset = original.offset_to(&error.input);\n        let span = if offset == original.len() {\n            offset..offset\n        } else {\n            offset..(offset + 1)\n        };\n\n        let message = error.to_string();\n        let original = original.next_slice(original.eof_offset()).1;\n\n        Self {\n            message,\n            original: Some(\n                String::from_utf8(original.to_owned()).expect(\"original document was utf8\"),\n            ),\n            keys: Vec::new(),\n            span: Some(span),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::TomlError::span":["/// The start/end index into the original document where the error occurred\npub fn span(&self) -> Option<std::ops::Range<usize>>{\n        self.span.clone()\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::errors::translate_position":["fn translate_position(input: &[u8], index: usize) -> (usize, usize){\n    if input.is_empty() {\n        return (0, index);\n    }\n\n    let safe_index = index.min(input.len() - 1);\n    let column_offset = index - safe_index;\n    let index = safe_index;\n\n    let nl = input[0..index]\n        .iter()\n        .rev()\n        .enumerate()\n        .find(|(_, b)| **b == b'\\n')\n        .map(|(nl, _)| index - nl - 1);\n    let line_start = match nl {\n        Some(nl) => nl + 1,\n        None => 0,\n    };\n    let line = input[0..line_start].iter().filter(|b| **b == b'\\n').count();\n    let line = line;\n\n    let column = std::str::from_utf8(&input[line_start..=index])\n        .map(|s| s.chars().count() - 1)\n        .unwrap_or_else(|_| index - line_start);\n    let column = column + column_offset;\n\n    (line, column)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))"],"parser::inline_table::descend_path":["fn descend_path<'a>(\n    mut table: &'a mut InlineTable,\n    path: &'a [Key],\n) -> Result<&'a mut InlineTable, CustomError>{\n    for (i, key) in path.iter().enumerate() {\n        let entry = table.entry_format(key).or_insert_with(|| {\n            let mut new_table = InlineTable::new();\n            new_table.set_dotted(true);\n\n            Value::InlineTable(new_table)\n        });\n        match *entry {\n            Value::InlineTable(ref mut sweet_child_of_mine) => {\n                table = sweet_child_of_mine;\n            }\n            ref v => {\n                return Err(CustomError::extend_wrong_type(path, i, v.type_name()));\n            }\n        }\n    }\n    Ok(table)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))"],"parser::inline_table::inline_table":["pub(crate) fn inline_table(\n    check: RecursionCheck,\n) -> impl FnMut(Input<'_>) -> IResult<Input<'_>, InlineTable, ParserError<'_>>{\n    move |input| {\n        delimited(\n            INLINE_TABLE_OPEN,\n            cut_err(inline_table_keyvals(check).try_map(|(kv, p)| table_from_pairs(kv, p))),\n            cut_err(INLINE_TABLE_CLOSE)\n                .context(Context::Expression(\"inline table\"))\n                .context(Context::Expected(ParserValue::CharLiteral('}'))),\n        )\n        .parse_next(input)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))"],"parser::inline_table::inline_table_keyvals":["fn inline_table_keyvals(\n    check: RecursionCheck,\n) -> impl FnMut(\n    Input<'_>,\n) -> IResult<Input<'_>, (Vec<(Vec<Key>, TableKeyValue)>, RawString), ParserError<'_>>{\n    move |input| {\n        let check = check.recursing(input)?;\n        (\n            separated0(keyval(check), INLINE_TABLE_SEP),\n            ws.span().map(RawString::with_span),\n        )\n            .parse_next(input)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))"],"parser::inline_table::keyval":["fn keyval(\n    check: RecursionCheck,\n) -> impl FnMut(Input<'_>) -> IResult<Input<'_>, (Vec<Key>, TableKeyValue), ParserError<'_>>{\n    move |input| {\n        (\n            key,\n            cut_err((\n                one_of(KEYVAL_SEP)\n                    .context(Context::Expected(ParserValue::CharLiteral('.')))\n                    .context(Context::Expected(ParserValue::CharLiteral('='))),\n                (ws.span(), value(check), ws.span()),\n            )),\n        )\n            .map(|(key, (_, v))| {\n                let mut path = key;\n                let key = path.pop().expect(\"grammar ensures at least 1\");\n\n                let (pre, v, suf) = v;\n                let pre = RawString::with_span(pre);\n                let suf = RawString::with_span(suf);\n                let v = v.decorated(pre, suf);\n                (\n                    path,\n                    TableKeyValue {\n                        key,\n                        value: Item::Value(v),\n                    },\n                )\n            })\n            .parse_next(input)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))"],"parser::inline_table::table_from_pairs":["fn table_from_pairs(\n    v: Vec<(Vec<Key>, TableKeyValue)>,\n    preamble: RawString,\n) -> Result<InlineTable, CustomError>{\n    let mut root = InlineTable::new();\n    root.set_preamble(preamble);\n    // Assuming almost all pairs will be directly in `root`\n    root.items.reserve(v.len());\n\n    for (path, kv) in v {\n        let table = descend_path(&mut root, &path)?;\n        let key: InternalString = kv.key.get_internal().into();\n        match table.items.entry(key) {\n            Entry::Vacant(o) => {\n                o.insert(kv);\n            }\n            Entry::Occupied(o) => {\n                return Err(CustomError::DuplicateKey {\n                    key: o.key().as_str().into(),\n                    table: None,\n                });\n            }\n        }\n    }\n    Ok(root)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))"],"parser::key::is_unquoted_char":["pub(crate) fn is_unquoted_char(c: u8) -> bool{\n    use winnow::stream::ContainsToken;\n    UNQUOTED_CHAR.contains_token(c)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/key.rs\"))"],"parser::key::key":["pub(crate) fn key(input: Input<'_>) -> IResult<Input<'_>, Vec<Key>, ParserError<'_>>{\n    separated1(\n        (ws.span(), simple_key, ws.span()).map(|(pre, (raw, key), suffix)| {\n            Key::new(key)\n                .with_repr_unchecked(Repr::new_unchecked(raw))\n                .with_decor(Decor::new(\n                    RawString::with_span(pre),\n                    RawString::with_span(suffix),\n                ))\n        }),\n        DOT_SEP,\n    )\n    .context(Context::Expression(\"key\"))\n    .try_map(|k: Vec<_>| {\n        // Inserting the key will require recursion down the line\n        RecursionCheck::check_depth(k.len())?;\n        Ok::<_, CustomError>(k)\n    })\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/key.rs\"))"],"parser::key::simple_key":["pub(crate) fn simple_key(\n    input: Input<'_>,\n) -> IResult<Input<'_>, (RawString, InternalString), ParserError<'_>>{\n    dispatch! {peek(any);\n        crate::parser::strings::QUOTATION_MARK => basic_string\n            .map(|s: std::borrow::Cow<'_, str>| s.as_ref().into()),\n        crate::parser::strings::APOSTROPHE => literal_string.map(|s: &str| s.into()),\n        _ => unquoted_key.map(|s: &str| s.into()),\n    }\n    .with_span()\n    .map(|(k, span)| {\n        let raw = RawString::with_span(span);\n        (raw, k)\n    })\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/key.rs\"))"],"parser::key::unquoted_key":["fn unquoted_key(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    take_while(1.., UNQUOTED_CHAR)\n        .map(|b| unsafe { from_utf8_unchecked(b, \"`is_unquoted_char` filters out on-ASCII\") })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/key.rs\"))"],"parser::numbers::bin_int":["pub(crate) fn bin_int(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    preceded(\n        BIN_PREFIX,\n        cut_err((\n            one_of(DIGIT0_1),\n            repeat(\n                0..,\n                alt((\n                    one_of(DIGIT0_1).value(()),\n                    (\n                        one_of(b'_'),\n                        cut_err(one_of(DIGIT0_1))\n                            .context(Context::Expected(ParserValue::Description(\"digit\"))),\n                    )\n                        .value(()),\n                )),\n            )\n            .map(|()| ()),\n        ))\n        .recognize(),\n    )\n    .map(|b| unsafe { from_utf8_unchecked(b, \"`DIGIT0_1` and `_` filter out non-ASCII\") })\n    .context(Context::Expression(\"binary integer\"))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::boolean":["#[allow(dead_code)]\npub(crate) fn boolean(input: Input<'_>) -> IResult<Input<'_>, bool, ParserError<'_>>{\n    alt((true_, false_)).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::dec_int":["pub(crate) fn dec_int(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    (\n        opt(one_of((b'+', b'-'))),\n        alt((\n            (\n                one_of(DIGIT1_9),\n                repeat(\n                    0..,\n                    alt((\n                        digit.value(()),\n                        (\n                            one_of(b'_'),\n                            cut_err(digit)\n                                .context(Context::Expected(ParserValue::Description(\"digit\"))),\n                        )\n                            .value(()),\n                    )),\n                )\n                .map(|()| ()),\n            )\n                .value(()),\n            digit.value(()),\n        )),\n    )\n        .recognize()\n        .map(|b: &[u8]| unsafe { from_utf8_unchecked(b, \"`digit` and `_` filter out non-ASCII\") })\n        .context(Context::Expression(\"integer\"))\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::digit":["pub(crate) fn digit(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    one_of(DIGIT).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::exp":["pub(crate) fn exp(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    (\n        one_of((b'e', b'E')),\n        opt(one_of([b'+', b'-'])),\n        cut_err(zero_prefixable_int),\n    )\n        .recognize()\n        .map(|b: &[u8]| unsafe {\n            from_utf8_unchecked(\n                b,\n                \"`one_of` and `parse_zero_prefixable_int` filter out non-ASCII\",\n            )\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::false_":["pub(crate) fn false_(input: Input<'_>) -> IResult<Input<'_>, bool, ParserError<'_>>{\n    (peek(FALSE[0]), cut_err(FALSE))\n        .value(false)\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::float":["pub(crate) fn float(input: Input<'_>) -> IResult<Input<'_>, f64, ParserError<'_>>{\n    alt((\n        float_.and_then(cut_err(\n            rest.try_map(|s: &str| s.replace('_', \"\").parse())\n                .verify(|f: &f64| *f != f64::INFINITY),\n        )),\n        special_float,\n    ))\n    .context(Context::Expression(\"floating-point number\"))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::float_":["pub(crate) fn float_(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    (dec_int, alt((exp, (frac, opt(exp)).map(|_| \"\"))))\n        .recognize()\n        .map(|b: &[u8]| unsafe {\n            from_utf8_unchecked(\n                b,\n                \"`dec_int`, `one_of`, `exp`, and `frac` filter out non-ASCII\",\n            )\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::frac":["pub(crate) fn frac(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    (\n        b'.',\n        cut_err(zero_prefixable_int).context(Context::Expected(ParserValue::Description(\"digit\"))),\n    )\n        .recognize()\n        .map(|b: &[u8]| unsafe {\n            from_utf8_unchecked(\n                b,\n                \"`.` and `parse_zero_prefixable_int` filter out non-ASCII\",\n            )\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::hex_int":["pub(crate) fn hex_int(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    preceded(\n        HEX_PREFIX,\n        cut_err((\n            hexdig,\n            repeat(\n                0..,\n                alt((\n                    hexdig.value(()),\n                    (\n                        one_of(b'_'),\n                        cut_err(hexdig)\n                            .context(Context::Expected(ParserValue::Description(\"digit\"))),\n                    )\n                        .value(()),\n                )),\n            )\n            .map(|()| ()),\n        ))\n        .recognize(),\n    )\n    .map(|b| unsafe { from_utf8_unchecked(b, \"`hexdig` and `_` filter out non-ASCII\") })\n    .context(Context::Expression(\"hexadecimal integer\"))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::hexdig":["pub(crate) fn hexdig(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    one_of(HEXDIG).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::inf":["pub(crate) fn inf(input: Input<'_>) -> IResult<Input<'_>, f64, ParserError<'_>>{\n    tag(INF).value(f64::INFINITY).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::integer":["pub(crate) fn integer(input: Input<'_>) -> IResult<Input<'_>, i64, ParserError<'_>>{\n    dispatch! {peek(opt::<_, &[u8], _, _>(take(2usize)));\n        Some(b\"0x\") => cut_err(hex_int.try_map(|s| i64::from_str_radix(&s.replace('_', \"\"), 16))),\n        Some(b\"0o\") => cut_err(oct_int.try_map(|s| i64::from_str_radix(&s.replace('_', \"\"), 8))),\n        Some(b\"0b\") => cut_err(bin_int.try_map(|s| i64::from_str_radix(&s.replace('_', \"\"), 2))),\n        _ => dec_int.and_then(cut_err(rest\n            .try_map(|s: &str| s.replace('_', \"\").parse())))\n    }\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::nan":["pub(crate) fn nan(input: Input<'_>) -> IResult<Input<'_>, f64, ParserError<'_>>{\n    tag(NAN).value(f64::NAN).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::oct_int":["pub(crate) fn oct_int(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    preceded(\n        OCT_PREFIX,\n        cut_err((\n            one_of(DIGIT0_7),\n            repeat(\n                0..,\n                alt((\n                    one_of(DIGIT0_7).value(()),\n                    (\n                        one_of(b'_'),\n                        cut_err(one_of(DIGIT0_7))\n                            .context(Context::Expected(ParserValue::Description(\"digit\"))),\n                    )\n                        .value(()),\n                )),\n            )\n            .map(|()| ()),\n        ))\n        .recognize(),\n    )\n    .map(|b| unsafe { from_utf8_unchecked(b, \"`DIGIT0_7` and `_` filter out non-ASCII\") })\n    .context(Context::Expression(\"octal integer\"))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::special_float":["pub(crate) fn special_float(input: Input<'_>) -> IResult<Input<'_>, f64, ParserError<'_>>{\n    (opt(one_of((b'+', b'-'))), alt((inf, nan)))\n        .map(|(s, f)| match s {\n            Some(b'+') | None => f,\n            Some(b'-') => -f,\n            _ => unreachable!(\"one_of should prevent this\"),\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::true_":["pub(crate) fn true_(input: Input<'_>) -> IResult<Input<'_>, bool, ParserError<'_>>{\n    (peek(TRUE[0]), cut_err(TRUE)).value(true).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::numbers::zero_prefixable_int":["pub(crate) fn zero_prefixable_int(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    (\n        digit,\n        repeat(\n            0..,\n            alt((\n                digit.value(()),\n                (\n                    one_of(b'_'),\n                    cut_err(digit).context(Context::Expected(ParserValue::Description(\"digit\"))),\n                )\n                    .value(()),\n            )),\n        )\n        .map(|()| ()),\n    )\n        .recognize()\n        .map(|b: &[u8]| unsafe { from_utf8_unchecked(b, \"`digit` and `_` filter out non-ASCII\") })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))"],"parser::parse_document":["pub(crate) fn parse_document(raw: &str) -> Result<crate::Document, TomlError>{\n    use prelude::*;\n\n    let b = new_input(raw);\n    let mut doc = document::document\n        .parse(b)\n        .map_err(|e| TomlError::new(e, b))?;\n    doc.span = Some(0..(raw.len()));\n    doc.original = Some(raw.to_owned());\n    Ok(doc)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::parse_key":["pub(crate) fn parse_key(raw: &str) -> Result<crate::Key, TomlError>{\n    use prelude::*;\n\n    let b = new_input(raw);\n    let result = key::simple_key.parse(b);\n    match result {\n        Ok((raw, key)) => {\n            Ok(crate::Key::new(key).with_repr_unchecked(crate::Repr::new_unchecked(raw)))\n        }\n        Err(e) => Err(TomlError::new(e, b)),\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::parse_key_path":["pub(crate) fn parse_key_path(raw: &str) -> Result<Vec<crate::Key>, TomlError>{\n    use prelude::*;\n\n    let b = new_input(raw);\n    let result = key::key.parse(b);\n    match result {\n        Ok(mut keys) => {\n            for key in &mut keys {\n                key.despan(raw);\n            }\n            Ok(keys)\n        }\n        Err(e) => Err(TomlError::new(e, b)),\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::parse_value":["pub(crate) fn parse_value(raw: &str) -> Result<crate::Value, TomlError>{\n    use prelude::*;\n\n    let b = new_input(raw);\n    let parsed = value::value(RecursionCheck::default()).parse(b);\n    match parsed {\n        Ok(mut value) => {\n            // Only take the repr and not decor, as its probably not intended\n            value.decor_mut().clear();\n            value.despan(raw);\n            Ok(value)\n        }\n        Err(e) => Err(TomlError::new(e, b)),\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::prelude::RecursionCheck":["#[cfg(not(feature = \"unbounded\"))]\npub(crate) struct RecursionCheck {\n        current: usize,\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::prelude::RecursionCheck::check_depth":["pub(crate) fn check_depth(depth: usize) -> Result<(), super::errors::CustomError>{\n            if depth < 128 {\n                Ok(())\n            } else {\n                Err(super::errors::CustomError::RecursionLimitExceeded)\n            }\n        }","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::prelude::RecursionCheck::recursing":["pub(crate) fn recursing(\n            mut self,\n            input: Input<'_>,\n        ) -> Result<Self, winnow::error::ErrMode<ParserError<'_>>>{\n            self.current += 1;\n            if self.current < 128 {\n                Ok(self)\n            } else {\n                Err(winnow::error::ErrMode::Backtrack(\n                    winnow::error::FromExternalError::from_external_error(\n                        input,\n                        winnow::error::ErrorKind::Eof,\n                        super::errors::CustomError::RecursionLimitExceeded,\n                    ),\n                ))\n            }\n        }","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::prelude::new_input":["pub(crate) fn new_input(s: &str) -> Input<'_>{\n        winnow::Located::new(winnow::BStr::new(s))\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::prelude::ok_error":["pub(crate) fn ok_error<I, O, E>(\n        res: IResult<I, O, E>,\n    ) -> Result<Option<(I, O)>, winnow::error::ErrMode<E>>{\n        match res {\n            Ok(ok) => Ok(Some(ok)),\n            Err(winnow::error::ErrMode::Backtrack(_)) => Ok(None),\n            Err(err) => Err(err),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::prelude::trace":["#[allow(dead_code)]\npub(crate) fn trace<I: std::fmt::Debug, O: std::fmt::Debug, E: std::fmt::Debug>(\n        context: impl std::fmt::Display,\n        mut parser: impl winnow::Parser<I, O, E>,\n    ) -> impl FnMut(I) -> IResult<I, O, E>{\n        static DEPTH: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(0);\n        move |input: I| {\n            let depth = DEPTH.fetch_add(1, std::sync::atomic::Ordering::SeqCst) * 2;\n            eprintln!(\"{:depth$}--> {} {:?}\", \"\", context, input);\n            match parser.parse_next(input) {\n                Ok((i, o)) => {\n                    DEPTH.fetch_sub(1, std::sync::atomic::Ordering::SeqCst);\n                    eprintln!(\"{:depth$}<-- {} {:?}\", \"\", context, i);\n                    Ok((i, o))\n                }\n                Err(err) => {\n                    DEPTH.fetch_sub(1, std::sync::atomic::Ordering::SeqCst);\n                    eprintln!(\"{:depth$}<-- {} {:?}\", \"\", context, err);\n                    Err(err)\n                }\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))"],"parser::state::ParseState":["pub(crate) struct ParseState {\n    document: Document,\n    trailing: Option<std::ops::Range<usize>>,\n    current_table_position: usize,\n    current_table: Table,\n    current_is_array: bool,\n    current_table_path: Vec<Key>,\n}","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::descend_path":["pub(crate) fn descend_path<'t, 'k>(\n        mut table: &'t mut Table,\n        path: &'k [Key],\n        dotted: bool,\n    ) -> Result<&'t mut Table, CustomError>{\n        for (i, key) in path.iter().enumerate() {\n            let entry = table.entry_format(key).or_insert_with(|| {\n                let mut new_table = Table::new();\n                new_table.set_implicit(true);\n                new_table.set_dotted(dotted);\n\n                Item::Table(new_table)\n            });\n            match *entry {\n                Item::Value(ref v) => {\n                    return Err(CustomError::extend_wrong_type(path, i, v.type_name()));\n                }\n                Item::ArrayOfTables(ref mut array) => {\n                    debug_assert!(!array.is_empty());\n\n                    let index = array.len() - 1;\n                    let last_child = array.get_mut(index).unwrap();\n\n                    table = last_child;\n                }\n                Item::Table(ref mut sweet_child_of_mine) => {\n                    // Since tables cannot be defined more than once, redefining such tables using a\n                    // [table] header is not allowed. Likewise, using dotted keys to redefine tables\n                    // already defined in [table] form is not allowed.\n                    if dotted && !sweet_child_of_mine.is_implicit() {\n                        return Err(CustomError::DuplicateKey {\n                            key: key.get().into(),\n                            table: None,\n                        });\n                    }\n                    table = sweet_child_of_mine;\n                }\n                _ => unreachable!(),\n            }\n        }\n        Ok(table)\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::finalize_table":["pub(crate) fn finalize_table(&mut self) -> Result<(), CustomError>{\n        let mut table = std::mem::take(&mut self.current_table);\n        let path = std::mem::take(&mut self.current_table_path);\n\n        let root = self.document.as_table_mut();\n        if path.is_empty() {\n            assert!(root.is_empty());\n            std::mem::swap(&mut table, root);\n        } else if self.current_is_array {\n            let parent_table = Self::descend_path(root, &path[..path.len() - 1], false)?;\n            let key = &path[path.len() - 1];\n\n            let entry = parent_table\n                .entry_format(key)\n                .or_insert(Item::ArrayOfTables(ArrayOfTables::new()));\n            let array = entry\n                .as_array_of_tables_mut()\n                .ok_or_else(|| CustomError::duplicate_key(&path, path.len() - 1))?;\n            array.push(table);\n            let span = if let (Some(first), Some(last)) = (\n                array.values.first().and_then(|t| t.span()),\n                array.values.last().and_then(|t| t.span()),\n            ) {\n                Some((first.start)..(last.end))\n            } else {\n                None\n            };\n            array.span = span;\n        } else {\n            let parent_table = Self::descend_path(root, &path[..path.len() - 1], false)?;\n            let key = &path[path.len() - 1];\n\n            let entry = parent_table.entry_format(key);\n            match entry {\n                crate::Entry::Occupied(entry) => {\n                    match entry.into_mut() {\n                        // if [a.b.c] header preceded [a.b]\n                        Item::Table(ref mut t) if t.implicit => {\n                            std::mem::swap(t, &mut table);\n                        }\n                        _ => return Err(CustomError::duplicate_key(&path, path.len() - 1)),\n                    }\n                }\n                crate::Entry::Vacant(entry) => {\n                    let item = Item::Table(table);\n                    entry.insert(item);\n                }\n            }\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::into_document":["pub(crate) fn into_document(mut self) -> Result<Document, CustomError>{\n        self.finalize_table()?;\n        let trailing = self.trailing.map(RawString::with_span);\n        self.document.trailing = trailing.unwrap_or_default();\n        Ok(self.document)\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::on_array_header":["pub(crate) fn on_array_header(\n        &mut self,\n        path: Vec<Key>,\n        trailing: std::ops::Range<usize>,\n        span: std::ops::Range<usize>,\n    ) -> Result<(), CustomError>{\n        debug_assert!(!path.is_empty());\n\n        self.finalize_table()?;\n        let leading = self\n            .trailing\n            .take()\n            .map(RawString::with_span)\n            .unwrap_or_default();\n        self.start_aray_table(\n            path,\n            Decor::new(leading, RawString::with_span(trailing)),\n            span,\n        )?;\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::on_comment":["pub(crate) fn on_comment(&mut self, span: std::ops::Range<usize>){\n        if let Some(old) = self.trailing.take() {\n            self.trailing = Some(old.start..span.end);\n        } else {\n            self.trailing = Some(span);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::on_keyval":["pub(crate) fn on_keyval(\n        &mut self,\n        mut path: Vec<Key>,\n        mut kv: TableKeyValue,\n    ) -> Result<(), CustomError>{\n        {\n            let mut prefix = self.trailing.take();\n            let first_key = if path.is_empty() {\n                &mut kv.key\n            } else {\n                &mut path[0]\n            };\n            let prefix = match (\n                prefix.take(),\n                first_key.decor.prefix().and_then(|d| d.span()),\n            ) {\n                (Some(p), Some(k)) => Some(p.start..k.end),\n                (Some(p), None) | (None, Some(p)) => Some(p),\n                (None, None) => None,\n            };\n            first_key\n                .decor\n                .set_prefix(prefix.map(RawString::with_span).unwrap_or_default());\n        }\n\n        if let (Some(existing), Some(value)) = (self.current_table.span(), kv.value.span()) {\n            self.current_table.span = Some((existing.start)..(value.end));\n        }\n        let table = &mut self.current_table;\n        let table = Self::descend_path(table, &path, true)?;\n\n        // \"Likewise, using dotted keys to redefine tables already defined in [table] form is not allowed\"\n        let mixed_table_types = table.is_dotted() == path.is_empty();\n        if mixed_table_types {\n            return Err(CustomError::DuplicateKey {\n                key: kv.key.get().into(),\n                table: None,\n            });\n        }\n\n        let key: InternalString = kv.key.get_internal().into();\n        match table.items.entry(key) {\n            indexmap::map::Entry::Vacant(o) => {\n                o.insert(kv);\n            }\n            indexmap::map::Entry::Occupied(o) => {\n                // \"Since tables cannot be defined more than once, redefining such tables using a [table] header is not allowed\"\n                return Err(CustomError::DuplicateKey {\n                    key: o.key().as_str().into(),\n                    table: Some(self.current_table_path.clone()),\n                });\n            }\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::on_std_header":["pub(crate) fn on_std_header(\n        &mut self,\n        path: Vec<Key>,\n        trailing: std::ops::Range<usize>,\n        span: std::ops::Range<usize>,\n    ) -> Result<(), CustomError>{\n        debug_assert!(!path.is_empty());\n\n        self.finalize_table()?;\n        let leading = self\n            .trailing\n            .take()\n            .map(RawString::with_span)\n            .unwrap_or_default();\n        self.start_table(\n            path,\n            Decor::new(leading, RawString::with_span(trailing)),\n            span,\n        )?;\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::on_ws":["pub(crate) fn on_ws(&mut self, span: std::ops::Range<usize>){\n        if let Some(old) = self.trailing.take() {\n            self.trailing = Some(old.start..span.end);\n        } else {\n            self.trailing = Some(span);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::start_aray_table":["pub(crate) fn start_aray_table(\n        &mut self,\n        path: Vec<Key>,\n        decor: Decor,\n        span: std::ops::Range<usize>,\n    ) -> Result<(), CustomError>{\n        debug_assert!(!path.is_empty());\n        debug_assert!(self.current_table.is_empty());\n        debug_assert!(self.current_table_path.is_empty());\n\n        // Look up the table on start to ensure the duplicate_key error points to the right line\n        let root = self.document.as_table_mut();\n        let parent_table = Self::descend_path(root, &path[..path.len() - 1], false)?;\n        let key = &path[path.len() - 1];\n        let entry = parent_table\n            .entry_format(key)\n            .or_insert(Item::ArrayOfTables(ArrayOfTables::new()));\n        entry\n            .as_array_of_tables()\n            .ok_or_else(|| CustomError::duplicate_key(&path, path.len() - 1))?;\n\n        self.current_table_position += 1;\n        self.current_table.decor = decor;\n        self.current_table.set_implicit(false);\n        self.current_table.set_dotted(false);\n        self.current_table.set_position(self.current_table_position);\n        self.current_table.span = Some(span);\n        self.current_is_array = true;\n        self.current_table_path = path;\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::state::ParseState::start_table":["pub(crate) fn start_table(\n        &mut self,\n        path: Vec<Key>,\n        decor: Decor,\n        span: std::ops::Range<usize>,\n    ) -> Result<(), CustomError>{\n        debug_assert!(!path.is_empty());\n        debug_assert!(self.current_table.is_empty());\n        debug_assert!(self.current_table_path.is_empty());\n\n        // 1. Look up the table on start to ensure the duplicate_key error points to the right line\n        // 2. Ensure any child tables from an implicit table are preserved\n        let root = self.document.as_table_mut();\n        let parent_table = Self::descend_path(root, &path[..path.len() - 1], false)?;\n        let key = &path[path.len() - 1];\n        if let Some(entry) = parent_table.remove(key.get()) {\n            match entry {\n                Item::Table(t) if t.implicit && !t.is_dotted() => {\n                    self.current_table = t;\n                }\n                // Since tables cannot be defined more than once, redefining such tables using a [table] header is not allowed. Likewise, using dotted keys to redefine tables already defined in [table] form is not allowed.\n                _ => return Err(CustomError::duplicate_key(&path, path.len() - 1)),\n            }\n        }\n\n        self.current_table_position += 1;\n        self.current_table.decor = decor;\n        self.current_table.set_implicit(false);\n        self.current_table.set_dotted(false);\n        self.current_table.set_position(self.current_table_position);\n        self.current_table.span = Some(span);\n        self.current_is_array = false;\n        self.current_table_path = path;\n\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))"],"parser::strings::basic_chars":["fn basic_chars(input: Input<'_>) -> IResult<Input<'_>, Cow<'_, str>, ParserError<'_>>{\n    alt((\n        // Deviate from the official grammar by batching the unescaped chars so we build a string a\n        // chunk at a time, rather than a `char` at a time.\n        take_while(1.., BASIC_UNESCAPED)\n            .try_map(std::str::from_utf8)\n            .map(Cow::Borrowed),\n        escaped.map(|c| Cow::Owned(String::from(c))),\n    ))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::basic_string":["pub(crate) fn basic_string(input: Input<'_>) -> IResult<Input<'_>, Cow<'_, str>, ParserError<'_>>{\n    let (mut input, _) = one_of(QUOTATION_MARK).parse_next(input)?;\n\n    let mut c = Cow::Borrowed(\"\");\n    if let Some((i, ci)) = ok_error(basic_chars.parse_next(input))? {\n        input = i;\n        c = ci;\n    }\n    while let Some((i, ci)) = ok_error(basic_chars.parse_next(input))? {\n        input = i;\n        c.to_mut().push_str(&ci);\n    }\n\n    let (input, _) = cut_err(one_of(QUOTATION_MARK))\n        .context(Context::Expression(\"basic string\"))\n        .parse_next(input)?;\n\n    Ok((input, c))\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::escape_seq_char":["fn escape_seq_char(input: Input<'_>) -> IResult<Input<'_>, char, ParserError<'_>>{\n    dispatch! {any;\n        b'b' => success('\\u{8}'),\n        b'f' => success('\\u{c}'),\n        b'n' => success('\\n'),\n        b'r' => success('\\r'),\n        b't' => success('\\t'),\n        b'u' => cut_err(hexescape::<4>).context(Context::Expression(\"unicode 4-digit hex code\")),\n        b'U' => cut_err(hexescape::<8>).context(Context::Expression(\"unicode 8-digit hex code\")),\n        b'\\\\' => success('\\\\'),\n        b'\"' => success('\"'),\n        _ => {\n            cut_err(fail::<_, char, _>)\n            .context(Context::Expression(\"escape sequence\"))\n            .context(Context::Expected(ParserValue::CharLiteral('b')))\n            .context(Context::Expected(ParserValue::CharLiteral('f')))\n            .context(Context::Expected(ParserValue::CharLiteral('n')))\n            .context(Context::Expected(ParserValue::CharLiteral('r')))\n            .context(Context::Expected(ParserValue::CharLiteral('t')))\n            .context(Context::Expected(ParserValue::CharLiteral('u')))\n            .context(Context::Expected(ParserValue::CharLiteral('U')))\n            .context(Context::Expected(ParserValue::CharLiteral('\\\\')))\n            .context(Context::Expected(ParserValue::CharLiteral('\"')))\n        }\n    }\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::escaped":["fn escaped(input: Input<'_>) -> IResult<Input<'_>, char, ParserError<'_>>{\n    preceded(ESCAPE, escape_seq_char).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::hexescape":["pub(crate) fn hexescape<const N: usize>(\n    input: Input<'_>,\n) -> IResult<Input<'_>, char, ParserError<'_>>{\n    take_while(0..=N, HEXDIG)\n        .verify(|b: &[u8]| b.len() == N)\n        .map(|b: &[u8]| unsafe { from_utf8_unchecked(b, \"`is_ascii_digit` filters out on-ASCII\") })\n        .verify_map(|s| u32::from_str_radix(s, 16).ok())\n        .try_map(|h| char::from_u32(h).ok_or(CustomError::OutOfRange))\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::literal_string":["pub(crate) fn literal_string(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    delimited(\n        APOSTROPHE,\n        cut_err(take_while(0.., LITERAL_CHAR)),\n        cut_err(APOSTROPHE),\n    )\n    .try_map(std::str::from_utf8)\n    .context(Context::Expression(\"literal string\"))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::ml_basic_body":["fn ml_basic_body(mut input: Input<'_>) -> IResult<Input<'_>, Cow<'_, str>, ParserError<'_>>{\n    let mut c = Cow::Borrowed(\"\");\n    if let Some((i, ci)) = ok_error(mlb_content.parse_next(input))? {\n        input = i;\n        c = ci;\n    }\n    while let Some((i, ci)) = ok_error(mlb_content.parse_next(input))? {\n        input = i;\n        c.to_mut().push_str(&ci);\n    }\n\n    while let Some((i, qi)) = ok_error(mlb_quotes(none_of(b'\\\"').value(())).parse_next(input))? {\n        if let Some((i, ci)) = ok_error(mlb_content.parse_next(i))? {\n            input = i;\n            c.to_mut().push_str(qi);\n            c.to_mut().push_str(&ci);\n            while let Some((i, ci)) = ok_error(mlb_content.parse_next(input))? {\n                input = i;\n                c.to_mut().push_str(&ci);\n            }\n        } else {\n            break;\n        }\n    }\n\n    if let Some((i, qi)) =\n        ok_error(mlb_quotes(tag(ML_BASIC_STRING_DELIM).value(())).parse_next(input))?\n    {\n        input = i;\n        c.to_mut().push_str(qi);\n    }\n\n    Ok((input, c))\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::ml_basic_string":["fn ml_basic_string(input: Input<'_>) -> IResult<Input<'_>, Cow<'_, str>, ParserError<'_>>{\n    delimited(\n        ML_BASIC_STRING_DELIM,\n        preceded(opt(newline), cut_err(ml_basic_body)),\n        cut_err(ML_BASIC_STRING_DELIM),\n    )\n    .context(Context::Expression(\"multiline basic string\"))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::ml_literal_body":["fn ml_literal_body(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    (\n        repeat(0.., mll_content).map(|()| ()),\n        repeat(\n            0..,\n            (\n                mll_quotes(none_of(APOSTROPHE).value(())),\n                repeat(1.., mll_content).map(|()| ()),\n            ),\n        )\n        .map(|()| ()),\n        opt(mll_quotes(tag(ML_LITERAL_STRING_DELIM).value(()))),\n    )\n        .recognize()\n        .try_map(std::str::from_utf8)\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::ml_literal_string":["fn ml_literal_string(input: Input<'_>) -> IResult<Input<'_>, Cow<'_, str>, ParserError<'_>>{\n    delimited(\n        (ML_LITERAL_STRING_DELIM, opt(newline)),\n        cut_err(ml_literal_body.map(|t| {\n            if t.contains(\"\\r\\n\") {\n                Cow::Owned(t.replace(\"\\r\\n\", \"\\n\"))\n            } else {\n                Cow::Borrowed(t)\n            }\n        })),\n        cut_err(ML_LITERAL_STRING_DELIM),\n    )\n    .context(Context::Expression(\"multiline literal string\"))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::mlb_content":["fn mlb_content(input: Input<'_>) -> IResult<Input<'_>, Cow<'_, str>, ParserError<'_>>{\n    alt((\n        // Deviate from the official grammar by batching the unescaped chars so we build a string a\n        // chunk at a time, rather than a `char` at a time.\n        take_while(1.., MLB_UNESCAPED)\n            .try_map(std::str::from_utf8)\n            .map(Cow::Borrowed),\n        // Order changed fromg grammar so `escaped` can more easily `cut_err` on bad escape sequences\n        mlb_escaped_nl.map(|_| Cow::Borrowed(\"\")),\n        escaped.map(|c| Cow::Owned(String::from(c))),\n        newline.map(|_| Cow::Borrowed(\"\\n\")),\n    ))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::mlb_escaped_nl":["fn mlb_escaped_nl(input: Input<'_>) -> IResult<Input<'_>, (), ParserError<'_>>{\n    repeat(1.., (ESCAPE, ws, ws_newlines))\n        .map(|()| ())\n        .value(())\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::mlb_quotes":["fn mlb_quotes<'i>(\n    mut term: impl winnow::Parser<Input<'i>, (), ParserError<'i>>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, &str, ParserError<'i>>{\n    move |input| {\n        let res = terminated(b\"\\\"\\\"\", peek(term.by_ref()))\n            .map(|b| unsafe { from_utf8_unchecked(b, \"`bytes` out non-ASCII\") })\n            .parse_next(input);\n\n        match res {\n            Err(winnow::error::ErrMode::Backtrack(_)) => terminated(b\"\\\"\", peek(term.by_ref()))\n                .map(|b| unsafe { from_utf8_unchecked(b, \"`bytes` out non-ASCII\") })\n                .parse_next(input),\n            res => res,\n        }\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::mll_content":["fn mll_content(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    alt((one_of(MLL_CHAR), newline)).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::mll_quotes":["fn mll_quotes<'i>(\n    mut term: impl winnow::Parser<Input<'i>, (), ParserError<'i>>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, &str, ParserError<'i>>{\n    move |input| {\n        let res = terminated(b\"''\", peek(term.by_ref()))\n            .map(|b| unsafe { from_utf8_unchecked(b, \"`bytes` out non-ASCII\") })\n            .parse_next(input);\n\n        match res {\n            Err(winnow::error::ErrMode::Backtrack(_)) => terminated(b\"'\", peek(term.by_ref()))\n                .map(|b| unsafe { from_utf8_unchecked(b, \"`bytes` out non-ASCII\") })\n                .parse_next(input),\n            res => res,\n        }\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::strings::string":["pub(crate) fn string(input: Input<'_>) -> IResult<Input<'_>, Cow<'_, str>, ParserError<'_>>{\n    alt((\n        ml_basic_string,\n        basic_string,\n        ml_literal_string,\n        literal_string.map(Cow::Borrowed),\n    ))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))"],"parser::table::array_table":["pub(crate) fn array_table<'s, 'i>(\n    state: &'s RefCell<ParseState>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, (), ParserError<'i>> + 's{\n    move |i| {\n        (\n            delimited(\n                ARRAY_TABLE_OPEN,\n                cut_err(key),\n                cut_err(ARRAY_TABLE_CLOSE)\n                    .context(Context::Expected(ParserValue::CharLiteral('.')))\n                    .context(Context::Expected(ParserValue::StringLiteral(\"]]\"))),\n            )\n            .with_span(),\n            cut_err(line_trailing)\n                .context(Context::Expected(ParserValue::CharLiteral('\\n')))\n                .context(Context::Expected(ParserValue::CharLiteral('#'))),\n        )\n            .try_map(|((h, span), t)| state.borrow_mut().deref_mut().on_array_header(h, t, span))\n            .parse_next(i)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/table.rs\"))"],"parser::table::std_table":["pub(crate) fn std_table<'s, 'i>(\n    state: &'s RefCell<ParseState>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, (), ParserError<'i>> + 's{\n    move |i| {\n        (\n            delimited(\n                STD_TABLE_OPEN,\n                cut_err(key),\n                cut_err(STD_TABLE_CLOSE)\n                    .context(Context::Expected(ParserValue::CharLiteral('.')))\n                    .context(Context::Expected(ParserValue::StringLiteral(\"]\"))),\n            )\n            .with_span(),\n            cut_err(line_trailing)\n                .context(Context::Expected(ParserValue::CharLiteral('\\n')))\n                .context(Context::Expected(ParserValue::CharLiteral('#'))),\n        )\n            .try_map(|((h, span), t)| state.borrow_mut().deref_mut().on_std_header(h, t, span))\n            .parse_next(i)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/table.rs\"))"],"parser::table::table":["pub(crate) fn table<'s, 'i>(\n    state: &'s RefCell<ParseState>,\n) -> impl FnMut(Input<'i>) -> IResult<Input<'i>, (), ParserError<'i>> + 's{\n    move |i| {\n        dispatch!(peek::<_, &[u8],_,_>(take(2usize));\n            b\"[[\" => array_table(state),\n            _ => std_table(state),\n        )\n        .context(Context::Expression(\"table header\"))\n        .parse_next(i)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/table.rs\"))"],"parser::trivia::comment":["pub(crate) fn comment(input: Input<'_>) -> IResult<Input<'_>, &[u8], ParserError<'_>>{\n    (COMMENT_START_SYMBOL, take_while(0.., NON_EOL))\n        .recognize()\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::trivia::from_utf8_unchecked":["pub(crate) unsafe fn from_utf8_unchecked<'b>(\n    bytes: &'b [u8],\n    safety_justification: &'static str,\n) -> &'b str{\n    if cfg!(debug_assertions) {\n        // Catch problems more quickly when testing\n        std::str::from_utf8(bytes).expect(safety_justification)\n    } else {\n        std::str::from_utf8_unchecked(bytes)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::trivia::line_ending":["pub(crate) fn line_ending(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    alt((newline.value(\"\\n\"), eof.value(\"\"))).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::trivia::line_trailing":["pub(crate) fn line_trailing(\n    input: Input<'_>,\n) -> IResult<Input<'_>, std::ops::Range<usize>, ParserError<'_>>{\n    terminated((ws, opt(comment)).span(), line_ending).parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::trivia::newline":["pub(crate) fn newline(input: Input<'_>) -> IResult<Input<'_>, u8, ParserError<'_>>{\n    alt((\n        one_of(LF).value(b'\\n'),\n        (one_of(CR), one_of(LF)).value(b'\\n'),\n    ))\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::trivia::ws":["pub(crate) fn ws(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    take_while(0.., WSCHAR)\n        .map(|b| unsafe { from_utf8_unchecked(b, \"`is_wschar` filters out on-ASCII\") })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::trivia::ws_comment_newline":["pub(crate) fn ws_comment_newline(input: Input<'_>) -> IResult<Input<'_>, &[u8], ParserError<'_>>{\n    repeat(\n        0..,\n        alt((\n            repeat(\n                1..,\n                alt((take_while(1.., WSCHAR), newline.value(&b\"\\n\"[..]))),\n            )\n            .map(|()| ()),\n            comment.value(()),\n        )),\n    )\n    .map(|()| ())\n    .recognize()\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::trivia::ws_newline":["pub(crate) fn ws_newline(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    repeat(\n        0..,\n        alt((newline.value(&b\"\\n\"[..]), take_while(1.., WSCHAR))),\n    )\n    .map(|()| ())\n    .recognize()\n    .map(|b| unsafe { from_utf8_unchecked(b, \"`is_wschar` and `newline` filters out on-ASCII\") })\n    .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::trivia::ws_newlines":["pub(crate) fn ws_newlines(input: Input<'_>) -> IResult<Input<'_>, &str, ParserError<'_>>{\n    (newline, ws_newline)\n        .recognize()\n        .map(|b| unsafe {\n            from_utf8_unchecked(b, \"`is_wschar` and `newline` filters out on-ASCII\")\n        })\n        .parse_next(input)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))"],"parser::value::apply_raw":["fn apply_raw(mut val: Value, span: std::ops::Range<usize>) -> Result<Value, std::str::Utf8Error>{\n    match val {\n        Value::String(ref mut f) => {\n            let raw = RawString::with_span(span);\n            f.set_repr_unchecked(Repr::new_unchecked(raw));\n        }\n        Value::Integer(ref mut f) => {\n            let raw = RawString::with_span(span);\n            f.set_repr_unchecked(Repr::new_unchecked(raw));\n        }\n        Value::Float(ref mut f) => {\n            let raw = RawString::with_span(span);\n            f.set_repr_unchecked(Repr::new_unchecked(raw));\n        }\n        Value::Boolean(ref mut f) => {\n            let raw = RawString::with_span(span);\n            f.set_repr_unchecked(Repr::new_unchecked(raw));\n        }\n        Value::Datetime(ref mut f) => {\n            let raw = RawString::with_span(span);\n            f.set_repr_unchecked(Repr::new_unchecked(raw));\n        }\n        Value::Array(ref mut arr) => {\n            arr.span = Some(span);\n        }\n        Value::InlineTable(ref mut table) => {\n            table.span = Some(span);\n        }\n    };\n    val.decorate(\"\", \"\");\n    Ok(val)\n}","Real(LocalPath(\"crates/toml_edit/src/parser/value.rs\"))"],"parser::value::value":["pub(crate) fn value(\n    check: RecursionCheck,\n) -> impl FnMut(Input<'_>) -> IResult<Input<'_>, v::Value, ParserError<'_>>{\n    move |input| {\n        dispatch!{peek(any);\n            crate::parser::strings::QUOTATION_MARK |\n            crate::parser::strings::APOSTROPHE => string.map(|s| {\n                v::Value::String(Formatted::new(\n                    s.into_owned()\n                ))\n            }),\n            crate::parser::array::ARRAY_OPEN => array(check).map(v::Value::Array),\n            crate::parser::inline_table::INLINE_TABLE_OPEN => inline_table(check).map(v::Value::InlineTable),\n            // Date/number starts\n            b'+' | b'-' | b'0'..=b'9' => {\n                // Uncommon enough not to be worth optimizing at this time\n                alt((\n                    date_time\n                        .map(v::Value::from),\n                    float\n                        .map(v::Value::from),\n                    integer\n                        .map(v::Value::from),\n                ))\n            },\n            // Report as if they were numbers because its most likely a typo\n            b'_' => {\n                    integer\n                        .map(v::Value::from)\n                .context(Context::Expected(ParserValue::Description(\"leading digit\")))\n            },\n            // Report as if they were numbers because its most likely a typo\n            b'.' =>  {\n                    float\n                        .map(v::Value::from)\n                .context(Context::Expected(ParserValue::Description(\"leading digit\")))\n            },\n            b't' => {\n                crate::parser::numbers::true_.map(v::Value::from)\n                    .context(Context::Expression(\"string\"))\n                    .context(Context::Expected(ParserValue::CharLiteral('\"')))\n                    .context(Context::Expected(ParserValue::CharLiteral('\\'')))\n            },\n            b'f' => {\n                crate::parser::numbers::false_.map(v::Value::from)\n                    .context(Context::Expression(\"string\"))\n                    .context(Context::Expected(ParserValue::CharLiteral('\"')))\n                    .context(Context::Expected(ParserValue::CharLiteral('\\'')))\n            },\n            b'i' => {\n                crate::parser::numbers::inf.map(v::Value::from)\n                    .context(Context::Expression(\"string\"))\n                    .context(Context::Expected(ParserValue::CharLiteral('\"')))\n                    .context(Context::Expected(ParserValue::CharLiteral('\\'')))\n            },\n            b'n' => {\n                crate::parser::numbers::nan.map(v::Value::from)\n                    .context(Context::Expression(\"string\"))\n                    .context(Context::Expected(ParserValue::CharLiteral('\"')))\n                    .context(Context::Expected(ParserValue::CharLiteral('\\'')))\n            },\n            _ => {\n                fail\n                    .context(Context::Expression(\"string\"))\n                    .context(Context::Expected(ParserValue::CharLiteral('\"')))\n                    .context(Context::Expected(ParserValue::CharLiteral('\\'')))\n            },\n    }\n        .with_span()\n        .try_map(|(value, span)| apply_raw(value, span))\n        .parse_next(input)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/parser/value.rs\"))"],"private::Sealed":["pub trait Sealed {}","Real(LocalPath(\"crates/toml_edit/src/lib.rs\"))"],"raw_string::RawString":["/// Opaque string storage for raw TOML; internal to `toml_edit`\npub struct RawString(RawStringInner);","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawString::as_str":["/// Access the underlying string\npub fn as_str(&self) -> Option<&str>{\n        match &self.0 {\n            RawStringInner::Empty => Some(\"\"),\n            RawStringInner::Explicit(s) => Some(s.as_str()),\n            RawStringInner::Spanned(_) => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawString::despan":["pub(crate) fn despan(&mut self, input: &str){\n        match &self.0 {\n            RawStringInner::Empty => {}\n            RawStringInner::Explicit(_) => {}\n            RawStringInner::Spanned(span) => {\n                *self = Self::from(input.get(span.clone()).unwrap_or_else(|| {\n                    panic!(\"span {:?} should be in input:\\n```\\n{}\\n```\", span, input)\n                }))\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawString::encode":["pub(crate) fn encode(&self, buf: &mut dyn std::fmt::Write, input: &str) -> std::fmt::Result{\n        let raw = self.to_str(input);\n        for part in raw.split('\\r') {\n            write!(buf, \"{}\", part)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawString::encode_with_default":["pub(crate) fn encode_with_default(\n        &self,\n        buf: &mut dyn std::fmt::Write,\n        input: Option<&str>,\n        default: &str,\n    ) -> std::fmt::Result{\n        let raw = self.to_str_with_default(input, default);\n        for part in raw.split('\\r') {\n            write!(buf, \"{}\", part)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawString::span":["/// Access the underlying span\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        match &self.0 {\n            RawStringInner::Empty => None,\n            RawStringInner::Explicit(_) => None,\n            RawStringInner::Spanned(span) => Some(span.clone()),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawString::to_str":["pub(crate) fn to_str<'s>(&'s self, input: &'s str) -> &'s str{\n        match &self.0 {\n            RawStringInner::Empty => \"\",\n            RawStringInner::Explicit(s) => s.as_str(),\n            RawStringInner::Spanned(span) => input.get(span.clone()).unwrap_or_else(|| {\n                panic!(\"span {:?} should be in input:\\n```\\n{}\\n```\", span, input)\n            }),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawString::to_str_with_default":["pub(crate) fn to_str_with_default<'s>(\n        &'s self,\n        input: Option<&'s str>,\n        default: &'s str,\n    ) -> &'s str{\n        match &self.0 {\n            RawStringInner::Empty => \"\",\n            RawStringInner::Explicit(s) => s.as_str(),\n            RawStringInner::Spanned(span) => {\n                if let Some(input) = input {\n                    input.get(span.clone()).unwrap_or_else(|| {\n                        panic!(\"span {:?} should be in input:\\n```\\n{}\\n```\", span, input)\n                    })\n                } else {\n                    default\n                }\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawString::with_span":["pub(crate) fn with_span(span: std::ops::Range<usize>) -> Self{\n        if span.start == span.end {\n            RawString(RawStringInner::Empty)\n        } else {\n            RawString(RawStringInner::Spanned(span))\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"raw_string::RawStringInner":["enum RawStringInner {\n    Empty,\n    Explicit(InternalString),\n    Spanned(std::ops::Range<usize>),\n}","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))"],"repr::Decor":["/// A prefix and suffix,\n///\n/// Including comments, whitespaces and newlines.\npub struct Decor {\n    prefix: Option<RawString>,\n    suffix: Option<RawString>,\n}","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::clear":["/// Go back to default decor\npub fn clear(&mut self){\n        self.prefix = None;\n        self.suffix = None;\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::despan":["pub(crate) fn despan(&mut self, input: &str){\n        if let Some(prefix) = &mut self.prefix {\n            prefix.despan(input);\n        }\n        if let Some(suffix) = &mut self.suffix {\n            suffix.despan(input);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::new":["/// Creates a new decor from the given prefix and suffix.\npub fn new(prefix: impl Into<RawString>, suffix: impl Into<RawString>) -> Self{\n        Self {\n            prefix: Some(prefix.into()),\n            suffix: Some(suffix.into()),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::prefix":["/// Get the prefix.\npub fn prefix(&self) -> Option<&RawString>{\n        self.prefix.as_ref()\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::prefix_encode":["pub(crate) fn prefix_encode(\n        &self,\n        buf: &mut dyn std::fmt::Write,\n        input: Option<&str>,\n        default: &str,\n    ) -> std::fmt::Result{\n        if let Some(prefix) = self.prefix() {\n            prefix.encode_with_default(buf, input, default)\n        } else {\n            write!(buf, \"{}\", default)\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::set_prefix":["/// Set the prefix.\npub fn set_prefix(&mut self, prefix: impl Into<RawString>){\n        self.prefix = Some(prefix.into());\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::set_suffix":["/// Set the suffix.\npub fn set_suffix(&mut self, suffix: impl Into<RawString>){\n        self.suffix = Some(suffix.into());\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::suffix":["/// Get the suffix.\npub fn suffix(&self) -> Option<&RawString>{\n        self.suffix.as_ref()\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Decor::suffix_encode":["pub(crate) fn suffix_encode(\n        &self,\n        buf: &mut dyn std::fmt::Write,\n        input: Option<&str>,\n        default: &str,\n    ) -> std::fmt::Result{\n        if let Some(suffix) = self.suffix() {\n            suffix.encode_with_default(buf, input, default)\n        } else {\n            write!(buf, \"{}\", default)\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted":["/// A value together with its `to_string` representation,\n/// including surrounding it whitespaces and comments.\npub struct Formatted<T> {\n    value: T,\n    repr: Option<Repr>,\n    decor: Decor,\n}","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::as_repr":["/// Returns the raw representation, if available.\npub fn as_repr(&self) -> Option<&Repr>{\n        self.repr.as_ref()\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::decor":["/// Returns the surrounding whitespace\npub fn decor(&self) -> &Decor{\n        &self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::decor_mut":["/// Returns the surrounding whitespace\npub fn decor_mut(&mut self) -> &mut Decor{\n        &mut self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::default_repr":["/// Returns the default raw representation.\npub fn default_repr(&self) -> Repr{\n        self.value.to_repr()\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::despan":["pub(crate) fn despan(&mut self, input: &str){\n        self.decor.despan(input);\n        if let Some(repr) = &mut self.repr {\n            repr.despan(input);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::display_repr":["/// Returns a raw representation.\npub fn display_repr(&self) -> Cow<str>{\n        self.as_repr()\n            .and_then(|r| r.as_raw().as_str())\n            .map(Cow::Borrowed)\n            .unwrap_or_else(|| {\n                Cow::Owned(self.default_repr().as_raw().as_str().unwrap().to_owned())\n            })\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::fmt":["/// Auto formats the value.\npub fn fmt(&mut self){\n        self.repr = Some(self.value.to_repr());\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::into_value":["/// The wrapped value\npub fn into_value(self) -> T{\n        self.value\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::new":["/// Default-formatted value\npub fn new(value: T) -> Self{\n        Self {\n            value,\n            repr: None,\n            decor: Default::default(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::set_repr_unchecked":["pub(crate) fn set_repr_unchecked(&mut self, repr: Repr){\n        self.repr = Some(repr);\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::span":["/// Returns the location within the original document\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        self.repr.as_ref().and_then(|r| r.span())\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Formatted::<T>::value":["/// The wrapped value\npub fn value(&self) -> &T{\n        &self.value\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Repr":["/// TOML-encoded value\npub struct Repr {\n    raw_value: RawString,\n}","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Repr::as_raw":["/// Access the underlying value\npub fn as_raw(&self) -> &RawString{\n        &self.raw_value\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Repr::despan":["pub(crate) fn despan(&mut self, input: &str){\n        self.raw_value.despan(input)\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Repr::encode":["pub(crate) fn encode(&self, buf: &mut dyn std::fmt::Write, input: &str) -> std::fmt::Result{\n        self.as_raw().encode(buf, input)\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Repr::new_unchecked":["pub(crate) fn new_unchecked(raw: impl Into<RawString>) -> Self{\n        Repr {\n            raw_value: raw.into(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::Repr::span":["/// Returns the location within the original document\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        self.raw_value.span()\n    }","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"repr::ValueRepr":["pub trait ValueRepr: crate::private::Sealed {\n    /// The TOML representation of the value\n    fn to_repr(&self) -> Repr;\n}","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))"],"table::Entry":["/// A view into a single location in a map, which may be vacant or occupied.\npub enum Entry<'a> {\n    /// An occupied Entry.\n    Occupied(OccupiedEntry<'a>),\n    /// A vacant Entry.\n    Vacant(VacantEntry<'a>),\n}","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Entry::<'a>::key":["/// Returns the entry key\n///\n/// # Examples\n///\n/// ```\n/// use toml_edit::Table;\n///\n/// let mut map = Table::new();\n///\n/// assert_eq!(\"hello\", map.entry(\"hello\").key());\n/// ```\npub fn key(&self) -> &str{\n        match self {\n            Entry::Occupied(e) => e.key(),\n            Entry::Vacant(e) => e.key(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Entry::<'a>::or_insert":["/// Ensures a value is in the entry by inserting the default if empty, and returns\n/// a mutable reference to the value in the entry.\npub fn or_insert(self, default: Item) -> &'a mut Item{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Entry::<'a>::or_insert_with":["/// Ensures a value is in the entry by inserting the result of the default function if empty,\n/// and returns a mutable reference to the value in the entry.\npub fn or_insert_with<F: FnOnce() -> Item>(self, default: F) -> &'a mut Item{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::OccupiedEntry":["/// A view into a single occupied location in a `IndexMap`.\npub struct OccupiedEntry<'a> {\n    pub(crate) entry: indexmap::map::OccupiedEntry<'a, InternalString, TableKeyValue>,\n}","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::OccupiedEntry::<'a>::get":["/// Gets a reference to the value in the entry.\npub fn get(&self) -> &Item{\n        &self.entry.get().value\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::OccupiedEntry::<'a>::get_mut":["/// Gets a mutable reference to the value in the entry.\npub fn get_mut(&mut self) -> &mut Item{\n        &mut self.entry.get_mut().value\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::OccupiedEntry::<'a>::insert":["/// Sets the value of the entry, and returns the entry's old value\npub fn insert(&mut self, mut value: Item) -> Item{\n        std::mem::swap(&mut value, &mut self.entry.get_mut().value);\n        value\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::OccupiedEntry::<'a>::into_mut":["/// Converts the OccupiedEntry into a mutable reference to the value in the entry\n/// with a lifetime bound to the map itself\npub fn into_mut(self) -> &'a mut Item{\n        &mut self.entry.into_mut().value\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::OccupiedEntry::<'a>::key":["/// Gets a reference to the entry key\n///\n/// # Examples\n///\n/// ```\n/// use toml_edit::Table;\n///\n/// let mut map = Table::new();\n///\n/// assert_eq!(\"foo\", map.entry(\"foo\").key());\n/// ```\npub fn key(&self) -> &str{\n        self.entry.key().as_str()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::OccupiedEntry::<'a>::key_mut":["/// Gets a mutable reference to the entry key\npub fn key_mut(&mut self) -> KeyMut<'_>{\n        self.entry.get_mut().key.as_mut()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::OccupiedEntry::<'a>::remove":["/// Takes the value out of the entry, and returns it\npub fn remove(self) -> Item{\n        self.entry.shift_remove().value\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table":["/// Type representing a TOML non-inline table\npub struct Table {\n    // Comments/spaces before and after the header\n    pub(crate) decor: Decor,\n    // Whether to hide an empty table\n    pub(crate) implicit: bool,\n    // Whether this is a proxy for dotted keys\n    pub(crate) dotted: bool,\n    // Used for putting tables back in their original order when serialising.\n    //\n    // `None` for user created tables (can be overridden with `set_position`)\n    doc_position: Option<usize>,\n    pub(crate) span: Option<std::ops::Range<usize>>,\n    pub(crate) items: KeyValuePairs,\n}","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::append_values":["fn append_values<'s, 'c>(\n        &'s self,\n        parent: &[&'s Key],\n        values: &'c mut Vec<(Vec<&'s Key>, &'s Value)>,\n    ){\n        for value in self.items.values() {\n            let mut path = parent.to_vec();\n            path.push(&value.key);\n            match &value.value {\n                Item::Table(table) if table.is_dotted() => {\n                    table.append_values(&path, values);\n                }\n                Item::Value(value) => {\n                    if let Some(table) = value.as_inline_table() {\n                        if table.is_dotted() {\n                            table.append_values(&path, values);\n                        } else {\n                            values.push((path, value));\n                        }\n                    } else {\n                        values.push((path, value));\n                    }\n                }\n                _ => {}\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::clear":["/// Clears the table, removing all key-value pairs. Keeps the allocated memory for reuse.\npub fn clear(&mut self){\n        self.items.clear()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::contains_array_of_tables":["/// Returns true if the table contains an array of tables with the given key.\npub fn contains_array_of_tables(&self, key: &str) -> bool{\n        if let Some(kv) = self.items.get(key) {\n            kv.value.is_array_of_tables()\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::contains_key":["/// Returns true if the table contains an item with the given key.\npub fn contains_key(&self, key: &str) -> bool{\n        if let Some(kv) = self.items.get(key) {\n            !kv.value.is_none()\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::contains_table":["/// Returns true if the table contains a table with the given key.\npub fn contains_table(&self, key: &str) -> bool{\n        if let Some(kv) = self.items.get(key) {\n            kv.value.is_table()\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::contains_value":["/// Returns true if the table contains a value with the given key.\npub fn contains_value(&self, key: &str) -> bool{\n        if let Some(kv) = self.items.get(key) {\n            kv.value.is_value()\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::decor":["/// Returns the decor associated with a given key of the table.\npub fn decor(&self) -> &Decor{\n        &self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::decor_mut":["/// Returns the surrounding whitespace\npub fn decor_mut(&mut self) -> &mut Decor{\n        &mut self.decor\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::despan":["pub(crate) fn despan(&mut self, input: &str){\n        self.span = None;\n        self.decor.despan(input);\n        for kv in self.items.values_mut() {\n            kv.key.despan(input);\n            kv.value.despan(input);\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::entry":["/// Gets the given key's corresponding entry in the Table for in-place manipulation.\npub fn entry<'a>(&'a mut self, key: &str) -> Entry<'a>{\n        // Accept a `&str` rather than an owned type to keep `InternalString`, well, internal\n        match self.items.entry(key.into()) {\n            indexmap::map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { entry }),\n            indexmap::map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry { entry, key: None }),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::entry_format":["/// Gets the given key's corresponding entry in the Table for in-place manipulation.\npub fn entry_format<'a>(&'a mut self, key: &Key) -> Entry<'a>{\n        // Accept a `&Key` to be consistent with `entry`\n        match self.items.entry(key.get().into()) {\n            indexmap::map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { entry }),\n            indexmap::map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry {\n                entry,\n                key: Some(key.to_owned()),\n            }),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::fmt":["/// Auto formats the table.\npub fn fmt(&mut self){\n        decorate_table(self);\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::get":["/// Returns an optional reference to an item given the key.\npub fn get<'a>(&'a self, key: &str) -> Option<&'a Item>{\n        self.items.get(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some(&kv.value)\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::get_key_value":["/// Return references to the key-value pair stored for key, if it is present, else None.\npub fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)>{\n        self.items.get(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some((&kv.key, &kv.value))\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::get_key_value_mut":["/// Return mutable references to the key-value pair stored for key, if it is present, else None.\npub fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)>{\n        self.items.get_mut(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some((kv.key.as_mut(), &mut kv.value))\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::get_mut":["/// Returns an optional mutable reference to an item given the key.\npub fn get_mut<'a>(&'a mut self, key: &str) -> Option<&'a mut Item>{\n        self.items.get_mut(key).and_then(|kv| {\n            if !kv.value.is_none() {\n                Some(&mut kv.value)\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::get_values":["/// Get key/values for values that are visually children of this table\n///\n/// For example, this will return dotted keys\npub fn get_values(&self) -> Vec<(Vec<&Key>, &Value)>{\n        let mut values = Vec::new();\n        let root = Vec::new();\n        self.append_values(&root, &mut values);\n        values\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::insert":["/// Inserts a key-value pair into the map.\npub fn insert(&mut self, key: &str, item: Item) -> Option<Item>{\n        let kv = TableKeyValue::new(Key::new(key), item);\n        self.items.insert(key.into(), kv).map(|kv| kv.value)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::insert_formatted":["/// Inserts a key-value pair into the map.\npub fn insert_formatted(&mut self, key: &Key, item: Item) -> Option<Item>{\n        let kv = TableKeyValue::new(key.to_owned(), item);\n        self.items.insert(key.get().into(), kv).map(|kv| kv.value)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::into_inline_table":["/// Convert to an inline table\npub fn into_inline_table(mut self) -> InlineTable{\n        for (_, kv) in self.items.iter_mut() {\n            kv.value.make_value();\n        }\n        let mut t = InlineTable::with_pairs(self.items);\n        t.fmt();\n        t\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::is_dotted":["/// Check if this is a wrapper for dotted keys, rather than a standard table\npub fn is_dotted(&self) -> bool{\n        self.dotted\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::is_empty":["/// Returns true if the table is empty.\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::is_implicit":["/// If a table has no key/value pairs and implicit, it will not be displayed.\npub fn is_implicit(&self) -> bool{\n        self.implicit\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::iter":["/// Returns an iterator over all key/value pairs, including empty.\npub fn iter(&self) -> Iter<'_>{\n        Box::new(\n            self.items\n                .iter()\n                .filter(|(_, kv)| !kv.value.is_none())\n                .map(|(key, kv)| (&key[..], &kv.value)),\n        )\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::iter_mut":["/// Returns an mutable iterator over all key/value pairs, including empty.\npub fn iter_mut(&mut self) -> IterMut<'_>{\n        Box::new(\n            self.items\n                .iter_mut()\n                .filter(|(_, kv)| !kv.value.is_none())\n                .map(|(_, kv)| (kv.key.as_mut(), &mut kv.value)),\n        )\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::key_decor":["/// Returns the decor associated with a given key of the table.\npub fn key_decor(&self, key: &str) -> Option<&Decor>{\n        self.items.get(key).map(|kv| &kv.key.decor)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::key_decor_mut":["/// Returns the decor associated with a given key of the table.\npub fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor>{\n        self.items.get_mut(key).map(|kv| &mut kv.key.decor)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::len":["/// Returns the number of non-empty items in the table.\npub fn len(&self) -> usize{\n        self.items.iter().filter(|i| !(i.1).value.is_none()).count()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::new":["/// Creates an empty table.\npub fn new() -> Self{\n        Default::default()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::position":["/// The position of the `Table` within the `Document`.\n///\n/// Returns `None` if the `Table` was created manually (i.e. not via parsing)\n/// in which case its position is set automatically.  This can be overridden with\n/// [`Table::set_position`].\npub fn position(&self) -> Option<usize>{\n        self.doc_position\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::remove":["/// Removes an item given the key.\npub fn remove(&mut self, key: &str) -> Option<Item>{\n        self.items.shift_remove(key).map(|kv| kv.value)\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::remove_entry":["/// Removes a key from the map, returning the stored key and value if the key was previously in the map.\npub fn remove_entry(&mut self, key: &str) -> Option<(Key, Item)>{\n        self.items.shift_remove(key).map(|kv| (kv.key, kv.value))\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::set_dotted":["/// Change this table's dotted status\npub fn set_dotted(&mut self, yes: bool){\n        self.dotted = yes;\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::set_implicit":["/// If a table has no key/value pairs and implicit, it will not be displayed.\n///\n/// # Examples\n///\n/// ```notrust\n/// [target.\"x86_64/windows.json\".dependencies]\n/// ```\n///\n/// In the document above, tables `target` and `target.\"x86_64/windows.json\"` are implicit.\n///\n/// ```\n/// use toml_edit::Document;\n/// let mut doc = \"[a]\\n[a.b]\\n\".parse::<Document>().expect(\"invalid toml\");\n///\n/// doc[\"a\"].as_table_mut().unwrap().set_implicit(true);\n/// assert_eq!(doc.to_string(), \"[a.b]\\n\");\n/// ```\npub fn set_implicit(&mut self, implicit: bool){\n        self.implicit = implicit;\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::set_position":["/// Sets the position of the `Table` within the `Document`.\npub fn set_position(&mut self, doc_position: usize){\n        self.doc_position = Some(doc_position);\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::sort_values":["/// Sorts Key/Value Pairs of the table.\n///\n/// Doesn't affect subtables or subarrays.\npub fn sort_values(&mut self){\n        // Assuming standard tables have their doc_position set and this won't negatively impact them\n        self.items.sort_keys();\n        for kv in self.items.values_mut() {\n            match &mut kv.value {\n                Item::Table(table) if table.is_dotted() => {\n                    table.sort_values();\n                }\n                _ => {}\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::sort_values_by":["/// Sort Key/Value Pairs of the table using the using the comparison function `compare`.\n///\n/// The comparison function receives two key and value pairs to compare (you can sort by keys or\n/// values or their combination as needed).\npub fn sort_values_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&Key, &Item, &Key, &Item) -> std::cmp::Ordering,{\n        self.sort_values_by_internal(&mut compare);\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::sort_values_by_internal":["fn sort_values_by_internal<F>(&mut self, compare: &mut F)\n    where\n        F: FnMut(&Key, &Item, &Key, &Item) -> std::cmp::Ordering,{\n        let modified_cmp = |_: &InternalString,\n                            val1: &TableKeyValue,\n                            _: &InternalString,\n                            val2: &TableKeyValue|\n         -> std::cmp::Ordering {\n            compare(&val1.key, &val1.value, &val2.key, &val2.value)\n        };\n\n        self.items.sort_by(modified_cmp);\n\n        for kv in self.items.values_mut() {\n            match &mut kv.value {\n                Item::Table(table) if table.is_dotted() => {\n                    table.sort_values_by_internal(compare);\n                }\n                _ => {}\n            }\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::span":["/// Returns the location within the original document\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        self.span.clone()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::with_pairs":["pub(crate) fn with_pairs(items: KeyValuePairs) -> Self{\n        Self {\n            items,\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::Table::with_pos":["pub(crate) fn with_pos(doc_position: Option<usize>) -> Self{\n        Self {\n            doc_position,\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::TableKeyValue":["pub(crate) struct TableKeyValue {\n    pub(crate) key: Key,\n    pub(crate) value: Item,\n}","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::TableKeyValue::new":["pub(crate) fn new(key: Key, value: Item) -> Self{\n        TableKeyValue { key, value }\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::TableLike":["/// This trait represents either a `Table`, or an `InlineTable`.\npub trait TableLike: crate::private::Sealed {\n    /// Returns an iterator over key/value pairs.\n    fn iter(&self) -> Iter<'_>;\n    /// Returns an mutable iterator over all key/value pairs, including empty.\n    fn iter_mut(&mut self) -> IterMut<'_>;\n    /// Returns the number of nonempty items.\n    fn len(&self) -> usize {\n        self.iter().filter(|&(_, v)| !v.is_none()).count()\n    }\n    /// Returns true if the table is empty.\n    fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n    /// Clears the table, removing all key-value pairs. Keeps the allocated memory for reuse.\n    fn clear(&mut self);\n    /// Gets the given key's corresponding entry in the Table for in-place manipulation.\n    fn entry<'a>(&'a mut self, key: &str) -> Entry<'a>;\n    /// Gets the given key's corresponding entry in the Table for in-place manipulation.\n    fn entry_format<'a>(&'a mut self, key: &Key) -> Entry<'a>;\n    /// Returns an optional reference to an item given the key.\n    fn get<'s>(&'s self, key: &str) -> Option<&'s Item>;\n    /// Returns an optional mutable reference to an item given the key.\n    fn get_mut<'s>(&'s mut self, key: &str) -> Option<&'s mut Item>;\n    /// Return references to the key-value pair stored for key, if it is present, else None.\n    fn get_key_value<'a>(&'a self, key: &str) -> Option<(&'a Key, &'a Item)>;\n    /// Return mutable references to the key-value pair stored for key, if it is present, else None.\n    fn get_key_value_mut<'a>(&'a mut self, key: &str) -> Option<(KeyMut<'a>, &'a mut Item)>;\n    /// Returns true if the table contains an item with the given key.\n    fn contains_key(&self, key: &str) -> bool;\n    /// Inserts a key-value pair into the map.\n    fn insert(&mut self, key: &str, value: Item) -> Option<Item>;\n    /// Removes an item given the key.\n    fn remove(&mut self, key: &str) -> Option<Item>;\n\n    /// Get key/values for values that are visually children of this table\n    ///\n    /// For example, this will return dotted keys\n    fn get_values(&self) -> Vec<(Vec<&Key>, &Value)>;\n\n    /// Auto formats the table.\n    fn fmt(&mut self);\n    /// Sorts Key/Value Pairs of the table.\n    ///\n    /// Doesn't affect subtables or subarrays.\n    fn sort_values(&mut self);\n    /// Change this table's dotted status\n    fn set_dotted(&mut self, yes: bool);\n    /// Check if this is a wrapper for dotted keys, rather than a standard table\n    fn is_dotted(&self) -> bool;\n\n    /// Returns the decor associated with a given key of the table.\n    fn key_decor_mut(&mut self, key: &str) -> Option<&mut Decor>;\n    /// Returns the decor associated with a given key of the table.\n    fn key_decor(&self, key: &str) -> Option<&Decor>;\n}","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::TableLike::is_empty":["/// Returns true if the table is empty.\nfn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::TableLike::len":["/// Returns the number of nonempty items.\nfn len(&self) -> usize{\n        self.iter().filter(|&(_, v)| !v.is_none()).count()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::VacantEntry":["/// A view into a single empty location in a `IndexMap`.\npub struct VacantEntry<'a> {\n    pub(crate) entry: indexmap::map::VacantEntry<'a, InternalString, TableKeyValue>,\n    pub(crate) key: Option<Key>,\n}","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::VacantEntry::<'a>::insert":["/// Sets the value of the entry with the VacantEntry's key,\n/// and returns a mutable reference to it\npub fn insert(self, value: Item) -> &'a mut Item{\n        let entry = self.entry;\n        let key = self.key.unwrap_or_else(|| Key::new(entry.key().as_str()));\n        &mut entry.insert(TableKeyValue::new(key, value)).value\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::VacantEntry::<'a>::key":["/// Gets a reference to the entry key\n///\n/// # Examples\n///\n/// ```\n/// use toml_edit::Table;\n///\n/// let mut map = Table::new();\n///\n/// assert_eq!(\"foo\", map.entry(\"foo\").key());\n/// ```\npub fn key(&self) -> &str{\n        self.entry.key().as_str()\n    }","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"table::decorate_table":["fn decorate_table(table: &mut Table){\n    for (key_decor, value) in table\n        .items\n        .iter_mut()\n        .filter(|&(_, ref kv)| kv.value.is_value())\n        .map(|(_, kv)| (&mut kv.key.decor, kv.value.as_value_mut().unwrap()))\n    {\n        key_decor.clear();\n        value.decor_mut().clear();\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))"],"value::Value":["/// Representation of a TOML Value (as part of a Key/Value Pair).\npub enum Value {\n    /// A string value.\n    String(Formatted<String>),\n    /// A 64-bit integer value.\n    Integer(Formatted<i64>),\n    /// A 64-bit float value.\n    Float(Formatted<f64>),\n    /// A boolean value.\n    Boolean(Formatted<bool>),\n    /// An RFC 3339 formatted date-time with offset.\n    Datetime(Formatted<Datetime>),\n    /// An inline array of values.\n    Array(Array),\n    /// An inline table of key/value pairs.\n    InlineTable(InlineTable),\n}","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_array":["/// Casts `self` to array.\npub fn as_array(&self) -> Option<&Array>{\n        match *self {\n            Value::Array(ref value) => Some(value),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_array_mut":["/// Casts `self` to mutable array.\npub fn as_array_mut(&mut self) -> Option<&mut Array>{\n        match *self {\n            Value::Array(ref mut value) => Some(value),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_bool":["/// Casts `self` to boolean.\npub fn as_bool(&self) -> Option<bool>{\n        match *self {\n            Value::Boolean(ref value) => Some(*value.value()),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_datetime":["/// Casts `self` to date-time.\npub fn as_datetime(&self) -> Option<&Datetime>{\n        match *self {\n            Value::Datetime(ref value) => Some(value.value()),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_float":["/// Casts `self` to float.\npub fn as_float(&self) -> Option<f64>{\n        match *self {\n            Value::Float(ref value) => Some(*value.value()),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_inline_table":["/// Casts `self` to inline table.\npub fn as_inline_table(&self) -> Option<&InlineTable>{\n        match *self {\n            Value::InlineTable(ref value) => Some(value),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_inline_table_mut":["/// Casts `self` to mutable inline table.\npub fn as_inline_table_mut(&mut self) -> Option<&mut InlineTable>{\n        match *self {\n            Value::InlineTable(ref mut value) => Some(value),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_integer":["/// Casts `self` to integer.\npub fn as_integer(&self) -> Option<i64>{\n        match *self {\n            Value::Integer(ref value) => Some(*value.value()),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::as_str":["/// Casts `self` to str.\npub fn as_str(&self) -> Option<&str>{\n        match *self {\n            Value::String(ref value) => Some(value.value()),\n            _ => None,\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::decor":["/// Get the decoration of the value.\n/// # Example\n/// ```rust\n/// let v = toml_edit::Value::from(true);\n/// assert_eq!(v.decor().suffix(), None);\n///```\npub fn decor(&self) -> &Decor{\n        match *self {\n            Value::String(ref f) => f.decor(),\n            Value::Integer(ref f) => f.decor(),\n            Value::Float(ref f) => f.decor(),\n            Value::Boolean(ref f) => f.decor(),\n            Value::Datetime(ref f) => f.decor(),\n            Value::Array(ref a) => a.decor(),\n            Value::InlineTable(ref t) => t.decor(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::decor_mut":["/// Get the decoration of the value.\n/// # Example\n/// ```rust\n/// let v = toml_edit::Value::from(true);\n/// assert_eq!(v.decor().suffix(), None);\n///```\npub fn decor_mut(&mut self) -> &mut Decor{\n        match self {\n            Value::String(f) => f.decor_mut(),\n            Value::Integer(f) => f.decor_mut(),\n            Value::Float(f) => f.decor_mut(),\n            Value::Boolean(f) => f.decor_mut(),\n            Value::Datetime(f) => f.decor_mut(),\n            Value::Array(a) => a.decor_mut(),\n            Value::InlineTable(t) => t.decor_mut(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::decorate":["pub(crate) fn decorate(&mut self, prefix: impl Into<RawString>, suffix: impl Into<RawString>){\n        let decor = self.decor_mut();\n        *decor = Decor::new(prefix, suffix);\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::decorated":["/// Sets the prefix and the suffix for value.\n/// # Example\n/// ```rust\n/// let mut v = toml_edit::Value::from(42);\n/// assert_eq!(&v.to_string(), \"42\");\n/// let d = v.decorated(\" \", \" \");\n/// assert_eq!(&d.to_string(), \" 42 \");\n/// ```\npub fn decorated(mut self, prefix: impl Into<RawString>, suffix: impl Into<RawString>) -> Self{\n        self.decorate(prefix, suffix);\n        self\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::despan":["pub(crate) fn despan(&mut self, input: &str){\n        match self {\n            Value::String(f) => f.despan(input),\n            Value::Integer(f) => f.despan(input),\n            Value::Float(f) => f.despan(input),\n            Value::Boolean(f) => f.despan(input),\n            Value::Datetime(f) => f.despan(input),\n            Value::Array(a) => a.despan(input),\n            Value::InlineTable(t) => t.despan(input),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::is_array":["/// Returns true iff `self` is an array.\npub fn is_array(&self) -> bool{\n        self.as_array().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::is_bool":["/// Returns true iff `self` is a boolean.\npub fn is_bool(&self) -> bool{\n        self.as_bool().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::is_datetime":["/// Returns true iff `self` is a date-time.\npub fn is_datetime(&self) -> bool{\n        self.as_datetime().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::is_float":["/// Returns true iff `self` is a float.\npub fn is_float(&self) -> bool{\n        self.as_float().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::is_inline_table":["/// Returns true iff `self` is an inline table.\npub fn is_inline_table(&self) -> bool{\n        self.as_inline_table().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::is_integer":["/// Returns true iff `self` is an integer.\npub fn is_integer(&self) -> bool{\n        self.as_integer().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::is_str":["/// Returns true iff `self` is a string.\npub fn is_str(&self) -> bool{\n        self.as_str().is_some()\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::span":["/// Returns the location within the original document\npub(crate) fn span(&self) -> Option<std::ops::Range<usize>>{\n        match self {\n            Value::String(f) => f.span(),\n            Value::Integer(f) => f.span(),\n            Value::Float(f) => f.span(),\n            Value::Boolean(f) => f.span(),\n            Value::Datetime(f) => f.span(),\n            Value::Array(a) => a.span(),\n            Value::InlineTable(t) => t.span(),\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"value::Value::type_name":["/// Text description of value type\npub fn type_name(&self) -> &'static str{\n        match self {\n            Value::String(..) => \"string\",\n            Value::Integer(..) => \"integer\",\n            Value::Float(..) => \"float\",\n            Value::Boolean(..) => \"boolean\",\n            Value::Datetime(..) => \"datetime\",\n            Value::Array(..) => \"array\",\n            Value::InlineTable(..) => \"inline table\",\n        }\n    }","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))"],"visit::Visit":["/// Document tree traversal to mutate an exclusive borrow of a document tree in-place.\n///\n/// See the [module documentation](self) for details.\npub trait Visit<'doc> {\n    fn visit_document(&mut self, node: &'doc Document) {\n        visit_document(self, node);\n    }\n\n    fn visit_item(&mut self, node: &'doc Item) {\n        visit_item(self, node);\n    }\n\n    fn visit_table(&mut self, node: &'doc Table) {\n        visit_table(self, node);\n    }\n\n    fn visit_inline_table(&mut self, node: &'doc InlineTable) {\n        visit_inline_table(self, node)\n    }\n\n    fn visit_table_like(&mut self, node: &'doc dyn TableLike) {\n        visit_table_like(self, node);\n    }\n\n    fn visit_table_like_kv(&mut self, key: &'doc str, node: &'doc Item) {\n        visit_table_like_kv(self, key, node);\n    }\n\n    fn visit_array(&mut self, node: &'doc Array) {\n        visit_array(self, node);\n    }\n\n    fn visit_array_of_tables(&mut self, node: &'doc ArrayOfTables) {\n        visit_array_of_tables(self, node);\n    }\n\n    fn visit_value(&mut self, node: &'doc Value) {\n        visit_value(self, node);\n    }\n\n    fn visit_boolean(&mut self, node: &'doc Formatted<bool>) {\n        visit_boolean(self, node)\n    }\n\n    fn visit_datetime(&mut self, node: &'doc Formatted<Datetime>) {\n        visit_datetime(self, node);\n    }\n\n    fn visit_float(&mut self, node: &'doc Formatted<f64>) {\n        visit_float(self, node)\n    }\n\n    fn visit_integer(&mut self, node: &'doc Formatted<i64>) {\n        visit_integer(self, node)\n    }\n\n    fn visit_string(&mut self, node: &'doc Formatted<String>) {\n        visit_string(self, node)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_array":["fn visit_array(&mut self, node: &'doc Array){\n        visit_array(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_array_of_tables":["fn visit_array_of_tables(&mut self, node: &'doc ArrayOfTables){\n        visit_array_of_tables(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_boolean":["fn visit_boolean(&mut self, node: &'doc Formatted<bool>){\n        visit_boolean(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_datetime":["fn visit_datetime(&mut self, node: &'doc Formatted<Datetime>){\n        visit_datetime(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_document":["fn visit_document(&mut self, node: &'doc Document){\n        visit_document(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_float":["fn visit_float(&mut self, node: &'doc Formatted<f64>){\n        visit_float(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_inline_table":["fn visit_inline_table(&mut self, node: &'doc InlineTable){\n        visit_inline_table(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_integer":["fn visit_integer(&mut self, node: &'doc Formatted<i64>){\n        visit_integer(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_item":["fn visit_item(&mut self, node: &'doc Item){\n        visit_item(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_string":["fn visit_string(&mut self, node: &'doc Formatted<String>){\n        visit_string(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_table":["fn visit_table(&mut self, node: &'doc Table){\n        visit_table(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_table_like":["fn visit_table_like(&mut self, node: &'doc dyn TableLike){\n        visit_table_like(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_table_like_kv":["fn visit_table_like_kv(&mut self, key: &'doc str, node: &'doc Item){\n        visit_table_like_kv(self, key, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::Visit::visit_value":["fn visit_value(&mut self, node: &'doc Value){\n        visit_value(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_array":["pub fn visit_array<'doc, V>(v: &mut V, node: &'doc Array)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    for value in node.iter() {\n        v.visit_value(value);\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_array_of_tables":["pub fn visit_array_of_tables<'doc, V>(v: &mut V, node: &'doc ArrayOfTables)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    for table in node.iter() {\n        v.visit_table(table);\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_boolean":["fn $name<'doc, V>(_v: &mut V, _node: &'doc $t)\n        where\n            V: Visit<'doc> + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_datetime":["fn $name<'doc, V>(_v: &mut V, _node: &'doc $t)\n        where\n            V: Visit<'doc> + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_document":["pub fn visit_document<'doc, V>(v: &mut V, node: &'doc Document)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    v.visit_table(node.as_table());\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_float":["fn $name<'doc, V>(_v: &mut V, _node: &'doc $t)\n        where\n            V: Visit<'doc> + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_inline_table":["pub fn visit_inline_table<'doc, V>(v: &mut V, node: &'doc InlineTable)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    v.visit_table_like(node)\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_integer":["fn $name<'doc, V>(_v: &mut V, _node: &'doc $t)\n        where\n            V: Visit<'doc> + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_item":["pub fn visit_item<'doc, V>(v: &mut V, node: &'doc Item)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    match node {\n        Item::None => {}\n        Item::Value(value) => v.visit_value(value),\n        Item::Table(table) => v.visit_table(table),\n        Item::ArrayOfTables(array) => v.visit_array_of_tables(array),\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_string":["fn $name<'doc, V>(_v: &mut V, _node: &'doc $t)\n        where\n            V: Visit<'doc> + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_table":["pub fn visit_table<'doc, V>(v: &mut V, node: &'doc Table)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    v.visit_table_like(node)\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_table_like":["pub fn visit_table_like<'doc, V>(v: &mut V, node: &'doc dyn TableLike)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    for (key, item) in node.iter() {\n        v.visit_table_like_kv(key, item)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_table_like_kv":["pub fn visit_table_like_kv<'doc, V>(v: &mut V, _key: &'doc str, node: &'doc Item)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    v.visit_item(node)\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit::visit_value":["pub fn visit_value<'doc, V>(v: &mut V, node: &'doc Value)\nwhere\n    V: Visit<'doc> + ?Sized,{\n    match node {\n        Value::String(s) => v.visit_string(s),\n        Value::Integer(i) => v.visit_integer(i),\n        Value::Float(f) => v.visit_float(f),\n        Value::Boolean(b) => v.visit_boolean(b),\n        Value::Datetime(dt) => v.visit_datetime(dt),\n        Value::Array(array) => v.visit_array(array),\n        Value::InlineTable(table) => v.visit_inline_table(table),\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))"],"visit_mut::VisitMut":["/// Document tree traversal to mutate an exclusive borrow of a document tree in-place.\n///\n/// See the [module documentation](self) for details.\npub trait VisitMut {\n    fn visit_document_mut(&mut self, node: &mut Document) {\n        visit_document_mut(self, node);\n    }\n\n    fn visit_item_mut(&mut self, node: &mut Item) {\n        visit_item_mut(self, node);\n    }\n\n    fn visit_table_mut(&mut self, node: &mut Table) {\n        visit_table_mut(self, node);\n    }\n\n    fn visit_inline_table_mut(&mut self, node: &mut InlineTable) {\n        visit_inline_table_mut(self, node)\n    }\n\n    /// [`visit_table_mut`](Self::visit_table_mut) and\n    /// [`visit_inline_table_mut`](Self::visit_inline_table_mut) both recurse into this method.\n    fn visit_table_like_mut(&mut self, node: &mut dyn TableLike) {\n        visit_table_like_mut(self, node);\n    }\n\n    fn visit_table_like_kv_mut(&mut self, key: KeyMut<'_>, node: &mut Item) {\n        visit_table_like_kv_mut(self, key, node);\n    }\n\n    fn visit_array_mut(&mut self, node: &mut Array) {\n        visit_array_mut(self, node);\n    }\n\n    fn visit_array_of_tables_mut(&mut self, node: &mut ArrayOfTables) {\n        visit_array_of_tables_mut(self, node);\n    }\n\n    fn visit_value_mut(&mut self, node: &mut Value) {\n        visit_value_mut(self, node);\n    }\n\n    fn visit_boolean_mut(&mut self, node: &mut Formatted<bool>) {\n        visit_boolean_mut(self, node)\n    }\n\n    fn visit_datetime_mut(&mut self, node: &mut Formatted<Datetime>) {\n        visit_datetime_mut(self, node);\n    }\n\n    fn visit_float_mut(&mut self, node: &mut Formatted<f64>) {\n        visit_float_mut(self, node)\n    }\n\n    fn visit_integer_mut(&mut self, node: &mut Formatted<i64>) {\n        visit_integer_mut(self, node)\n    }\n\n    fn visit_string_mut(&mut self, node: &mut Formatted<String>) {\n        visit_string_mut(self, node)\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_array_mut":["fn visit_array_mut(&mut self, node: &mut Array){\n        visit_array_mut(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_array_of_tables_mut":["fn visit_array_of_tables_mut(&mut self, node: &mut ArrayOfTables){\n        visit_array_of_tables_mut(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_boolean_mut":["fn visit_boolean_mut(&mut self, node: &mut Formatted<bool>){\n        visit_boolean_mut(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_datetime_mut":["fn visit_datetime_mut(&mut self, node: &mut Formatted<Datetime>){\n        visit_datetime_mut(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_document_mut":["fn visit_document_mut(&mut self, node: &mut Document){\n        visit_document_mut(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_float_mut":["fn visit_float_mut(&mut self, node: &mut Formatted<f64>){\n        visit_float_mut(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_inline_table_mut":["fn visit_inline_table_mut(&mut self, node: &mut InlineTable){\n        visit_inline_table_mut(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_integer_mut":["fn visit_integer_mut(&mut self, node: &mut Formatted<i64>){\n        visit_integer_mut(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_item_mut":["fn visit_item_mut(&mut self, node: &mut Item){\n        visit_item_mut(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_string_mut":["fn visit_string_mut(&mut self, node: &mut Formatted<String>){\n        visit_string_mut(self, node)\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_table_like_kv_mut":["fn visit_table_like_kv_mut(&mut self, key: KeyMut<'_>, node: &mut Item){\n        visit_table_like_kv_mut(self, key, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_table_like_mut":["/// [`visit_table_mut`](Self::visit_table_mut) and\n/// [`visit_inline_table_mut`](Self::visit_inline_table_mut) both recurse into this method.\nfn visit_table_like_mut(&mut self, node: &mut dyn TableLike){\n        visit_table_like_mut(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_table_mut":["fn visit_table_mut(&mut self, node: &mut Table){\n        visit_table_mut(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::VisitMut::visit_value_mut":["fn visit_value_mut(&mut self, node: &mut Value){\n        visit_value_mut(self, node);\n    }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_array_mut":["pub fn visit_array_mut<V>(v: &mut V, node: &mut Array)\nwhere\n    V: VisitMut + ?Sized,{\n    for value in node.iter_mut() {\n        v.visit_value_mut(value);\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_array_of_tables_mut":["pub fn visit_array_of_tables_mut<V>(v: &mut V, node: &mut ArrayOfTables)\nwhere\n    V: VisitMut + ?Sized,{\n    for table in node.iter_mut() {\n        v.visit_table_mut(table);\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_boolean_mut":["fn $name<V>(_v: &mut V, _node: &mut $t)\n        where\n            V: VisitMut + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_datetime_mut":["fn $name<V>(_v: &mut V, _node: &mut $t)\n        where\n            V: VisitMut + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_document_mut":["pub fn visit_document_mut<V>(v: &mut V, node: &mut Document)\nwhere\n    V: VisitMut + ?Sized,{\n    v.visit_table_mut(node.as_table_mut());\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_float_mut":["fn $name<V>(_v: &mut V, _node: &mut $t)\n        where\n            V: VisitMut + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_inline_table_mut":["pub fn visit_inline_table_mut<V>(v: &mut V, node: &mut InlineTable)\nwhere\n    V: VisitMut + ?Sized,{\n    v.visit_table_like_mut(node);\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_integer_mut":["fn $name<V>(_v: &mut V, _node: &mut $t)\n        where\n            V: VisitMut + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_item_mut":["pub fn visit_item_mut<V>(v: &mut V, node: &mut Item)\nwhere\n    V: VisitMut + ?Sized,{\n    match node {\n        Item::None => {}\n        Item::Value(value) => v.visit_value_mut(value),\n        Item::Table(table) => v.visit_table_mut(table),\n        Item::ArrayOfTables(array) => v.visit_array_of_tables_mut(array),\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_string_mut":["fn $name<V>(_v: &mut V, _node: &mut $t)\n        where\n            V: VisitMut + ?Sized,{\n        }","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_table_like_kv_mut":["pub fn visit_table_like_kv_mut<V>(v: &mut V, _key: KeyMut<'_>, node: &mut Item)\nwhere\n    V: VisitMut + ?Sized,{\n    v.visit_item_mut(node)\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_table_like_mut":["pub fn visit_table_like_mut<V>(v: &mut V, node: &mut dyn TableLike)\nwhere\n    V: VisitMut + ?Sized,{\n    for (key, item) in node.iter_mut() {\n        v.visit_table_like_kv_mut(key, item);\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_table_mut":["pub fn visit_table_mut<V>(v: &mut V, node: &mut Table)\nwhere\n    V: VisitMut + ?Sized,{\n    v.visit_table_like_mut(node);\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"],"visit_mut::visit_value_mut":["pub fn visit_value_mut<V>(v: &mut V, node: &mut Value)\nwhere\n    V: VisitMut + ?Sized,{\n    match node {\n        Value::String(s) => v.visit_string_mut(s),\n        Value::Integer(i) => v.visit_integer_mut(i),\n        Value::Float(f) => v.visit_float_mut(f),\n        Value::Boolean(b) => v.visit_boolean_mut(b),\n        Value::Datetime(dt) => v.visit_datetime_mut(dt),\n        Value::Array(array) => v.visit_array_mut(array),\n        Value::InlineTable(table) => v.visit_inline_table_mut(table),\n    }\n}","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))"]},"struct_constructor":{"&'a item::Item":["get"],"&'a mut item::Item":["get_mut","insert","into_mut","or_insert","or_insert_with"],"&'a mut value::Value":["insert","into_mut","or_insert","or_insert_with"],"&'b str":["from_utf8_unchecked"],"&'s item::Item":["get"],"&'s mut item::Item":["get_mut"],"&'static str":["description","literal_end","literal_start","standard_end","standard_start","type_name"],"&<document::Document as std::ops::Deref>::Target":["deref"],"&<key::Key as std::ops::Deref>::Target":["deref"],"&<key::KeyMut<'k> as std::ops::Deref>::Target":["deref"],"&array::Array":["as_array"],"&array_of_tables::ArrayOfTables":["as_array_of_tables"],"&dyn table::TableLike":["as_table_like"],"&inline_table::InlineTable":["as_inline_table"],"&internal_string::InternalString":["get_internal"],"&item::Item":["as_item","get","index"],"&mut <document::Document as std::ops::Deref>::Target":["deref_mut"],"&mut array::Array":["as_array_mut"],"&mut array_of_tables::ArrayOfTables":["as_array_of_tables_mut"],"&mut dyn table::TableLike":["as_table_like_mut"],"&mut inline_table::InlineTable":["as_inline_table_mut"],"&mut item::Item":["as_item_mut","get_mut","index_mut"],"&mut repr::Decor":["decor_mut","key_decor_mut"],"&mut table::Table":["as_table_mut","get_mut"],"&mut value::Value":["as_value_mut","get_mut","get_or_insert","index_mut"],"&raw_string::RawString":["as_raw","preamble","prefix","suffix","trailing"],"&repr::Decor":["decor","key_decor"],"&repr::Repr":["as_repr"],"&str":["as_ref","as_str","borrow","deref","get","key","message"],"&table::Table":["as_table","get"],"&toml_datetime::Datetime":["as_datetime"],"&value::Value":["as_value","get","index"],"(&'a key::Key, &'a item::Item)":["get_key_value"],"(encode::StringStyle, bool)":["infer_style"],"(key::Key, item::Item)":["remove_entry"],"(key::Key, value::Value)":["remove_entry"],"(key::KeyMut<'a>, &'a mut item::Item)":["get_key_value_mut"],"(usize, usize)":["translate_position"],"(winnow::Located<&winnow::BStr>, &[u8])":["comment","ws_comment_newline"],"(winnow::Located<&winnow::BStr>, &str)":["bin_int","dec_int","exp","float_","frac","hex_int","line_ending","literal_string","ml_literal_body","oct_int","unquoted_key","unsigned_digits","ws","ws_newline","ws_newlines","zero_prefixable_int"],"(winnow::Located<&winnow::BStr>, ())":["mlb_escaped_nl"],"(winnow::Located<&winnow::BStr>, (raw_string::RawString, internal_string::InternalString))":["simple_key"],"(winnow::Located<&winnow::BStr>, (std::vec::Vec<key::Key>, table::TableKeyValue))":["parse_keyval"],"(winnow::Located<&winnow::BStr>, bool)":["boolean","false_","true_"],"(winnow::Located<&winnow::BStr>, char)":["escape_seq_char","escaped","hexescape"],"(winnow::Located<&winnow::BStr>, document::Document)":["document"],"(winnow::Located<&winnow::BStr>, f64)":["float","inf","nan","special_float"],"(winnow::Located<&winnow::BStr>, i64)":["integer"],"(winnow::Located<&winnow::BStr>, std::borrow::Cow<'_, str>)":["basic_chars","basic_string","ml_basic_body","ml_basic_string","ml_literal_string","mlb_content","string"],"(winnow::Located<&winnow::BStr>, std::ops::Range<usize>)":["line_trailing"],"(winnow::Located<&winnow::BStr>, std::vec::Vec<key::Key>)":["key"],"(winnow::Located<&winnow::BStr>, toml_datetime::Date)":["full_date"],"(winnow::Located<&winnow::BStr>, toml_datetime::Datetime)":["date_time"],"(winnow::Located<&winnow::BStr>, toml_datetime::Offset)":["time_offset"],"(winnow::Located<&winnow::BStr>, toml_datetime::Time)":["partial_time"],"(winnow::Located<&winnow::BStr>, u16)":["date_fullyear"],"(winnow::Located<&winnow::BStr>, u32)":["time_secfrac"],"(winnow::Located<&winnow::BStr>, u8)":["date_mday","date_month","digit","hexdig","mll_content","newline","time_delim","time_hour","time_minute","time_second"],"<&'s array::Array as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'s inline_table::InlineTable as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'s table::Table as std::iter::IntoIterator>::IntoIter":["into_iter"],"<array::Array as std::iter::IntoIterator>::IntoIter":["into_iter"],"<array_of_tables::ArrayOfTables as std::iter::IntoIterator>::IntoIter":["into_iter"],"<inline_table::InlineTable as std::iter::IntoIterator>::IntoIter":["into_iter"],"<table::Table as std::iter::IntoIterator>::IntoIter":["into_iter"],"array::Array":["clone","default","from_iter","into_array","new","with_vec"],"array_of_tables::ArrayOfTables":["clone","default","from_iter","into_array_of_tables","new"],"bool":["as_bool","contains_array_of_tables","contains_key","contains_table","contains_value","eq","is_array","is_array_of_tables","is_bool","is_datetime","is_dotted","is_empty","is_float","is_implicit","is_inline_table","is_integer","is_none","is_str","is_table","is_table_like","is_unquoted_char","is_value","trailing_comma"],"document::Document":["clone","default","from","from_str","into_document","new","parse_document"],"encode::StringStyle":["clone"],"f64":["as_float"],"i64":["as_integer"],"impl FnMut(I) -> std::result::Result<(I, O), winnow::error::ErrMode<E>>":["trace"],"impl FnMut(winnow::Located<&'i winnow::BStr>) -> std::result::Result<(winnow::Located<&'i winnow::BStr>, &'i str), winnow::error::ErrMode<parser::errors::ParserError<'i>>>":["mlb_quotes","mll_quotes"],"impl FnMut(winnow::Located<&'i winnow::BStr>) -> std::result::Result<(winnow::Located<&'i winnow::BStr>, ()), winnow::error::ErrMode<parser::errors::ParserError<'i>>> + 's":["array_table","keyval","parse_comment","parse_newline","parse_ws","std_table","table"],"impl for<'a> FnMut(winnow::Located<&'a winnow::BStr>) -> for<'a> std::result::Result<(winnow::Located<&'a winnow::BStr>, (std::vec::Vec<(std::vec::Vec<key::Key>, table::TableKeyValue)>, raw_string::RawString)), winnow::error::ErrMode<parser::errors::ParserError<'a>>>":["inline_table_keyvals"],"impl for<'a> FnMut(winnow::Located<&'a winnow::BStr>) -> for<'a> std::result::Result<(winnow::Located<&'a winnow::BStr>, (std::vec::Vec<key::Key>, table::TableKeyValue)), winnow::error::ErrMode<parser::errors::ParserError<'a>>>":["keyval"],"impl for<'a> FnMut(winnow::Located<&'a winnow::BStr>) -> for<'a> std::result::Result<(winnow::Located<&'a winnow::BStr>, array::Array), winnow::error::ErrMode<parser::errors::ParserError<'a>>>":["array","array_values"],"impl for<'a> FnMut(winnow::Located<&'a winnow::BStr>) -> for<'a> std::result::Result<(winnow::Located<&'a winnow::BStr>, inline_table::InlineTable), winnow::error::ErrMode<parser::errors::ParserError<'a>>>":["inline_table"],"impl for<'a> FnMut(winnow::Located<&'a winnow::BStr>) -> for<'a> std::result::Result<(winnow::Located<&'a winnow::BStr>, value::Value), winnow::error::ErrMode<parser::errors::ParserError<'a>>>":["array_value","value"],"inline_table::InlineEntry":["entry","entry_format"],"inline_table::InlineTable":["clone","default","from_iter","into_inline_table","new","table_from_pairs","with_pairs"],"internal_string::InternalString":["clone","default","from","from_str","new"],"item::Item":["array","clone","default","from_str","remove","table","value"],"key::Key":["clone","from","from_str","new","parse_key","try_parse_simple"],"key::KeyMut":["as_mut","key_mut"],"parser::errors::Context":["clone"],"parser::errors::CustomError":["clone","duplicate_key","extend_wrong_type"],"parser::errors::ParserError":["from_error_kind","from_external_error"],"parser::errors::ParserValue":["clone"],"parser::errors::TomlError":["clone","new"],"parser::prelude::RecursionCheck":["clone","default"],"parser::state::ParseState":["default"],"raw_string::RawString":["clone","default","from","with_span"],"raw_string::RawStringInner":["clone"],"repr::Decor":["clone","default","new"],"repr::Formatted":["clone","new"],"repr::Repr":["clone","default_repr","new_unchecked","to_f64_repr","to_key_repr","to_repr","to_string_repr"],"std::borrow::Cow":["display_repr"],"std::boxed::Box":["iter","iter_mut"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::ops::Range":["span"],"std::vec::Vec":["get_values","parse","parse_key_path","try_parse_path"],"table::Entry":["entry","entry_format"],"table::Table":["clone","default","from_iter","into_table","new","with_pairs","with_pos"],"table::TableKeyValue":["clone","new"],"usize":["len","position"],"value::Value":["clone","from","from_iter","from_str","into_value","parse_value","remove","replace"],"winnow::Located":["new_input"]},"struct_to_trait":{"array::Array":["encode::Encode","std::clone::Clone","std::default::Default","std::fmt::Debug","std::fmt::Display","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator"],"array_of_tables::ArrayOfTables":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::fmt::Display","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator"],"document::Document":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::ops::Deref","std::ops::DerefMut","std::ops::Index","std::ops::IndexMut","std::str::FromStr"],"encode::StringStyle":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"inline_table::InlineTable":["encode::Encode","private::Sealed","std::clone::Clone","std::default::Default","std::fmt::Debug","std::fmt::Display","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::ops::Index","std::ops::IndexMut","table::TableLike"],"internal_string::InternalString":["std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"],"item::Item":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::fmt::Display","std::ops::Index","std::ops::IndexMut","std::str::FromStr"],"key::Key":["encode::Encode","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::ops::Deref","std::str::FromStr"],"key::KeyMut":["std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref"],"parser::errors::Context":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"parser::errors::CustomError":["std::clone::Clone","std::error::Error","std::fmt::Debug","std::fmt::Display"],"parser::errors::ParserError":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","winnow::error::ContextError","winnow::error::FromExternalError","winnow::error::ParseError"],"parser::errors::ParserValue":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralPartialEq"],"parser::errors::TomlError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"parser::prelude::RecursionCheck":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Copy"],"parser::state::ParseState":["std::default::Default"],"raw_string::RawString":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"raw_string::RawStringInner":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"repr::Decor":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"repr::Formatted":["encode::Encode","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"repr::Repr":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::string::String":["index::Index","private::Sealed","repr::ValueRepr"],"table::Table":["private::Sealed","std::clone::Clone","std::default::Default","std::fmt::Debug","std::fmt::Display","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::ops::Index","std::ops::IndexMut","table::TableLike"],"table::TableKeyValue":["std::clone::Clone","std::fmt::Debug"],"toml_datetime::Datetime":["private::Sealed","repr::ValueRepr"],"value::Value":["encode::Encode","std::clone::Clone","std::convert::From","std::fmt::Debug","std::fmt::Display","std::iter::FromIterator","std::str::FromStr"]},"targets":{"<&'a T as index::Index>::index":["index","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","index::Index"],"<&'a T as index::Index>::index_mut":["index_mut","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","index::Index"],"<&'k [&'k key::Key] as encode::Encode>::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","encode::Encode"],"<&'k [key::Key] as encode::Encode>::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","encode::Encode"],"<&'s array::Array as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))","std::iter::IntoIterator"],"<&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))","std::iter::IntoIterator"],"<&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","std::iter::IntoIterator"],"<&'s table::Table as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","std::iter::IntoIterator"],"<array::Array as encode::Encode>::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","encode::Encode"],"<array::Array as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))","std::fmt::Display"],"<array::Array as std::iter::Extend<V>>::extend":["extend","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))","std::iter::Extend"],"<array::Array as std::iter::FromIterator<V>>::from_iter":["from_iter","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))","std::iter::FromIterator"],"<array::Array as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))","std::iter::IntoIterator"],"<array_of_tables::ArrayOfTables as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))","std::fmt::Display"],"<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend":["extend","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))","std::iter::Extend"],"<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter":["from_iter","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))","std::iter::FromIterator"],"<array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))","std::iter::IntoIterator"],"<document::Document as std::convert::From<table::Table>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))","std::convert::From"],"<document::Document as std::default::Default>::default":["default","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))","std::default::Default"],"<document::Document as std::ops::Deref>::deref":["deref","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))","std::ops::Deref"],"<document::Document as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))","std::ops::DerefMut"],"<document::Document as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))","std::str::FromStr"],"<inline_table::InlineTable as encode::Encode>::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","encode::Encode"],"<inline_table::InlineTable as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","std::fmt::Display"],"<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend":["extend","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","std::iter::Extend"],"<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter":["from_iter","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","std::iter::FromIterator"],"<inline_table::InlineTable as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","std::iter::IntoIterator"],"<inline_table::InlineTable as table::TableLike>::clear":["clear","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::contains_key":["contains_key","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::entry":["entry","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::entry_format":["entry_format","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::get":["get","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::get_key_value":["get_key_value","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::get_key_value_mut":["get_key_value_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::get_values":["get_values","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::is_dotted":["is_dotted","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::iter":["iter","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::iter_mut":["iter_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::key_decor":["key_decor","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::key_decor_mut":["key_decor_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::remove":["remove","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::set_dotted":["set_dotted","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<inline_table::InlineTable as table::TableLike>::sort_values":["sort_values","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))","table::TableLike"],"<internal_string::InternalString as std::borrow::Borrow<str>>::borrow":["borrow","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::borrow::Borrow"],"<internal_string::InternalString as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::convert::AsRef"],"<internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::convert::From"],"<internal_string::InternalString as std::convert::From<&std::string::String>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::convert::From"],"<internal_string::InternalString as std::convert::From<&str>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::convert::From"],"<internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::convert::From"],"<internal_string::InternalString as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::convert::From"],"<internal_string::InternalString as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::fmt::Debug"],"<internal_string::InternalString as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::fmt::Display"],"<internal_string::InternalString as std::ops::Deref>::deref":["deref","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::ops::Deref"],"<internal_string::InternalString as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))","std::str::FromStr"],"<item::Item as std::default::Default>::default":["default","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))","std::default::Default"],"<item::Item as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))","std::fmt::Display"],"<item::Item as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))","std::str::FromStr"],"<key::Key as encode::Encode>::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","encode::Encode"],"<key::Key as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::Ord"],"<key::Key as std::cmp::PartialEq<&'s str>>::eq":["eq","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::PartialEq"],"<key::Key as std::cmp::PartialEq<std::string::String>>::eq":["eq","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::PartialEq"],"<key::Key as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::PartialEq"],"<key::Key as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::PartialEq"],"<key::Key as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::PartialOrd"],"<key::Key as std::convert::From<&'b std::string::String>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::convert::From"],"<key::Key as std::convert::From<&'b str>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::convert::From"],"<key::Key as std::convert::From<internal_string::InternalString>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::convert::From"],"<key::Key as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::convert::From"],"<key::Key as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::fmt::Display"],"<key::Key as std::hash::Hash>::hash":["hash","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::hash::Hash"],"<key::Key as std::ops::Deref>::deref":["deref","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::ops::Deref"],"<key::Key as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::str::FromStr"],"<key::KeyMut<'k> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::fmt::Display"],"<key::KeyMut<'k> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::ops::Deref"],"<key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq":["eq","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::PartialEq"],"<key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq":["eq","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::PartialEq"],"<key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::cmp::PartialEq"],"<parser::errors::CustomError as std::error::Error>::description":["description","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","std::error::Error"],"<parser::errors::CustomError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","std::fmt::Display"],"<parser::errors::ParserError<'a> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","std::fmt::Display"],"<parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","std::cmp::PartialEq"],"<parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context":["add_context","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::ContextError"],"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error":["from_external_error","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::FromExternalError"],"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error":["from_external_error","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::FromExternalError"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append":["append","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::ParseError"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind":["from_error_kind","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::ParseError"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or":["or","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::ParseError"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append":["append","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::ParseError"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind":["from_error_kind","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::ParseError"],"<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or":["or","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","winnow::error::ParseError"],"<parser::errors::ParserValue as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","std::fmt::Display"],"<parser::errors::TomlError as std::error::Error>::description":["description","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","std::error::Error"],"<parser::errors::TomlError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))","std::fmt::Display"],"<parser::state::ParseState as std::default::Default>::default":["default","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))","std::default::Default"],"<raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))","std::convert::From"],"<raw_string::RawString as std::convert::From<&std::string::String>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))","std::convert::From"],"<raw_string::RawString as std::convert::From<&str>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))","std::convert::From"],"<raw_string::RawString as std::convert::From<internal_string::InternalString>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))","std::convert::From"],"<raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))","std::convert::From"],"<raw_string::RawString as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))","std::convert::From"],"<raw_string::RawString as std::default::Default>::default":["default","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))","std::default::Default"],"<raw_string::RawString as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))","std::fmt::Debug"],"<repr::Decor as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))","std::fmt::Debug"],"<repr::Formatted<T> as encode::Encode>::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","encode::Encode"],"<repr::Formatted<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))","std::fmt::Debug"],"<repr::Formatted<T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))","std::fmt::Display"],"<repr::Repr as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))","std::fmt::Debug"],"<std::string::String as index::Index>::index":["index","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","index::Index"],"<std::string::String as index::Index>::index_mut":["index_mut","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","index::Index"],"<str as index::Index>::index":["index","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","index::Index"],"<str as index::Index>::index_mut":["index_mut","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","index::Index"],"<table::Table as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","std::fmt::Display"],"<table::Table as std::iter::Extend<(K, V)>>::extend":["extend","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","std::iter::Extend"],"<table::Table as std::iter::FromIterator<(K, V)>>::from_iter":["from_iter","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","std::iter::FromIterator"],"<table::Table as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","std::iter::IntoIterator"],"<table::Table as table::TableLike>::clear":["clear","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::contains_key":["contains_key","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::entry":["entry","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::entry_format":["entry_format","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::get":["get","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::get_key_value":["get_key_value","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::get_key_value_mut":["get_key_value_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::get_values":["get_values","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::is_dotted":["is_dotted","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::iter":["iter","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::iter_mut":["iter_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::key_decor":["key_decor","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::key_decor_mut":["key_decor_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::remove":["remove","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::set_dotted":["set_dotted","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<table::Table as table::TableLike>::sort_values":["sort_values","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))","table::TableLike"],"<usize as index::Index>::index":["index","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","index::Index"],"<usize as index::Index>::index_mut":["index_mut","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","index::Index"],"<value::Value as encode::Encode>::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","encode::Encode"],"<value::Value as std::convert::From<&'b internal_string::InternalString>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<&'b std::string::String>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<&'b str>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<&'b value::Value>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<array::Array>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<bool>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<f64>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<i64>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<inline_table::InlineTable>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<internal_string::InternalString>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<toml_datetime::Date>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<toml_datetime::Datetime>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::convert::From<toml_datetime::Time>>::from":["from","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::convert::From"],"<value::Value as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::fmt::Display"],"<value::Value as std::iter::FromIterator<(K, V)>>::from_iter":["from_iter","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::iter::FromIterator"],"<value::Value as std::iter::FromIterator<V>>::from_iter":["from_iter","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::iter::FromIterator"],"<value::Value as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))","std::str::FromStr"],"array::Array::clear":["clear","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::decor":["decor","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::decor_mut":["decor_mut","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::get":["get","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::insert_formatted":["insert_formatted","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::is_empty":["is_empty","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::iter":["iter","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::iter_mut":["iter_mut","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::len":["len","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::new":["new","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::push":["push","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::push_formatted":["push_formatted","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::remove":["remove","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::replace":["replace","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::replace_formatted":["replace_formatted","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::set_trailing":["set_trailing","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::set_trailing_comma":["set_trailing_comma","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::span":["span","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::trailing":["trailing","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::trailing_comma":["trailing_comma","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::value_op":["value_op","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::Array::with_vec":["with_vec","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array::decorate_array":["decorate_array","Real(LocalPath(\"crates/toml_edit/src/array.rs\"))",""],"array_of_tables::ArrayOfTables::clear":["clear","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::get":["get","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::into_array":["into_array","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::is_empty":["is_empty","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::iter":["iter","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::iter_mut":["iter_mut","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::len":["len","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::new":["new","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::push":["push","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::remove":["remove","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"array_of_tables::ArrayOfTables::span":["span","Real(LocalPath(\"crates/toml_edit/src/array_of_tables.rs\"))",""],"document::Document::as_item":["as_item","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"document::Document::as_item_mut":["as_item_mut","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"document::Document::as_table":["as_table","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"document::Document::as_table_mut":["as_table_mut","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"document::Document::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"document::Document::iter":["iter","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"document::Document::new":["new","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"document::Document::set_trailing":["set_trailing","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"document::Document::trailing":["trailing","Real(LocalPath(\"crates/toml_edit/src/document.rs\"))",""],"encode::<impl repr::ValueRepr for bool>::to_repr":["to_repr","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","repr::ValueRepr"],"encode::<impl repr::ValueRepr for f64>::to_repr":["to_repr","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","repr::ValueRepr"],"encode::<impl repr::ValueRepr for i64>::to_repr":["to_repr","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","repr::ValueRepr"],"encode::<impl repr::ValueRepr for std::string::String>::to_repr":["to_repr","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","repr::ValueRepr"],"encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr":["to_repr","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","repr::ValueRepr"],"encode::<impl std::fmt::Display for document::Document>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))","std::fmt::Display"],"encode::StringStyle::literal_end":["literal_end","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"encode::StringStyle::literal_start":["literal_start","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"encode::StringStyle::standard_end":["standard_end","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"encode::StringStyle::standard_start":["standard_start","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"encode::infer_style":["infer_style","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"encode::to_f64_repr":["to_f64_repr","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"encode::to_string_repr":["to_string_repr","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"encode::visit_nested_tables":["visit_nested_tables","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"encode::visit_table":["visit_table","Real(LocalPath(\"crates/toml_edit/src/encode.rs\"))",""],"index::<impl std::ops::Index<&'s str> for document::Document>::index":["index","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","std::ops::Index"],"index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index":["index","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","std::ops::Index"],"index::<impl std::ops::Index<&'s str> for table::Table>::index":["index","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","std::ops::Index"],"index::<impl std::ops::Index<I> for item::Item>::index":["index","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","std::ops::Index"],"index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut":["index_mut","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","std::ops::IndexMut"],"index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut":["index_mut","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","std::ops::IndexMut"],"index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut":["index_mut","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","std::ops::IndexMut"],"index::<impl std::ops::IndexMut<I> for item::Item>::index_mut":["index_mut","Real(LocalPath(\"crates/toml_edit/src/index.rs\"))","std::ops::IndexMut"],"inline_table::InlineEntry::<'a>::key":["key","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineEntry::<'a>::or_insert":["or_insert","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineEntry::<'a>::or_insert_with":["or_insert_with","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineOccupiedEntry::<'a>::get":["get","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineOccupiedEntry::<'a>::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineOccupiedEntry::<'a>::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineOccupiedEntry::<'a>::into_mut":["into_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineOccupiedEntry::<'a>::key":["key","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineOccupiedEntry::<'a>::key_mut":["key_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineOccupiedEntry::<'a>::remove":["remove","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::append_values":["append_values","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::clear":["clear","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::contains_key":["contains_key","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::decor":["decor","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::decor_mut":["decor_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::entry":["entry","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::entry_format":["entry_format","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::get":["get","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::get_key_value":["get_key_value","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::get_key_value_mut":["get_key_value_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::get_or_insert":["get_or_insert","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::get_values":["get_values","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::insert_formatted":["insert_formatted","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::into_table":["into_table","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::is_dotted":["is_dotted","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::is_empty":["is_empty","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::iter":["iter","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::iter_mut":["iter_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::key_decor":["key_decor","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::key_decor_mut":["key_decor_mut","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::len":["len","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::new":["new","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::preamble":["preamble","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::remove":["remove","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::remove_entry":["remove_entry","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::set_dotted":["set_dotted","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::set_preamble":["set_preamble","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::sort_values":["sort_values","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::sort_values_by":["sort_values_by","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::sort_values_by_internal":["sort_values_by_internal","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::span":["span","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineTable::with_pairs":["with_pairs","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineVacantEntry::<'a>::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::InlineVacantEntry::<'a>::key":["key","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"inline_table::decorate_inline_table":["decorate_inline_table","Real(LocalPath(\"crates/toml_edit/src/inline_table.rs\"))",""],"internal_string::InternalString::as_str":["as_str","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))",""],"internal_string::InternalString::new":["new","Real(LocalPath(\"crates/toml_edit/src/internal_string.rs\"))",""],"item::Item::as_array":["as_array","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_array_mut":["as_array_mut","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_array_of_tables":["as_array_of_tables","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_array_of_tables_mut":["as_array_of_tables_mut","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_bool":["as_bool","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_datetime":["as_datetime","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_float":["as_float","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_inline_table":["as_inline_table","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_inline_table_mut":["as_inline_table_mut","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_integer":["as_integer","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_str":["as_str","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_table":["as_table","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_table_like":["as_table_like","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_table_like_mut":["as_table_like_mut","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_table_mut":["as_table_mut","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_value":["as_value","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::as_value_mut":["as_value_mut","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::get":["get","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::into_array_of_tables":["into_array_of_tables","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::into_table":["into_table","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::into_value":["into_value","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_array":["is_array","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_array_of_tables":["is_array_of_tables","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_bool":["is_bool","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_datetime":["is_datetime","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_float":["is_float","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_inline_table":["is_inline_table","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_integer":["is_integer","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_none":["is_none","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_str":["is_str","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_table":["is_table","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_table_like":["is_table_like","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::is_value":["is_value","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::make_item":["make_item","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::make_value":["make_value","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::or_insert":["or_insert","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::span":["span","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::Item::type_name":["type_name","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::array":["array","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::table":["table","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"item::value":["value","Real(LocalPath(\"crates/toml_edit/src/item.rs\"))",""],"key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from":["from","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))","std::convert::From"],"key::Key::as_mut":["as_mut","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::as_repr":["as_repr","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::decor":["decor","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::decor_mut":["decor_mut","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::default_repr":["default_repr","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::display_repr":["display_repr","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::get":["get","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::get_internal":["get_internal","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::new":["new","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::parse":["parse","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::try_parse_path":["try_parse_path","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::try_parse_simple":["try_parse_simple","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::with_decor":["with_decor","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::Key::with_repr_unchecked":["with_repr_unchecked","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::KeyMut::<'k>::as_repr":["as_repr","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::KeyMut::<'k>::decor":["decor","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::KeyMut::<'k>::decor_mut":["decor_mut","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::KeyMut::<'k>::default_repr":["default_repr","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::KeyMut::<'k>::display_repr":["display_repr","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::KeyMut::<'k>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::KeyMut::<'k>::get":["get","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"key::to_key_repr":["to_key_repr","Real(LocalPath(\"crates/toml_edit/src/key.rs\"))",""],"parser::array::array":["array","Real(LocalPath(\"crates/toml_edit/src/parser/array.rs\"))",""],"parser::array::array_value":["array_value","Real(LocalPath(\"crates/toml_edit/src/parser/array.rs\"))",""],"parser::array::array_values":["array_values","Real(LocalPath(\"crates/toml_edit/src/parser/array.rs\"))",""],"parser::datetime::date_fullyear":["date_fullyear","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::date_mday":["date_mday","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::date_month":["date_month","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::date_time":["date_time","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::full_date":["full_date","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::partial_time":["partial_time","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::time_delim":["time_delim","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::time_hour":["time_hour","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::time_minute":["time_minute","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::time_offset":["time_offset","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::time_secfrac":["time_secfrac","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::time_second":["time_second","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::datetime::unsigned_digits":["unsigned_digits","Real(LocalPath(\"crates/toml_edit/src/parser/datetime.rs\"))",""],"parser::document::document":["document","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))",""],"parser::document::keyval":["keyval","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))",""],"parser::document::parse_comment":["parse_comment","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))",""],"parser::document::parse_keyval":["parse_keyval","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))",""],"parser::document::parse_newline":["parse_newline","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))",""],"parser::document::parse_ws":["parse_ws","Real(LocalPath(\"crates/toml_edit/src/parser/document.rs\"))",""],"parser::errors::CustomError::duplicate_key":["duplicate_key","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))",""],"parser::errors::CustomError::extend_wrong_type":["extend_wrong_type","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))",""],"parser::errors::TomlError::message":["message","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))",""],"parser::errors::TomlError::new":["new","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))",""],"parser::errors::TomlError::span":["span","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))",""],"parser::errors::translate_position":["translate_position","Real(LocalPath(\"crates/toml_edit/src/parser/errors.rs\"))",""],"parser::inline_table::descend_path":["descend_path","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))",""],"parser::inline_table::inline_table":["inline_table","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))",""],"parser::inline_table::inline_table_keyvals":["inline_table_keyvals","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))",""],"parser::inline_table::keyval":["keyval","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))",""],"parser::inline_table::table_from_pairs":["table_from_pairs","Real(LocalPath(\"crates/toml_edit/src/parser/inline_table.rs\"))",""],"parser::key::is_unquoted_char":["is_unquoted_char","Real(LocalPath(\"crates/toml_edit/src/parser/key.rs\"))",""],"parser::key::key":["key","Real(LocalPath(\"crates/toml_edit/src/parser/key.rs\"))",""],"parser::key::simple_key":["simple_key","Real(LocalPath(\"crates/toml_edit/src/parser/key.rs\"))",""],"parser::key::unquoted_key":["unquoted_key","Real(LocalPath(\"crates/toml_edit/src/parser/key.rs\"))",""],"parser::numbers::bin_int":["bin_int","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::boolean":["boolean","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::dec_int":["dec_int","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::digit":["digit","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::exp":["exp","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::false_":["false_","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::float":["float","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::float_":["float_","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::frac":["frac","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::hex_int":["hex_int","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::hexdig":["hexdig","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::inf":["inf","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::integer":["integer","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::nan":["nan","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::oct_int":["oct_int","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::special_float":["special_float","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::true_":["true_","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::numbers::zero_prefixable_int":["zero_prefixable_int","Real(LocalPath(\"crates/toml_edit/src/parser/numbers.rs\"))",""],"parser::parse_document":["parse_document","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::parse_key":["parse_key","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::parse_key_path":["parse_key_path","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::parse_value":["parse_value","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::prelude::RecursionCheck::check_depth":["check_depth","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::prelude::RecursionCheck::recursing":["recursing","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::prelude::new_input":["new_input","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::prelude::ok_error":["ok_error","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::prelude::trace":["trace","Real(LocalPath(\"crates/toml_edit/src/parser/mod.rs\"))",""],"parser::state::ParseState::descend_path":["descend_path","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::finalize_table":["finalize_table","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::into_document":["into_document","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::on_array_header":["on_array_header","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::on_comment":["on_comment","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::on_keyval":["on_keyval","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::on_std_header":["on_std_header","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::on_ws":["on_ws","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::start_aray_table":["start_aray_table","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::state::ParseState::start_table":["start_table","Real(LocalPath(\"crates/toml_edit/src/parser/state.rs\"))",""],"parser::strings::basic_chars":["basic_chars","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::basic_string":["basic_string","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::escape_seq_char":["escape_seq_char","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::escaped":["escaped","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::hexescape":["hexescape","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::literal_string":["literal_string","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::ml_basic_body":["ml_basic_body","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::ml_basic_string":["ml_basic_string","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::ml_literal_body":["ml_literal_body","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::ml_literal_string":["ml_literal_string","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::mlb_content":["mlb_content","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::mlb_escaped_nl":["mlb_escaped_nl","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::mlb_quotes":["mlb_quotes","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::mll_content":["mll_content","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::mll_quotes":["mll_quotes","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::strings::string":["string","Real(LocalPath(\"crates/toml_edit/src/parser/strings.rs\"))",""],"parser::table::array_table":["array_table","Real(LocalPath(\"crates/toml_edit/src/parser/table.rs\"))",""],"parser::table::std_table":["std_table","Real(LocalPath(\"crates/toml_edit/src/parser/table.rs\"))",""],"parser::table::table":["table","Real(LocalPath(\"crates/toml_edit/src/parser/table.rs\"))",""],"parser::trivia::comment":["comment","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::trivia::from_utf8_unchecked":["from_utf8_unchecked","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::trivia::line_ending":["line_ending","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::trivia::line_trailing":["line_trailing","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::trivia::newline":["newline","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::trivia::ws":["ws","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::trivia::ws_comment_newline":["ws_comment_newline","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::trivia::ws_newline":["ws_newline","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::trivia::ws_newlines":["ws_newlines","Real(LocalPath(\"crates/toml_edit/src/parser/trivia.rs\"))",""],"parser::value::apply_raw":["apply_raw","Real(LocalPath(\"crates/toml_edit/src/parser/value.rs\"))",""],"parser::value::value":["value","Real(LocalPath(\"crates/toml_edit/src/parser/value.rs\"))",""],"raw_string::RawString::as_str":["as_str","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))",""],"raw_string::RawString::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))",""],"raw_string::RawString::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))",""],"raw_string::RawString::encode_with_default":["encode_with_default","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))",""],"raw_string::RawString::span":["span","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))",""],"raw_string::RawString::to_str":["to_str","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))",""],"raw_string::RawString::to_str_with_default":["to_str_with_default","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))",""],"raw_string::RawString::with_span":["with_span","Real(LocalPath(\"crates/toml_edit/src/raw_string.rs\"))",""],"repr::Decor::clear":["clear","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Decor::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Decor::new":["new","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Decor::prefix":["prefix","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Decor::prefix_encode":["prefix_encode","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Decor::set_prefix":["set_prefix","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Decor::set_suffix":["set_suffix","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Decor::suffix":["suffix","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Decor::suffix_encode":["suffix_encode","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::as_repr":["as_repr","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::decor":["decor","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::decor_mut":["decor_mut","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::default_repr":["default_repr","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::display_repr":["display_repr","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::into_value":["into_value","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::new":["new","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::set_repr_unchecked":["set_repr_unchecked","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::span":["span","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Formatted::<T>::value":["value","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Repr::as_raw":["as_raw","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Repr::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Repr::encode":["encode","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Repr::new_unchecked":["new_unchecked","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"repr::Repr::span":["span","Real(LocalPath(\"crates/toml_edit/src/repr.rs\"))",""],"table::Entry::<'a>::key":["key","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Entry::<'a>::or_insert":["or_insert","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Entry::<'a>::or_insert_with":["or_insert_with","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::OccupiedEntry::<'a>::get":["get","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::OccupiedEntry::<'a>::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::OccupiedEntry::<'a>::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::OccupiedEntry::<'a>::into_mut":["into_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::OccupiedEntry::<'a>::key":["key","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::OccupiedEntry::<'a>::key_mut":["key_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::OccupiedEntry::<'a>::remove":["remove","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::append_values":["append_values","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::clear":["clear","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::contains_array_of_tables":["contains_array_of_tables","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::contains_key":["contains_key","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::contains_table":["contains_table","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::contains_value":["contains_value","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::decor":["decor","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::decor_mut":["decor_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::entry":["entry","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::entry_format":["entry_format","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::fmt":["fmt","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::get":["get","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::get_key_value":["get_key_value","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::get_key_value_mut":["get_key_value_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::get_mut":["get_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::get_values":["get_values","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::insert_formatted":["insert_formatted","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::into_inline_table":["into_inline_table","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::is_dotted":["is_dotted","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::is_empty":["is_empty","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::is_implicit":["is_implicit","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::iter":["iter","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::iter_mut":["iter_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::key_decor":["key_decor","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::key_decor_mut":["key_decor_mut","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::len":["len","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::new":["new","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::position":["position","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::remove":["remove","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::remove_entry":["remove_entry","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::set_dotted":["set_dotted","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::set_implicit":["set_implicit","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::set_position":["set_position","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::sort_values":["sort_values","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::sort_values_by":["sort_values_by","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::sort_values_by_internal":["sort_values_by_internal","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::span":["span","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::with_pairs":["with_pairs","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::Table::with_pos":["with_pos","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::TableKeyValue::new":["new","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::TableLike::is_empty":["is_empty","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::TableLike::len":["len","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::VacantEntry::<'a>::insert":["insert","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::VacantEntry::<'a>::key":["key","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"table::decorate_table":["decorate_table","Real(LocalPath(\"crates/toml_edit/src/table.rs\"))",""],"value::Value::as_array":["as_array","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::as_array_mut":["as_array_mut","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::as_bool":["as_bool","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::as_datetime":["as_datetime","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::as_float":["as_float","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::as_inline_table":["as_inline_table","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::as_inline_table_mut":["as_inline_table_mut","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::as_integer":["as_integer","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::as_str":["as_str","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::decor":["decor","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::decor_mut":["decor_mut","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::decorate":["decorate","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::decorated":["decorated","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::despan":["despan","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::is_array":["is_array","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::is_bool":["is_bool","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::is_datetime":["is_datetime","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::is_float":["is_float","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::is_inline_table":["is_inline_table","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::is_integer":["is_integer","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::is_str":["is_str","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::span":["span","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"value::Value::type_name":["type_name","Real(LocalPath(\"crates/toml_edit/src/value.rs\"))",""],"visit::Visit::visit_array":["visit_array","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_array_of_tables":["visit_array_of_tables","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_boolean":["visit_boolean","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_datetime":["visit_datetime","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_document":["visit_document","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_float":["visit_float","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_inline_table":["visit_inline_table","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_integer":["visit_integer","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_item":["visit_item","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_string":["visit_string","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_table":["visit_table","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_table_like":["visit_table_like","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_table_like_kv":["visit_table_like_kv","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::Visit::visit_value":["visit_value","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_array":["visit_array","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_array_of_tables":["visit_array_of_tables","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_boolean":["visit_boolean","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_datetime":["visit_datetime","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_document":["visit_document","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_float":["visit_float","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_inline_table":["visit_inline_table","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_integer":["visit_integer","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_item":["visit_item","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_string":["visit_string","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_table":["visit_table","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_table_like":["visit_table_like","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_table_like_kv":["visit_table_like_kv","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit::visit_value":["visit_value","Real(LocalPath(\"crates/toml_edit/src/visit.rs\"))",""],"visit_mut::VisitMut::visit_array_mut":["visit_array_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_array_of_tables_mut":["visit_array_of_tables_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_boolean_mut":["visit_boolean_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_datetime_mut":["visit_datetime_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_document_mut":["visit_document_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_float_mut":["visit_float_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_inline_table_mut":["visit_inline_table_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_integer_mut":["visit_integer_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_item_mut":["visit_item_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_string_mut":["visit_string_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_table_like_kv_mut":["visit_table_like_kv_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_table_like_mut":["visit_table_like_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_table_mut":["visit_table_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::VisitMut::visit_value_mut":["visit_value_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_array_mut":["visit_array_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_array_of_tables_mut":["visit_array_of_tables_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_boolean_mut":["visit_boolean_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_datetime_mut":["visit_datetime_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_document_mut":["visit_document_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_float_mut":["visit_float_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_inline_table_mut":["visit_inline_table_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_integer_mut":["visit_integer_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_item_mut":["visit_item_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_string_mut":["visit_string_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_table_like_kv_mut":["visit_table_like_kv_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_table_like_mut":["visit_table_like_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_table_mut":["visit_table_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""],"visit_mut::visit_value_mut":["visit_value_mut","Real(LocalPath(\"crates/toml_edit/src/visit_mut.rs\"))",""]},"trait_to_struct":{"encode::Encode":["array::Array","inline_table::InlineTable","key::Key","repr::Formatted","value::Value"],"index::Index":["std::string::String"],"private::Sealed":["inline_table::InlineTable","std::string::String","table::Table","toml_datetime::Datetime"],"repr::ValueRepr":["std::string::String","toml_datetime::Datetime"],"std::borrow::Borrow":["internal_string::InternalString"],"std::clone::Clone":["array::Array","array_of_tables::ArrayOfTables","document::Document","encode::StringStyle","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","parser::errors::Context","parser::errors::CustomError","parser::errors::ParserValue","parser::errors::TomlError","parser::prelude::RecursionCheck","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","repr::Repr","table::Table","table::TableKeyValue","value::Value"],"std::cmp::Eq":["encode::StringStyle","internal_string::InternalString","key::Key","key::KeyMut","parser::errors::TomlError","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","repr::Repr"],"std::cmp::Ord":["internal_string::InternalString","key::Key","key::KeyMut"],"std::cmp::PartialEq":["encode::StringStyle","internal_string::InternalString","key::Key","key::KeyMut","parser::errors::Context","parser::errors::ParserError","parser::errors::ParserValue","parser::errors::TomlError","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","repr::Repr"],"std::cmp::PartialOrd":["internal_string::InternalString","key::Key","key::KeyMut"],"std::convert::AsRef":["internal_string::InternalString"],"std::convert::From":["document::Document","internal_string::InternalString","key::Key","raw_string::RawString","value::Value"],"std::default::Default":["array::Array","array_of_tables::ArrayOfTables","document::Document","inline_table::InlineTable","internal_string::InternalString","item::Item","parser::prelude::RecursionCheck","parser::state::ParseState","raw_string::RawString","repr::Decor","table::Table"],"std::error::Error":["parser::errors::CustomError","parser::errors::TomlError"],"std::fmt::Debug":["array::Array","array_of_tables::ArrayOfTables","document::Document","encode::StringStyle","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","key::KeyMut","parser::errors::Context","parser::errors::CustomError","parser::errors::ParserError","parser::errors::ParserValue","parser::errors::TomlError","parser::prelude::RecursionCheck","raw_string::RawString","repr::Decor","repr::Formatted","repr::Repr","table::Table","table::TableKeyValue","value::Value"],"std::fmt::Display":["array::Array","array_of_tables::ArrayOfTables","document::Document","inline_table::InlineTable","internal_string::InternalString","item::Item","key::Key","key::KeyMut","parser::errors::CustomError","parser::errors::ParserError","parser::errors::ParserValue","parser::errors::TomlError","repr::Formatted","table::Table","value::Value"],"std::hash::Hash":["internal_string::InternalString","key::Key","key::KeyMut","parser::errors::TomlError","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","repr::Repr"],"std::iter::Extend":["array::Array","array_of_tables::ArrayOfTables","inline_table::InlineTable","table::Table"],"std::iter::FromIterator":["array::Array","array_of_tables::ArrayOfTables","inline_table::InlineTable","table::Table","value::Value"],"std::iter::IntoIterator":["array::Array","array_of_tables::ArrayOfTables","inline_table::InlineTable","table::Table"],"std::marker::Copy":["encode::StringStyle","parser::errors::Context","parser::errors::ParserValue","parser::prelude::RecursionCheck"],"std::marker::StructuralEq":["encode::StringStyle","internal_string::InternalString","key::KeyMut","parser::errors::TomlError","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","repr::Repr"],"std::marker::StructuralPartialEq":["encode::StringStyle","internal_string::InternalString","key::KeyMut","parser::errors::Context","parser::errors::ParserValue","parser::errors::TomlError","raw_string::RawString","raw_string::RawStringInner","repr::Decor","repr::Formatted","repr::Repr"],"std::ops::Deref":["document::Document","internal_string::InternalString","key::Key","key::KeyMut"],"std::ops::DerefMut":["document::Document"],"std::ops::Index":["document::Document","inline_table::InlineTable","item::Item","table::Table"],"std::ops::IndexMut":["document::Document","inline_table::InlineTable","item::Item","table::Table"],"std::str::FromStr":["document::Document","internal_string::InternalString","item::Item","key::Key","value::Value"],"table::TableLike":["inline_table::InlineTable","table::Table"],"winnow::error::ContextError":["parser::errors::ParserError"],"winnow::error::FromExternalError":["parser::errors::ParserError"],"winnow::error::ParseError":["parser::errors::ParserError"]},"type_to_def_path":{"array::Array":"array::Array","array_of_tables::ArrayOfTables":"array_of_tables::ArrayOfTables","document::Document":"document::Document","encode::StringStyle":"encode::StringStyle","inline_table::InlineEntry<'a>":"inline_table::InlineEntry","inline_table::InlineOccupiedEntry<'a>":"inline_table::InlineOccupiedEntry","inline_table::InlineTable":"inline_table::InlineTable","inline_table::InlineVacantEntry<'a>":"inline_table::InlineVacantEntry","internal_string::InternalString":"internal_string::InternalString","item::Item":"item::Item","key::Key":"key::Key","key::KeyMut<'k>":"key::KeyMut","parser::errors::Context":"parser::errors::Context","parser::errors::CustomError":"parser::errors::CustomError","parser::errors::ParserError<'b>":"parser::errors::ParserError","parser::errors::ParserValue":"parser::errors::ParserValue","parser::errors::TomlError":"parser::errors::TomlError","parser::prelude::RecursionCheck":"parser::prelude::RecursionCheck","parser::state::ParseState":"parser::state::ParseState","raw_string::RawString":"raw_string::RawString","raw_string::RawStringInner":"raw_string::RawStringInner","repr::Decor":"repr::Decor","repr::Formatted<T>":"repr::Formatted","repr::Repr":"repr::Repr","table::Entry<'a>":"table::Entry","table::OccupiedEntry<'a>":"table::OccupiedEntry","table::Table":"table::Table","table::TableKeyValue":"table::TableKeyValue","table::VacantEntry<'a>":"table::VacantEntry","value::Value":"value::Value"}}