#![feature(prelude_import)]
#![feature(backtrace)]
#![feature(rustc_private)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
///! This implementation is based on `cargo-miri`
///! https://github.com/rust-lang/miri/blob/master/src/bin/cargo-miri.rs
#[macro_use]
extern crate log as log_crate;
use std::env;
use std::fmt::Display;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::time::Duration;
use rustc_version::VersionMeta;
use wait_timeout::ChildExt;
const CARGO_RUDRA_HELP: &str = r#"Tests crates with Rudra
Usage:
    cargo rudra [<cargo options>] [--] [<rustc/rudra options>...]

Common options:
    -h, --help               Print this message

Other [options] are the same as `cargo check`. Everything after the first "--" is
passed verbatim to Rudra.
"#;
fn show_help() {
    {
        ::std::io::_print(::core::fmt::Arguments::new_v1(
            &["", "\n"],
            &[::core::fmt::ArgumentV1::new_display(&CARGO_RUDRA_HELP)],
        ));
    };
}
fn show_error(msg: impl AsRef<str>) -> ! {
    std::process::exit(1)
}
fn has_arg_flag(name: &str) -> bool {
    let mut args = std::env::args().take_while(|val| val != "--");
    args.any(|val| val == name)
}
/// Gets the value of a `--flag`.
fn get_arg_flag_value(name: &str) -> Option<String> {
    let mut args = std::env::args().take_while(|val| val != "--");
    loop {
        let arg = match args.next() {
            Some(arg) => arg,
            None => return None,
        };
        if !arg.starts_with(name) {
            continue;
        }
        let suffix = &arg[name.len()..];
        if suffix.is_empty() {
            return args.next();
        } else if suffix.starts_with('=') {
            return Some(suffix[1..].to_owned());
        }
    }
}
fn any_arg_flag<F>(name: &str, mut check: F) -> bool
where
    F: FnMut(&str) -> bool,
{
    let mut args = std::env::args().take_while(|val| val != "--");
    loop {
        let arg = match args.next() {
            Some(arg) => arg,
            None => return false,
        };
        if !arg.starts_with(name) {
            continue;
        }
        let suffix = &arg[name.len()..];
        let value = if suffix.is_empty() {
            match args.next() {
                Some(arg) => arg,
                None => return false,
            }
        } else if suffix.starts_with('=') {
            suffix[1..].to_owned()
        } else {
            return false;
        };
        if check(&value) {
            return true;
        }
    }
}
/// Finds the first argument ends with `.rs`.
fn get_first_arg_with_rs_suffix() -> Option<String> {
    let mut args = std::env::args().take_while(|val| val != "--");
    args.find(|arg| arg.ends_with(".rs"))
}
fn version_info() -> VersionMeta {
    VersionMeta::for_command(Command::new(find_rudra()))
        .expect("failed to determine underlying rustc version of Rudra")
}
fn cargo_package() -> cargo_metadata::Package {
    let manifest_path =
        get_arg_flag_value("--manifest-path").map(|m| Path::new(&m).canonicalize().unwrap());
    let mut cmd = cargo_metadata::MetadataCommand::new();
    if let Some(manifest_path) = &manifest_path {
        cmd.manifest_path(manifest_path);
    }
    let mut metadata = match cmd.exec() {
        Ok(metadata) => metadata,
        Err(e) => show_error({
            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                &["Could not obtain Cargo metadata\n"],
                &[::core::fmt::ArgumentV1::new_display(&e)],
            ));
            res
        }),
    };
    let current_dir = std::env::current_dir();
    let package_index = metadata
        .packages
        .iter()
        .position(|package| {
            let package_manifest_path = Path::new(&package.manifest_path);
            if let Some(manifest_path) = &manifest_path {
                package_manifest_path == manifest_path
            } else {
                let current_dir = current_dir
                    .as_ref()
                    .expect("could not read current directory");
                let package_manifest_directory = package_manifest_path
                    .parent()
                    .expect("could not find parent directory of package manifest");
                package_manifest_directory == current_dir
            }
        })
        .unwrap_or_else(|| {
            show_error("This seems to be a workspace, which is not supported by cargo-rudra");
        });
    metadata.packages.remove(package_index)
}
/// Returns the path to the `rudra` binary
fn find_rudra() -> PathBuf {
    let mut path = std::env::current_exe().expect("current executable path invalid");
    path.set_file_name("safefinder");
    path
}
/// Make sure that the `rudra` and `rustc` binary are from the same sysroot.
/// This can be violated e.g. when rudra is locally built and installed with a different
/// toolchain than what is used when `cargo rudra` is run.
fn test_sysroot_consistency() {
    fn get_sysroot(mut cmd: Command) -> PathBuf {
        let out = cmd
            .arg("--print")
            .arg("sysroot")
            .output()
            .expect("Failed to run rustc to get sysroot info");
        let stdout = String::from_utf8(out.stdout).expect("stdout is not valid UTF-8");
        let stderr = String::from_utf8(out.stderr).expect("stderr is not valid UTF-8");
        let stdout = stdout.trim();
        if !out.status.success() {
            ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &[
                    "Bad status code when getting sysroot info.\nstdout:\n",
                    "\nstderr:\n",
                ],
                &[
                    ::core::fmt::ArgumentV1::new_display(&stdout),
                    ::core::fmt::ArgumentV1::new_display(&stderr),
                ],
            ))
        };
        PathBuf::from(stdout).canonicalize().unwrap_or_else(|_| {
            ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["Failed to canonicalize sysroot: "],
                &[::core::fmt::ArgumentV1::new_display(&stdout)],
            ))
        })
    }
    let rustc_sysroot = get_sysroot(Command::new("rustc"));
    let rudra_sysroot = get_sysroot(Command::new(find_rudra()));
    if rustc_sysroot != rudra_sysroot {
        show_error({
            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["rudra was built for a different sysroot than the rustc in your current toolchain.\nMake sure you use the same toolchain to run rudra that you used to build it!\nrustc sysroot: `" , "`\nrudra sysroot: `" , "`"] , & [:: core :: fmt :: ArgumentV1 :: new_display (& rustc_sysroot . display ()) , :: core :: fmt :: ArgumentV1 :: new_display (& rudra_sysroot . display ())])) ;
            res
        });
    }
}
fn clean_package(package_name: &str) {
    let mut cmd = Command::new("cargo");
    cmd.arg("clean");
    cmd.arg("-p");
    cmd.arg(package_name);
    cmd.arg("--target");
    cmd.arg(version_info().host);
    let exit_status = cmd
        .spawn()
        .expect("could not run cargo clean")
        .wait()
        .expect("failed to wait for cargo?");
    if !exit_status.success() {
        show_error({
            let res =
                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["cargo clean failed"], &[]));
            res
        });
    }
}
fn main() {
    if let Some("rudra") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {
        in_cargo_rudra();
    } else if let Some("rustc") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {
        inside_cargo_rustc();
    } else {
        show_error(
            "`cargo-rudra` must be called with either `rudra` or `rustc` as first argument.",
        );
    }
}
#[repr(u8)]
enum TargetKind {
    Library = 0,
    Bin,
    Unknown,
}
impl TargetKind {
    fn is_lib_str(s: &str) -> bool {
        s == "lib" || s == "rlib" || s == "staticlib"
    }
}
impl From<&cargo_metadata::Target> for TargetKind {
    fn from(target: &cargo_metadata::Target) -> Self {
        if target.kind.iter().any(|s| TargetKind::is_lib_str(s)) {
            TargetKind::Library
        } else if let Some("bin") = target.kind.get(0).map(|s| s.as_ref()) {
            TargetKind::Bin
        } else {
            TargetKind::Unknown
        }
    }
}
impl Display for TargetKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(::core::fmt::Arguments::new_v1(
            &[""],
            &[::core::fmt::ArgumentV1::new_display(&match self {
                TargetKind::Library => "lib",
                TargetKind::Bin => "bin",
                TargetKind::Unknown => "unknown",
            })],
        ))
    }
}
fn in_cargo_rudra() {
    let verbose = has_arg_flag("-v");
    test_sysroot_consistency();
    let package = cargo_package();
    let mut targets: Vec<_> = package.targets.into_iter().collect();
    targets.sort_by_key(|target| TargetKind::from(target) as u8);
    for target in targets {
        let mut args = std::env::args().skip(2);
        let kind = TargetKind::from(&target);
        let mut cmd = Command::new("cargo");
        cmd.arg("check");
        if std::env::var_os("RUDRA_USE_XARGO_INSTEAD_OF_CARGO").is_some() {
            cmd = Command::new("xargo-check");
        }
        match kind {
            TargetKind::Bin => {
                cmd.arg("--bin").arg(&target.name);
            }
            TargetKind::Library => {
                cmd.arg("--lib");
                clean_package(&package.name);
            }
            TargetKind::Unknown => {
                {
                    let lvl = ::log::Level::Warn;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            ::core::fmt::Arguments::new_v1(
                                &["Target ", ":", " is not supported"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &target.kind.as_slice().join("/"),
                                    ),
                                    ::core::fmt::ArgumentV1::new_display(&&target.name),
                                ],
                            ),
                            lvl,
                            &(
                                "cargorunner",
                                "cargorunner",
                                "src/bin/cargorunner.rs",
                                327u32,
                            ),
                        );
                    }
                };
                continue;
            }
        }
        if !true && !verbose {
            cmd.arg("-q");
        }
        while let Some(arg) = args.next() {
            if arg == "--" {
                break;
            }
            cmd.arg(arg);
        }
        if get_arg_flag_value("--target").is_none() {
            cmd.arg("--target");
            cmd.arg(version_info().host);
        }
        if let Ok(report) = env::var("RUDRA_REPORT_PATH") {
            cmd.env("RUDRA_REPORT_PATH", {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["", "-", "-"],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&report),
                        ::core::fmt::ArgumentV1::new_display(&kind),
                        ::core::fmt::ArgumentV1::new_display(&&target.name),
                    ],
                ));
                res
            });
        }
        let args_vec: Vec<String> = args.collect();
        cmd.env(
            "RUDRA_ARGS",
            serde_json::to_string(&args_vec).expect("failed to serialize args"),
        );
        if env::var_os("RUSTC_WRAPPER").is_some() {
            {
                :: std :: io :: _print (:: core :: fmt :: Arguments :: new_v1 (& ["WARNING: Ignoring existing `RUSTC_WRAPPER` environment variable, Rudra does not support wrapping.\n"] , & [])) ;
            };
        }
        let path = std::env::current_exe().expect("current executable path invalid");
        cmd.env("RUSTC_WRAPPER", path);
        if verbose {
            cmd.env("RUDRA_VERBOSE", "");
            {
                ::std::io::_eprint(::core::fmt::Arguments::new_v1(
                    &["+ ", "\n"],
                    &[::core::fmt::ArgumentV1::new_debug(&cmd)],
                ));
            };
        }
        let mut child = cmd.spawn().expect("could not run cargo check");
        match child
            .wait_timeout(Duration::from_secs(60 * 60))
            .expect("failed to wait for subprocess")
        {
            Some(exit_status) => {
                if !exit_status.success() {
                    show_error("Finished with non-zero exit code");
                }
            }
            None => {
                child.kill().expect("failed to kill subprocess");
                child.wait().expect("failed to wait for subprocess");
                show_error("Killed due to timeout");
            }
        };
    }
}
fn inside_cargo_rustc() {
    /// Determines if we are being invoked (as rustc) to build a crate for
    /// the "target" architecture, in contrast to the "host" architecture.
    /// Host crates are for build scripts and proc macros and still need to
    /// be built like normal; target crates need to be built for or interpreted
    /// by Rudra.
    ///
    /// Currently, we detect this by checking for "--target=", which is
    /// never set for host crates. This matches what rustc bootstrap does,
    /// which hopefully makes it "reliable enough". This relies on us always
    /// invoking cargo itself with `--target`, which `in_cargo_rudra` ensures.
    fn contains_target_flag() -> bool {
        get_arg_flag_value("--target").is_some()
    }
    /// Returns whether we are building the target crate.
    /// Cargo passes the file name as a relative address when building the local crate,
    /// such as `crawl/src/bin/unsafe-counter.rs` when building the target crate.
    /// This might not be a stable behavior, but let's rely on this for now.
    fn is_target_crate() -> bool {
        let entry_path_arg = match get_first_arg_with_rs_suffix() {
            Some(arg) => arg,
            None => return false,
        };
        let entry_path: &Path = entry_path_arg.as_ref();
        entry_path.is_relative()
    }
    fn is_crate_type_lib() -> bool {
        any_arg_flag("--crate-type", TargetKind::is_lib_str)
    }
    fn run_command(mut cmd: Command) {
        let verbose = std::env::var_os("RUDRA_VERBOSE").is_some();
        if verbose {
            {
                ::std::io::_eprint(::core::fmt::Arguments::new_v1(
                    &["+ ", "\n"],
                    &[::core::fmt::ArgumentV1::new_debug(&cmd)],
                ));
            };
        }
        match cmd.status() {
            Ok(exit) => {
                if !exit.success() {
                    std::process::exit(exit.code().unwrap_or(42));
                }
            }
            Err(e) => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["error running ", ":\n"],
                &[
                    ::core::fmt::ArgumentV1::new_debug(&cmd),
                    ::core::fmt::ArgumentV1::new_debug(&e),
                ],
            )),
        }
    }
    let is_direct_target = contains_target_flag() && is_target_crate();
    let mut is_additional_target = false;
    if let (Ok(cargo_pkg_name), Ok(rudra_also_analyze_crates)) =
        (env::var("CARGO_PKG_NAME"), env::var("RUDRA_ALSO_ANALYZE"))
    {
        if rudra_also_analyze_crates
            .split(',')
            .any(|x| x.to_lowercase() == cargo_pkg_name.to_lowercase())
        {
            is_additional_target = true;
        }
    }
    if is_direct_target || is_additional_target {
        let mut cmd = Command::new(find_rudra());
        cmd.args(std::env::args().skip(2));
        if let Ok(report) = env::var("RUDRA_REPORT_PATH") {
            cmd.env("RUDRA_REPORT_PATH", {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["", "-"],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&report),
                        ::core::fmt::ArgumentV1::new_display(
                            &env::var("CARGO_PKG_NAME").unwrap_or(String::from("unknown")),
                        ),
                    ],
                ));
                res
            });
        }
        let magic = std::env::var("RUDRA_ARGS").expect("missing RUDRA_ARGS");
        let rudra_args: Vec<String> =
            serde_json::from_str(&magic).expect("failed to deserialize RUDRA_ARGS");
        cmd.args(rudra_args);
        run_command(cmd);
    }
    if !is_direct_target || is_crate_type_lib() {
        let cmd = {
            let mut cmd = Command::new("rustc");
            cmd.args(std::env::args().skip(2));
            cmd
        };
        run_command(cmd);
    }
}
