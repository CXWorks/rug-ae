{"<u64 as duration::OverflowOp>::add": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::duration::*;\n    \n    #[test]\n    fn test_add_ok() {\n        let duration1: u64 = 10;\n        let duration2: u64 = 20;\n        \n        let result = duration1.add(duration2);\n        \n        assert_eq!(result, Ok(30));\n    }\n    \n    #[test]\n    fn test_add_error() {\n        let duration1: u64 = u64::MAX;\n        let duration2: u64 = 1;\n        \n        let result = duration1.add(duration2);\n        \n        assert_eq!(result, Err(Error::NumberOverflow));\n    }\n}\n```", "<u64 as duration::OverflowOp>::mul": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use humantime::duration::Error;\n\n    #[test]\n    fn test_mul() {\n        assert_eq!(<u64 as duration::OverflowOp>::mul(10, 5), Ok(50));\n        assert_eq!(<u64 as duration::OverflowOp>::mul(2, 0), Ok(0));\n        assert_eq!(<u64 as duration::OverflowOp>::mul(u64::MAX, 2), Err(Error::NumberOverflow));\n        assert_eq!(<u64 as duration::OverflowOp>::mul(0, u64::MAX), Ok(0));\n    }\n}\n```", "<wrapper::Duration as std::convert::AsRef<std::time::Duration>>::as_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_as_ref() {\n        let duration = wrapper::Duration::from_str(\"1h\").unwrap();\n        let as_ref_duration = duration.as_ref();\n        assert_eq!(*as_ref_duration, std::time::Duration::from_secs(3600));\n    }\n}\n```", "<wrapper::Duration as std::convert::From<std::time::Duration>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::wrapper::Duration;\n    use std::time::Duration as StdDuration;\n    use std::str::FromStr;\n    \n    #[test]\n    fn test_from() {\n        let dur: StdDuration = StdDuration::new(10, 0);\n        let res: Duration = Duration::from(dur);\n        assert_eq!(res, Duration(StdDuration::new(10, 0)));\n    }\n}\n```", "<wrapper::Duration as std::convert::Into<std::time::Duration>>::into": "```rust\n#[cfg(test)]\nmod tests {\n    use std::time::Duration;\n    use humantime::{Duration as HDuration, parse_duration};\n\n    #[test]\n    fn test_into_duration() {\n        let h_duration: HDuration = \"12h 5min 2ns\".parse().unwrap();\n        let std_duration: Duration = h_duration.into();\n        assert_eq!(std_duration, Duration::new(12 * 3600 + 5 * 60, 2));\n    }\n}\n```", "<wrapper::Duration as std::ops::Deref>::deref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Duration as StdDuration;\n    \n    #[test]\n    fn test_deref() {\n        let duration = Duration(StdDuration::new(10, 0));\n        let dereferenced = duration.deref();\n        assert_eq!(dereferenced, &StdDuration::new(10, 0));\n    }\n}\n```", "<wrapper::Duration as std::str::FromStr>::from_str": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n    use crate::wrapper::Duration;\n    use crate::parse_duration;\n    \n    #[test]\n    fn test_from_str() {\n        let input = \"2h30m\";\n        let expected = Duration::from_str(input).unwrap();\n        let result = crate::wrapper::from_str(input).unwrap();\n        assert_eq!(result, expected);\n    }\n}\n```", "<wrapper::Timestamp as std::convert::AsRef<std::time::SystemTime>>::as_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_as_ref() {\n        let timestamp = Timestamp(SystemTime::UNIX_EPOCH);\n        let result = timestamp.as_ref();\n        assert_eq!(result, &SystemTime::UNIX_EPOCH);\n    }\n}\n```", "<wrapper::Timestamp as std::convert::From<std::time::SystemTime>>::from": "```rust\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_from() {\n        let dur = SystemTime::UNIX_EPOCH;\n        let timestamp = Timestamp::from(dur);\n        assert_eq!(dur, *timestamp);\n    }\n\n    #[test]\n    fn test_from_str() {\n        let timestamp = Timestamp::from_str(\"2018-02-16T00:31:37Z\").unwrap();\n        assert_eq!(timestamp.to_string(), \"2018-02-16T00:31:37Z\");\n    }\n}\n```", "<wrapper::Timestamp as std::convert::Into<std::time::SystemTime>>::into": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_into() {\n        let timestamp = Timestamp(SystemTime::UNIX_EPOCH);\n        let system_time: SystemTime = timestamp.into();\n        assert_eq!(system_time, SystemTime::UNIX_EPOCH);\n    }\n}\n```", "<wrapper::Timestamp as std::ops::Deref>::deref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::SystemTime;\n    \n    #[test]\n    fn test_deref() {\n        let time = SystemTime::UNIX_EPOCH;\n        let timestamp = Timestamp::from(time);\n        \n        assert_eq!(timestamp.deref(), &time);\n    }\n}\n```", "<wrapper::Timestamp as std::str::FromStr>::from_str": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Timestamp;\n\n    use super::from_str;\n\n    #[test]\n    fn test_from_str() {\n        let input = \"2022-01-01T12:00:00Z\";\n        let expected = Timestamp::from_str(input).unwrap();\n        let result = from_str(input).unwrap();\n        assert_eq!(result, expected);\n    }\n}\n```", "date::Rfc3339Timestamp::get_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{Duration, SystemTime, UNIX_EPOCH};\n\n    #[test]\n    fn test_get_ref() {\n        let system_time = SystemTime::now();\n        let timestamp = Rfc3339Timestamp(system_time, Precision::Smart);\n        let result = timestamp.get_ref();\n        assert_eq!(result, &system_time);\n    }\n}\n```", "date::format_rfc3339": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    #[test]\n    fn test_format_rfc3339() {\n        // Create a dummy SystemTime with a specific timestamp\n        let dummy_time = UNIX_EPOCH + std::time::Duration::from_secs(1518572887);\n\n        // Call the format_rfc3339 function\n        let result = format_rfc3339(dummy_time);\n\n        // Assert the expected result\n        assert_eq!(result.to_string(), \"2018-02-14T00:28:07Z\");\n    }\n}\n```", "date::format_rfc3339_micros": "```rust\nuse date::Precision;\nuse date::Rfc3339Timestamp;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use crate::date::format_rfc3339_micros;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    #[test]\n    fn test_format_rfc3339_micros() {\n        let system_time = UNIX_EPOCH;\n        let result = format_rfc3339_micros(system_time);\n        let expected = Rfc3339Timestamp(system_time, Precision::Micros);\n\n        assert_eq!(result, expected);\n    }\n}\n```", "date::format_rfc3339_millis": "```rust\n#[cfg(test)]\nmod tests_llm_16_19 {\n    use crate::date::{format_rfc3339_millis, Precision, Rfc3339Timestamp};\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    #[test]\n    fn test_format_rfc3339_millis() {\n        let system_time = SystemTime::UNIX_EPOCH;\n        let result = format_rfc3339_millis(system_time);\n        assert_eq!(result, Rfc3339Timestamp(system_time, Precision::Millis));\n    }\n}\n```", "date::format_rfc3339_nanos": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_format_rfc3339_nanos() {\n        // Test cases\n    }\n}\n```", "date::format_rfc3339_seconds": "```rust\n#[cfg(test)]\nmod tests_llm_16_22 {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n    use date::Precision::Seconds;\n    use date::Rfc3339Timestamp;\n    \n    #[test]\n    fn test_format_rfc3339_seconds() {\n        let system_time = SystemTime::UNIX_EPOCH;\n        let expected = Rfc3339Timestamp(system_time, Seconds);\n        assert_eq!(format_rfc3339_seconds(system_time), expected);\n    }\n}\n```\n", "date::is_leap_year": "```rust\n#[cfg(test)]\nmod tests_llm_16_24 {\n    use super::*;\n\n    #[test]\n    fn test_is_leap_year() {\n        assert_eq!(is_leap_year(1900), false);\n        assert_eq!(is_leap_year(2000), true);\n        assert_eq!(is_leap_year(2004), true);\n        assert_eq!(is_leap_year(2100), false);\n        assert_eq!(is_leap_year(2400), true);\n    }\n}\n```", "date::parse_rfc3339": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::SystemTime;\n\n    #[test]\n    fn test_parse_rfc3339_valid_timestamp() {\n        assert!(parse_rfc3339(\"2018-02-14T00:28:07Z\").is_ok());\n    }\n\n    #[test]\n    fn test_parse_rfc3339_invalid_timestamp() {\n        assert!(parse_rfc3339(\"2018-02-14T00:28:07\").is_err());\n    }\n}\n```", "date::parse_rfc3339_weak": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{Duration, UNIX_EPOCH};\n\n    #[test]\n    fn test_parse_rfc3339_weak_valid() {\n        let input = \"2018-02-14 00:28:07\";\n        let expected = Ok(UNIX_EPOCH + Duration::new(1518563287, 0));\n        assert_eq!(parse_rfc3339_weak(input), expected);\n    }\n\n    #[test]\n    fn test_parse_rfc3339_weak_invalid_format() {\n        let input = \"2018-02-14 00:28:07.\";\n        let expected = Err(Error::InvalidFormat);\n        assert_eq!(parse_rfc3339_weak(input), expected);\n    }\n\n    #[test]\n    fn test_parse_rfc3339_weak_invalid_out_of_range() {\n        let input = \"1969-12-31 23:59:59\";\n        let expected = Err(Error::OutOfRange);\n        assert_eq!(parse_rfc3339_weak(input), expected);\n    }\n}\n```", "date::two_digits": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_two_digits() {\n        assert_eq!(two_digits(b'0', b'0'), Ok(0));\n        assert_eq!(two_digits(b'0', b'9'), Ok(9));\n        assert_eq!(two_digits(b'1', b'0'), Ok(10));\n        assert_eq!(two_digits(b'9', b'9'), Ok(99));\n        assert_eq!(two_digits(b'a', b'a'), Err(Error::InvalidDigit));\n        assert_eq!(two_digits(b'0', b'a'), Err(Error::InvalidDigit));\n        assert_eq!(two_digits(b'a', b'0'), Err(Error::InvalidDigit));\n    }\n}\n```", "date::two_digits_inner": "```rust\n#[cfg(test)]\nmod tests_llm_16_29 {\n    use super::two_digits_inner;\n\n    #[test]\n    fn test_two_digits_inner() {\n        assert_eq!(two_digits_inner('0', '0'), Some(0));\n        assert_eq!(two_digits_inner('9', '0'), Some(90));\n        assert_eq!(two_digits_inner('1', '9'), Some(19));\n        assert_eq!(two_digits_inner('4', '5'), Some(45));\n    }\n}\n```", "duration::FormattedDuration::get_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Duration;\n    \n    #[test]\n    fn test_get_ref() {\n        let duration = Duration::new(100, 0);\n        let formatted_duration = FormattedDuration(duration);\n        \n        let result = formatted_duration.get_ref();\n        \n        assert_eq!(result, &duration);\n    }\n}\n```", "duration::Parser::<'a>::off": "```rust\n#[cfg(test)]\nmod tests {\n    use crate::duration::{Parser, Error, Duration};\n    use std::str::Chars;\n\n    #[test]\n    fn test_off() {\n        let src = \"10 seconds\";\n        let iter = src.chars();\n        let parser = Parser {\n            iter,\n            src,\n            current: (0, 0),\n        };\n        assert_eq!(parser.off(), 0);\n    }\n}\n```", "duration::Parser::<'a>::parse": "Here is the revised unit test code that resolves the compilation errors:\n\n```rust\n#[cfg(test)]\nmod tests_llm_16_34 {\n    use crate::duration::{Duration, Error, Parser};\n    use std::str::FromStr;\n    \n    #[test]\n    fn test_parse_duration() {\n        let test_cases = [\n            (\"1s\", Ok(Duration::from_secs(1))),\n            (\"5 minutes\", Ok(Duration::from_secs(300))),\n            (\"2hrs\", Ok(Duration::from_secs(7200))),\n            (\"3 days\", Ok(Duration::from_secs(259_200))),\n            (\"1 week\", Ok(Duration::from_secs(604_800))),\n            (\"1 month\", Ok(Duration::from_secs(2_630_016))),\n            (\"2 years\", Ok(Duration::from_secs(63_115_200))),\n            (\"1.5s\", Ok(Duration::from_secs_f64(1.5))),\n            (\"1.5 minutes\", Ok(Duration::from_secs_f64(90.0))),\n            (\"1.5hrs\", Ok(Duration::from_secs_f64(5_400.0))),\n            (\"1.5 days\", Ok(Duration::from_secs_f64(129_600.0))),\n            (\"1.5 week\", Ok(Duration::from_secs_f64(362_880.0))),\n            (\"1.5 month\", Ok(Duration::from_secs_f64(3_945_024.0))),\n            (\"1.5 years\", Ok(Duration::from_secs_f64(94_200_000.0))),\n            (\"2.5s\", Ok(Duration::from_secs_f64(2.5))),\n            (\"2.5 minutes\", Ok(Duration::from_secs_f64(150.0))),\n            (\"2.5hrs\", Ok(Duration::from_secs_f64(9_000.0))),\n            (\"2.5 days\", Ok(Duration::from_secs_f64(216_000.0))),\n            (\"2.5 week\", Ok(Duration::from_secs_f64(604_800.0))),\n            (\"2.5 month\", Ok(Duration::from_secs_f64(6_575_040.0))),\n            (\"2.5 years\", Ok(Duration::from_secs_f64(157_800_000.0))),\n            (\"1\", Ok(Duration::from_secs(1))),\n            (\"89634\", Ok(Duration::from_secs(89_634))),\n            (\"0.5\", Ok(Duration::from_secs_f64(0.5))),\n            (\"0.03125\", Ok(Duration::from_secs_f64(0.03125))),\n            (\"\", Err(Error::Empty)),\n            (\"1e12d\", Err(Error::NumberOverflow)),\n            (\"1d\", Err(Error::InvalidCharacter(1))),\n            (\"1.5sd\", Err(Error::InvalidCharacter(3))),\n            (\"1.5d\", Err(Error::InvalidCharacter(3))),\n            (\"2sd\", Err(Error::InvalidCharacter(2))),\n            (\"2 month\", Err(Error::InvalidCharacter(2))),\n            (\"1.5 monthsd\", Err(Error::InvalidCharacter(7))),\n            (\"1.5 yearsd\", Err(Error::InvalidCharacter(7))),\n            (\"1.5e2 month\", Err(Error::InvalidCharacter(0))),\n            (\"1.5e2 years\", Err(Error::InvalidCharacter(0))),\n            (\"1.5est\", Err(Error::UnknownUnit {\n                start: 3,\n                end: 6,\n                unit: \"est\".to_string(),\n                value: 1.5,\n            })),\n        ];\n        \n        for (input, expected_output) in &test_cases {\n            let result = Parser::new(*input).parse();\n            assert_eq!(result, *expected_output);\n        }\n    }\n}\n```\n\nHowever, please note that you may still receive warnings about unused imports. You can either remove those unused imports or disable the warning by adding `#[allow(unused_imports)]` directly above the imports.", "duration::Parser::<'a>::parse_first_char": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_parse_first_char_with_digit() {\n        let mut parser = Parser {\n            iter: \"123\".chars(),\n            src: \"test\",\n            current: (0, 0)\n        };\n        assert_eq!(parser.parse_first_char(), Ok(Some(1)));\n    }\n    \n    #[test]\n    fn test_parse_first_char_with_whitespace() {\n        let mut parser = Parser {\n            iter: \" \\t\\n\".chars(),\n            src: \"test\",\n            current: (0, 0)\n        };\n        assert_eq!(parser.parse_first_char(), Ok(None));\n    }\n    \n    #[test]\n    fn test_parse_first_char_with_invalid_char() {\n        let mut parser = Parser {\n            iter: \"_\".chars(),\n            src: \"test\",\n            current: (0, 0)\n        };\n        assert_eq!(parser.parse_first_char(), Err(Error::NumberExpected(0)));\n    }\n}\n```", "duration::Parser::<'a>::parse_unit": "```rust\n#[cfg(test)]\nmod tests_llm_16_37 {\n\n    use super::super::duration::*;\n    use super::super::duration::Error;\n    use super::*;\n    use std::time::Duration;\n    use std::str::Chars;\n    \n    #[test]\n    fn test_parse_unit_nanoseconds() {\n        let mut parser = Parser {\n            iter: \"5 nanos\".chars(),\n            src: \"5 nanos\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(5, 2, 7);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (0, 5));\n    }\n\n    #[test]\n    fn test_parse_unit_microseconds() {\n        let mut parser = Parser {\n            iter: \"3 us\".chars(),\n            src: \"3 us\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(3, 2, 4);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (0, 3000));\n    }\n\n    #[test]\n    fn test_parse_unit_milliseconds() {\n        let mut parser = Parser {\n            iter: \"7 millis\".chars(),\n            src: \"7 millis\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(7, 2, 8);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (0, 7000000));\n    }\n\n    #[test]\n    fn test_parse_unit_seconds() {\n        let mut parser = Parser {\n            iter: \"2 sec\".chars(),\n            src: \"2 sec\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(2, 2, 5);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (2, 0));\n    }\n\n    #[test]\n    fn test_parse_unit_minutes() {\n        let mut parser = Parser {\n            iter: \"3 mins\".chars(),\n            src: \"3 mins\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(3, 2, 7);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (180, 0));\n    }\n\n    #[test]\n    fn test_parse_unit_hours() {\n        let mut parser = Parser {\n            iter: \"1 hr\".chars(),\n            src: \"1 hr\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(1, 2, 4);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (3600, 0));\n    }\n\n    #[test]\n    fn test_parse_unit_days() {\n        let mut parser = Parser {\n            iter: \"4 day\".chars(),\n            src: \"4 day\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(4, 2, 5);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (345600, 0));\n    }\n\n    #[test]\n    fn test_parse_unit_weeks() {\n        let mut parser = Parser {\n            iter: \"1 week\".chars(),\n            src: \"1 week\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(1, 2, 6);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (604800, 0));\n    }\n\n    #[test]\n    fn test_parse_unit_months() {\n        let mut parser = Parser {\n            iter: \"2 month\".chars(),\n            src: \"2 month\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(2, 2, 7);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (52560032, 0));\n    }\n\n    #[test]\n    fn test_parse_unit_years() {\n        let mut parser = Parser {\n            iter: \"3 year\".chars(),\n            src: \"3 year\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(3, 2, 6);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (94670800, 0));\n    }\n\n    #[test]\n    fn test_parse_unit_unknown_unit() {\n        let mut parser = Parser {\n            iter: \"5 unknown\".chars(),\n            src: \"5 unknown\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(5, 2, 9);\n        assert_eq!(\n            result,\n            Err(Error::UnknownUnit {\n                start: 2,\n                end: 9,\n                unit: \"unknown\".to_string(),\n                value: 5,\n            })\n        );\n    }\n\n    #[test]\n    fn test_parse_unit_overflow() {\n        let mut parser = Parser {\n            iter: \"999999999 seconds\".chars(),\n            src: \"999999999 seconds\",\n            current: (0, 0),\n        };\n        let result = parser.parse_unit(999999999, 0, 9);\n        assert_eq!(result, Ok(()));\n        assert_eq!(parser.current, (999999999, 0));\n    }\n}\n```\n", "duration::format_duration": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Duration;\n\n    #[test]\n    fn test_format_duration_zero() {\n        let val = Duration::new(0, 0);\n        assert_eq!(format_duration(val).to_string(), \"0s\");\n    }\n\n    #[test]\n    fn test_format_duration_hours_and_minutes() {\n        let val = Duration::new(9420, 0);\n        assert_eq!(format_duration(val).to_string(), \"2h 37m\");\n    }\n\n    #[test]\n    fn test_format_duration_milliseconds() {\n        let val = Duration::new(0, 32_000_000);\n        assert_eq!(format_duration(val).to_string(), \"32ms\");\n    }\n}\n```", "duration::item": "```rust\n#[cfg(test)]\nmod tests_llm_16_40 {\n    use std::fmt::Write;\n    use crate::duration::item;\n    \n    #[test]\n    fn test_item() {\n        let mut started = false;\n        let mut formatter = String::new();\n        let name = \"test\";\n        let value = 10;\n        let result = item(&mut formatter, &mut started, name, value);\n        assert!(result.is_ok());\n        assert_eq!(&*formatter, \"10test\");\n        assert_eq!(started, true);\n    }\n}\n```", "duration::item_plural": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::{Write, Formatter};\n\n    #[test]\n    fn test_item_plural() {\n        let mut f = Formatter::new(&mut String::new());\n        let mut started = false;\n        let name = \"item\";\n        let value = 1;\n        assert_eq!(\n            item_plural(&mut f, &mut started, name, value).unwrap(),\n            ()\n        );\n        assert_eq!(f.into_inner(), \"1item\");\n        assert_eq!(started, true);\n\n        let mut f = Formatter::new(&mut String::new());\n        started = false;\n        let name = \"item\";\n        let value = 0;\n        assert_eq!(\n            item_plural(&mut f, &mut started, name, value).unwrap(),\n            ()\n        );\n        assert_eq!(f.into_inner(), \"\");\n        assert_eq!(started, false);\n\n        let mut f = Formatter::new(&mut String::new());\n        started = false;\n        let name = \"item\";\n        let value = 3;\n        assert_eq!(\n            item_plural(&mut f, &mut started, name, value).unwrap(),\n            ()\n        );\n        assert_eq!(f.into_inner(), \"3items\");\n        assert_eq!(started, true);\n    }\n}\n```", "duration::parse_duration": "```rust\n#[cfg(test)]\nmod tests {\n    use std::time::Duration;\n    use crate::duration::parse_duration;\n\n    #[test]\n    fn test_parse_duration() {\n        assert_eq!(parse_duration(\"2h 37min\"), Ok(Duration::new(9420, 0)));\n        assert_eq!(parse_duration(\"32ms\"), Ok(Duration::new(0, 32_000_000)));\n    }\n}\n```"}